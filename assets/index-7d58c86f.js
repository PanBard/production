function Die(e,t){for(var n=0;n<t.length;n++){const r=t[n];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in e)){const a=Object.getOwnPropertyDescriptor(r,s);a&&Object.defineProperty(e,s,a.get?a:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const a of s)if(a.type==="childList")for(const i of a.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function n(s){const a={};return s.integrity&&(a.integrity=s.integrity),s.referrerPolicy&&(a.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?a.credentials="include":s.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function r(s){if(s.ep)return;s.ep=!0;const a=n(s);fetch(s.href,a)}})();var mi=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function QH(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function Fie(e){if(e.__esModule)return e;var t=e.default;if(typeof t=="function"){var n=function r(){if(this instanceof r){var s=[null];s.push.apply(s,arguments);var a=Function.bind.apply(t,s);return new a}return t.apply(this,arguments)};n.prototype=t.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(e).forEach(function(r){var s=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:function(){return e[r]}})}),n}var qx={},Oie={get exports(){return qx},set exports(e){qx=e}},sC={},J={},Mie={get exports(){return J},set exports(e){J=e}},Yt={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var q0=Symbol.for("react.element"),Lie=Symbol.for("react.portal"),Pie=Symbol.for("react.fragment"),zie=Symbol.for("react.strict_mode"),Bie=Symbol.for("react.profiler"),Wie=Symbol.for("react.provider"),Vie=Symbol.for("react.context"),Uie=Symbol.for("react.forward_ref"),Gie=Symbol.for("react.suspense"),Hie=Symbol.for("react.memo"),jie=Symbol.for("react.lazy"),k4=Symbol.iterator;function qie(e){return e===null||typeof e!="object"?null:(e=k4&&e[k4]||e["@@iterator"],typeof e=="function"?e:null)}var e5={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},t5=Object.assign,n5={};function qg(e,t,n){this.props=e,this.context=t,this.refs=n5,this.updater=n||e5}qg.prototype.isReactComponent={};qg.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};qg.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function r5(){}r5.prototype=qg.prototype;function gD(e,t,n){this.props=e,this.context=t,this.refs=n5,this.updater=n||e5}var yD=gD.prototype=new r5;yD.constructor=gD;t5(yD,qg.prototype);yD.isPureReactComponent=!0;var I4=Array.isArray,s5=Object.prototype.hasOwnProperty,bD={current:null},a5={key:!0,ref:!0,__self:!0,__source:!0};function i5(e,t,n){var r,s={},a=null,i=null;if(t!=null)for(r in t.ref!==void 0&&(i=t.ref),t.key!==void 0&&(a=""+t.key),t)s5.call(t,r)&&!a5.hasOwnProperty(r)&&(s[r]=t[r]);var o=arguments.length-2;if(o===1)s.children=n;else if(1<o){for(var l=Array(o),u=0;u<o;u++)l[u]=arguments[u+2];s.children=l}if(e&&e.defaultProps)for(r in o=e.defaultProps,o)s[r]===void 0&&(s[r]=o[r]);return{$$typeof:q0,type:e,key:a,ref:i,props:s,_owner:bD.current}}function Kie(e,t){return{$$typeof:q0,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}function xD(e){return typeof e=="object"&&e!==null&&e.$$typeof===q0}function Xie(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return t[n]})}var S4=/\/+/g;function IT(e,t){return typeof e=="object"&&e!==null&&e.key!=null?Xie(""+e.key):t.toString(36)}function Uk(e,t,n,r,s){var a=typeof e;(a==="undefined"||a==="boolean")&&(e=null);var i=!1;if(e===null)i=!0;else switch(a){case"string":case"number":i=!0;break;case"object":switch(e.$$typeof){case q0:case Lie:i=!0}}if(i)return i=e,s=s(i),e=r===""?"."+IT(i,0):r,I4(s)?(n="",e!=null&&(n=e.replace(S4,"$&/")+"/"),Uk(s,t,n,"",function(u){return u})):s!=null&&(xD(s)&&(s=Kie(s,n+(!s.key||i&&i.key===s.key?"":(""+s.key).replace(S4,"$&/")+"/")+e)),t.push(s)),1;if(i=0,r=r===""?".":r+":",I4(e))for(var o=0;o<e.length;o++){a=e[o];var l=r+IT(a,o);i+=Uk(a,t,n,l,s)}else if(l=qie(e),typeof l=="function")for(e=l.call(e),o=0;!(a=e.next()).done;)a=a.value,l=r+IT(a,o++),i+=Uk(a,t,n,l,s);else if(a==="object")throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return i}function Lv(e,t,n){if(e==null)return e;var r=[],s=0;return Uk(e,r,"","",function(a){return t.call(n,a,s++)}),r}function Yie(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var Aa={current:null},Gk={transition:null},Zie={ReactCurrentDispatcher:Aa,ReactCurrentBatchConfig:Gk,ReactCurrentOwner:bD};Yt.Children={map:Lv,forEach:function(e,t,n){Lv(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return Lv(e,function(){t++}),t},toArray:function(e){return Lv(e,function(t){return t})||[]},only:function(e){if(!xD(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};Yt.Component=qg;Yt.Fragment=Pie;Yt.Profiler=Bie;Yt.PureComponent=gD;Yt.StrictMode=zie;Yt.Suspense=Gie;Yt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Zie;Yt.cloneElement=function(e,t,n){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=t5({},e.props),s=e.key,a=e.ref,i=e._owner;if(t!=null){if(t.ref!==void 0&&(a=t.ref,i=bD.current),t.key!==void 0&&(s=""+t.key),e.type&&e.type.defaultProps)var o=e.type.defaultProps;for(l in t)s5.call(t,l)&&!a5.hasOwnProperty(l)&&(r[l]=t[l]===void 0&&o!==void 0?o[l]:t[l])}var l=arguments.length-2;if(l===1)r.children=n;else if(1<l){o=Array(l);for(var u=0;u<l;u++)o[u]=arguments[u+2];r.children=o}return{$$typeof:q0,type:e.type,key:s,ref:a,props:r,_owner:i}};Yt.createContext=function(e){return e={$$typeof:Vie,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:Wie,_context:e},e.Consumer=e};Yt.createElement=i5;Yt.createFactory=function(e){var t=i5.bind(null,e);return t.type=e,t};Yt.createRef=function(){return{current:null}};Yt.forwardRef=function(e){return{$$typeof:Uie,render:e}};Yt.isValidElement=xD;Yt.lazy=function(e){return{$$typeof:jie,_payload:{_status:-1,_result:e},_init:Yie}};Yt.memo=function(e,t){return{$$typeof:Hie,type:e,compare:t===void 0?null:t}};Yt.startTransition=function(e){var t=Gk.transition;Gk.transition={};try{e()}finally{Gk.transition=t}};Yt.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")};Yt.useCallback=function(e,t){return Aa.current.useCallback(e,t)};Yt.useContext=function(e){return Aa.current.useContext(e)};Yt.useDebugValue=function(){};Yt.useDeferredValue=function(e){return Aa.current.useDeferredValue(e)};Yt.useEffect=function(e,t){return Aa.current.useEffect(e,t)};Yt.useId=function(){return Aa.current.useId()};Yt.useImperativeHandle=function(e,t,n){return Aa.current.useImperativeHandle(e,t,n)};Yt.useInsertionEffect=function(e,t){return Aa.current.useInsertionEffect(e,t)};Yt.useLayoutEffect=function(e,t){return Aa.current.useLayoutEffect(e,t)};Yt.useMemo=function(e,t){return Aa.current.useMemo(e,t)};Yt.useReducer=function(e,t,n){return Aa.current.useReducer(e,t,n)};Yt.useRef=function(e){return Aa.current.useRef(e)};Yt.useState=function(e){return Aa.current.useState(e)};Yt.useSyncExternalStore=function(e,t,n){return Aa.current.useSyncExternalStore(e,t,n)};Yt.useTransition=function(){return Aa.current.useTransition()};Yt.version="18.2.0";(function(e){e.exports=Yt})(Mie);const Kg=QH(J);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Jie=J,Qie=Symbol.for("react.element"),eoe=Symbol.for("react.fragment"),toe=Object.prototype.hasOwnProperty,noe=Jie.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,roe={key:!0,ref:!0,__self:!0,__source:!0};function o5(e,t,n){var r,s={},a=null,i=null;n!==void 0&&(a=""+n),t.key!==void 0&&(a=""+t.key),t.ref!==void 0&&(i=t.ref);for(r in t)toe.call(t,r)&&!roe.hasOwnProperty(r)&&(s[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps,t)s[r]===void 0&&(s[r]=t[r]);return{$$typeof:Qie,type:e,key:a,ref:i,props:s,_owner:noe.current}}sC.Fragment=eoe;sC.jsx=o5;sC.jsxs=o5;(function(e){e.exports=sC})(Oie);const wD=qx.Fragment,D=qx.jsx,K=qx.jsxs;var Y_={},Z_={},soe={get exports(){return Z_},set exports(e){Z_=e}},Fi={},J_={},aoe={get exports(){return J_},set exports(e){J_=e}},l5={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function t(P,O){var L=P.length;P.push(O);e:for(;0<L;){var V=L-1>>>1,q=P[V];if(0<s(q,O))P[V]=O,P[L]=q,L=V;else break e}}function n(P){return P.length===0?null:P[0]}function r(P){if(P.length===0)return null;var O=P[0],L=P.pop();if(L!==O){P[0]=L;e:for(var V=0,q=P.length,B=q>>>1;V<B;){var X=2*(V+1)-1,ee=P[X],Z=X+1,fe=P[Z];if(0>s(ee,L))Z<q&&0>s(fe,ee)?(P[V]=fe,P[Z]=L,V=Z):(P[V]=ee,P[X]=L,V=X);else if(Z<q&&0>s(fe,L))P[V]=fe,P[Z]=L,V=Z;else break e}}return O}function s(P,O){var L=P.sortIndex-O.sortIndex;return L!==0?L:P.id-O.id}if(typeof performance=="object"&&typeof performance.now=="function"){var a=performance;e.unstable_now=function(){return a.now()}}else{var i=Date,o=i.now();e.unstable_now=function(){return i.now()-o}}var l=[],u=[],c=1,d=null,h=3,p=!1,f=!1,m=!1,g=typeof setTimeout=="function"?setTimeout:null,y=typeof clearTimeout=="function"?clearTimeout:null,b=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function x(P){for(var O=n(u);O!==null;){if(O.callback===null)r(u);else if(O.startTime<=P)r(u),O.sortIndex=O.expirationTime,t(l,O);else break;O=n(u)}}function w(P){if(m=!1,x(P),!f)if(n(l)!==null)f=!0,z(v);else{var O=n(u);O!==null&&H(w,O.startTime-P)}}function v(P,O){f=!1,m&&(m=!1,y(S),S=-1),p=!0;var L=h;try{for(x(O),d=n(l);d!==null&&(!(d.expirationTime>O)||P&&!T());){var V=d.callback;if(typeof V=="function"){d.callback=null,h=d.priorityLevel;var q=V(d.expirationTime<=O);O=e.unstable_now(),typeof q=="function"?d.callback=q:d===n(l)&&r(l),x(O)}else r(l);d=n(l)}if(d!==null)var B=!0;else{var X=n(u);X!==null&&H(w,X.startTime-O),B=!1}return B}finally{d=null,h=L,p=!1}}var k=!1,I=null,S=-1,$=5,N=-1;function T(){return!(e.unstable_now()-N<$)}function C(){if(I!==null){var P=e.unstable_now();N=P;var O=!0;try{O=I(!0,P)}finally{O?E():(k=!1,I=null)}}else k=!1}var E;if(typeof b=="function")E=function(){b(C)};else if(typeof MessageChannel<"u"){var M=new MessageChannel,F=M.port2;M.port1.onmessage=C,E=function(){F.postMessage(null)}}else E=function(){g(C,0)};function z(P){I=P,k||(k=!0,E())}function H(P,O){S=g(function(){P(e.unstable_now())},O)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(P){P.callback=null},e.unstable_continueExecution=function(){f||p||(f=!0,z(v))},e.unstable_forceFrameRate=function(P){0>P||125<P?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):$=0<P?Math.floor(1e3/P):5},e.unstable_getCurrentPriorityLevel=function(){return h},e.unstable_getFirstCallbackNode=function(){return n(l)},e.unstable_next=function(P){switch(h){case 1:case 2:case 3:var O=3;break;default:O=h}var L=h;h=O;try{return P()}finally{h=L}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(P,O){switch(P){case 1:case 2:case 3:case 4:case 5:break;default:P=3}var L=h;h=P;try{return O()}finally{h=L}},e.unstable_scheduleCallback=function(P,O,L){var V=e.unstable_now();switch(typeof L=="object"&&L!==null?(L=L.delay,L=typeof L=="number"&&0<L?V+L:V):L=V,P){case 1:var q=-1;break;case 2:q=250;break;case 5:q=1073741823;break;case 4:q=1e4;break;default:q=5e3}return q=L+q,P={id:c++,callback:O,priorityLevel:P,startTime:L,expirationTime:q,sortIndex:-1},L>V?(P.sortIndex=L,t(u,P),n(l)===null&&P===n(u)&&(m?(y(S),S=-1):m=!0,H(w,L-V))):(P.sortIndex=q,t(l,P),f||p||(f=!0,z(v))),P},e.unstable_shouldYield=T,e.unstable_wrapCallback=function(P){var O=h;return function(){var L=h;h=O;try{return P.apply(this,arguments)}finally{h=L}}}})(l5);(function(e){e.exports=l5})(aoe);/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var u5=J,Ni=J_;function Oe(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var c5=new Set,Kx={};function pp(e,t){Qm(e,t),Qm(e+"Capture",t)}function Qm(e,t){for(Kx[e]=t,e=0;e<t.length;e++)c5.add(t[e])}var Eu=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Q_=Object.prototype.hasOwnProperty,ioe=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,C4={},N4={};function ooe(e){return Q_.call(N4,e)?!0:Q_.call(C4,e)?!1:ioe.test(e)?N4[e]=!0:(C4[e]=!0,!1)}function loe(e,t,n,r){if(n!==null&&n.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return r?!1:n!==null?!n.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function uoe(e,t,n,r){if(t===null||typeof t>"u"||loe(e,t,n,r))return!0;if(r)return!1;if(n!==null)switch(n.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function Ra(e,t,n,r,s,a,i){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=r,this.attributeNamespace=s,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=a,this.removeEmptyString=i}var Os={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){Os[e]=new Ra(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];Os[t]=new Ra(t,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){Os[e]=new Ra(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){Os[e]=new Ra(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){Os[e]=new Ra(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){Os[e]=new Ra(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){Os[e]=new Ra(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){Os[e]=new Ra(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){Os[e]=new Ra(e,5,!1,e.toLowerCase(),null,!1,!1)});var vD=/[\-:]([a-z])/g;function kD(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(vD,kD);Os[t]=new Ra(t,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(vD,kD);Os[t]=new Ra(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(vD,kD);Os[t]=new Ra(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){Os[e]=new Ra(e,1,!1,e.toLowerCase(),null,!1,!1)});Os.xlinkHref=new Ra("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){Os[e]=new Ra(e,1,!1,e.toLowerCase(),null,!0,!0)});function ID(e,t,n,r){var s=Os.hasOwnProperty(t)?Os[t]:null;(s!==null?s.type!==0:r||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(uoe(t,n,s,r)&&(n=null),r||s===null?ooe(t)&&(n===null?e.removeAttribute(t):e.setAttribute(t,""+n)):s.mustUseProperty?e[s.propertyName]=n===null?s.type===3?!1:"":n:(t=s.attributeName,r=s.attributeNamespace,n===null?e.removeAttribute(t):(s=s.type,n=s===3||s===4&&n===!0?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}var Bu=u5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,Pv=Symbol.for("react.element"),vm=Symbol.for("react.portal"),km=Symbol.for("react.fragment"),SD=Symbol.for("react.strict_mode"),eE=Symbol.for("react.profiler"),d5=Symbol.for("react.provider"),h5=Symbol.for("react.context"),CD=Symbol.for("react.forward_ref"),tE=Symbol.for("react.suspense"),nE=Symbol.for("react.suspense_list"),ND=Symbol.for("react.memo"),ic=Symbol.for("react.lazy"),p5=Symbol.for("react.offscreen"),$4=Symbol.iterator;function Gb(e){return e===null||typeof e!="object"?null:(e=$4&&e[$4]||e["@@iterator"],typeof e=="function"?e:null)}var pr=Object.assign,ST;function cx(e){if(ST===void 0)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);ST=t&&t[1]||""}return`
`+ST+e}var CT=!1;function NT(e,t){if(!e||CT)return"";CT=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(u){var r=u}Reflect.construct(e,[],t)}else{try{t.call()}catch(u){r=u}e.call(t.prototype)}else{try{throw Error()}catch(u){r=u}e()}}catch(u){if(u&&r&&typeof u.stack=="string"){for(var s=u.stack.split(`
`),a=r.stack.split(`
`),i=s.length-1,o=a.length-1;1<=i&&0<=o&&s[i]!==a[o];)o--;for(;1<=i&&0<=o;i--,o--)if(s[i]!==a[o]){if(i!==1||o!==1)do if(i--,o--,0>o||s[i]!==a[o]){var l=`
`+s[i].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}while(1<=i&&0<=o);break}}}finally{CT=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?cx(e):""}function coe(e){switch(e.tag){case 5:return cx(e.type);case 16:return cx("Lazy");case 13:return cx("Suspense");case 19:return cx("SuspenseList");case 0:case 2:case 15:return e=NT(e.type,!1),e;case 11:return e=NT(e.type.render,!1),e;case 1:return e=NT(e.type,!0),e;default:return""}}function rE(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case km:return"Fragment";case vm:return"Portal";case eE:return"Profiler";case SD:return"StrictMode";case tE:return"Suspense";case nE:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case h5:return(e.displayName||"Context")+".Consumer";case d5:return(e._context.displayName||"Context")+".Provider";case CD:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case ND:return t=e.displayName||null,t!==null?t:rE(e.type)||"Memo";case ic:t=e._payload,e=e._init;try{return rE(e(t))}catch{}}return null}function doe(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return rE(t);case 8:return t===SD?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function Bc(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function f5(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function hoe(e){var t=f5(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var s=n.get,a=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(i){r=""+i,a.call(this,i)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(i){r=""+i},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function zv(e){e._valueTracker||(e._valueTracker=hoe(e))}function m5(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=f5(e)?e.checked?"true":"false":e.value),e=r,e!==n?(t.setValue(e),!0):!1}function xI(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function sE(e,t){var n=t.checked;return pr({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??e._wrapperState.initialChecked})}function T4(e,t){var n=t.defaultValue==null?"":t.defaultValue,r=t.checked!=null?t.checked:t.defaultChecked;n=Bc(t.value!=null?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function g5(e,t){t=t.checked,t!=null&&ID(e,"checked",t,!1)}function aE(e,t){g5(e,t);var n=Bc(t.value),r=t.type;if(n!=null)r==="number"?(n===0&&e.value===""||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if(r==="submit"||r==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?iE(e,t.type,n):t.hasOwnProperty("defaultValue")&&iE(e,t.type,Bc(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function _4(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!(r!=="submit"&&r!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}n=e.name,n!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,n!==""&&(e.name=n)}function iE(e,t,n){(t!=="number"||xI(e.ownerDocument)!==e)&&(n==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var dx=Array.isArray;function Mm(e,t,n,r){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&r&&(e[n].defaultSelected=!0)}else{for(n=""+Bc(n),t=null,s=0;s<e.length;s++){if(e[s].value===n){e[s].selected=!0,r&&(e[s].defaultSelected=!0);return}t!==null||e[s].disabled||(t=e[s])}t!==null&&(t.selected=!0)}}function oE(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(Oe(91));return pr({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function E4(e,t){var n=t.value;if(n==null){if(n=t.children,t=t.defaultValue,n!=null){if(t!=null)throw Error(Oe(92));if(dx(n)){if(1<n.length)throw Error(Oe(93));n=n[0]}t=n}t==null&&(t=""),n=t}e._wrapperState={initialValue:Bc(n)}}function y5(e,t){var n=Bc(t.value),r=Bc(t.defaultValue);n!=null&&(n=""+n,n!==e.value&&(e.value=n),t.defaultValue==null&&e.defaultValue!==n&&(e.defaultValue=n)),r!=null&&(e.defaultValue=""+r)}function A4(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function b5(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lE(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?b5(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var Bv,x5=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(t,n,r,s){MSApp.execUnsafeLocalFunction(function(){return e(t,n,r,s)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(Bv=Bv||document.createElement("div"),Bv.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=Bv.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function Xx(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var Ex={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},poe=["Webkit","ms","Moz","O"];Object.keys(Ex).forEach(function(e){poe.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),Ex[t]=Ex[e]})});function w5(e,t,n){return t==null||typeof t=="boolean"||t===""?"":n||typeof t!="number"||t===0||Ex.hasOwnProperty(e)&&Ex[e]?(""+t).trim():t+"px"}function v5(e,t){e=e.style;for(var n in t)if(t.hasOwnProperty(n)){var r=n.indexOf("--")===0,s=w5(n,t[n],r);n==="float"&&(n="cssFloat"),r?e.setProperty(n,s):e[n]=s}}var foe=pr({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function uE(e,t){if(t){if(foe[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(Oe(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(Oe(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(Oe(61))}if(t.style!=null&&typeof t.style!="object")throw Error(Oe(62))}}function cE(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var dE=null;function $D(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var hE=null,Lm=null,Pm=null;function R4(e){if(e=Y0(e)){if(typeof hE!="function")throw Error(Oe(280));var t=e.stateNode;t&&(t=uC(t),hE(e.stateNode,e.type,t))}}function k5(e){Lm?Pm?Pm.push(e):Pm=[e]:Lm=e}function I5(){if(Lm){var e=Lm,t=Pm;if(Pm=Lm=null,R4(e),t)for(e=0;e<t.length;e++)R4(t[e])}}function S5(e,t){return e(t)}function C5(){}var $T=!1;function N5(e,t,n){if($T)return e(t,n);$T=!0;try{return S5(e,t,n)}finally{$T=!1,(Lm!==null||Pm!==null)&&(C5(),I5())}}function Yx(e,t){var n=e.stateNode;if(n===null)return null;var r=uC(n);if(r===null)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(e=e.type,r=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!r;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(Oe(231,t,typeof n));return n}var pE=!1;if(Eu)try{var Hb={};Object.defineProperty(Hb,"passive",{get:function(){pE=!0}}),window.addEventListener("test",Hb,Hb),window.removeEventListener("test",Hb,Hb)}catch{pE=!1}function moe(e,t,n,r,s,a,i,o,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch(c){this.onError(c)}}var Ax=!1,wI=null,vI=!1,fE=null,goe={onError:function(e){Ax=!0,wI=e}};function yoe(e,t,n,r,s,a,i,o,l){Ax=!1,wI=null,moe.apply(goe,arguments)}function boe(e,t,n,r,s,a,i,o,l){if(yoe.apply(this,arguments),Ax){if(Ax){var u=wI;Ax=!1,wI=null}else throw Error(Oe(198));vI||(vI=!0,fE=u)}}function fp(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function $5(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function D4(e){if(fp(e)!==e)throw Error(Oe(188))}function xoe(e){var t=e.alternate;if(!t){if(t=fp(e),t===null)throw Error(Oe(188));return t!==e?null:e}for(var n=e,r=t;;){var s=n.return;if(s===null)break;var a=s.alternate;if(a===null){if(r=s.return,r!==null){n=r;continue}break}if(s.child===a.child){for(a=s.child;a;){if(a===n)return D4(s),e;if(a===r)return D4(s),t;a=a.sibling}throw Error(Oe(188))}if(n.return!==r.return)n=s,r=a;else{for(var i=!1,o=s.child;o;){if(o===n){i=!0,n=s,r=a;break}if(o===r){i=!0,r=s,n=a;break}o=o.sibling}if(!i){for(o=a.child;o;){if(o===n){i=!0,n=a,r=s;break}if(o===r){i=!0,r=a,n=s;break}o=o.sibling}if(!i)throw Error(Oe(189))}}if(n.alternate!==r)throw Error(Oe(190))}if(n.tag!==3)throw Error(Oe(188));return n.stateNode.current===n?e:t}function T5(e){return e=xoe(e),e!==null?_5(e):null}function _5(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=_5(e);if(t!==null)return t;e=e.sibling}return null}var E5=Ni.unstable_scheduleCallback,F4=Ni.unstable_cancelCallback,woe=Ni.unstable_shouldYield,voe=Ni.unstable_requestPaint,Sr=Ni.unstable_now,koe=Ni.unstable_getCurrentPriorityLevel,TD=Ni.unstable_ImmediatePriority,A5=Ni.unstable_UserBlockingPriority,kI=Ni.unstable_NormalPriority,Ioe=Ni.unstable_LowPriority,R5=Ni.unstable_IdlePriority,aC=null,Rl=null;function Soe(e){if(Rl&&typeof Rl.onCommitFiberRoot=="function")try{Rl.onCommitFiberRoot(aC,e,void 0,(e.current.flags&128)===128)}catch{}}var Wo=Math.clz32?Math.clz32:$oe,Coe=Math.log,Noe=Math.LN2;function $oe(e){return e>>>=0,e===0?32:31-(Coe(e)/Noe|0)|0}var Wv=64,Vv=4194304;function hx(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function II(e,t){var n=e.pendingLanes;if(n===0)return 0;var r=0,s=e.suspendedLanes,a=e.pingedLanes,i=n&268435455;if(i!==0){var o=i&~s;o!==0?r=hx(o):(a&=i,a!==0&&(r=hx(a)))}else i=n&~s,i!==0?r=hx(i):a!==0&&(r=hx(a));if(r===0)return 0;if(t!==0&&t!==r&&!(t&s)&&(s=r&-r,a=t&-t,s>=a||s===16&&(a&4194240)!==0))return t;if(r&4&&(r|=n&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=r;0<t;)n=31-Wo(t),s=1<<n,r|=e[n],t&=~s;return r}function Toe(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function _oe(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,s=e.expirationTimes,a=e.pendingLanes;0<a;){var i=31-Wo(a),o=1<<i,l=s[i];l===-1?(!(o&n)||o&r)&&(s[i]=Toe(o,t)):l<=t&&(e.expiredLanes|=o),a&=~o}}function mE(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function D5(){var e=Wv;return Wv<<=1,!(Wv&4194240)&&(Wv=64),e}function TT(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function K0(e,t,n){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-Wo(t),e[t]=n}function Eoe(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var s=31-Wo(n),a=1<<s;t[s]=0,r[s]=-1,e[s]=-1,n&=~a}}function _D(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-Wo(n),s=1<<r;s&t|e[r]&t&&(e[r]|=t),n&=~s}}var kn=0;function F5(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var O5,ED,M5,L5,P5,gE=!1,Uv=[],Ic=null,Sc=null,Cc=null,Zx=new Map,Jx=new Map,cc=[],Aoe="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function O4(e,t){switch(e){case"focusin":case"focusout":Ic=null;break;case"dragenter":case"dragleave":Sc=null;break;case"mouseover":case"mouseout":Cc=null;break;case"pointerover":case"pointerout":Zx.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Jx.delete(t.pointerId)}}function jb(e,t,n,r,s,a){return e===null||e.nativeEvent!==a?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:a,targetContainers:[s]},t!==null&&(t=Y0(t),t!==null&&ED(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,s!==null&&t.indexOf(s)===-1&&t.push(s),e)}function Roe(e,t,n,r,s){switch(t){case"focusin":return Ic=jb(Ic,e,t,n,r,s),!0;case"dragenter":return Sc=jb(Sc,e,t,n,r,s),!0;case"mouseover":return Cc=jb(Cc,e,t,n,r,s),!0;case"pointerover":var a=s.pointerId;return Zx.set(a,jb(Zx.get(a)||null,e,t,n,r,s)),!0;case"gotpointercapture":return a=s.pointerId,Jx.set(a,jb(Jx.get(a)||null,e,t,n,r,s)),!0}return!1}function z5(e){var t=ph(e.target);if(t!==null){var n=fp(t);if(n!==null){if(t=n.tag,t===13){if(t=$5(n),t!==null){e.blockedOn=t,P5(e.priority,function(){M5(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Hk(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=yE(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(n===null){n=e.nativeEvent;var r=new n.constructor(n.type,n);dE=r,n.target.dispatchEvent(r),dE=null}else return t=Y0(n),t!==null&&ED(t),e.blockedOn=n,!1;t.shift()}return!0}function M4(e,t,n){Hk(e)&&n.delete(t)}function Doe(){gE=!1,Ic!==null&&Hk(Ic)&&(Ic=null),Sc!==null&&Hk(Sc)&&(Sc=null),Cc!==null&&Hk(Cc)&&(Cc=null),Zx.forEach(M4),Jx.forEach(M4)}function qb(e,t){e.blockedOn===t&&(e.blockedOn=null,gE||(gE=!0,Ni.unstable_scheduleCallback(Ni.unstable_NormalPriority,Doe)))}function Qx(e){function t(s){return qb(s,e)}if(0<Uv.length){qb(Uv[0],e);for(var n=1;n<Uv.length;n++){var r=Uv[n];r.blockedOn===e&&(r.blockedOn=null)}}for(Ic!==null&&qb(Ic,e),Sc!==null&&qb(Sc,e),Cc!==null&&qb(Cc,e),Zx.forEach(t),Jx.forEach(t),n=0;n<cc.length;n++)r=cc[n],r.blockedOn===e&&(r.blockedOn=null);for(;0<cc.length&&(n=cc[0],n.blockedOn===null);)z5(n),n.blockedOn===null&&cc.shift()}var zm=Bu.ReactCurrentBatchConfig,SI=!0;function Foe(e,t,n,r){var s=kn,a=zm.transition;zm.transition=null;try{kn=1,AD(e,t,n,r)}finally{kn=s,zm.transition=a}}function Ooe(e,t,n,r){var s=kn,a=zm.transition;zm.transition=null;try{kn=4,AD(e,t,n,r)}finally{kn=s,zm.transition=a}}function AD(e,t,n,r){if(SI){var s=yE(e,t,n,r);if(s===null)PT(e,t,r,CI,n),O4(e,r);else if(Roe(s,e,t,n,r))r.stopPropagation();else if(O4(e,r),t&4&&-1<Aoe.indexOf(e)){for(;s!==null;){var a=Y0(s);if(a!==null&&O5(a),a=yE(e,t,n,r),a===null&&PT(e,t,r,CI,n),a===s)break;s=a}s!==null&&r.stopPropagation()}else PT(e,t,r,null,n)}}var CI=null;function yE(e,t,n,r){if(CI=null,e=$D(r),e=ph(e),e!==null)if(t=fp(e),t===null)e=null;else if(n=t.tag,n===13){if(e=$5(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return CI=e,null}function B5(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(koe()){case TD:return 1;case A5:return 4;case kI:case Ioe:return 16;case R5:return 536870912;default:return 16}default:return 16}}var pc=null,RD=null,jk=null;function W5(){if(jk)return jk;var e,t=RD,n=t.length,r,s="value"in pc?pc.value:pc.textContent,a=s.length;for(e=0;e<n&&t[e]===s[e];e++);var i=n-e;for(r=1;r<=i&&t[n-r]===s[a-r];r++);return jk=s.slice(e,1<r?1-r:void 0)}function qk(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function Gv(){return!0}function L4(){return!1}function Oi(e){function t(n,r,s,a,i){this._reactName=n,this._targetInst=s,this.type=r,this.nativeEvent=a,this.target=i,this.currentTarget=null;for(var o in e)e.hasOwnProperty(o)&&(n=e[o],this[o]=n?n(a):a[o]);return this.isDefaultPrevented=(a.defaultPrevented!=null?a.defaultPrevented:a.returnValue===!1)?Gv:L4,this.isPropagationStopped=L4,this}return pr(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=Gv)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=Gv)},persist:function(){},isPersistent:Gv}),t}var Xg={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},DD=Oi(Xg),X0=pr({},Xg,{view:0,detail:0}),Moe=Oi(X0),_T,ET,Kb,iC=pr({},X0,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:FD,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Kb&&(Kb&&e.type==="mousemove"?(_T=e.screenX-Kb.screenX,ET=e.screenY-Kb.screenY):ET=_T=0,Kb=e),_T)},movementY:function(e){return"movementY"in e?e.movementY:ET}}),P4=Oi(iC),Loe=pr({},iC,{dataTransfer:0}),Poe=Oi(Loe),zoe=pr({},X0,{relatedTarget:0}),AT=Oi(zoe),Boe=pr({},Xg,{animationName:0,elapsedTime:0,pseudoElement:0}),Woe=Oi(Boe),Voe=pr({},Xg,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),Uoe=Oi(Voe),Goe=pr({},Xg,{data:0}),z4=Oi(Goe),Hoe={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},joe={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},qoe={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Koe(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=qoe[e])?!!t[e]:!1}function FD(){return Koe}var Xoe=pr({},X0,{key:function(e){if(e.key){var t=Hoe[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=qk(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?joe[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:FD,charCode:function(e){return e.type==="keypress"?qk(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?qk(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),Yoe=Oi(Xoe),Zoe=pr({},iC,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),B4=Oi(Zoe),Joe=pr({},X0,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:FD}),Qoe=Oi(Joe),ele=pr({},Xg,{propertyName:0,elapsedTime:0,pseudoElement:0}),tle=Oi(ele),nle=pr({},iC,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),rle=Oi(nle),sle=[9,13,27,32],OD=Eu&&"CompositionEvent"in window,Rx=null;Eu&&"documentMode"in document&&(Rx=document.documentMode);var ale=Eu&&"TextEvent"in window&&!Rx,V5=Eu&&(!OD||Rx&&8<Rx&&11>=Rx),W4=String.fromCharCode(32),V4=!1;function U5(e,t){switch(e){case"keyup":return sle.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function G5(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var Im=!1;function ile(e,t){switch(e){case"compositionend":return G5(t);case"keypress":return t.which!==32?null:(V4=!0,W4);case"textInput":return e=t.data,e===W4&&V4?null:e;default:return null}}function ole(e,t){if(Im)return e==="compositionend"||!OD&&U5(e,t)?(e=W5(),jk=RD=pc=null,Im=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return V5&&t.locale!=="ko"?null:t.data;default:return null}}var lle={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function U4(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!lle[e.type]:t==="textarea"}function H5(e,t,n,r){k5(r),t=NI(t,"onChange"),0<t.length&&(n=new DD("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Dx=null,e0=null;function ule(e){nj(e,0)}function oC(e){var t=Nm(e);if(m5(t))return e}function cle(e,t){if(e==="change")return t}var j5=!1;if(Eu){var RT;if(Eu){var DT="oninput"in document;if(!DT){var G4=document.createElement("div");G4.setAttribute("oninput","return;"),DT=typeof G4.oninput=="function"}RT=DT}else RT=!1;j5=RT&&(!document.documentMode||9<document.documentMode)}function H4(){Dx&&(Dx.detachEvent("onpropertychange",q5),e0=Dx=null)}function q5(e){if(e.propertyName==="value"&&oC(e0)){var t=[];H5(t,e0,e,$D(e)),N5(ule,t)}}function dle(e,t,n){e==="focusin"?(H4(),Dx=t,e0=n,Dx.attachEvent("onpropertychange",q5)):e==="focusout"&&H4()}function hle(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return oC(e0)}function ple(e,t){if(e==="click")return oC(t)}function fle(e,t){if(e==="input"||e==="change")return oC(t)}function mle(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var Xo=typeof Object.is=="function"?Object.is:mle;function t0(e,t){if(Xo(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var s=n[r];if(!Q_.call(t,s)||!Xo(e[s],t[s]))return!1}return!0}function j4(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function q4(e,t){var n=j4(e);e=0;for(var r;n;){if(n.nodeType===3){if(r=e+n.textContent.length,e<=t&&r>=t)return{node:n,offset:t-e};e=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=j4(n)}}function K5(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?K5(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function X5(){for(var e=window,t=xI();t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href=="string"}catch{n=!1}if(n)e=t.contentWindow;else break;t=xI(e.document)}return t}function MD(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function gle(e){var t=X5(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&K5(n.ownerDocument.documentElement,n)){if(r!==null&&MD(n)){if(t=r.start,e=r.end,e===void 0&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if(e=(t=n.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var s=n.textContent.length,a=Math.min(r.start,s);r=r.end===void 0?a:Math.min(r.end,s),!e.extend&&a>r&&(s=r,r=a,a=s),s=q4(n,a);var i=q4(n,r);s&&i&&(e.rangeCount!==1||e.anchorNode!==s.node||e.anchorOffset!==s.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&(t=t.createRange(),t.setStart(s.node,s.offset),e.removeAllRanges(),a>r?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}}for(t=[],e=n;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<t.length;n++)e=t[n],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var yle=Eu&&"documentMode"in document&&11>=document.documentMode,Sm=null,bE=null,Fx=null,xE=!1;function K4(e,t,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;xE||Sm==null||Sm!==xI(r)||(r=Sm,"selectionStart"in r&&MD(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),Fx&&t0(Fx,r)||(Fx=r,r=NI(bE,"onSelect"),0<r.length&&(t=new DD("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=Sm)))}function Hv(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var Cm={animationend:Hv("Animation","AnimationEnd"),animationiteration:Hv("Animation","AnimationIteration"),animationstart:Hv("Animation","AnimationStart"),transitionend:Hv("Transition","TransitionEnd")},FT={},Y5={};Eu&&(Y5=document.createElement("div").style,"AnimationEvent"in window||(delete Cm.animationend.animation,delete Cm.animationiteration.animation,delete Cm.animationstart.animation),"TransitionEvent"in window||delete Cm.transitionend.transition);function lC(e){if(FT[e])return FT[e];if(!Cm[e])return e;var t=Cm[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in Y5)return FT[e]=t[n];return e}var Z5=lC("animationend"),J5=lC("animationiteration"),Q5=lC("animationstart"),ej=lC("transitionend"),tj=new Map,X4="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function dd(e,t){tj.set(e,t),pp(t,[e])}for(var OT=0;OT<X4.length;OT++){var MT=X4[OT],ble=MT.toLowerCase(),xle=MT[0].toUpperCase()+MT.slice(1);dd(ble,"on"+xle)}dd(Z5,"onAnimationEnd");dd(J5,"onAnimationIteration");dd(Q5,"onAnimationStart");dd("dblclick","onDoubleClick");dd("focusin","onFocus");dd("focusout","onBlur");dd(ej,"onTransitionEnd");Qm("onMouseEnter",["mouseout","mouseover"]);Qm("onMouseLeave",["mouseout","mouseover"]);Qm("onPointerEnter",["pointerout","pointerover"]);Qm("onPointerLeave",["pointerout","pointerover"]);pp("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));pp("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));pp("onBeforeInput",["compositionend","keypress","textInput","paste"]);pp("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));pp("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));pp("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var px="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),wle=new Set("cancel close invalid load scroll toggle".split(" ").concat(px));function Y4(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,boe(r,t,void 0,e),e.currentTarget=null}function nj(e,t){t=(t&4)!==0;for(var n=0;n<e.length;n++){var r=e[n],s=r.event;r=r.listeners;e:{var a=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==a&&s.isPropagationStopped())break e;Y4(s,o,u),a=l}else for(i=0;i<r.length;i++){if(o=r[i],l=o.instance,u=o.currentTarget,o=o.listener,l!==a&&s.isPropagationStopped())break e;Y4(s,o,u),a=l}}}if(vI)throw e=fE,vI=!1,fE=null,e}function qn(e,t){var n=t[SE];n===void 0&&(n=t[SE]=new Set);var r=e+"__bubble";n.has(r)||(rj(t,e,2,!1),n.add(r))}function LT(e,t,n){var r=0;t&&(r|=4),rj(n,e,r,t)}var jv="_reactListening"+Math.random().toString(36).slice(2);function n0(e){if(!e[jv]){e[jv]=!0,c5.forEach(function(n){n!=="selectionchange"&&(wle.has(n)||LT(n,!1,e),LT(n,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[jv]||(t[jv]=!0,LT("selectionchange",!1,t))}}function rj(e,t,n,r){switch(B5(t)){case 1:var s=Foe;break;case 4:s=Ooe;break;default:s=AD}n=s.bind(null,t,n,e),s=void 0,!pE||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(s=!0),r?s!==void 0?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):s!==void 0?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function PT(e,t,n,r,s){var a=r;if(!(t&1)&&!(t&2)&&r!==null)e:for(;;){if(r===null)return;var i=r.tag;if(i===3||i===4){var o=r.stateNode.containerInfo;if(o===s||o.nodeType===8&&o.parentNode===s)break;if(i===4)for(i=r.return;i!==null;){var l=i.tag;if((l===3||l===4)&&(l=i.stateNode.containerInfo,l===s||l.nodeType===8&&l.parentNode===s))return;i=i.return}for(;o!==null;){if(i=ph(o),i===null)return;if(l=i.tag,l===5||l===6){r=a=i;continue e}o=o.parentNode}}r=r.return}N5(function(){var u=a,c=$D(n),d=[];e:{var h=tj.get(e);if(h!==void 0){var p=DD,f=e;switch(e){case"keypress":if(qk(n)===0)break e;case"keydown":case"keyup":p=Yoe;break;case"focusin":f="focus",p=AT;break;case"focusout":f="blur",p=AT;break;case"beforeblur":case"afterblur":p=AT;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":p=P4;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":p=Poe;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":p=Qoe;break;case Z5:case J5:case Q5:p=Woe;break;case ej:p=tle;break;case"scroll":p=Moe;break;case"wheel":p=rle;break;case"copy":case"cut":case"paste":p=Uoe;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":p=B4}var m=(t&4)!==0,g=!m&&e==="scroll",y=m?h!==null?h+"Capture":null:h;m=[];for(var b=u,x;b!==null;){x=b;var w=x.stateNode;if(x.tag===5&&w!==null&&(x=w,y!==null&&(w=Yx(b,y),w!=null&&m.push(r0(b,w,x)))),g)break;b=b.return}0<m.length&&(h=new p(h,f,null,n,c),d.push({event:h,listeners:m}))}}if(!(t&7)){e:{if(h=e==="mouseover"||e==="pointerover",p=e==="mouseout"||e==="pointerout",h&&n!==dE&&(f=n.relatedTarget||n.fromElement)&&(ph(f)||f[Au]))break e;if((p||h)&&(h=c.window===c?c:(h=c.ownerDocument)?h.defaultView||h.parentWindow:window,p?(f=n.relatedTarget||n.toElement,p=u,f=f?ph(f):null,f!==null&&(g=fp(f),f!==g||f.tag!==5&&f.tag!==6)&&(f=null)):(p=null,f=u),p!==f)){if(m=P4,w="onMouseLeave",y="onMouseEnter",b="mouse",(e==="pointerout"||e==="pointerover")&&(m=B4,w="onPointerLeave",y="onPointerEnter",b="pointer"),g=p==null?h:Nm(p),x=f==null?h:Nm(f),h=new m(w,b+"leave",p,n,c),h.target=g,h.relatedTarget=x,w=null,ph(c)===u&&(m=new m(y,b+"enter",f,n,c),m.target=x,m.relatedTarget=g,w=m),g=w,p&&f)t:{for(m=p,y=f,b=0,x=m;x;x=sm(x))b++;for(x=0,w=y;w;w=sm(w))x++;for(;0<b-x;)m=sm(m),b--;for(;0<x-b;)y=sm(y),x--;for(;b--;){if(m===y||y!==null&&m===y.alternate)break t;m=sm(m),y=sm(y)}m=null}else m=null;p!==null&&Z4(d,h,p,m,!1),f!==null&&g!==null&&Z4(d,g,f,m,!0)}}e:{if(h=u?Nm(u):window,p=h.nodeName&&h.nodeName.toLowerCase(),p==="select"||p==="input"&&h.type==="file")var v=cle;else if(U4(h))if(j5)v=fle;else{v=hle;var k=dle}else(p=h.nodeName)&&p.toLowerCase()==="input"&&(h.type==="checkbox"||h.type==="radio")&&(v=ple);if(v&&(v=v(e,u))){H5(d,v,n,c);break e}k&&k(e,h,u),e==="focusout"&&(k=h._wrapperState)&&k.controlled&&h.type==="number"&&iE(h,"number",h.value)}switch(k=u?Nm(u):window,e){case"focusin":(U4(k)||k.contentEditable==="true")&&(Sm=k,bE=u,Fx=null);break;case"focusout":Fx=bE=Sm=null;break;case"mousedown":xE=!0;break;case"contextmenu":case"mouseup":case"dragend":xE=!1,K4(d,n,c);break;case"selectionchange":if(yle)break;case"keydown":case"keyup":K4(d,n,c)}var I;if(OD)e:{switch(e){case"compositionstart":var S="onCompositionStart";break e;case"compositionend":S="onCompositionEnd";break e;case"compositionupdate":S="onCompositionUpdate";break e}S=void 0}else Im?U5(e,n)&&(S="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(S="onCompositionStart");S&&(V5&&n.locale!=="ko"&&(Im||S!=="onCompositionStart"?S==="onCompositionEnd"&&Im&&(I=W5()):(pc=c,RD="value"in pc?pc.value:pc.textContent,Im=!0)),k=NI(u,S),0<k.length&&(S=new z4(S,e,null,n,c),d.push({event:S,listeners:k}),I?S.data=I:(I=G5(n),I!==null&&(S.data=I)))),(I=ale?ile(e,n):ole(e,n))&&(u=NI(u,"onBeforeInput"),0<u.length&&(c=new z4("onBeforeInput","beforeinput",null,n,c),d.push({event:c,listeners:u}),c.data=I))}nj(d,t)})}function r0(e,t,n){return{instance:e,listener:t,currentTarget:n}}function NI(e,t){for(var n=t+"Capture",r=[];e!==null;){var s=e,a=s.stateNode;s.tag===5&&a!==null&&(s=a,a=Yx(e,n),a!=null&&r.unshift(r0(e,a,s)),a=Yx(e,t),a!=null&&r.push(r0(e,a,s))),e=e.return}return r}function sm(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function Z4(e,t,n,r,s){for(var a=t._reactName,i=[];n!==null&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(l!==null&&l===r)break;o.tag===5&&u!==null&&(o=u,s?(l=Yx(n,a),l!=null&&i.unshift(r0(n,l,o))):s||(l=Yx(n,a),l!=null&&i.push(r0(n,l,o)))),n=n.return}i.length!==0&&e.push({event:t,listeners:i})}var vle=/\r\n?/g,kle=/\u0000|\uFFFD/g;function J4(e){return(typeof e=="string"?e:""+e).replace(vle,`
`).replace(kle,"")}function qv(e,t,n){if(t=J4(t),J4(e)!==t&&n)throw Error(Oe(425))}function $I(){}var wE=null,vE=null;function kE(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var IE=typeof setTimeout=="function"?setTimeout:void 0,Ile=typeof clearTimeout=="function"?clearTimeout:void 0,Q4=typeof Promise=="function"?Promise:void 0,Sle=typeof queueMicrotask=="function"?queueMicrotask:typeof Q4<"u"?function(e){return Q4.resolve(null).then(e).catch(Cle)}:IE;function Cle(e){setTimeout(function(){throw e})}function zT(e,t){var n=t,r=0;do{var s=n.nextSibling;if(e.removeChild(n),s&&s.nodeType===8)if(n=s.data,n==="/$"){if(r===0){e.removeChild(s),Qx(t);return}r--}else n!=="$"&&n!=="$?"&&n!=="$!"||r++;n=s}while(n);Qx(t)}function Nc(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function eW(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"){if(t===0)return e;t--}else n==="/$"&&t++}e=e.previousSibling}return null}var Yg=Math.random().toString(36).slice(2),Nl="__reactFiber$"+Yg,s0="__reactProps$"+Yg,Au="__reactContainer$"+Yg,SE="__reactEvents$"+Yg,Nle="__reactListeners$"+Yg,$le="__reactHandles$"+Yg;function ph(e){var t=e[Nl];if(t)return t;for(var n=e.parentNode;n;){if(t=n[Au]||n[Nl]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=eW(e);e!==null;){if(n=e[Nl])return n;e=eW(e)}return t}e=n,n=e.parentNode}return null}function Y0(e){return e=e[Nl]||e[Au],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function Nm(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(Oe(33))}function uC(e){return e[s0]||null}var CE=[],$m=-1;function hd(e){return{current:e}}function Xn(e){0>$m||(e.current=CE[$m],CE[$m]=null,$m--)}function Vn(e,t){$m++,CE[$m]=e.current,e.current=t}var Wc={},Qs=hd(Wc),qa=hd(!1),Eh=Wc;function eg(e,t){var n=e.type.contextTypes;if(!n)return Wc;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var s={},a;for(a in n)s[a]=t[a];return r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=s),s}function Ka(e){return e=e.childContextTypes,e!=null}function TI(){Xn(qa),Xn(Qs)}function tW(e,t,n){if(Qs.current!==Wc)throw Error(Oe(168));Vn(Qs,t),Vn(qa,n)}function sj(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,typeof r.getChildContext!="function")return n;r=r.getChildContext();for(var s in r)if(!(s in t))throw Error(Oe(108,doe(e)||"Unknown",s));return pr({},n,r)}function _I(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Wc,Eh=Qs.current,Vn(Qs,e),Vn(qa,qa.current),!0}function nW(e,t,n){var r=e.stateNode;if(!r)throw Error(Oe(169));n?(e=sj(e,t,Eh),r.__reactInternalMemoizedMergedChildContext=e,Xn(qa),Xn(Qs),Vn(Qs,e)):Xn(qa),Vn(qa,n)}var du=null,cC=!1,BT=!1;function aj(e){du===null?du=[e]:du.push(e)}function Tle(e){cC=!0,aj(e)}function pd(){if(!BT&&du!==null){BT=!0;var e=0,t=kn;try{var n=du;for(kn=1;e<n.length;e++){var r=n[e];do r=r(!0);while(r!==null)}du=null,cC=!1}catch(s){throw du!==null&&(du=du.slice(e+1)),E5(TD,pd),s}finally{kn=t,BT=!1}}return null}var Tm=[],_m=0,EI=null,AI=0,Ji=[],Qi=0,Ah=null,vu=1,ku="";function eh(e,t){Tm[_m++]=AI,Tm[_m++]=EI,EI=e,AI=t}function ij(e,t,n){Ji[Qi++]=vu,Ji[Qi++]=ku,Ji[Qi++]=Ah,Ah=e;var r=vu;e=ku;var s=32-Wo(r)-1;r&=~(1<<s),n+=1;var a=32-Wo(t)+s;if(30<a){var i=s-s%5;a=(r&(1<<i)-1).toString(32),r>>=i,s-=i,vu=1<<32-Wo(t)+s|n<<s|r,ku=a+e}else vu=1<<a|n<<s|r,ku=e}function LD(e){e.return!==null&&(eh(e,1),ij(e,1,0))}function PD(e){for(;e===EI;)EI=Tm[--_m],Tm[_m]=null,AI=Tm[--_m],Tm[_m]=null;for(;e===Ah;)Ah=Ji[--Qi],Ji[Qi]=null,ku=Ji[--Qi],Ji[Qi]=null,vu=Ji[--Qi],Ji[Qi]=null}var Si=null,yi=null,nr=!1,Fo=null;function oj(e,t){var n=to(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)}function rW(e,t){switch(e.tag){case 5:var n=e.type;return t=t.nodeType!==1||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,Si=e,yi=Nc(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,Si=e,yi=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(n=Ah!==null?{id:vu,overflow:ku}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},n=to(18,null,null,0),n.stateNode=t,n.return=e,e.child=n,Si=e,yi=null,!0):!1;default:return!1}}function NE(e){return(e.mode&1)!==0&&(e.flags&128)===0}function $E(e){if(nr){var t=yi;if(t){var n=t;if(!rW(e,t)){if(NE(e))throw Error(Oe(418));t=Nc(n.nextSibling);var r=Si;t&&rW(e,t)?oj(r,n):(e.flags=e.flags&-4097|2,nr=!1,Si=e)}}else{if(NE(e))throw Error(Oe(418));e.flags=e.flags&-4097|2,nr=!1,Si=e}}}function sW(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;Si=e}function Kv(e){if(e!==Si)return!1;if(!nr)return sW(e),nr=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!kE(e.type,e.memoizedProps)),t&&(t=yi)){if(NE(e))throw lj(),Error(Oe(418));for(;t;)oj(e,t),t=Nc(t.nextSibling)}if(sW(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(Oe(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"){if(t===0){yi=Nc(e.nextSibling);break e}t--}else n!=="$"&&n!=="$!"&&n!=="$?"||t++}e=e.nextSibling}yi=null}}else yi=Si?Nc(e.stateNode.nextSibling):null;return!0}function lj(){for(var e=yi;e;)e=Nc(e.nextSibling)}function tg(){yi=Si=null,nr=!1}function zD(e){Fo===null?Fo=[e]:Fo.push(e)}var _le=Bu.ReactCurrentBatchConfig;function Ro(e,t){if(e&&e.defaultProps){t=pr({},t),e=e.defaultProps;for(var n in e)t[n]===void 0&&(t[n]=e[n]);return t}return t}var RI=hd(null),DI=null,Em=null,BD=null;function WD(){BD=Em=DI=null}function VD(e){var t=RI.current;Xn(RI),e._currentValue=t}function TE(e,t,n){for(;e!==null;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,r!==null&&(r.childLanes|=t)):r!==null&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function Bm(e,t){DI=e,BD=Em=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&t&&(Ua=!0),e.firstContext=null)}function mo(e){var t=e._currentValue;if(BD!==e)if(e={context:e,memoizedValue:t,next:null},Em===null){if(DI===null)throw Error(Oe(308));Em=e,DI.dependencies={lanes:0,firstContext:e}}else Em=Em.next=e;return t}var fh=null;function UD(e){fh===null?fh=[e]:fh.push(e)}function uj(e,t,n,r){var s=t.interleaved;return s===null?(n.next=n,UD(t)):(n.next=s.next,s.next=n),t.interleaved=n,Ru(e,r)}function Ru(e,t){e.lanes|=t;var n=e.alternate;for(n!==null&&(n.lanes|=t),n=e,e=e.return;e!==null;)e.childLanes|=t,n=e.alternate,n!==null&&(n.childLanes|=t),n=e,e=e.return;return n.tag===3?n.stateNode:null}var oc=!1;function GD(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function cj(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Iu(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function $c(e,t,n){var r=e.updateQueue;if(r===null)return null;if(r=r.shared,cn&2){var s=r.pending;return s===null?t.next=t:(t.next=s.next,s.next=t),r.pending=t,Ru(e,n)}return s=r.interleaved,s===null?(t.next=t,UD(r)):(t.next=s.next,s.next=t),r.interleaved=t,Ru(e,n)}function Kk(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,(n&4194240)!==0)){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,_D(e,n)}}function aW(e,t){var n=e.updateQueue,r=e.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var s=null,a=null;if(n=n.firstBaseUpdate,n!==null){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};a===null?s=a=i:a=a.next=i,n=n.next}while(n!==null);a===null?s=a=t:a=a.next=t}else s=a=t;n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:a,shared:r.shared,effects:r.effects},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function FI(e,t,n,r){var s=e.updateQueue;oc=!1;var a=s.firstBaseUpdate,i=s.lastBaseUpdate,o=s.shared.pending;if(o!==null){s.shared.pending=null;var l=o,u=l.next;l.next=null,i===null?a=u:i.next=u,i=l;var c=e.alternate;c!==null&&(c=c.updateQueue,o=c.lastBaseUpdate,o!==i&&(o===null?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(a!==null){var d=s.baseState;i=0,c=u=l=null,o=a;do{var h=o.lane,p=o.eventTime;if((r&h)===h){c!==null&&(c=c.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(h=t,p=n,m.tag){case 1:if(f=m.payload,typeof f=="function"){d=f.call(p,d,h);break e}d=f;break e;case 3:f.flags=f.flags&-65537|128;case 0:if(f=m.payload,h=typeof f=="function"?f.call(p,d,h):f,h==null)break e;d=pr({},d,h);break e;case 2:oc=!0}}o.callback!==null&&o.lane!==0&&(e.flags|=64,h=s.effects,h===null?s.effects=[o]:h.push(o))}else p={eventTime:p,lane:h,tag:o.tag,payload:o.payload,callback:o.callback,next:null},c===null?(u=c=p,l=d):c=c.next=p,i|=h;if(o=o.next,o===null){if(o=s.shared.pending,o===null)break;h=o,o=h.next,h.next=null,s.lastBaseUpdate=h,s.shared.pending=null}}while(1);if(c===null&&(l=d),s.baseState=l,s.firstBaseUpdate=u,s.lastBaseUpdate=c,t=s.shared.interleaved,t!==null){s=t;do i|=s.lane,s=s.next;while(s!==t)}else a===null&&(s.shared.lanes=0);Dh|=i,e.lanes=i,e.memoizedState=d}}function iW(e,t,n){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var r=e[t],s=r.callback;if(s!==null){if(r.callback=null,r=n,typeof s!="function")throw Error(Oe(191,s));s.call(r)}}}var dj=new u5.Component().refs;function _E(e,t,n,r){t=e.memoizedState,n=n(r,t),n=n==null?t:pr({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var dC={isMounted:function(e){return(e=e._reactInternals)?fp(e)===e:!1},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=Ia(),s=_c(e),a=Iu(r,s);a.payload=t,n!=null&&(a.callback=n),t=$c(e,a,s),t!==null&&(Vo(t,e,s,r),Kk(t,e,s))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=Ia(),s=_c(e),a=Iu(r,s);a.tag=1,a.payload=t,n!=null&&(a.callback=n),t=$c(e,a,s),t!==null&&(Vo(t,e,s,r),Kk(t,e,s))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=Ia(),r=_c(e),s=Iu(n,r);s.tag=2,t!=null&&(s.callback=t),t=$c(e,s,r),t!==null&&(Vo(t,e,r,n),Kk(t,e,r))}};function oW(e,t,n,r,s,a,i){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(r,a,i):t.prototype&&t.prototype.isPureReactComponent?!t0(n,r)||!t0(s,a):!0}function hj(e,t,n){var r=!1,s=Wc,a=t.contextType;return typeof a=="object"&&a!==null?a=mo(a):(s=Ka(t)?Eh:Qs.current,r=t.contextTypes,a=(r=r!=null)?eg(e,s):Wc),t=new t(n,a),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=dC,e.stateNode=t,t._reactInternals=e,r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=s,e.__reactInternalMemoizedMaskedChildContext=a),t}function lW(e,t,n,r){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(n,r),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&dC.enqueueReplaceState(t,t.state,null)}function EE(e,t,n,r){var s=e.stateNode;s.props=n,s.state=e.memoizedState,s.refs=dj,GD(e);var a=t.contextType;typeof a=="object"&&a!==null?s.context=mo(a):(a=Ka(t)?Eh:Qs.current,s.context=eg(e,a)),s.state=e.memoizedState,a=t.getDerivedStateFromProps,typeof a=="function"&&(_E(e,t,a,n),s.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof s.getSnapshotBeforeUpdate=="function"||typeof s.UNSAFE_componentWillMount!="function"&&typeof s.componentWillMount!="function"||(t=s.state,typeof s.componentWillMount=="function"&&s.componentWillMount(),typeof s.UNSAFE_componentWillMount=="function"&&s.UNSAFE_componentWillMount(),t!==s.state&&dC.enqueueReplaceState(s,s.state,null),FI(e,n,s,r),s.state=e.memoizedState),typeof s.componentDidMount=="function"&&(e.flags|=4194308)}function Xb(e,t,n){if(e=n.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(Oe(309));var r=n.stateNode}if(!r)throw Error(Oe(147,e));var s=r,a=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===a?t.ref:(t=function(i){var o=s.refs;o===dj&&(o=s.refs={}),i===null?delete o[a]:o[a]=i},t._stringRef=a,t)}if(typeof e!="string")throw Error(Oe(284));if(!n._owner)throw Error(Oe(290,e))}return e}function Xv(e,t){throw e=Object.prototype.toString.call(t),Error(Oe(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function uW(e){var t=e._init;return t(e._payload)}function pj(e){function t(y,b){if(e){var x=y.deletions;x===null?(y.deletions=[b],y.flags|=16):x.push(b)}}function n(y,b){if(!e)return null;for(;b!==null;)t(y,b),b=b.sibling;return null}function r(y,b){for(y=new Map;b!==null;)b.key!==null?y.set(b.key,b):y.set(b.index,b),b=b.sibling;return y}function s(y,b){return y=Ec(y,b),y.index=0,y.sibling=null,y}function a(y,b,x){return y.index=x,e?(x=y.alternate,x!==null?(x=x.index,x<b?(y.flags|=2,b):x):(y.flags|=2,b)):(y.flags|=1048576,b)}function i(y){return e&&y.alternate===null&&(y.flags|=2),y}function o(y,b,x,w){return b===null||b.tag!==6?(b=qT(x,y.mode,w),b.return=y,b):(b=s(b,x),b.return=y,b)}function l(y,b,x,w){var v=x.type;return v===km?c(y,b,x.props.children,w,x.key):b!==null&&(b.elementType===v||typeof v=="object"&&v!==null&&v.$$typeof===ic&&uW(v)===b.type)?(w=s(b,x.props),w.ref=Xb(y,b,x),w.return=y,w):(w=eI(x.type,x.key,x.props,null,y.mode,w),w.ref=Xb(y,b,x),w.return=y,w)}function u(y,b,x,w){return b===null||b.tag!==4||b.stateNode.containerInfo!==x.containerInfo||b.stateNode.implementation!==x.implementation?(b=KT(x,y.mode,w),b.return=y,b):(b=s(b,x.children||[]),b.return=y,b)}function c(y,b,x,w,v){return b===null||b.tag!==7?(b=Ih(x,y.mode,w,v),b.return=y,b):(b=s(b,x),b.return=y,b)}function d(y,b,x){if(typeof b=="string"&&b!==""||typeof b=="number")return b=qT(""+b,y.mode,x),b.return=y,b;if(typeof b=="object"&&b!==null){switch(b.$$typeof){case Pv:return x=eI(b.type,b.key,b.props,null,y.mode,x),x.ref=Xb(y,null,b),x.return=y,x;case vm:return b=KT(b,y.mode,x),b.return=y,b;case ic:var w=b._init;return d(y,w(b._payload),x)}if(dx(b)||Gb(b))return b=Ih(b,y.mode,x,null),b.return=y,b;Xv(y,b)}return null}function h(y,b,x,w){var v=b!==null?b.key:null;if(typeof x=="string"&&x!==""||typeof x=="number")return v!==null?null:o(y,b,""+x,w);if(typeof x=="object"&&x!==null){switch(x.$$typeof){case Pv:return x.key===v?l(y,b,x,w):null;case vm:return x.key===v?u(y,b,x,w):null;case ic:return v=x._init,h(y,b,v(x._payload),w)}if(dx(x)||Gb(x))return v!==null?null:c(y,b,x,w,null);Xv(y,x)}return null}function p(y,b,x,w,v){if(typeof w=="string"&&w!==""||typeof w=="number")return y=y.get(x)||null,o(b,y,""+w,v);if(typeof w=="object"&&w!==null){switch(w.$$typeof){case Pv:return y=y.get(w.key===null?x:w.key)||null,l(b,y,w,v);case vm:return y=y.get(w.key===null?x:w.key)||null,u(b,y,w,v);case ic:var k=w._init;return p(y,b,x,k(w._payload),v)}if(dx(w)||Gb(w))return y=y.get(x)||null,c(b,y,w,v,null);Xv(b,w)}return null}function f(y,b,x,w){for(var v=null,k=null,I=b,S=b=0,$=null;I!==null&&S<x.length;S++){I.index>S?($=I,I=null):$=I.sibling;var N=h(y,I,x[S],w);if(N===null){I===null&&(I=$);break}e&&I&&N.alternate===null&&t(y,I),b=a(N,b,S),k===null?v=N:k.sibling=N,k=N,I=$}if(S===x.length)return n(y,I),nr&&eh(y,S),v;if(I===null){for(;S<x.length;S++)I=d(y,x[S],w),I!==null&&(b=a(I,b,S),k===null?v=I:k.sibling=I,k=I);return nr&&eh(y,S),v}for(I=r(y,I);S<x.length;S++)$=p(I,y,S,x[S],w),$!==null&&(e&&$.alternate!==null&&I.delete($.key===null?S:$.key),b=a($,b,S),k===null?v=$:k.sibling=$,k=$);return e&&I.forEach(function(T){return t(y,T)}),nr&&eh(y,S),v}function m(y,b,x,w){var v=Gb(x);if(typeof v!="function")throw Error(Oe(150));if(x=v.call(x),x==null)throw Error(Oe(151));for(var k=v=null,I=b,S=b=0,$=null,N=x.next();I!==null&&!N.done;S++,N=x.next()){I.index>S?($=I,I=null):$=I.sibling;var T=h(y,I,N.value,w);if(T===null){I===null&&(I=$);break}e&&I&&T.alternate===null&&t(y,I),b=a(T,b,S),k===null?v=T:k.sibling=T,k=T,I=$}if(N.done)return n(y,I),nr&&eh(y,S),v;if(I===null){for(;!N.done;S++,N=x.next())N=d(y,N.value,w),N!==null&&(b=a(N,b,S),k===null?v=N:k.sibling=N,k=N);return nr&&eh(y,S),v}for(I=r(y,I);!N.done;S++,N=x.next())N=p(I,y,S,N.value,w),N!==null&&(e&&N.alternate!==null&&I.delete(N.key===null?S:N.key),b=a(N,b,S),k===null?v=N:k.sibling=N,k=N);return e&&I.forEach(function(C){return t(y,C)}),nr&&eh(y,S),v}function g(y,b,x,w){if(typeof x=="object"&&x!==null&&x.type===km&&x.key===null&&(x=x.props.children),typeof x=="object"&&x!==null){switch(x.$$typeof){case Pv:e:{for(var v=x.key,k=b;k!==null;){if(k.key===v){if(v=x.type,v===km){if(k.tag===7){n(y,k.sibling),b=s(k,x.props.children),b.return=y,y=b;break e}}else if(k.elementType===v||typeof v=="object"&&v!==null&&v.$$typeof===ic&&uW(v)===k.type){n(y,k.sibling),b=s(k,x.props),b.ref=Xb(y,k,x),b.return=y,y=b;break e}n(y,k);break}else t(y,k);k=k.sibling}x.type===km?(b=Ih(x.props.children,y.mode,w,x.key),b.return=y,y=b):(w=eI(x.type,x.key,x.props,null,y.mode,w),w.ref=Xb(y,b,x),w.return=y,y=w)}return i(y);case vm:e:{for(k=x.key;b!==null;){if(b.key===k)if(b.tag===4&&b.stateNode.containerInfo===x.containerInfo&&b.stateNode.implementation===x.implementation){n(y,b.sibling),b=s(b,x.children||[]),b.return=y,y=b;break e}else{n(y,b);break}else t(y,b);b=b.sibling}b=KT(x,y.mode,w),b.return=y,y=b}return i(y);case ic:return k=x._init,g(y,b,k(x._payload),w)}if(dx(x))return f(y,b,x,w);if(Gb(x))return m(y,b,x,w);Xv(y,x)}return typeof x=="string"&&x!==""||typeof x=="number"?(x=""+x,b!==null&&b.tag===6?(n(y,b.sibling),b=s(b,x),b.return=y,y=b):(n(y,b),b=qT(x,y.mode,w),b.return=y,y=b),i(y)):n(y,b)}return g}var ng=pj(!0),fj=pj(!1),Z0={},Dl=hd(Z0),a0=hd(Z0),i0=hd(Z0);function mh(e){if(e===Z0)throw Error(Oe(174));return e}function HD(e,t){switch(Vn(i0,t),Vn(a0,e),Vn(Dl,Z0),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:lE(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=lE(t,e)}Xn(Dl),Vn(Dl,t)}function rg(){Xn(Dl),Xn(a0),Xn(i0)}function mj(e){mh(i0.current);var t=mh(Dl.current),n=lE(t,e.type);t!==n&&(Vn(a0,e),Vn(Dl,n))}function jD(e){a0.current===e&&(Xn(Dl),Xn(a0))}var cr=hd(0);function OI(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var WT=[];function qD(){for(var e=0;e<WT.length;e++)WT[e]._workInProgressVersionPrimary=null;WT.length=0}var Xk=Bu.ReactCurrentDispatcher,VT=Bu.ReactCurrentBatchConfig,Rh=0,hr=null,Zr=null,ps=null,MI=!1,Ox=!1,o0=0,Ele=0;function Us(){throw Error(Oe(321))}function KD(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Xo(e[n],t[n]))return!1;return!0}function XD(e,t,n,r,s,a){if(Rh=a,hr=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,Xk.current=e===null||e.memoizedState===null?Fle:Ole,e=n(r,s),Ox){a=0;do{if(Ox=!1,o0=0,25<=a)throw Error(Oe(301));a+=1,ps=Zr=null,t.updateQueue=null,Xk.current=Mle,e=n(r,s)}while(Ox)}if(Xk.current=LI,t=Zr!==null&&Zr.next!==null,Rh=0,ps=Zr=hr=null,MI=!1,t)throw Error(Oe(300));return e}function YD(){var e=o0!==0;return o0=0,e}function yl(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return ps===null?hr.memoizedState=ps=e:ps=ps.next=e,ps}function go(){if(Zr===null){var e=hr.alternate;e=e!==null?e.memoizedState:null}else e=Zr.next;var t=ps===null?hr.memoizedState:ps.next;if(t!==null)ps=t,Zr=e;else{if(e===null)throw Error(Oe(310));Zr=e,e={memoizedState:Zr.memoizedState,baseState:Zr.baseState,baseQueue:Zr.baseQueue,queue:Zr.queue,next:null},ps===null?hr.memoizedState=ps=e:ps=ps.next=e}return ps}function l0(e,t){return typeof t=="function"?t(e):t}function UT(e){var t=go(),n=t.queue;if(n===null)throw Error(Oe(311));n.lastRenderedReducer=e;var r=Zr,s=r.baseQueue,a=n.pending;if(a!==null){if(s!==null){var i=s.next;s.next=a.next,a.next=i}r.baseQueue=s=a,n.pending=null}if(s!==null){a=s.next,r=r.baseState;var o=i=null,l=null,u=a;do{var c=u.lane;if((Rh&c)===c)l!==null&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),r=u.hasEagerState?u.eagerState:e(r,u.action);else{var d={lane:c,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};l===null?(o=l=d,i=r):l=l.next=d,hr.lanes|=c,Dh|=c}u=u.next}while(u!==null&&u!==a);l===null?i=r:l.next=o,Xo(r,t.memoizedState)||(Ua=!0),t.memoizedState=r,t.baseState=i,t.baseQueue=l,n.lastRenderedState=r}if(e=n.interleaved,e!==null){s=e;do a=s.lane,hr.lanes|=a,Dh|=a,s=s.next;while(s!==e)}else s===null&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function GT(e){var t=go(),n=t.queue;if(n===null)throw Error(Oe(311));n.lastRenderedReducer=e;var r=n.dispatch,s=n.pending,a=t.memoizedState;if(s!==null){n.pending=null;var i=s=s.next;do a=e(a,i.action),i=i.next;while(i!==s);Xo(a,t.memoizedState)||(Ua=!0),t.memoizedState=a,t.baseQueue===null&&(t.baseState=a),n.lastRenderedState=a}return[a,r]}function gj(){}function yj(e,t){var n=hr,r=go(),s=t(),a=!Xo(r.memoizedState,s);if(a&&(r.memoizedState=s,Ua=!0),r=r.queue,ZD(wj.bind(null,n,r,e),[e]),r.getSnapshot!==t||a||ps!==null&&ps.memoizedState.tag&1){if(n.flags|=2048,u0(9,xj.bind(null,n,r,s,t),void 0,null),vs===null)throw Error(Oe(349));Rh&30||bj(n,t,s)}return s}function bj(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=hr.updateQueue,t===null?(t={lastEffect:null,stores:null},hr.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function xj(e,t,n,r){t.value=n,t.getSnapshot=r,vj(t)&&kj(e)}function wj(e,t,n){return n(function(){vj(t)&&kj(e)})}function vj(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Xo(e,n)}catch{return!0}}function kj(e){var t=Ru(e,1);t!==null&&Vo(t,e,1,-1)}function cW(e){var t=yl();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:l0,lastRenderedState:e},t.queue=e,e=e.dispatch=Dle.bind(null,hr,e),[t.memoizedState,e]}function u0(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},t=hr.updateQueue,t===null?(t={lastEffect:null,stores:null},hr.updateQueue=t,t.lastEffect=e.next=e):(n=t.lastEffect,n===null?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e)),e}function Ij(){return go().memoizedState}function Yk(e,t,n,r){var s=yl();hr.flags|=e,s.memoizedState=u0(1|t,n,void 0,r===void 0?null:r)}function hC(e,t,n,r){var s=go();r=r===void 0?null:r;var a=void 0;if(Zr!==null){var i=Zr.memoizedState;if(a=i.destroy,r!==null&&KD(r,i.deps)){s.memoizedState=u0(t,n,a,r);return}}hr.flags|=e,s.memoizedState=u0(1|t,n,a,r)}function dW(e,t){return Yk(8390656,8,e,t)}function ZD(e,t){return hC(2048,8,e,t)}function Sj(e,t){return hC(4,2,e,t)}function Cj(e,t){return hC(4,4,e,t)}function Nj(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function $j(e,t,n){return n=n!=null?n.concat([e]):null,hC(4,4,Nj.bind(null,t,e),n)}function JD(){}function Tj(e,t){var n=go();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&KD(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function _j(e,t){var n=go();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&KD(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Ej(e,t,n){return Rh&21?(Xo(n,t)||(n=D5(),hr.lanes|=n,Dh|=n,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,Ua=!0),e.memoizedState=n)}function Ale(e,t){var n=kn;kn=n!==0&&4>n?n:4,e(!0);var r=VT.transition;VT.transition={};try{e(!1),t()}finally{kn=n,VT.transition=r}}function Aj(){return go().memoizedState}function Rle(e,t,n){var r=_c(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},Rj(e))Dj(t,n);else if(n=uj(e,t,n,r),n!==null){var s=Ia();Vo(n,e,r,s),Fj(n,t,r)}}function Dle(e,t,n){var r=_c(e),s={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(Rj(e))Dj(t,s);else{var a=e.alternate;if(e.lanes===0&&(a===null||a.lanes===0)&&(a=t.lastRenderedReducer,a!==null))try{var i=t.lastRenderedState,o=a(i,n);if(s.hasEagerState=!0,s.eagerState=o,Xo(o,i)){var l=t.interleaved;l===null?(s.next=s,UD(t)):(s.next=l.next,l.next=s),t.interleaved=s;return}}catch{}finally{}n=uj(e,t,s,r),n!==null&&(s=Ia(),Vo(n,e,r,s),Fj(n,t,r))}}function Rj(e){var t=e.alternate;return e===hr||t!==null&&t===hr}function Dj(e,t){Ox=MI=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Fj(e,t,n){if(n&4194240){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,_D(e,n)}}var LI={readContext:mo,useCallback:Us,useContext:Us,useEffect:Us,useImperativeHandle:Us,useInsertionEffect:Us,useLayoutEffect:Us,useMemo:Us,useReducer:Us,useRef:Us,useState:Us,useDebugValue:Us,useDeferredValue:Us,useTransition:Us,useMutableSource:Us,useSyncExternalStore:Us,useId:Us,unstable_isNewReconciler:!1},Fle={readContext:mo,useCallback:function(e,t){return yl().memoizedState=[e,t===void 0?null:t],e},useContext:mo,useEffect:dW,useImperativeHandle:function(e,t,n){return n=n!=null?n.concat([e]):null,Yk(4194308,4,Nj.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Yk(4194308,4,e,t)},useInsertionEffect:function(e,t){return Yk(4,2,e,t)},useMemo:function(e,t){var n=yl();return t=t===void 0?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=yl();return t=n!==void 0?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=Rle.bind(null,hr,e),[r.memoizedState,e]},useRef:function(e){var t=yl();return e={current:e},t.memoizedState=e},useState:cW,useDebugValue:JD,useDeferredValue:function(e){return yl().memoizedState=e},useTransition:function(){var e=cW(!1),t=e[0];return e=Ale.bind(null,e[1]),yl().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=hr,s=yl();if(nr){if(n===void 0)throw Error(Oe(407));n=n()}else{if(n=t(),vs===null)throw Error(Oe(349));Rh&30||bj(r,t,n)}s.memoizedState=n;var a={value:n,getSnapshot:t};return s.queue=a,dW(wj.bind(null,r,a,e),[e]),r.flags|=2048,u0(9,xj.bind(null,r,a,n,t),void 0,null),n},useId:function(){var e=yl(),t=vs.identifierPrefix;if(nr){var n=ku,r=vu;n=(r&~(1<<32-Wo(r)-1)).toString(32)+n,t=":"+t+"R"+n,n=o0++,0<n&&(t+="H"+n.toString(32)),t+=":"}else n=Ele++,t=":"+t+"r"+n.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},Ole={readContext:mo,useCallback:Tj,useContext:mo,useEffect:ZD,useImperativeHandle:$j,useInsertionEffect:Sj,useLayoutEffect:Cj,useMemo:_j,useReducer:UT,useRef:Ij,useState:function(){return UT(l0)},useDebugValue:JD,useDeferredValue:function(e){var t=go();return Ej(t,Zr.memoizedState,e)},useTransition:function(){var e=UT(l0)[0],t=go().memoizedState;return[e,t]},useMutableSource:gj,useSyncExternalStore:yj,useId:Aj,unstable_isNewReconciler:!1},Mle={readContext:mo,useCallback:Tj,useContext:mo,useEffect:ZD,useImperativeHandle:$j,useInsertionEffect:Sj,useLayoutEffect:Cj,useMemo:_j,useReducer:GT,useRef:Ij,useState:function(){return GT(l0)},useDebugValue:JD,useDeferredValue:function(e){var t=go();return Zr===null?t.memoizedState=e:Ej(t,Zr.memoizedState,e)},useTransition:function(){var e=GT(l0)[0],t=go().memoizedState;return[e,t]},useMutableSource:gj,useSyncExternalStore:yj,useId:Aj,unstable_isNewReconciler:!1};function sg(e,t){try{var n="",r=t;do n+=coe(r),r=r.return;while(r);var s=n}catch(a){s=`
Error generating stack: `+a.message+`
`+a.stack}return{value:e,source:t,stack:s,digest:null}}function HT(e,t,n){return{value:e,source:null,stack:n??null,digest:t??null}}function AE(e,t){try{console.error(t.value)}catch(n){setTimeout(function(){throw n})}}var Lle=typeof WeakMap=="function"?WeakMap:Map;function Oj(e,t,n){n=Iu(-1,n),n.tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){zI||(zI=!0,WE=r),AE(e,t)},n}function Mj(e,t,n){n=Iu(-1,n),n.tag=3;var r=e.type.getDerivedStateFromError;if(typeof r=="function"){var s=t.value;n.payload=function(){return r(s)},n.callback=function(){AE(e,t)}}var a=e.stateNode;return a!==null&&typeof a.componentDidCatch=="function"&&(n.callback=function(){AE(e,t),typeof r!="function"&&(Tc===null?Tc=new Set([this]):Tc.add(this));var i=t.stack;this.componentDidCatch(t.value,{componentStack:i!==null?i:""})}),n}function hW(e,t,n){var r=e.pingCache;if(r===null){r=e.pingCache=new Lle;var s=new Set;r.set(t,s)}else s=r.get(t),s===void 0&&(s=new Set,r.set(t,s));s.has(n)||(s.add(n),e=Zle.bind(null,e,t,n),t.then(e,e))}function pW(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function fW(e,t,n,r,s){return e.mode&1?(e.flags|=65536,e.lanes=s,e):(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(t=Iu(-1,1),t.tag=2,$c(n,t,1))),n.lanes|=1),e)}var Ple=Bu.ReactCurrentOwner,Ua=!1;function ma(e,t,n,r){t.child=e===null?fj(t,null,n,r):ng(t,e.child,n,r)}function mW(e,t,n,r,s){n=n.render;var a=t.ref;return Bm(t,s),r=XD(e,t,n,r,a,s),n=YD(),e!==null&&!Ua?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,Du(e,t,s)):(nr&&n&&LD(t),t.flags|=1,ma(e,t,r,s),t.child)}function gW(e,t,n,r,s){if(e===null){var a=n.type;return typeof a=="function"&&!iF(a)&&a.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(t.tag=15,t.type=a,Lj(e,t,a,r,s)):(e=eI(n.type,null,r,t,t.mode,s),e.ref=t.ref,e.return=t,t.child=e)}if(a=e.child,!(e.lanes&s)){var i=a.memoizedProps;if(n=n.compare,n=n!==null?n:t0,n(i,r)&&e.ref===t.ref)return Du(e,t,s)}return t.flags|=1,e=Ec(a,r),e.ref=t.ref,e.return=t,t.child=e}function Lj(e,t,n,r,s){if(e!==null){var a=e.memoizedProps;if(t0(a,r)&&e.ref===t.ref)if(Ua=!1,t.pendingProps=r=a,(e.lanes&s)!==0)e.flags&131072&&(Ua=!0);else return t.lanes=e.lanes,Du(e,t,s)}return RE(e,t,n,r,s)}function Pj(e,t,n){var r=t.pendingProps,s=r.children,a=e!==null?e.memoizedState:null;if(r.mode==="hidden")if(!(t.mode&1))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Vn(Rm,fi),fi|=n;else{if(!(n&1073741824))return e=a!==null?a.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Vn(Rm,fi),fi|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=a!==null?a.baseLanes:n,Vn(Rm,fi),fi|=r}else a!==null?(r=a.baseLanes|n,t.memoizedState=null):r=n,Vn(Rm,fi),fi|=r;return ma(e,t,s,n),t.child}function zj(e,t){var n=t.ref;(e===null&&n!==null||e!==null&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function RE(e,t,n,r,s){var a=Ka(n)?Eh:Qs.current;return a=eg(t,a),Bm(t,s),n=XD(e,t,n,r,a,s),r=YD(),e!==null&&!Ua?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,Du(e,t,s)):(nr&&r&&LD(t),t.flags|=1,ma(e,t,n,s),t.child)}function yW(e,t,n,r,s){if(Ka(n)){var a=!0;_I(t)}else a=!1;if(Bm(t,s),t.stateNode===null)Zk(e,t),hj(t,n,r),EE(t,n,r,s),r=!0;else if(e===null){var i=t.stateNode,o=t.memoizedProps;i.props=o;var l=i.context,u=n.contextType;typeof u=="object"&&u!==null?u=mo(u):(u=Ka(n)?Eh:Qs.current,u=eg(t,u));var c=n.getDerivedStateFromProps,d=typeof c=="function"||typeof i.getSnapshotBeforeUpdate=="function";d||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(o!==r||l!==u)&&lW(t,i,r,u),oc=!1;var h=t.memoizedState;i.state=h,FI(t,r,i,s),l=t.memoizedState,o!==r||h!==l||qa.current||oc?(typeof c=="function"&&(_E(t,n,c,r),l=t.memoizedState),(o=oc||oW(t,n,o,r,h,l,u))?(d||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount()),typeof i.componentDidMount=="function"&&(t.flags|=4194308)):(typeof i.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),i.props=r,i.state=l,i.context=u,r=o):(typeof i.componentDidMount=="function"&&(t.flags|=4194308),r=!1)}else{i=t.stateNode,cj(e,t),o=t.memoizedProps,u=t.type===t.elementType?o:Ro(t.type,o),i.props=u,d=t.pendingProps,h=i.context,l=n.contextType,typeof l=="object"&&l!==null?l=mo(l):(l=Ka(n)?Eh:Qs.current,l=eg(t,l));var p=n.getDerivedStateFromProps;(c=typeof p=="function"||typeof i.getSnapshotBeforeUpdate=="function")||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(o!==d||h!==l)&&lW(t,i,r,l),oc=!1,h=t.memoizedState,i.state=h,FI(t,r,i,s);var f=t.memoizedState;o!==d||h!==f||qa.current||oc?(typeof p=="function"&&(_E(t,n,p,r),f=t.memoizedState),(u=oc||oW(t,n,u,r,h,f,l)||!1)?(c||typeof i.UNSAFE_componentWillUpdate!="function"&&typeof i.componentWillUpdate!="function"||(typeof i.componentWillUpdate=="function"&&i.componentWillUpdate(r,f,l),typeof i.UNSAFE_componentWillUpdate=="function"&&i.UNSAFE_componentWillUpdate(r,f,l)),typeof i.componentDidUpdate=="function"&&(t.flags|=4),typeof i.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof i.componentDidUpdate!="function"||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),i.props=r,i.state=f,i.context=l,r=u):(typeof i.componentDidUpdate!="function"||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),r=!1)}return DE(e,t,n,r,a,s)}function DE(e,t,n,r,s,a){zj(e,t);var i=(t.flags&128)!==0;if(!r&&!i)return s&&nW(t,n,!1),Du(e,t,a);r=t.stateNode,Ple.current=t;var o=i&&typeof n.getDerivedStateFromError!="function"?null:r.render();return t.flags|=1,e!==null&&i?(t.child=ng(t,e.child,null,a),t.child=ng(t,null,o,a)):ma(e,t,o,a),t.memoizedState=r.state,s&&nW(t,n,!0),t.child}function Bj(e){var t=e.stateNode;t.pendingContext?tW(e,t.pendingContext,t.pendingContext!==t.context):t.context&&tW(e,t.context,!1),HD(e,t.containerInfo)}function bW(e,t,n,r,s){return tg(),zD(s),t.flags|=256,ma(e,t,n,r),t.child}var FE={dehydrated:null,treeContext:null,retryLane:0};function OE(e){return{baseLanes:e,cachePool:null,transitions:null}}function Wj(e,t,n){var r=t.pendingProps,s=cr.current,a=!1,i=(t.flags&128)!==0,o;if((o=i)||(o=e!==null&&e.memoizedState===null?!1:(s&2)!==0),o?(a=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(s|=1),Vn(cr,s&1),e===null)return $E(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(t.mode&1?e.data==="$!"?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(i=r.children,e=r.fallback,a?(r=t.mode,a=t.child,i={mode:"hidden",children:i},!(r&1)&&a!==null?(a.childLanes=0,a.pendingProps=i):a=mC(i,r,0,null),e=Ih(e,r,n,null),a.return=t,e.return=t,a.sibling=e,t.child=a,t.child.memoizedState=OE(n),t.memoizedState=FE,e):QD(t,i));if(s=e.memoizedState,s!==null&&(o=s.dehydrated,o!==null))return zle(e,t,i,r,o,s,n);if(a){a=r.fallback,i=t.mode,s=e.child,o=s.sibling;var l={mode:"hidden",children:r.children};return!(i&1)&&t.child!==s?(r=t.child,r.childLanes=0,r.pendingProps=l,t.deletions=null):(r=Ec(s,l),r.subtreeFlags=s.subtreeFlags&14680064),o!==null?a=Ec(o,a):(a=Ih(a,i,n,null),a.flags|=2),a.return=t,r.return=t,r.sibling=a,t.child=r,r=a,a=t.child,i=e.child.memoizedState,i=i===null?OE(n):{baseLanes:i.baseLanes|n,cachePool:null,transitions:i.transitions},a.memoizedState=i,a.childLanes=e.childLanes&~n,t.memoizedState=FE,r}return a=e.child,e=a.sibling,r=Ec(a,{mode:"visible",children:r.children}),!(t.mode&1)&&(r.lanes=n),r.return=t,r.sibling=null,e!==null&&(n=t.deletions,n===null?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=r,t.memoizedState=null,r}function QD(e,t){return t=mC({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function Yv(e,t,n,r){return r!==null&&zD(r),ng(t,e.child,null,n),e=QD(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function zle(e,t,n,r,s,a,i){if(n)return t.flags&256?(t.flags&=-257,r=HT(Error(Oe(422))),Yv(e,t,i,r)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(a=r.fallback,s=t.mode,r=mC({mode:"visible",children:r.children},s,0,null),a=Ih(a,s,i,null),a.flags|=2,r.return=t,a.return=t,r.sibling=a,t.child=r,t.mode&1&&ng(t,e.child,null,i),t.child.memoizedState=OE(i),t.memoizedState=FE,a);if(!(t.mode&1))return Yv(e,t,i,null);if(s.data==="$!"){if(r=s.nextSibling&&s.nextSibling.dataset,r)var o=r.dgst;return r=o,a=Error(Oe(419)),r=HT(a,r,void 0),Yv(e,t,i,r)}if(o=(i&e.childLanes)!==0,Ua||o){if(r=vs,r!==null){switch(i&-i){case 4:s=2;break;case 16:s=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:s=32;break;case 536870912:s=268435456;break;default:s=0}s=s&(r.suspendedLanes|i)?0:s,s!==0&&s!==a.retryLane&&(a.retryLane=s,Ru(e,s),Vo(r,e,s,-1))}return aF(),r=HT(Error(Oe(421))),Yv(e,t,i,r)}return s.data==="$?"?(t.flags|=128,t.child=e.child,t=Jle.bind(null,e),s._reactRetry=t,null):(e=a.treeContext,yi=Nc(s.nextSibling),Si=t,nr=!0,Fo=null,e!==null&&(Ji[Qi++]=vu,Ji[Qi++]=ku,Ji[Qi++]=Ah,vu=e.id,ku=e.overflow,Ah=t),t=QD(t,r.children),t.flags|=4096,t)}function xW(e,t,n){e.lanes|=t;var r=e.alternate;r!==null&&(r.lanes|=t),TE(e.return,t,n)}function jT(e,t,n,r,s){var a=e.memoizedState;a===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s}:(a.isBackwards=t,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=n,a.tailMode=s)}function Vj(e,t,n){var r=t.pendingProps,s=r.revealOrder,a=r.tail;if(ma(e,t,r.children,n),r=cr.current,r&2)r=r&1|2,t.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&xW(e,n,t);else if(e.tag===19)xW(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Vn(cr,r),!(t.mode&1))t.memoizedState=null;else switch(s){case"forwards":for(n=t.child,s=null;n!==null;)e=n.alternate,e!==null&&OI(e)===null&&(s=n),n=n.sibling;n=s,n===null?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),jT(t,!1,s,n,a);break;case"backwards":for(n=null,s=t.child,t.child=null;s!==null;){if(e=s.alternate,e!==null&&OI(e)===null){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}jT(t,!0,n,null,a);break;case"together":jT(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Zk(e,t){!(t.mode&1)&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Du(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),Dh|=t.lanes,!(n&t.childLanes))return null;if(e!==null&&t.child!==e.child)throw Error(Oe(153));if(t.child!==null){for(e=t.child,n=Ec(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=Ec(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function Ble(e,t,n){switch(t.tag){case 3:Bj(t),tg();break;case 5:mj(t);break;case 1:Ka(t.type)&&_I(t);break;case 4:HD(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,s=t.memoizedProps.value;Vn(RI,r._currentValue),r._currentValue=s;break;case 13:if(r=t.memoizedState,r!==null)return r.dehydrated!==null?(Vn(cr,cr.current&1),t.flags|=128,null):n&t.child.childLanes?Wj(e,t,n):(Vn(cr,cr.current&1),e=Du(e,t,n),e!==null?e.sibling:null);Vn(cr,cr.current&1);break;case 19:if(r=(n&t.childLanes)!==0,e.flags&128){if(r)return Vj(e,t,n);t.flags|=128}if(s=t.memoizedState,s!==null&&(s.rendering=null,s.tail=null,s.lastEffect=null),Vn(cr,cr.current),r)break;return null;case 22:case 23:return t.lanes=0,Pj(e,t,n)}return Du(e,t,n)}var Uj,ME,Gj,Hj;Uj=function(e,t){for(var n=t.child;n!==null;){if(n.tag===5||n.tag===6)e.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};ME=function(){};Gj=function(e,t,n,r){var s=e.memoizedProps;if(s!==r){e=t.stateNode,mh(Dl.current);var a=null;switch(n){case"input":s=sE(e,s),r=sE(e,r),a=[];break;case"select":s=pr({},s,{value:void 0}),r=pr({},r,{value:void 0}),a=[];break;case"textarea":s=oE(e,s),r=oE(e,r),a=[];break;default:typeof s.onClick!="function"&&typeof r.onClick=="function"&&(e.onclick=$I)}uE(n,r);var i;n=null;for(u in s)if(!r.hasOwnProperty(u)&&s.hasOwnProperty(u)&&s[u]!=null)if(u==="style"){var o=s[u];for(i in o)o.hasOwnProperty(i)&&(n||(n={}),n[i]="")}else u!=="dangerouslySetInnerHTML"&&u!=="children"&&u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&u!=="autoFocus"&&(Kx.hasOwnProperty(u)?a||(a=[]):(a=a||[]).push(u,null));for(u in r){var l=r[u];if(o=s!=null?s[u]:void 0,r.hasOwnProperty(u)&&l!==o&&(l!=null||o!=null))if(u==="style")if(o){for(i in o)!o.hasOwnProperty(i)||l&&l.hasOwnProperty(i)||(n||(n={}),n[i]="");for(i in l)l.hasOwnProperty(i)&&o[i]!==l[i]&&(n||(n={}),n[i]=l[i])}else n||(a||(a=[]),a.push(u,n)),n=l;else u==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,o=o?o.__html:void 0,l!=null&&o!==l&&(a=a||[]).push(u,l)):u==="children"?typeof l!="string"&&typeof l!="number"||(a=a||[]).push(u,""+l):u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&(Kx.hasOwnProperty(u)?(l!=null&&u==="onScroll"&&qn("scroll",e),a||o===l||(a=[])):(a=a||[]).push(u,l))}n&&(a=a||[]).push("style",n);var u=a;(t.updateQueue=u)&&(t.flags|=4)}};Hj=function(e,t,n,r){n!==r&&(t.flags|=4)};function Yb(e,t){if(!nr)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Gs(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,r=0;if(t)for(var s=e.child;s!==null;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags&14680064,r|=s.flags&14680064,s.return=e,s=s.sibling;else for(s=e.child;s!==null;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags,r|=s.flags,s.return=e,s=s.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function Wle(e,t,n){var r=t.pendingProps;switch(PD(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Gs(t),null;case 1:return Ka(t.type)&&TI(),Gs(t),null;case 3:return r=t.stateNode,rg(),Xn(qa),Xn(Qs),qD(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),(e===null||e.child===null)&&(Kv(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,Fo!==null&&(GE(Fo),Fo=null))),ME(e,t),Gs(t),null;case 5:jD(t);var s=mh(i0.current);if(n=t.type,e!==null&&t.stateNode!=null)Gj(e,t,n,r,s),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(t.stateNode===null)throw Error(Oe(166));return Gs(t),null}if(e=mh(Dl.current),Kv(t)){r=t.stateNode,n=t.type;var a=t.memoizedProps;switch(r[Nl]=t,r[s0]=a,e=(t.mode&1)!==0,n){case"dialog":qn("cancel",r),qn("close",r);break;case"iframe":case"object":case"embed":qn("load",r);break;case"video":case"audio":for(s=0;s<px.length;s++)qn(px[s],r);break;case"source":qn("error",r);break;case"img":case"image":case"link":qn("error",r),qn("load",r);break;case"details":qn("toggle",r);break;case"input":T4(r,a),qn("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!a.multiple},qn("invalid",r);break;case"textarea":E4(r,a),qn("invalid",r)}uE(n,a),s=null;for(var i in a)if(a.hasOwnProperty(i)){var o=a[i];i==="children"?typeof o=="string"?r.textContent!==o&&(a.suppressHydrationWarning!==!0&&qv(r.textContent,o,e),s=["children",o]):typeof o=="number"&&r.textContent!==""+o&&(a.suppressHydrationWarning!==!0&&qv(r.textContent,o,e),s=["children",""+o]):Kx.hasOwnProperty(i)&&o!=null&&i==="onScroll"&&qn("scroll",r)}switch(n){case"input":zv(r),_4(r,a,!0);break;case"textarea":zv(r),A4(r);break;case"select":case"option":break;default:typeof a.onClick=="function"&&(r.onclick=$I)}r=s,t.updateQueue=r,r!==null&&(t.flags|=4)}else{i=s.nodeType===9?s:s.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=b5(n)),e==="http://www.w3.org/1999/xhtml"?n==="script"?(e=i.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof r.is=="string"?e=i.createElement(n,{is:r.is}):(e=i.createElement(n),n==="select"&&(i=e,r.multiple?i.multiple=!0:r.size&&(i.size=r.size))):e=i.createElementNS(e,n),e[Nl]=t,e[s0]=r,Uj(e,t,!1,!1),t.stateNode=e;e:{switch(i=cE(n,r),n){case"dialog":qn("cancel",e),qn("close",e),s=r;break;case"iframe":case"object":case"embed":qn("load",e),s=r;break;case"video":case"audio":for(s=0;s<px.length;s++)qn(px[s],e);s=r;break;case"source":qn("error",e),s=r;break;case"img":case"image":case"link":qn("error",e),qn("load",e),s=r;break;case"details":qn("toggle",e),s=r;break;case"input":T4(e,r),s=sE(e,r),qn("invalid",e);break;case"option":s=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},s=pr({},r,{value:void 0}),qn("invalid",e);break;case"textarea":E4(e,r),s=oE(e,r),qn("invalid",e);break;default:s=r}uE(n,s),o=s;for(a in o)if(o.hasOwnProperty(a)){var l=o[a];a==="style"?v5(e,l):a==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&x5(e,l)):a==="children"?typeof l=="string"?(n!=="textarea"||l!=="")&&Xx(e,l):typeof l=="number"&&Xx(e,""+l):a!=="suppressContentEditableWarning"&&a!=="suppressHydrationWarning"&&a!=="autoFocus"&&(Kx.hasOwnProperty(a)?l!=null&&a==="onScroll"&&qn("scroll",e):l!=null&&ID(e,a,l,i))}switch(n){case"input":zv(e),_4(e,r,!1);break;case"textarea":zv(e),A4(e);break;case"option":r.value!=null&&e.setAttribute("value",""+Bc(r.value));break;case"select":e.multiple=!!r.multiple,a=r.value,a!=null?Mm(e,!!r.multiple,a,!1):r.defaultValue!=null&&Mm(e,!!r.multiple,r.defaultValue,!0);break;default:typeof s.onClick=="function"&&(e.onclick=$I)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return Gs(t),null;case 6:if(e&&t.stateNode!=null)Hj(e,t,e.memoizedProps,r);else{if(typeof r!="string"&&t.stateNode===null)throw Error(Oe(166));if(n=mh(i0.current),mh(Dl.current),Kv(t)){if(r=t.stateNode,n=t.memoizedProps,r[Nl]=t,(a=r.nodeValue!==n)&&(e=Si,e!==null))switch(e.tag){case 3:qv(r.nodeValue,n,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&qv(r.nodeValue,n,(e.mode&1)!==0)}a&&(t.flags|=4)}else r=(n.nodeType===9?n:n.ownerDocument).createTextNode(r),r[Nl]=t,t.stateNode=r}return Gs(t),null;case 13:if(Xn(cr),r=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(nr&&yi!==null&&t.mode&1&&!(t.flags&128))lj(),tg(),t.flags|=98560,a=!1;else if(a=Kv(t),r!==null&&r.dehydrated!==null){if(e===null){if(!a)throw Error(Oe(318));if(a=t.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(Oe(317));a[Nl]=t}else tg(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;Gs(t),a=!1}else Fo!==null&&(GE(Fo),Fo=null),a=!0;if(!a)return t.flags&65536?t:null}return t.flags&128?(t.lanes=n,t):(r=r!==null,r!==(e!==null&&e.memoizedState!==null)&&r&&(t.child.flags|=8192,t.mode&1&&(e===null||cr.current&1?es===0&&(es=3):aF())),t.updateQueue!==null&&(t.flags|=4),Gs(t),null);case 4:return rg(),ME(e,t),e===null&&n0(t.stateNode.containerInfo),Gs(t),null;case 10:return VD(t.type._context),Gs(t),null;case 17:return Ka(t.type)&&TI(),Gs(t),null;case 19:if(Xn(cr),a=t.memoizedState,a===null)return Gs(t),null;if(r=(t.flags&128)!==0,i=a.rendering,i===null)if(r)Yb(a,!1);else{if(es!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(i=OI(e),i!==null){for(t.flags|=128,Yb(a,!1),r=i.updateQueue,r!==null&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;n!==null;)a=n,e=r,a.flags&=14680066,i=a.alternate,i===null?(a.childLanes=0,a.lanes=e,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=i.childLanes,a.lanes=i.lanes,a.child=i.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=i.memoizedProps,a.memoizedState=i.memoizedState,a.updateQueue=i.updateQueue,a.type=i.type,e=i.dependencies,a.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Vn(cr,cr.current&1|2),t.child}e=e.sibling}a.tail!==null&&Sr()>ag&&(t.flags|=128,r=!0,Yb(a,!1),t.lanes=4194304)}else{if(!r)if(e=OI(i),e!==null){if(t.flags|=128,r=!0,n=e.updateQueue,n!==null&&(t.updateQueue=n,t.flags|=4),Yb(a,!0),a.tail===null&&a.tailMode==="hidden"&&!i.alternate&&!nr)return Gs(t),null}else 2*Sr()-a.renderingStartTime>ag&&n!==1073741824&&(t.flags|=128,r=!0,Yb(a,!1),t.lanes=4194304);a.isBackwards?(i.sibling=t.child,t.child=i):(n=a.last,n!==null?n.sibling=i:t.child=i,a.last=i)}return a.tail!==null?(t=a.tail,a.rendering=t,a.tail=t.sibling,a.renderingStartTime=Sr(),t.sibling=null,n=cr.current,Vn(cr,r?n&1|2:n&1),t):(Gs(t),null);case 22:case 23:return sF(),r=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==r&&(t.flags|=8192),r&&t.mode&1?fi&1073741824&&(Gs(t),t.subtreeFlags&6&&(t.flags|=8192)):Gs(t),null;case 24:return null;case 25:return null}throw Error(Oe(156,t.tag))}function Vle(e,t){switch(PD(t),t.tag){case 1:return Ka(t.type)&&TI(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return rg(),Xn(qa),Xn(Qs),qD(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 5:return jD(t),null;case 13:if(Xn(cr),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(Oe(340));tg()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return Xn(cr),null;case 4:return rg(),null;case 10:return VD(t.type._context),null;case 22:case 23:return sF(),null;case 24:return null;default:return null}}var Zv=!1,js=!1,Ule=typeof WeakSet=="function"?WeakSet:Set,at=null;function Am(e,t){var n=e.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(r){gr(e,t,r)}else n.current=null}function LE(e,t,n){try{n()}catch(r){gr(e,t,r)}}var wW=!1;function Gle(e,t){if(wE=SI,e=X5(),MD(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var r=n.getSelection&&n.getSelection();if(r&&r.rangeCount!==0){n=r.anchorNode;var s=r.anchorOffset,a=r.focusNode;r=r.focusOffset;try{n.nodeType,a.nodeType}catch{n=null;break e}var i=0,o=-1,l=-1,u=0,c=0,d=e,h=null;t:for(;;){for(var p;d!==n||s!==0&&d.nodeType!==3||(o=i+s),d!==a||r!==0&&d.nodeType!==3||(l=i+r),d.nodeType===3&&(i+=d.nodeValue.length),(p=d.firstChild)!==null;)h=d,d=p;for(;;){if(d===e)break t;if(h===n&&++u===s&&(o=i),h===a&&++c===r&&(l=i),(p=d.nextSibling)!==null)break;d=h,h=d.parentNode}d=p}n=o===-1||l===-1?null:{start:o,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(vE={focusedElem:e,selectionRange:n},SI=!1,at=t;at!==null;)if(t=at,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,at=e;else for(;at!==null;){t=at;try{var f=t.alternate;if(t.flags&1024)switch(t.tag){case 0:case 11:case 15:break;case 1:if(f!==null){var m=f.memoizedProps,g=f.memoizedState,y=t.stateNode,b=y.getSnapshotBeforeUpdate(t.elementType===t.type?m:Ro(t.type,m),g);y.__reactInternalSnapshotBeforeUpdate=b}break;case 3:var x=t.stateNode.containerInfo;x.nodeType===1?x.textContent="":x.nodeType===9&&x.documentElement&&x.removeChild(x.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(Oe(163))}}catch(w){gr(t,t.return,w)}if(e=t.sibling,e!==null){e.return=t.return,at=e;break}at=t.return}return f=wW,wW=!1,f}function Mx(e,t,n){var r=t.updateQueue;if(r=r!==null?r.lastEffect:null,r!==null){var s=r=r.next;do{if((s.tag&e)===e){var a=s.destroy;s.destroy=void 0,a!==void 0&&LE(t,n,a)}s=s.next}while(s!==r)}}function pC(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function PE(e){var t=e.ref;if(t!==null){var n=e.stateNode;switch(e.tag){case 5:e=n;break;default:e=n}typeof t=="function"?t(e):t.current=e}}function jj(e){var t=e.alternate;t!==null&&(e.alternate=null,jj(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[Nl],delete t[s0],delete t[SE],delete t[Nle],delete t[$le])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function qj(e){return e.tag===5||e.tag===3||e.tag===4}function vW(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||qj(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function zE(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.nodeType===8?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(n.nodeType===8?(t=n.parentNode,t.insertBefore(e,n)):(t=n,t.appendChild(e)),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=$I));else if(r!==4&&(e=e.child,e!==null))for(zE(e,t,n),e=e.sibling;e!==null;)zE(e,t,n),e=e.sibling}function BE(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(r!==4&&(e=e.child,e!==null))for(BE(e,t,n),e=e.sibling;e!==null;)BE(e,t,n),e=e.sibling}var As=null,Do=!1;function Qu(e,t,n){for(n=n.child;n!==null;)Kj(e,t,n),n=n.sibling}function Kj(e,t,n){if(Rl&&typeof Rl.onCommitFiberUnmount=="function")try{Rl.onCommitFiberUnmount(aC,n)}catch{}switch(n.tag){case 5:js||Am(n,t);case 6:var r=As,s=Do;As=null,Qu(e,t,n),As=r,Do=s,As!==null&&(Do?(e=As,n=n.stateNode,e.nodeType===8?e.parentNode.removeChild(n):e.removeChild(n)):As.removeChild(n.stateNode));break;case 18:As!==null&&(Do?(e=As,n=n.stateNode,e.nodeType===8?zT(e.parentNode,n):e.nodeType===1&&zT(e,n),Qx(e)):zT(As,n.stateNode));break;case 4:r=As,s=Do,As=n.stateNode.containerInfo,Do=!0,Qu(e,t,n),As=r,Do=s;break;case 0:case 11:case 14:case 15:if(!js&&(r=n.updateQueue,r!==null&&(r=r.lastEffect,r!==null))){s=r=r.next;do{var a=s,i=a.destroy;a=a.tag,i!==void 0&&(a&2||a&4)&&LE(n,t,i),s=s.next}while(s!==r)}Qu(e,t,n);break;case 1:if(!js&&(Am(n,t),r=n.stateNode,typeof r.componentWillUnmount=="function"))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(o){gr(n,t,o)}Qu(e,t,n);break;case 21:Qu(e,t,n);break;case 22:n.mode&1?(js=(r=js)||n.memoizedState!==null,Qu(e,t,n),js=r):Qu(e,t,n);break;default:Qu(e,t,n)}}function kW(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var n=e.stateNode;n===null&&(n=e.stateNode=new Ule),t.forEach(function(r){var s=Qle.bind(null,e,r);n.has(r)||(n.add(r),r.then(s,s))})}}function _o(e,t){var n=t.deletions;if(n!==null)for(var r=0;r<n.length;r++){var s=n[r];try{var a=e,i=t,o=i;e:for(;o!==null;){switch(o.tag){case 5:As=o.stateNode,Do=!1;break e;case 3:As=o.stateNode.containerInfo,Do=!0;break e;case 4:As=o.stateNode.containerInfo,Do=!0;break e}o=o.return}if(As===null)throw Error(Oe(160));Kj(a,i,s),As=null,Do=!1;var l=s.alternate;l!==null&&(l.return=null),s.return=null}catch(u){gr(s,t,u)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)Xj(t,e),t=t.sibling}function Xj(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(_o(t,e),pl(e),r&4){try{Mx(3,e,e.return),pC(3,e)}catch(m){gr(e,e.return,m)}try{Mx(5,e,e.return)}catch(m){gr(e,e.return,m)}}break;case 1:_o(t,e),pl(e),r&512&&n!==null&&Am(n,n.return);break;case 5:if(_o(t,e),pl(e),r&512&&n!==null&&Am(n,n.return),e.flags&32){var s=e.stateNode;try{Xx(s,"")}catch(m){gr(e,e.return,m)}}if(r&4&&(s=e.stateNode,s!=null)){var a=e.memoizedProps,i=n!==null?n.memoizedProps:a,o=e.type,l=e.updateQueue;if(e.updateQueue=null,l!==null)try{o==="input"&&a.type==="radio"&&a.name!=null&&g5(s,a),cE(o,i);var u=cE(o,a);for(i=0;i<l.length;i+=2){var c=l[i],d=l[i+1];c==="style"?v5(s,d):c==="dangerouslySetInnerHTML"?x5(s,d):c==="children"?Xx(s,d):ID(s,c,d,u)}switch(o){case"input":aE(s,a);break;case"textarea":y5(s,a);break;case"select":var h=s._wrapperState.wasMultiple;s._wrapperState.wasMultiple=!!a.multiple;var p=a.value;p!=null?Mm(s,!!a.multiple,p,!1):h!==!!a.multiple&&(a.defaultValue!=null?Mm(s,!!a.multiple,a.defaultValue,!0):Mm(s,!!a.multiple,a.multiple?[]:"",!1))}s[s0]=a}catch(m){gr(e,e.return,m)}}break;case 6:if(_o(t,e),pl(e),r&4){if(e.stateNode===null)throw Error(Oe(162));s=e.stateNode,a=e.memoizedProps;try{s.nodeValue=a}catch(m){gr(e,e.return,m)}}break;case 3:if(_o(t,e),pl(e),r&4&&n!==null&&n.memoizedState.isDehydrated)try{Qx(t.containerInfo)}catch(m){gr(e,e.return,m)}break;case 4:_o(t,e),pl(e);break;case 13:_o(t,e),pl(e),s=e.child,s.flags&8192&&(a=s.memoizedState!==null,s.stateNode.isHidden=a,!a||s.alternate!==null&&s.alternate.memoizedState!==null||(nF=Sr())),r&4&&kW(e);break;case 22:if(c=n!==null&&n.memoizedState!==null,e.mode&1?(js=(u=js)||c,_o(t,e),js=u):_o(t,e),pl(e),r&8192){if(u=e.memoizedState!==null,(e.stateNode.isHidden=u)&&!c&&e.mode&1)for(at=e,c=e.child;c!==null;){for(d=at=c;at!==null;){switch(h=at,p=h.child,h.tag){case 0:case 11:case 14:case 15:Mx(4,h,h.return);break;case 1:Am(h,h.return);var f=h.stateNode;if(typeof f.componentWillUnmount=="function"){r=h,n=h.return;try{t=r,f.props=t.memoizedProps,f.state=t.memoizedState,f.componentWillUnmount()}catch(m){gr(r,n,m)}}break;case 5:Am(h,h.return);break;case 22:if(h.memoizedState!==null){SW(d);continue}}p!==null?(p.return=h,at=p):SW(d)}c=c.sibling}e:for(c=null,d=e;;){if(d.tag===5){if(c===null){c=d;try{s=d.stateNode,u?(a=s.style,typeof a.setProperty=="function"?a.setProperty("display","none","important"):a.display="none"):(o=d.stateNode,l=d.memoizedProps.style,i=l!=null&&l.hasOwnProperty("display")?l.display:null,o.style.display=w5("display",i))}catch(m){gr(e,e.return,m)}}}else if(d.tag===6){if(c===null)try{d.stateNode.nodeValue=u?"":d.memoizedProps}catch(m){gr(e,e.return,m)}}else if((d.tag!==22&&d.tag!==23||d.memoizedState===null||d===e)&&d.child!==null){d.child.return=d,d=d.child;continue}if(d===e)break e;for(;d.sibling===null;){if(d.return===null||d.return===e)break e;c===d&&(c=null),d=d.return}c===d&&(c=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:_o(t,e),pl(e),r&4&&kW(e);break;case 21:break;default:_o(t,e),pl(e)}}function pl(e){var t=e.flags;if(t&2){try{e:{for(var n=e.return;n!==null;){if(qj(n)){var r=n;break e}n=n.return}throw Error(Oe(160))}switch(r.tag){case 5:var s=r.stateNode;r.flags&32&&(Xx(s,""),r.flags&=-33);var a=vW(e);BE(e,a,s);break;case 3:case 4:var i=r.stateNode.containerInfo,o=vW(e);zE(e,o,i);break;default:throw Error(Oe(161))}}catch(l){gr(e,e.return,l)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function Hle(e,t,n){at=e,Yj(e)}function Yj(e,t,n){for(var r=(e.mode&1)!==0;at!==null;){var s=at,a=s.child;if(s.tag===22&&r){var i=s.memoizedState!==null||Zv;if(!i){var o=s.alternate,l=o!==null&&o.memoizedState!==null||js;o=Zv;var u=js;if(Zv=i,(js=l)&&!u)for(at=s;at!==null;)i=at,l=i.child,i.tag===22&&i.memoizedState!==null?CW(s):l!==null?(l.return=i,at=l):CW(s);for(;a!==null;)at=a,Yj(a),a=a.sibling;at=s,Zv=o,js=u}IW(e)}else s.subtreeFlags&8772&&a!==null?(a.return=s,at=a):IW(e)}}function IW(e){for(;at!==null;){var t=at;if(t.flags&8772){var n=t.alternate;try{if(t.flags&8772)switch(t.tag){case 0:case 11:case 15:js||pC(5,t);break;case 1:var r=t.stateNode;if(t.flags&4&&!js)if(n===null)r.componentDidMount();else{var s=t.elementType===t.type?n.memoizedProps:Ro(t.type,n.memoizedProps);r.componentDidUpdate(s,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var a=t.updateQueue;a!==null&&iW(t,a,r);break;case 3:var i=t.updateQueue;if(i!==null){if(n=null,t.child!==null)switch(t.child.tag){case 5:n=t.child.stateNode;break;case 1:n=t.child.stateNode}iW(t,i,n)}break;case 5:var o=t.stateNode;if(n===null&&t.flags&4){n=o;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var u=t.alternate;if(u!==null){var c=u.memoizedState;if(c!==null){var d=c.dehydrated;d!==null&&Qx(d)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(Oe(163))}js||t.flags&512&&PE(t)}catch(h){gr(t,t.return,h)}}if(t===e){at=null;break}if(n=t.sibling,n!==null){n.return=t.return,at=n;break}at=t.return}}function SW(e){for(;at!==null;){var t=at;if(t===e){at=null;break}var n=t.sibling;if(n!==null){n.return=t.return,at=n;break}at=t.return}}function CW(e){for(;at!==null;){var t=at;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{pC(4,t)}catch(l){gr(t,n,l)}break;case 1:var r=t.stateNode;if(typeof r.componentDidMount=="function"){var s=t.return;try{r.componentDidMount()}catch(l){gr(t,s,l)}}var a=t.return;try{PE(t)}catch(l){gr(t,a,l)}break;case 5:var i=t.return;try{PE(t)}catch(l){gr(t,i,l)}}}catch(l){gr(t,t.return,l)}if(t===e){at=null;break}var o=t.sibling;if(o!==null){o.return=t.return,at=o;break}at=t.return}}var jle=Math.ceil,PI=Bu.ReactCurrentDispatcher,eF=Bu.ReactCurrentOwner,uo=Bu.ReactCurrentBatchConfig,cn=0,vs=null,Dr=null,Ds=0,fi=0,Rm=hd(0),es=0,c0=null,Dh=0,fC=0,tF=0,Lx=null,Ba=null,nF=0,ag=1/0,cu=null,zI=!1,WE=null,Tc=null,Jv=!1,fc=null,BI=0,Px=0,VE=null,Jk=-1,Qk=0;function Ia(){return cn&6?Sr():Jk!==-1?Jk:Jk=Sr()}function _c(e){return e.mode&1?cn&2&&Ds!==0?Ds&-Ds:_le.transition!==null?(Qk===0&&(Qk=D5()),Qk):(e=kn,e!==0||(e=window.event,e=e===void 0?16:B5(e.type)),e):1}function Vo(e,t,n,r){if(50<Px)throw Px=0,VE=null,Error(Oe(185));K0(e,n,r),(!(cn&2)||e!==vs)&&(e===vs&&(!(cn&2)&&(fC|=n),es===4&&dc(e,Ds)),Xa(e,r),n===1&&cn===0&&!(t.mode&1)&&(ag=Sr()+500,cC&&pd()))}function Xa(e,t){var n=e.callbackNode;_oe(e,t);var r=II(e,e===vs?Ds:0);if(r===0)n!==null&&F4(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(n!=null&&F4(n),t===1)e.tag===0?Tle(NW.bind(null,e)):aj(NW.bind(null,e)),Sle(function(){!(cn&6)&&pd()}),n=null;else{switch(F5(r)){case 1:n=TD;break;case 4:n=A5;break;case 16:n=kI;break;case 536870912:n=R5;break;default:n=kI}n=s6(n,Zj.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function Zj(e,t){if(Jk=-1,Qk=0,cn&6)throw Error(Oe(327));var n=e.callbackNode;if(Wm()&&e.callbackNode!==n)return null;var r=II(e,e===vs?Ds:0);if(r===0)return null;if(r&30||r&e.expiredLanes||t)t=WI(e,r);else{t=r;var s=cn;cn|=2;var a=Qj();(vs!==e||Ds!==t)&&(cu=null,ag=Sr()+500,kh(e,t));do try{Xle();break}catch(o){Jj(e,o)}while(1);WD(),PI.current=a,cn=s,Dr!==null?t=0:(vs=null,Ds=0,t=es)}if(t!==0){if(t===2&&(s=mE(e),s!==0&&(r=s,t=UE(e,s))),t===1)throw n=c0,kh(e,0),dc(e,r),Xa(e,Sr()),n;if(t===6)dc(e,r);else{if(s=e.current.alternate,!(r&30)&&!qle(s)&&(t=WI(e,r),t===2&&(a=mE(e),a!==0&&(r=a,t=UE(e,a))),t===1))throw n=c0,kh(e,0),dc(e,r),Xa(e,Sr()),n;switch(e.finishedWork=s,e.finishedLanes=r,t){case 0:case 1:throw Error(Oe(345));case 2:th(e,Ba,cu);break;case 3:if(dc(e,r),(r&130023424)===r&&(t=nF+500-Sr(),10<t)){if(II(e,0)!==0)break;if(s=e.suspendedLanes,(s&r)!==r){Ia(),e.pingedLanes|=e.suspendedLanes&s;break}e.timeoutHandle=IE(th.bind(null,e,Ba,cu),t);break}th(e,Ba,cu);break;case 4:if(dc(e,r),(r&4194240)===r)break;for(t=e.eventTimes,s=-1;0<r;){var i=31-Wo(r);a=1<<i,i=t[i],i>s&&(s=i),r&=~a}if(r=s,r=Sr()-r,r=(120>r?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*jle(r/1960))-r,10<r){e.timeoutHandle=IE(th.bind(null,e,Ba,cu),r);break}th(e,Ba,cu);break;case 5:th(e,Ba,cu);break;default:throw Error(Oe(329))}}}return Xa(e,Sr()),e.callbackNode===n?Zj.bind(null,e):null}function UE(e,t){var n=Lx;return e.current.memoizedState.isDehydrated&&(kh(e,t).flags|=256),e=WI(e,t),e!==2&&(t=Ba,Ba=n,t!==null&&GE(t)),e}function GE(e){Ba===null?Ba=e:Ba.push.apply(Ba,e)}function qle(e){for(var t=e;;){if(t.flags&16384){var n=t.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var r=0;r<n.length;r++){var s=n[r],a=s.getSnapshot;s=s.value;try{if(!Xo(a(),s))return!1}catch{return!1}}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function dc(e,t){for(t&=~tF,t&=~fC,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-Wo(t),r=1<<n;e[n]=-1,t&=~r}}function NW(e){if(cn&6)throw Error(Oe(327));Wm();var t=II(e,0);if(!(t&1))return Xa(e,Sr()),null;var n=WI(e,t);if(e.tag!==0&&n===2){var r=mE(e);r!==0&&(t=r,n=UE(e,r))}if(n===1)throw n=c0,kh(e,0),dc(e,t),Xa(e,Sr()),n;if(n===6)throw Error(Oe(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,th(e,Ba,cu),Xa(e,Sr()),null}function rF(e,t){var n=cn;cn|=1;try{return e(t)}finally{cn=n,cn===0&&(ag=Sr()+500,cC&&pd())}}function Fh(e){fc!==null&&fc.tag===0&&!(cn&6)&&Wm();var t=cn;cn|=1;var n=uo.transition,r=kn;try{if(uo.transition=null,kn=1,e)return e()}finally{kn=r,uo.transition=n,cn=t,!(cn&6)&&pd()}}function sF(){fi=Rm.current,Xn(Rm)}function kh(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(n!==-1&&(e.timeoutHandle=-1,Ile(n)),Dr!==null)for(n=Dr.return;n!==null;){var r=n;switch(PD(r),r.tag){case 1:r=r.type.childContextTypes,r!=null&&TI();break;case 3:rg(),Xn(qa),Xn(Qs),qD();break;case 5:jD(r);break;case 4:rg();break;case 13:Xn(cr);break;case 19:Xn(cr);break;case 10:VD(r.type._context);break;case 22:case 23:sF()}n=n.return}if(vs=e,Dr=e=Ec(e.current,null),Ds=fi=t,es=0,c0=null,tF=fC=Dh=0,Ba=Lx=null,fh!==null){for(t=0;t<fh.length;t++)if(n=fh[t],r=n.interleaved,r!==null){n.interleaved=null;var s=r.next,a=n.pending;if(a!==null){var i=a.next;a.next=s,r.next=i}n.pending=r}fh=null}return e}function Jj(e,t){do{var n=Dr;try{if(WD(),Xk.current=LI,MI){for(var r=hr.memoizedState;r!==null;){var s=r.queue;s!==null&&(s.pending=null),r=r.next}MI=!1}if(Rh=0,ps=Zr=hr=null,Ox=!1,o0=0,eF.current=null,n===null||n.return===null){es=1,c0=t,Dr=null;break}e:{var a=e,i=n.return,o=n,l=t;if(t=Ds,o.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var u=l,c=o,d=c.tag;if(!(c.mode&1)&&(d===0||d===11||d===15)){var h=c.alternate;h?(c.updateQueue=h.updateQueue,c.memoizedState=h.memoizedState,c.lanes=h.lanes):(c.updateQueue=null,c.memoizedState=null)}var p=pW(i);if(p!==null){p.flags&=-257,fW(p,i,o,a,t),p.mode&1&&hW(a,u,t),t=p,l=u;var f=t.updateQueue;if(f===null){var m=new Set;m.add(l),t.updateQueue=m}else f.add(l);break e}else{if(!(t&1)){hW(a,u,t),aF();break e}l=Error(Oe(426))}}else if(nr&&o.mode&1){var g=pW(i);if(g!==null){!(g.flags&65536)&&(g.flags|=256),fW(g,i,o,a,t),zD(sg(l,o));break e}}a=l=sg(l,o),es!==4&&(es=2),Lx===null?Lx=[a]:Lx.push(a),a=i;do{switch(a.tag){case 3:a.flags|=65536,t&=-t,a.lanes|=t;var y=Oj(a,l,t);aW(a,y);break e;case 1:o=l;var b=a.type,x=a.stateNode;if(!(a.flags&128)&&(typeof b.getDerivedStateFromError=="function"||x!==null&&typeof x.componentDidCatch=="function"&&(Tc===null||!Tc.has(x)))){a.flags|=65536,t&=-t,a.lanes|=t;var w=Mj(a,o,t);aW(a,w);break e}}a=a.return}while(a!==null)}t6(n)}catch(v){t=v,Dr===n&&n!==null&&(Dr=n=n.return);continue}break}while(1)}function Qj(){var e=PI.current;return PI.current=LI,e===null?LI:e}function aF(){(es===0||es===3||es===2)&&(es=4),vs===null||!(Dh&268435455)&&!(fC&268435455)||dc(vs,Ds)}function WI(e,t){var n=cn;cn|=2;var r=Qj();(vs!==e||Ds!==t)&&(cu=null,kh(e,t));do try{Kle();break}catch(s){Jj(e,s)}while(1);if(WD(),cn=n,PI.current=r,Dr!==null)throw Error(Oe(261));return vs=null,Ds=0,es}function Kle(){for(;Dr!==null;)e6(Dr)}function Xle(){for(;Dr!==null&&!woe();)e6(Dr)}function e6(e){var t=r6(e.alternate,e,fi);e.memoizedProps=e.pendingProps,t===null?t6(e):Dr=t,eF.current=null}function t6(e){var t=e;do{var n=t.alternate;if(e=t.return,t.flags&32768){if(n=Vle(n,t),n!==null){n.flags&=32767,Dr=n;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{es=6,Dr=null;return}}else if(n=Wle(n,t,fi),n!==null){Dr=n;return}if(t=t.sibling,t!==null){Dr=t;return}Dr=t=e}while(t!==null);es===0&&(es=5)}function th(e,t,n){var r=kn,s=uo.transition;try{uo.transition=null,kn=1,Yle(e,t,n,r)}finally{uo.transition=s,kn=r}return null}function Yle(e,t,n,r){do Wm();while(fc!==null);if(cn&6)throw Error(Oe(327));n=e.finishedWork;var s=e.finishedLanes;if(n===null)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(Oe(177));e.callbackNode=null,e.callbackPriority=0;var a=n.lanes|n.childLanes;if(Eoe(e,a),e===vs&&(Dr=vs=null,Ds=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||Jv||(Jv=!0,s6(kI,function(){return Wm(),null})),a=(n.flags&15990)!==0,n.subtreeFlags&15990||a){a=uo.transition,uo.transition=null;var i=kn;kn=1;var o=cn;cn|=4,eF.current=null,Gle(e,n),Xj(n,e),gle(vE),SI=!!wE,vE=wE=null,e.current=n,Hle(n),voe(),cn=o,kn=i,uo.transition=a}else e.current=n;if(Jv&&(Jv=!1,fc=e,BI=s),a=e.pendingLanes,a===0&&(Tc=null),Soe(n.stateNode),Xa(e,Sr()),t!==null)for(r=e.onRecoverableError,n=0;n<t.length;n++)s=t[n],r(s.value,{componentStack:s.stack,digest:s.digest});if(zI)throw zI=!1,e=WE,WE=null,e;return BI&1&&e.tag!==0&&Wm(),a=e.pendingLanes,a&1?e===VE?Px++:(Px=0,VE=e):Px=0,pd(),null}function Wm(){if(fc!==null){var e=F5(BI),t=uo.transition,n=kn;try{if(uo.transition=null,kn=16>e?16:e,fc===null)var r=!1;else{if(e=fc,fc=null,BI=0,cn&6)throw Error(Oe(331));var s=cn;for(cn|=4,at=e.current;at!==null;){var a=at,i=a.child;if(at.flags&16){var o=a.deletions;if(o!==null){for(var l=0;l<o.length;l++){var u=o[l];for(at=u;at!==null;){var c=at;switch(c.tag){case 0:case 11:case 15:Mx(8,c,a)}var d=c.child;if(d!==null)d.return=c,at=d;else for(;at!==null;){c=at;var h=c.sibling,p=c.return;if(jj(c),c===u){at=null;break}if(h!==null){h.return=p,at=h;break}at=p}}}var f=a.alternate;if(f!==null){var m=f.child;if(m!==null){f.child=null;do{var g=m.sibling;m.sibling=null,m=g}while(m!==null)}}at=a}}if(a.subtreeFlags&2064&&i!==null)i.return=a,at=i;else e:for(;at!==null;){if(a=at,a.flags&2048)switch(a.tag){case 0:case 11:case 15:Mx(9,a,a.return)}var y=a.sibling;if(y!==null){y.return=a.return,at=y;break e}at=a.return}}var b=e.current;for(at=b;at!==null;){i=at;var x=i.child;if(i.subtreeFlags&2064&&x!==null)x.return=i,at=x;else e:for(i=b;at!==null;){if(o=at,o.flags&2048)try{switch(o.tag){case 0:case 11:case 15:pC(9,o)}}catch(v){gr(o,o.return,v)}if(o===i){at=null;break e}var w=o.sibling;if(w!==null){w.return=o.return,at=w;break e}at=o.return}}if(cn=s,pd(),Rl&&typeof Rl.onPostCommitFiberRoot=="function")try{Rl.onPostCommitFiberRoot(aC,e)}catch{}r=!0}return r}finally{kn=n,uo.transition=t}}return!1}function $W(e,t,n){t=sg(n,t),t=Oj(e,t,1),e=$c(e,t,1),t=Ia(),e!==null&&(K0(e,1,t),Xa(e,t))}function gr(e,t,n){if(e.tag===3)$W(e,e,n);else for(;t!==null;){if(t.tag===3){$W(t,e,n);break}else if(t.tag===1){var r=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(Tc===null||!Tc.has(r))){e=sg(n,e),e=Mj(t,e,1),t=$c(t,e,1),e=Ia(),t!==null&&(K0(t,1,e),Xa(t,e));break}}t=t.return}}function Zle(e,t,n){var r=e.pingCache;r!==null&&r.delete(t),t=Ia(),e.pingedLanes|=e.suspendedLanes&n,vs===e&&(Ds&n)===n&&(es===4||es===3&&(Ds&130023424)===Ds&&500>Sr()-nF?kh(e,0):tF|=n),Xa(e,t)}function n6(e,t){t===0&&(e.mode&1?(t=Vv,Vv<<=1,!(Vv&130023424)&&(Vv=4194304)):t=1);var n=Ia();e=Ru(e,t),e!==null&&(K0(e,t,n),Xa(e,n))}function Jle(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),n6(e,n)}function Qle(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,s=e.memoizedState;s!==null&&(n=s.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(Oe(314))}r!==null&&r.delete(t),n6(e,n)}var r6;r6=function(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps||qa.current)Ua=!0;else{if(!(e.lanes&n)&&!(t.flags&128))return Ua=!1,Ble(e,t,n);Ua=!!(e.flags&131072)}else Ua=!1,nr&&t.flags&1048576&&ij(t,AI,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;Zk(e,t),e=t.pendingProps;var s=eg(t,Qs.current);Bm(t,n),s=XD(null,t,r,e,s,n);var a=YD();return t.flags|=1,typeof s=="object"&&s!==null&&typeof s.render=="function"&&s.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Ka(r)?(a=!0,_I(t)):a=!1,t.memoizedState=s.state!==null&&s.state!==void 0?s.state:null,GD(t),s.updater=dC,t.stateNode=s,s._reactInternals=t,EE(t,r,e,n),t=DE(null,t,r,!0,a,n)):(t.tag=0,nr&&a&&LD(t),ma(null,t,s,n),t=t.child),t;case 16:r=t.elementType;e:{switch(Zk(e,t),e=t.pendingProps,s=r._init,r=s(r._payload),t.type=r,s=t.tag=tue(r),e=Ro(r,e),s){case 0:t=RE(null,t,r,e,n);break e;case 1:t=yW(null,t,r,e,n);break e;case 11:t=mW(null,t,r,e,n);break e;case 14:t=gW(null,t,r,Ro(r.type,e),n);break e}throw Error(Oe(306,r,""))}return t;case 0:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:Ro(r,s),RE(e,t,r,s,n);case 1:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:Ro(r,s),yW(e,t,r,s,n);case 3:e:{if(Bj(t),e===null)throw Error(Oe(387));r=t.pendingProps,a=t.memoizedState,s=a.element,cj(e,t),FI(t,r,null,n);var i=t.memoizedState;if(r=i.element,a.isDehydrated)if(a={element:r,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},t.updateQueue.baseState=a,t.memoizedState=a,t.flags&256){s=sg(Error(Oe(423)),t),t=bW(e,t,r,n,s);break e}else if(r!==s){s=sg(Error(Oe(424)),t),t=bW(e,t,r,n,s);break e}else for(yi=Nc(t.stateNode.containerInfo.firstChild),Si=t,nr=!0,Fo=null,n=fj(t,null,r,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(tg(),r===s){t=Du(e,t,n);break e}ma(e,t,r,n)}t=t.child}return t;case 5:return mj(t),e===null&&$E(t),r=t.type,s=t.pendingProps,a=e!==null?e.memoizedProps:null,i=s.children,kE(r,s)?i=null:a!==null&&kE(r,a)&&(t.flags|=32),zj(e,t),ma(e,t,i,n),t.child;case 6:return e===null&&$E(t),null;case 13:return Wj(e,t,n);case 4:return HD(t,t.stateNode.containerInfo),r=t.pendingProps,e===null?t.child=ng(t,null,r,n):ma(e,t,r,n),t.child;case 11:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:Ro(r,s),mW(e,t,r,s,n);case 7:return ma(e,t,t.pendingProps,n),t.child;case 8:return ma(e,t,t.pendingProps.children,n),t.child;case 12:return ma(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,s=t.pendingProps,a=t.memoizedProps,i=s.value,Vn(RI,r._currentValue),r._currentValue=i,a!==null)if(Xo(a.value,i)){if(a.children===s.children&&!qa.current){t=Du(e,t,n);break e}}else for(a=t.child,a!==null&&(a.return=t);a!==null;){var o=a.dependencies;if(o!==null){i=a.child;for(var l=o.firstContext;l!==null;){if(l.context===r){if(a.tag===1){l=Iu(-1,n&-n),l.tag=2;var u=a.updateQueue;if(u!==null){u=u.shared;var c=u.pending;c===null?l.next=l:(l.next=c.next,c.next=l),u.pending=l}}a.lanes|=n,l=a.alternate,l!==null&&(l.lanes|=n),TE(a.return,n,t),o.lanes|=n;break}l=l.next}}else if(a.tag===10)i=a.type===t.type?null:a.child;else if(a.tag===18){if(i=a.return,i===null)throw Error(Oe(341));i.lanes|=n,o=i.alternate,o!==null&&(o.lanes|=n),TE(i,n,t),i=a.sibling}else i=a.child;if(i!==null)i.return=a;else for(i=a;i!==null;){if(i===t){i=null;break}if(a=i.sibling,a!==null){a.return=i.return,i=a;break}i=i.return}a=i}ma(e,t,s.children,n),t=t.child}return t;case 9:return s=t.type,r=t.pendingProps.children,Bm(t,n),s=mo(s),r=r(s),t.flags|=1,ma(e,t,r,n),t.child;case 14:return r=t.type,s=Ro(r,t.pendingProps),s=Ro(r.type,s),gW(e,t,r,s,n);case 15:return Lj(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:Ro(r,s),Zk(e,t),t.tag=1,Ka(r)?(e=!0,_I(t)):e=!1,Bm(t,n),hj(t,r,s),EE(t,r,s,n),DE(null,t,r,!0,e,n);case 19:return Vj(e,t,n);case 22:return Pj(e,t,n)}throw Error(Oe(156,t.tag))};function s6(e,t){return E5(e,t)}function eue(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function to(e,t,n,r){return new eue(e,t,n,r)}function iF(e){return e=e.prototype,!(!e||!e.isReactComponent)}function tue(e){if(typeof e=="function")return iF(e)?1:0;if(e!=null){if(e=e.$$typeof,e===CD)return 11;if(e===ND)return 14}return 2}function Ec(e,t){var n=e.alternate;return n===null?(n=to(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&14680064,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function eI(e,t,n,r,s,a){var i=2;if(r=e,typeof e=="function")iF(e)&&(i=1);else if(typeof e=="string")i=5;else e:switch(e){case km:return Ih(n.children,s,a,t);case SD:i=8,s|=8;break;case eE:return e=to(12,n,t,s|2),e.elementType=eE,e.lanes=a,e;case tE:return e=to(13,n,t,s),e.elementType=tE,e.lanes=a,e;case nE:return e=to(19,n,t,s),e.elementType=nE,e.lanes=a,e;case p5:return mC(n,s,a,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case d5:i=10;break e;case h5:i=9;break e;case CD:i=11;break e;case ND:i=14;break e;case ic:i=16,r=null;break e}throw Error(Oe(130,e==null?e:typeof e,""))}return t=to(i,n,t,s),t.elementType=e,t.type=r,t.lanes=a,t}function Ih(e,t,n,r){return e=to(7,e,r,t),e.lanes=n,e}function mC(e,t,n,r){return e=to(22,e,r,t),e.elementType=p5,e.lanes=n,e.stateNode={isHidden:!1},e}function qT(e,t,n){return e=to(6,e,null,t),e.lanes=n,e}function KT(e,t,n){return t=to(4,e.children!==null?e.children:[],e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function nue(e,t,n,r,s){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=TT(0),this.expirationTimes=TT(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=TT(0),this.identifierPrefix=r,this.onRecoverableError=s,this.mutableSourceEagerHydrationData=null}function oF(e,t,n,r,s,a,i,o,l){return e=new nue(e,t,n,o,l),t===1?(t=1,a===!0&&(t|=8)):t=0,a=to(3,null,null,t),e.current=a,a.stateNode=e,a.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},GD(a),e}function rue(e,t,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:vm,key:r==null?null:""+r,children:e,containerInfo:t,implementation:n}}function a6(e){if(!e)return Wc;e=e._reactInternals;e:{if(fp(e)!==e||e.tag!==1)throw Error(Oe(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Ka(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(t!==null);throw Error(Oe(171))}if(e.tag===1){var n=e.type;if(Ka(n))return sj(e,n,t)}return t}function i6(e,t,n,r,s,a,i,o,l){return e=oF(n,r,!0,e,s,a,i,o,l),e.context=a6(null),n=e.current,r=Ia(),s=_c(n),a=Iu(r,s),a.callback=t??null,$c(n,a,s),e.current.lanes=s,K0(e,s,r),Xa(e,r),e}function gC(e,t,n,r){var s=t.current,a=Ia(),i=_c(s);return n=a6(n),t.context===null?t.context=n:t.pendingContext=n,t=Iu(a,i),t.payload={element:e},r=r===void 0?null:r,r!==null&&(t.callback=r),e=$c(s,t,i),e!==null&&(Vo(e,s,i,a),Kk(e,s,i)),i}function VI(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function TW(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function lF(e,t){TW(e,t),(e=e.alternate)&&TW(e,t)}function sue(){return null}var o6=typeof reportError=="function"?reportError:function(e){console.error(e)};function uF(e){this._internalRoot=e}yC.prototype.render=uF.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(Oe(409));gC(e,t,null,null)};yC.prototype.unmount=uF.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;Fh(function(){gC(null,e,null,null)}),t[Au]=null}};function yC(e){this._internalRoot=e}yC.prototype.unstable_scheduleHydration=function(e){if(e){var t=L5();e={blockedOn:null,target:e,priority:t};for(var n=0;n<cc.length&&t!==0&&t<cc[n].priority;n++);cc.splice(n,0,e),n===0&&z5(e)}};function cF(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function bC(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function _W(){}function aue(e,t,n,r,s){if(s){if(typeof r=="function"){var a=r;r=function(){var u=VI(i);a.call(u)}}var i=i6(t,r,e,0,null,!1,!1,"",_W);return e._reactRootContainer=i,e[Au]=i.current,n0(e.nodeType===8?e.parentNode:e),Fh(),i}for(;s=e.lastChild;)e.removeChild(s);if(typeof r=="function"){var o=r;r=function(){var u=VI(l);o.call(u)}}var l=oF(e,0,!1,null,null,!1,!1,"",_W);return e._reactRootContainer=l,e[Au]=l.current,n0(e.nodeType===8?e.parentNode:e),Fh(function(){gC(t,l,n,r)}),l}function xC(e,t,n,r,s){var a=n._reactRootContainer;if(a){var i=a;if(typeof s=="function"){var o=s;s=function(){var l=VI(i);o.call(l)}}gC(t,i,e,s)}else i=aue(n,t,e,s,r);return VI(i)}O5=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=hx(t.pendingLanes);n!==0&&(_D(t,n|1),Xa(t,Sr()),!(cn&6)&&(ag=Sr()+500,pd()))}break;case 13:Fh(function(){var r=Ru(e,1);if(r!==null){var s=Ia();Vo(r,e,1,s)}}),lF(e,1)}};ED=function(e){if(e.tag===13){var t=Ru(e,134217728);if(t!==null){var n=Ia();Vo(t,e,134217728,n)}lF(e,134217728)}};M5=function(e){if(e.tag===13){var t=_c(e),n=Ru(e,t);if(n!==null){var r=Ia();Vo(n,e,t,r)}lF(e,t)}};L5=function(){return kn};P5=function(e,t){var n=kn;try{return kn=e,t()}finally{kn=n}};hE=function(e,t,n){switch(t){case"input":if(aE(e,n),t=n.name,n.type==="radio"&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var s=uC(r);if(!s)throw Error(Oe(90));m5(r),aE(r,s)}}}break;case"textarea":y5(e,n);break;case"select":t=n.value,t!=null&&Mm(e,!!n.multiple,t,!1)}};S5=rF;C5=Fh;var iue={usingClientEntryPoint:!1,Events:[Y0,Nm,uC,k5,I5,rF]},Zb={findFiberByHostInstance:ph,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},oue={bundleType:Zb.bundleType,version:Zb.version,rendererPackageName:Zb.rendererPackageName,rendererConfig:Zb.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Bu.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=T5(e),e===null?null:e.stateNode},findFiberByHostInstance:Zb.findFiberByHostInstance||sue,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Qv=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Qv.isDisabled&&Qv.supportsFiber)try{aC=Qv.inject(oue),Rl=Qv}catch{}}Fi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=iue;Fi.createPortal=function(e,t){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!cF(t))throw Error(Oe(200));return rue(e,t,null,n)};Fi.createRoot=function(e,t){if(!cF(e))throw Error(Oe(299));var n=!1,r="",s=o6;return t!=null&&(t.unstable_strictMode===!0&&(n=!0),t.identifierPrefix!==void 0&&(r=t.identifierPrefix),t.onRecoverableError!==void 0&&(s=t.onRecoverableError)),t=oF(e,1,!1,null,null,n,!1,r,s),e[Au]=t.current,n0(e.nodeType===8?e.parentNode:e),new uF(t)};Fi.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(Oe(188)):(e=Object.keys(e).join(","),Error(Oe(268,e)));return e=T5(t),e=e===null?null:e.stateNode,e};Fi.flushSync=function(e){return Fh(e)};Fi.hydrate=function(e,t,n){if(!bC(t))throw Error(Oe(200));return xC(null,e,t,!0,n)};Fi.hydrateRoot=function(e,t,n){if(!cF(e))throw Error(Oe(405));var r=n!=null&&n.hydratedSources||null,s=!1,a="",i=o6;if(n!=null&&(n.unstable_strictMode===!0&&(s=!0),n.identifierPrefix!==void 0&&(a=n.identifierPrefix),n.onRecoverableError!==void 0&&(i=n.onRecoverableError)),t=i6(t,null,e,1,n??null,s,!1,a,i),e[Au]=t.current,n0(e),r)for(e=0;e<r.length;e++)n=r[e],s=n._getVersion,s=s(n._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[n,s]:t.mutableSourceEagerHydrationData.push(n,s);return new yC(t)};Fi.render=function(e,t,n){if(!bC(t))throw Error(Oe(200));return xC(null,e,t,!1,n)};Fi.unmountComponentAtNode=function(e){if(!bC(e))throw Error(Oe(40));return e._reactRootContainer?(Fh(function(){xC(null,null,e,!1,function(){e._reactRootContainer=null,e[Au]=null})}),!0):!1};Fi.unstable_batchedUpdates=rF;Fi.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!bC(n))throw Error(Oe(200));if(e==null||e._reactInternals===void 0)throw Error(Oe(38));return xC(e,t,n,!1,r)};Fi.version="18.2.0-next-9e3b772b8-20220608";(function(e){function t(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(n){console.error(n)}}t(),e.exports=Fi})(soe);var EW=Z_;Y_.createRoot=EW.createRoot,Y_.hydrateRoot=EW.hydrateRoot;var UI={},lue={get exports(){return UI},set exports(e){UI=e}},$n={};/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var dF=Symbol.for("react.element"),hF=Symbol.for("react.portal"),wC=Symbol.for("react.fragment"),vC=Symbol.for("react.strict_mode"),kC=Symbol.for("react.profiler"),IC=Symbol.for("react.provider"),SC=Symbol.for("react.context"),uue=Symbol.for("react.server_context"),CC=Symbol.for("react.forward_ref"),NC=Symbol.for("react.suspense"),$C=Symbol.for("react.suspense_list"),TC=Symbol.for("react.memo"),_C=Symbol.for("react.lazy"),cue=Symbol.for("react.offscreen"),l6;l6=Symbol.for("react.module.reference");function wo(e){if(typeof e=="object"&&e!==null){var t=e.$$typeof;switch(t){case dF:switch(e=e.type,e){case wC:case kC:case vC:case NC:case $C:return e;default:switch(e=e&&e.$$typeof,e){case uue:case SC:case CC:case _C:case TC:case IC:return e;default:return t}}case hF:return t}}}$n.ContextConsumer=SC;$n.ContextProvider=IC;$n.Element=dF;$n.ForwardRef=CC;$n.Fragment=wC;$n.Lazy=_C;$n.Memo=TC;$n.Portal=hF;$n.Profiler=kC;$n.StrictMode=vC;$n.Suspense=NC;$n.SuspenseList=$C;$n.isAsyncMode=function(){return!1};$n.isConcurrentMode=function(){return!1};$n.isContextConsumer=function(e){return wo(e)===SC};$n.isContextProvider=function(e){return wo(e)===IC};$n.isElement=function(e){return typeof e=="object"&&e!==null&&e.$$typeof===dF};$n.isForwardRef=function(e){return wo(e)===CC};$n.isFragment=function(e){return wo(e)===wC};$n.isLazy=function(e){return wo(e)===_C};$n.isMemo=function(e){return wo(e)===TC};$n.isPortal=function(e){return wo(e)===hF};$n.isProfiler=function(e){return wo(e)===kC};$n.isStrictMode=function(e){return wo(e)===vC};$n.isSuspense=function(e){return wo(e)===NC};$n.isSuspenseList=function(e){return wo(e)===$C};$n.isValidElementType=function(e){return typeof e=="string"||typeof e=="function"||e===wC||e===kC||e===vC||e===NC||e===$C||e===cue||typeof e=="object"&&e!==null&&(e.$$typeof===_C||e.$$typeof===TC||e.$$typeof===IC||e.$$typeof===SC||e.$$typeof===CC||e.$$typeof===l6||e.getModuleId!==void 0)};$n.typeOf=wo;(function(e){e.exports=$n})(lue);function due(e){function t(q,B,X,ee,Z){for(var fe=0,Q=0,be=0,we=0,Ne,$e,je=0,He=0,Re,Fe=Re=Ne=0,Pe=0,Je=0,pn=0,ct=0,an=X.length,Lt=an-1,Gt,Qe="",It="",mn="",en="",on;Pe<an;){if($e=X.charCodeAt(Pe),Pe===Lt&&Q+we+be+fe!==0&&(Q!==0&&($e=Q===47?10:47),we=be=fe=0,an++,Lt++),Q+we+be+fe===0){if(Pe===Lt&&(0<Je&&(Qe=Qe.replace(h,"")),0<Qe.trim().length)){switch($e){case 32:case 9:case 59:case 13:case 10:break;default:Qe+=X.charAt(Pe)}$e=59}switch($e){case 123:for(Qe=Qe.trim(),Ne=Qe.charCodeAt(0),Re=1,ct=++Pe;Pe<an;){switch($e=X.charCodeAt(Pe)){case 123:Re++;break;case 125:Re--;break;case 47:switch($e=X.charCodeAt(Pe+1)){case 42:case 47:e:{for(Fe=Pe+1;Fe<Lt;++Fe)switch(X.charCodeAt(Fe)){case 47:if($e===42&&X.charCodeAt(Fe-1)===42&&Pe+2!==Fe){Pe=Fe+1;break e}break;case 10:if($e===47){Pe=Fe+1;break e}}Pe=Fe}}break;case 91:$e++;case 40:$e++;case 34:case 39:for(;Pe++<Lt&&X.charCodeAt(Pe)!==$e;);}if(Re===0)break;Pe++}switch(Re=X.substring(ct,Pe),Ne===0&&(Ne=(Qe=Qe.replace(d,"").trim()).charCodeAt(0)),Ne){case 64:switch(0<Je&&(Qe=Qe.replace(h,"")),$e=Qe.charCodeAt(1),$e){case 100:case 109:case 115:case 45:Je=B;break;default:Je=z}if(Re=t(B,Je,Re,$e,Z+1),ct=Re.length,0<P&&(Je=n(z,Qe,pn),on=o(3,Re,Je,B,E,C,ct,$e,Z,ee),Qe=Je.join(""),on!==void 0&&(ct=(Re=on.trim()).length)===0&&($e=0,Re="")),0<ct)switch($e){case 115:Qe=Qe.replace(k,i);case 100:case 109:case 45:Re=Qe+"{"+Re+"}";break;case 107:Qe=Qe.replace(b,"$1 $2"),Re=Qe+"{"+Re+"}",Re=F===1||F===2&&a("@"+Re,3)?"@-webkit-"+Re+"@"+Re:"@"+Re;break;default:Re=Qe+Re,ee===112&&(Re=(It+=Re,""))}else Re="";break;default:Re=t(B,n(B,Qe,pn),Re,ee,Z+1)}mn+=Re,Re=pn=Je=Fe=Ne=0,Qe="",$e=X.charCodeAt(++Pe);break;case 125:case 59:if(Qe=(0<Je?Qe.replace(h,""):Qe).trim(),1<(ct=Qe.length))switch(Fe===0&&(Ne=Qe.charCodeAt(0),Ne===45||96<Ne&&123>Ne)&&(ct=(Qe=Qe.replace(" ",":")).length),0<P&&(on=o(1,Qe,B,q,E,C,It.length,ee,Z,ee))!==void 0&&(ct=(Qe=on.trim()).length)===0&&(Qe="\0\0"),Ne=Qe.charCodeAt(0),$e=Qe.charCodeAt(1),Ne){case 0:break;case 64:if($e===105||$e===99){en+=Qe+X.charAt(Pe);break}default:Qe.charCodeAt(ct-1)!==58&&(It+=s(Qe,Ne,$e,Qe.charCodeAt(2)))}pn=Je=Fe=Ne=0,Qe="",$e=X.charCodeAt(++Pe)}}switch($e){case 13:case 10:Q===47?Q=0:1+Ne===0&&ee!==107&&0<Qe.length&&(Je=1,Qe+="\0"),0<P*L&&o(0,Qe,B,q,E,C,It.length,ee,Z,ee),C=1,E++;break;case 59:case 125:if(Q+we+be+fe===0){C++;break}default:switch(C++,Gt=X.charAt(Pe),$e){case 9:case 32:if(we+fe+Q===0)switch(je){case 44:case 58:case 9:case 32:Gt="";break;default:$e!==32&&(Gt=" ")}break;case 0:Gt="\\0";break;case 12:Gt="\\f";break;case 11:Gt="\\v";break;case 38:we+Q+fe===0&&(Je=pn=1,Gt="\f"+Gt);break;case 108:if(we+Q+fe+M===0&&0<Fe)switch(Pe-Fe){case 2:je===112&&X.charCodeAt(Pe-3)===58&&(M=je);case 8:He===111&&(M=He)}break;case 58:we+Q+fe===0&&(Fe=Pe);break;case 44:Q+be+we+fe===0&&(Je=1,Gt+="\r");break;case 34:case 39:Q===0&&(we=we===$e?0:we===0?$e:we);break;case 91:we+Q+be===0&&fe++;break;case 93:we+Q+be===0&&fe--;break;case 41:we+Q+fe===0&&be--;break;case 40:if(we+Q+fe===0){if(Ne===0)switch(2*je+3*He){case 533:break;default:Ne=1}be++}break;case 64:Q+be+we+fe+Fe+Re===0&&(Re=1);break;case 42:case 47:if(!(0<we+fe+be))switch(Q){case 0:switch(2*$e+3*X.charCodeAt(Pe+1)){case 235:Q=47;break;case 220:ct=Pe,Q=42}break;case 42:$e===47&&je===42&&ct+2!==Pe&&(X.charCodeAt(ct+2)===33&&(It+=X.substring(ct,Pe+1)),Gt="",Q=0)}}Q===0&&(Qe+=Gt)}He=je,je=$e,Pe++}if(ct=It.length,0<ct){if(Je=B,0<P&&(on=o(2,It,Je,q,E,C,ct,ee,Z,ee),on!==void 0&&(It=on).length===0))return en+It+mn;if(It=Je.join(",")+"{"+It+"}",F*M!==0){switch(F!==2||a(It,2)||(M=0),M){case 111:It=It.replace(w,":-moz-$1")+It;break;case 112:It=It.replace(x,"::-webkit-input-$1")+It.replace(x,"::-moz-$1")+It.replace(x,":-ms-input-$1")+It}M=0}}return en+It+mn}function n(q,B,X){var ee=B.trim().split(g);B=ee;var Z=ee.length,fe=q.length;switch(fe){case 0:case 1:var Q=0;for(q=fe===0?"":q[0]+" ";Q<Z;++Q)B[Q]=r(q,B[Q],X).trim();break;default:var be=Q=0;for(B=[];Q<Z;++Q)for(var we=0;we<fe;++we)B[be++]=r(q[we]+" ",ee[Q],X).trim()}return B}function r(q,B,X){var ee=B.charCodeAt(0);switch(33>ee&&(ee=(B=B.trim()).charCodeAt(0)),ee){case 38:return B.replace(y,"$1"+q.trim());case 58:return q.trim()+B.replace(y,"$1"+q.trim());default:if(0<1*X&&0<B.indexOf("\f"))return B.replace(y,(q.charCodeAt(0)===58?"":"$1")+q.trim())}return q+B}function s(q,B,X,ee){var Z=q+";",fe=2*B+3*X+4*ee;if(fe===944){q=Z.indexOf(":",9)+1;var Q=Z.substring(q,Z.length-1).trim();return Q=Z.substring(0,q).trim()+Q+";",F===1||F===2&&a(Q,1)?"-webkit-"+Q+Q:Q}if(F===0||F===2&&!a(Z,1))return Z;switch(fe){case 1015:return Z.charCodeAt(10)===97?"-webkit-"+Z+Z:Z;case 951:return Z.charCodeAt(3)===116?"-webkit-"+Z+Z:Z;case 963:return Z.charCodeAt(5)===110?"-webkit-"+Z+Z:Z;case 1009:if(Z.charCodeAt(4)!==100)break;case 969:case 942:return"-webkit-"+Z+Z;case 978:return"-webkit-"+Z+"-moz-"+Z+Z;case 1019:case 983:return"-webkit-"+Z+"-moz-"+Z+"-ms-"+Z+Z;case 883:if(Z.charCodeAt(8)===45)return"-webkit-"+Z+Z;if(0<Z.indexOf("image-set(",11))return Z.replace(T,"$1-webkit-$2")+Z;break;case 932:if(Z.charCodeAt(4)===45)switch(Z.charCodeAt(5)){case 103:return"-webkit-box-"+Z.replace("-grow","")+"-webkit-"+Z+"-ms-"+Z.replace("grow","positive")+Z;case 115:return"-webkit-"+Z+"-ms-"+Z.replace("shrink","negative")+Z;case 98:return"-webkit-"+Z+"-ms-"+Z.replace("basis","preferred-size")+Z}return"-webkit-"+Z+"-ms-"+Z+Z;case 964:return"-webkit-"+Z+"-ms-flex-"+Z+Z;case 1023:if(Z.charCodeAt(8)!==99)break;return Q=Z.substring(Z.indexOf(":",15)).replace("flex-","").replace("space-between","justify"),"-webkit-box-pack"+Q+"-webkit-"+Z+"-ms-flex-pack"+Q+Z;case 1005:return f.test(Z)?Z.replace(p,":-webkit-")+Z.replace(p,":-moz-")+Z:Z;case 1e3:switch(Q=Z.substring(13).trim(),B=Q.indexOf("-")+1,Q.charCodeAt(0)+Q.charCodeAt(B)){case 226:Q=Z.replace(v,"tb");break;case 232:Q=Z.replace(v,"tb-rl");break;case 220:Q=Z.replace(v,"lr");break;default:return Z}return"-webkit-"+Z+"-ms-"+Q+Z;case 1017:if(Z.indexOf("sticky",9)===-1)break;case 975:switch(B=(Z=q).length-10,Q=(Z.charCodeAt(B)===33?Z.substring(0,B):Z).substring(q.indexOf(":",7)+1).trim(),fe=Q.charCodeAt(0)+(Q.charCodeAt(7)|0)){case 203:if(111>Q.charCodeAt(8))break;case 115:Z=Z.replace(Q,"-webkit-"+Q)+";"+Z;break;case 207:case 102:Z=Z.replace(Q,"-webkit-"+(102<fe?"inline-":"")+"box")+";"+Z.replace(Q,"-webkit-"+Q)+";"+Z.replace(Q,"-ms-"+Q+"box")+";"+Z}return Z+";";case 938:if(Z.charCodeAt(5)===45)switch(Z.charCodeAt(6)){case 105:return Q=Z.replace("-items",""),"-webkit-"+Z+"-webkit-box-"+Q+"-ms-flex-"+Q+Z;case 115:return"-webkit-"+Z+"-ms-flex-item-"+Z.replace(S,"")+Z;default:return"-webkit-"+Z+"-ms-flex-line-pack"+Z.replace("align-content","").replace(S,"")+Z}break;case 973:case 989:if(Z.charCodeAt(3)!==45||Z.charCodeAt(4)===122)break;case 931:case 953:if(N.test(q)===!0)return(Q=q.substring(q.indexOf(":")+1)).charCodeAt(0)===115?s(q.replace("stretch","fill-available"),B,X,ee).replace(":fill-available",":stretch"):Z.replace(Q,"-webkit-"+Q)+Z.replace(Q,"-moz-"+Q.replace("fill-",""))+Z;break;case 962:if(Z="-webkit-"+Z+(Z.charCodeAt(5)===102?"-ms-"+Z:"")+Z,X+ee===211&&Z.charCodeAt(13)===105&&0<Z.indexOf("transform",10))return Z.substring(0,Z.indexOf(";",27)+1).replace(m,"$1-webkit-$2")+Z}return Z}function a(q,B){var X=q.indexOf(B===1?":":"{"),ee=q.substring(0,B!==3?X:10);return X=q.substring(X+1,q.length-1),O(B!==2?ee:ee.replace($,"$1"),X,B)}function i(q,B){var X=s(B,B.charCodeAt(0),B.charCodeAt(1),B.charCodeAt(2));return X!==B+";"?X.replace(I," or ($1)").substring(4):"("+B+")"}function o(q,B,X,ee,Z,fe,Q,be,we,Ne){for(var $e=0,je=B,He;$e<P;++$e)switch(He=H[$e].call(c,q,je,X,ee,Z,fe,Q,be,we,Ne)){case void 0:case!1:case!0:case null:break;default:je=He}if(je!==B)return je}function l(q){switch(q){case void 0:case null:P=H.length=0;break;default:if(typeof q=="function")H[P++]=q;else if(typeof q=="object")for(var B=0,X=q.length;B<X;++B)l(q[B]);else L=!!q|0}return l}function u(q){return q=q.prefix,q!==void 0&&(O=null,q?typeof q!="function"?F=1:(F=2,O=q):F=0),u}function c(q,B){var X=q;if(33>X.charCodeAt(0)&&(X=X.trim()),V=X,X=[V],0<P){var ee=o(-1,B,X,X,E,C,0,0,0,0);ee!==void 0&&typeof ee=="string"&&(B=ee)}var Z=t(z,X,B,0,0);return 0<P&&(ee=o(-2,Z,X,X,E,C,Z.length,0,0,0),ee!==void 0&&(Z=ee)),V="",M=0,C=E=1,Z}var d=/^\0+/g,h=/[\0\r\f]/g,p=/: */g,f=/zoo|gra/,m=/([,: ])(transform)/g,g=/,\r+?/g,y=/([\t\r\n ])*\f?&/g,b=/@(k\w+)\s*(\S*)\s*/,x=/::(place)/g,w=/:(read-only)/g,v=/[svh]\w+-[tblr]{2}/,k=/\(\s*(.*)\s*\)/g,I=/([\s\S]*?);/g,S=/-self|flex-/g,$=/[^]*?(:[rp][el]a[\w-]+)[^]*/,N=/stretch|:\s*\w+\-(?:conte|avail)/,T=/([^-])(image-set\()/,C=1,E=1,M=0,F=1,z=[],H=[],P=0,O=null,L=0,V="";return c.use=l,c.set=u,e!==void 0&&u(e),c}var hue={animationIterationCount:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1};function pue(e){var t=Object.create(null);return function(n){return t[n]===void 0&&(t[n]=e(n)),t[n]}}var fue=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,AW=pue(function(e){return fue.test(e)||e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&e.charCodeAt(2)<91}),HE={},mue={get exports(){return HE},set exports(e){HE=e}},Tn={};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ss=typeof Symbol=="function"&&Symbol.for,pF=Ss?Symbol.for("react.element"):60103,fF=Ss?Symbol.for("react.portal"):60106,EC=Ss?Symbol.for("react.fragment"):60107,AC=Ss?Symbol.for("react.strict_mode"):60108,RC=Ss?Symbol.for("react.profiler"):60114,DC=Ss?Symbol.for("react.provider"):60109,FC=Ss?Symbol.for("react.context"):60110,mF=Ss?Symbol.for("react.async_mode"):60111,OC=Ss?Symbol.for("react.concurrent_mode"):60111,MC=Ss?Symbol.for("react.forward_ref"):60112,LC=Ss?Symbol.for("react.suspense"):60113,gue=Ss?Symbol.for("react.suspense_list"):60120,PC=Ss?Symbol.for("react.memo"):60115,zC=Ss?Symbol.for("react.lazy"):60116,yue=Ss?Symbol.for("react.block"):60121,bue=Ss?Symbol.for("react.fundamental"):60117,xue=Ss?Symbol.for("react.responder"):60118,wue=Ss?Symbol.for("react.scope"):60119;function Mi(e){if(typeof e=="object"&&e!==null){var t=e.$$typeof;switch(t){case pF:switch(e=e.type,e){case mF:case OC:case EC:case RC:case AC:case LC:return e;default:switch(e=e&&e.$$typeof,e){case FC:case MC:case zC:case PC:case DC:return e;default:return t}}case fF:return t}}}function u6(e){return Mi(e)===OC}Tn.AsyncMode=mF;Tn.ConcurrentMode=OC;Tn.ContextConsumer=FC;Tn.ContextProvider=DC;Tn.Element=pF;Tn.ForwardRef=MC;Tn.Fragment=EC;Tn.Lazy=zC;Tn.Memo=PC;Tn.Portal=fF;Tn.Profiler=RC;Tn.StrictMode=AC;Tn.Suspense=LC;Tn.isAsyncMode=function(e){return u6(e)||Mi(e)===mF};Tn.isConcurrentMode=u6;Tn.isContextConsumer=function(e){return Mi(e)===FC};Tn.isContextProvider=function(e){return Mi(e)===DC};Tn.isElement=function(e){return typeof e=="object"&&e!==null&&e.$$typeof===pF};Tn.isForwardRef=function(e){return Mi(e)===MC};Tn.isFragment=function(e){return Mi(e)===EC};Tn.isLazy=function(e){return Mi(e)===zC};Tn.isMemo=function(e){return Mi(e)===PC};Tn.isPortal=function(e){return Mi(e)===fF};Tn.isProfiler=function(e){return Mi(e)===RC};Tn.isStrictMode=function(e){return Mi(e)===AC};Tn.isSuspense=function(e){return Mi(e)===LC};Tn.isValidElementType=function(e){return typeof e=="string"||typeof e=="function"||e===EC||e===OC||e===RC||e===AC||e===LC||e===gue||typeof e=="object"&&e!==null&&(e.$$typeof===zC||e.$$typeof===PC||e.$$typeof===DC||e.$$typeof===FC||e.$$typeof===MC||e.$$typeof===bue||e.$$typeof===xue||e.$$typeof===wue||e.$$typeof===yue)};Tn.typeOf=Mi;(function(e){e.exports=Tn})(mue);var gF=HE,vue={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},kue={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},Iue={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},c6={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},yF={};yF[gF.ForwardRef]=Iue;yF[gF.Memo]=c6;function RW(e){return gF.isMemo(e)?c6:yF[e.$$typeof]||vue}var Sue=Object.defineProperty,Cue=Object.getOwnPropertyNames,DW=Object.getOwnPropertySymbols,Nue=Object.getOwnPropertyDescriptor,$ue=Object.getPrototypeOf,FW=Object.prototype;function d6(e,t,n){if(typeof t!="string"){if(FW){var r=$ue(t);r&&r!==FW&&d6(e,r,n)}var s=Cue(t);DW&&(s=s.concat(DW(t)));for(var a=RW(e),i=RW(t),o=0;o<s.length;++o){var l=s[o];if(!kue[l]&&!(n&&n[l])&&!(i&&i[l])&&!(a&&a[l])){var u=Nue(t,l);try{Sue(e,l,u)}catch{}}}}return e}var Tue=d6;function $l(){return($l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var OW=function(e,t){for(var n=[e[0]],r=0,s=t.length;r<s;r+=1)n.push(t[r],e[r+1]);return n},jE=function(e){return e!==null&&typeof e=="object"&&(e.toString?e.toString():Object.prototype.toString.call(e))==="[object Object]"&&!UI.typeOf(e)},GI=Object.freeze([]),Ac=Object.freeze({});function ig(e){return typeof e=="function"}function MW(e){return e.displayName||e.name||"Component"}function bF(e){return e&&typeof e.styledComponentId=="string"}var og=typeof process<"u"&&process.env!==void 0&&({}.REACT_APP_SC_ATTR||{}.SC_ATTR)||"data-styled",xF=typeof window<"u"&&"HTMLElement"in window,_ue=Boolean(typeof SC_DISABLE_SPEEDY=="boolean"?SC_DISABLE_SPEEDY:typeof process<"u"&&process.env!==void 0&&({}.REACT_APP_SC_DISABLE_SPEEDY!==void 0&&{}.REACT_APP_SC_DISABLE_SPEEDY!==""?{}.REACT_APP_SC_DISABLE_SPEEDY!=="false"&&{}.REACT_APP_SC_DISABLE_SPEEDY:{}.SC_DISABLE_SPEEDY!==void 0&&{}.SC_DISABLE_SPEEDY!==""?{}.SC_DISABLE_SPEEDY!=="false"&&{}.SC_DISABLE_SPEEDY:!1));function Oh(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];throw new Error("An error occurred. See https://git.io/JUIaE#"+e+" for more information."+(n.length>0?" Args: "+n.join(", "):""))}var Eue=function(){function e(n){this.groupSizes=new Uint32Array(512),this.length=512,this.tag=n}var t=e.prototype;return t.indexOfGroup=function(n){for(var r=0,s=0;s<n;s++)r+=this.groupSizes[s];return r},t.insertRules=function(n,r){if(n>=this.groupSizes.length){for(var s=this.groupSizes,a=s.length,i=a;n>=i;)(i<<=1)<0&&Oh(16,""+n);this.groupSizes=new Uint32Array(i),this.groupSizes.set(s),this.length=i;for(var o=a;o<i;o++)this.groupSizes[o]=0}for(var l=this.indexOfGroup(n+1),u=0,c=r.length;u<c;u++)this.tag.insertRule(l,r[u])&&(this.groupSizes[n]++,l++)},t.clearGroup=function(n){if(n<this.length){var r=this.groupSizes[n],s=this.indexOfGroup(n),a=s+r;this.groupSizes[n]=0;for(var i=s;i<a;i++)this.tag.deleteRule(s)}},t.getGroup=function(n){var r="";if(n>=this.length||this.groupSizes[n]===0)return r;for(var s=this.groupSizes[n],a=this.indexOfGroup(n),i=a+s,o=a;o<i;o++)r+=this.tag.getRule(o)+`/*!sc*/
`;return r},e}(),tI=new Map,HI=new Map,zx=1,ek=function(e){if(tI.has(e))return tI.get(e);for(;HI.has(zx);)zx++;var t=zx++;return tI.set(e,t),HI.set(t,e),t},Aue=function(e){return HI.get(e)},Rue=function(e,t){t>=zx&&(zx=t+1),tI.set(e,t),HI.set(t,e)},Due="style["+og+'][data-styled-version="5.3.8"]',Fue=new RegExp("^"+og+'\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'),Oue=function(e,t,n){for(var r,s=n.split(","),a=0,i=s.length;a<i;a++)(r=s[a])&&e.registerName(t,r)},Mue=function(e,t){for(var n=(t.textContent||"").split(`/*!sc*/
`),r=[],s=0,a=n.length;s<a;s++){var i=n[s].trim();if(i){var o=i.match(Fue);if(o){var l=0|parseInt(o[1],10),u=o[2];l!==0&&(Rue(u,l),Oue(e,u,o[3]),e.getTag().insertRules(l,r)),r.length=0}else r.push(i)}}},Lue=function(){return typeof __webpack_nonce__<"u"?__webpack_nonce__:null},h6=function(e){var t=document.head,n=e||t,r=document.createElement("style"),s=function(o){for(var l=o.childNodes,u=l.length;u>=0;u--){var c=l[u];if(c&&c.nodeType===1&&c.hasAttribute(og))return c}}(n),a=s!==void 0?s.nextSibling:null;r.setAttribute(og,"active"),r.setAttribute("data-styled-version","5.3.8");var i=Lue();return i&&r.setAttribute("nonce",i),n.insertBefore(r,a),r},Pue=function(){function e(n){var r=this.element=h6(n);r.appendChild(document.createTextNode("")),this.sheet=function(s){if(s.sheet)return s.sheet;for(var a=document.styleSheets,i=0,o=a.length;i<o;i++){var l=a[i];if(l.ownerNode===s)return l}Oh(17)}(r),this.length=0}var t=e.prototype;return t.insertRule=function(n,r){try{return this.sheet.insertRule(r,n),this.length++,!0}catch{return!1}},t.deleteRule=function(n){this.sheet.deleteRule(n),this.length--},t.getRule=function(n){var r=this.sheet.cssRules[n];return r!==void 0&&typeof r.cssText=="string"?r.cssText:""},e}(),zue=function(){function e(n){var r=this.element=h6(n);this.nodes=r.childNodes,this.length=0}var t=e.prototype;return t.insertRule=function(n,r){if(n<=this.length&&n>=0){var s=document.createTextNode(r),a=this.nodes[n];return this.element.insertBefore(s,a||null),this.length++,!0}return!1},t.deleteRule=function(n){this.element.removeChild(this.nodes[n]),this.length--},t.getRule=function(n){return n<this.length?this.nodes[n].textContent:""},e}(),Bue=function(){function e(n){this.rules=[],this.length=0}var t=e.prototype;return t.insertRule=function(n,r){return n<=this.length&&(this.rules.splice(n,0,r),this.length++,!0)},t.deleteRule=function(n){this.rules.splice(n,1),this.length--},t.getRule=function(n){return n<this.length?this.rules[n]:""},e}(),LW=xF,Wue={isServer:!xF,useCSSOMInjection:!_ue},p6=function(){function e(n,r,s){n===void 0&&(n=Ac),r===void 0&&(r={}),this.options=$l({},Wue,{},n),this.gs=r,this.names=new Map(s),this.server=!!n.isServer,!this.server&&xF&&LW&&(LW=!1,function(a){for(var i=document.querySelectorAll(Due),o=0,l=i.length;o<l;o++){var u=i[o];u&&u.getAttribute(og)!=="active"&&(Mue(a,u),u.parentNode&&u.parentNode.removeChild(u))}}(this))}e.registerId=function(n){return ek(n)};var t=e.prototype;return t.reconstructWithOptions=function(n,r){return r===void 0&&(r=!0),new e($l({},this.options,{},n),this.gs,r&&this.names||void 0)},t.allocateGSInstance=function(n){return this.gs[n]=(this.gs[n]||0)+1},t.getTag=function(){return this.tag||(this.tag=(s=(r=this.options).isServer,a=r.useCSSOMInjection,i=r.target,n=s?new Bue(i):a?new Pue(i):new zue(i),new Eue(n)));var n,r,s,a,i},t.hasNameForId=function(n,r){return this.names.has(n)&&this.names.get(n).has(r)},t.registerName=function(n,r){if(ek(n),this.names.has(n))this.names.get(n).add(r);else{var s=new Set;s.add(r),this.names.set(n,s)}},t.insertRules=function(n,r,s){this.registerName(n,r),this.getTag().insertRules(ek(n),s)},t.clearNames=function(n){this.names.has(n)&&this.names.get(n).clear()},t.clearRules=function(n){this.getTag().clearGroup(ek(n)),this.clearNames(n)},t.clearTag=function(){this.tag=void 0},t.toString=function(){return function(n){for(var r=n.getTag(),s=r.length,a="",i=0;i<s;i++){var o=Aue(i);if(o!==void 0){var l=n.names.get(o),u=r.getGroup(i);if(l&&u&&l.size){var c=og+".g"+i+'[id="'+o+'"]',d="";l!==void 0&&l.forEach(function(h){h.length>0&&(d+=h+",")}),a+=""+u+c+'{content:"'+d+`"}/*!sc*/
`}}}return a}(this)},e}(),Vue=/(a)(d)/gi,PW=function(e){return String.fromCharCode(e+(e>25?39:97))};function qE(e){var t,n="";for(t=Math.abs(e);t>52;t=t/52|0)n=PW(t%52)+n;return(PW(t%52)+n).replace(Vue,"$1-$2")}var Dm=function(e,t){for(var n=t.length;n;)e=33*e^t.charCodeAt(--n);return e},f6=function(e){return Dm(5381,e)};function Uue(e){for(var t=0;t<e.length;t+=1){var n=e[t];if(ig(n)&&!bF(n))return!1}return!0}var Gue=f6("5.3.8"),Hue=function(){function e(t,n,r){this.rules=t,this.staticRulesId="",this.isStatic=(r===void 0||r.isStatic)&&Uue(t),this.componentId=n,this.baseHash=Dm(Gue,n),this.baseStyle=r,p6.registerId(n)}return e.prototype.generateAndInjectStyles=function(t,n,r){var s=this.componentId,a=[];if(this.baseStyle&&a.push(this.baseStyle.generateAndInjectStyles(t,n,r)),this.isStatic&&!r.hash)if(this.staticRulesId&&n.hasNameForId(s,this.staticRulesId))a.push(this.staticRulesId);else{var i=lg(this.rules,t,n,r).join(""),o=qE(Dm(this.baseHash,i)>>>0);if(!n.hasNameForId(s,o)){var l=r(i,"."+o,void 0,s);n.insertRules(s,o,l)}a.push(o),this.staticRulesId=o}else{for(var u=this.rules.length,c=Dm(this.baseHash,r.hash),d="",h=0;h<u;h++){var p=this.rules[h];if(typeof p=="string")d+=p;else if(p){var f=lg(p,t,n,r),m=Array.isArray(f)?f.join(""):f;c=Dm(c,m+h),d+=m}}if(d){var g=qE(c>>>0);if(!n.hasNameForId(s,g)){var y=r(d,"."+g,void 0,s);n.insertRules(s,g,y)}a.push(g)}}return a.join(" ")},e}(),jue=/^\s*\/\/.*$/gm,que=[":","[",".","#"];function Kue(e){var t,n,r,s,a=e===void 0?Ac:e,i=a.options,o=i===void 0?Ac:i,l=a.plugins,u=l===void 0?GI:l,c=new due(o),d=[],h=function(m){function g(y){if(y)try{m(y+"}")}catch{}}return function(y,b,x,w,v,k,I,S,$,N){switch(y){case 1:if($===0&&b.charCodeAt(0)===64)return m(b+";"),"";break;case 2:if(S===0)return b+"/*|*/";break;case 3:switch(S){case 102:case 112:return m(x[0]+b),"";default:return b+(N===0?"/*|*/":"")}case-2:b.split("/*|*/}").forEach(g)}}}(function(m){d.push(m)}),p=function(m,g,y){return g===0&&que.indexOf(y[n.length])!==-1||y.match(s)?m:"."+t};function f(m,g,y,b){b===void 0&&(b="&");var x=m.replace(jue,""),w=g&&y?y+" "+g+" { "+x+" }":x;return t=b,n=g,r=new RegExp("\\"+n+"\\b","g"),s=new RegExp("(\\"+n+"\\b){2,}"),c(y||!g?"":g,w)}return c.use([].concat(u,[function(m,g,y){m===2&&y.length&&y[0].lastIndexOf(n)>0&&(y[0]=y[0].replace(r,p))},h,function(m){if(m===-2){var g=d;return d=[],g}}])),f.hash=u.length?u.reduce(function(m,g){return g.name||Oh(15),Dm(m,g.name)},5381).toString():"",f}var m6=Kg.createContext();m6.Consumer;var g6=Kg.createContext(),Xue=(g6.Consumer,new p6),KE=Kue();function Yue(){return J.useContext(m6)||Xue}function Zue(){return J.useContext(g6)||KE}var Jue=function(){function e(t,n){var r=this;this.inject=function(s,a){a===void 0&&(a=KE);var i=r.name+a.hash;s.hasNameForId(r.id,i)||s.insertRules(r.id,i,a(r.rules,i,"@keyframes"))},this.toString=function(){return Oh(12,String(r.name))},this.name=t,this.id="sc-keyframes-"+t,this.rules=n}return e.prototype.getName=function(t){return t===void 0&&(t=KE),this.name+t.hash},e}(),Que=/([A-Z])/,ece=/([A-Z])/g,tce=/^ms-/,nce=function(e){return"-"+e.toLowerCase()};function zW(e){return Que.test(e)?e.replace(ece,nce).replace(tce,"-ms-"):e}var BW=function(e){return e==null||e===!1||e===""};function lg(e,t,n,r){if(Array.isArray(e)){for(var s,a=[],i=0,o=e.length;i<o;i+=1)(s=lg(e[i],t,n,r))!==""&&(Array.isArray(s)?a.push.apply(a,s):a.push(s));return a}if(BW(e))return"";if(bF(e))return"."+e.styledComponentId;if(ig(e)){if(typeof(u=e)!="function"||u.prototype&&u.prototype.isReactComponent||!t)return e;var l=e(t);return lg(l,t,n,r)}var u;return e instanceof Jue?n?(e.inject(n,r),e.getName(r)):e:jE(e)?function c(d,h){var p,f,m=[];for(var g in d)d.hasOwnProperty(g)&&!BW(d[g])&&(Array.isArray(d[g])&&d[g].isCss||ig(d[g])?m.push(zW(g)+":",d[g],";"):jE(d[g])?m.push.apply(m,c(d[g],g)):m.push(zW(g)+": "+(p=g,(f=d[g])==null||typeof f=="boolean"||f===""?"":typeof f!="number"||f===0||p in hue?String(f).trim():f+"px")+";"));return h?[h+" {"].concat(m,["}"]):m}(e):e.toString()}var WW=function(e){return Array.isArray(e)&&(e.isCss=!0),e};function rce(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return ig(e)||jE(e)?WW(lg(OW(GI,[e].concat(n)))):n.length===0&&e.length===1&&typeof e[0]=="string"?e:WW(lg(OW(e,n)))}var sce=function(e,t,n){return n===void 0&&(n=Ac),e.theme!==n.theme&&e.theme||t||n.theme},ace=/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,ice=/(^-|-$)/g;function XT(e){return e.replace(ace,"-").replace(ice,"")}var oce=function(e){return qE(f6(e)>>>0)};function tk(e){return typeof e=="string"&&!0}var XE=function(e){return typeof e=="function"||typeof e=="object"&&e!==null&&!Array.isArray(e)},lce=function(e){return e!=="__proto__"&&e!=="constructor"&&e!=="prototype"};function uce(e,t,n){var r=e[n];XE(t)&&XE(r)?y6(r,t):e[n]=t}function y6(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];for(var s=0,a=n;s<a.length;s++){var i=a[s];if(XE(i))for(var o in i)lce(o)&&uce(e,i[o],o)}return e}var jI=Kg.createContext();jI.Consumer;function cce(e){var t=J.useContext(jI),n=J.useMemo(function(){return function(r,s){if(!r)return Oh(14);if(ig(r)){var a=r(s);return a}return Array.isArray(r)||typeof r!="object"?Oh(8):s?$l({},s,{},r):r}(e.theme,t)},[e.theme,t]);return e.children?Kg.createElement(jI.Provider,{value:n},e.children):null}var YT={};function b6(e,t,n){var r=bF(e),s=!tk(e),a=t.attrs,i=a===void 0?GI:a,o=t.componentId,l=o===void 0?function(b,x){var w=typeof b!="string"?"sc":XT(b);YT[w]=(YT[w]||0)+1;var v=w+"-"+oce("5.3.8"+w+YT[w]);return x?x+"-"+v:v}(t.displayName,t.parentComponentId):o,u=t.displayName,c=u===void 0?function(b){return tk(b)?"styled."+b:"Styled("+MW(b)+")"}(e):u,d=t.displayName&&t.componentId?XT(t.displayName)+"-"+t.componentId:t.componentId||l,h=r&&e.attrs?Array.prototype.concat(e.attrs,i).filter(Boolean):i,p=t.shouldForwardProp;r&&e.shouldForwardProp&&(p=t.shouldForwardProp?function(b,x,w){return e.shouldForwardProp(b,x,w)&&t.shouldForwardProp(b,x,w)}:e.shouldForwardProp);var f,m=new Hue(n,d,r?e.componentStyle:void 0),g=m.isStatic&&i.length===0,y=function(b,x){return function(w,v,k,I){var S=w.attrs,$=w.componentStyle,N=w.defaultProps,T=w.foldedComponentIds,C=w.shouldForwardProp,E=w.styledComponentId,M=w.target,F=function(ee,Z,fe){ee===void 0&&(ee=Ac);var Q=$l({},Z,{theme:ee}),be={};return fe.forEach(function(we){var Ne,$e,je,He=we;for(Ne in ig(He)&&(He=He(Q)),He)Q[Ne]=be[Ne]=Ne==="className"?($e=be[Ne],je=He[Ne],$e&&je?$e+" "+je:$e||je):He[Ne]}),[Q,be]}(sce(v,J.useContext(jI),N)||Ac,v,S),z=F[0],H=F[1],P=function(ee,Z,fe,Q){var be=Yue(),we=Zue(),Ne=Z?ee.generateAndInjectStyles(Ac,be,we):ee.generateAndInjectStyles(fe,be,we);return Ne}($,I,z),O=k,L=H.$as||v.$as||H.as||v.as||M,V=tk(L),q=H!==v?$l({},v,{},H):v,B={};for(var X in q)X[0]!=="$"&&X!=="as"&&(X==="forwardedAs"?B.as=q[X]:(C?C(X,AW,L):!V||AW(X))&&(B[X]=q[X]));return v.style&&H.style!==v.style&&(B.style=$l({},v.style,{},H.style)),B.className=Array.prototype.concat(T,E,P!==E?P:null,v.className,H.className).filter(Boolean).join(" "),B.ref=O,J.createElement(L,B)}(f,b,x,g)};return y.displayName=c,(f=Kg.forwardRef(y)).attrs=h,f.componentStyle=m,f.displayName=c,f.shouldForwardProp=p,f.foldedComponentIds=r?Array.prototype.concat(e.foldedComponentIds,e.styledComponentId):GI,f.styledComponentId=d,f.target=r?e.target:e,f.withComponent=function(b){var x=t.componentId,w=function(k,I){if(k==null)return{};var S,$,N={},T=Object.keys(k);for($=0;$<T.length;$++)S=T[$],I.indexOf(S)>=0||(N[S]=k[S]);return N}(t,["componentId"]),v=x&&x+"-"+(tk(b)?b:XT(MW(b)));return b6(b,$l({},w,{attrs:h,componentId:v}),n)},Object.defineProperty(f,"defaultProps",{get:function(){return this._foldedDefaultProps},set:function(b){this._foldedDefaultProps=r?y6({},e.defaultProps,b):b}}),f.toString=function(){return"."+f.styledComponentId},s&&Tue(f,e,{attrs:!0,componentStyle:!0,displayName:!0,foldedComponentIds:!0,shouldForwardProp:!0,styledComponentId:!0,target:!0,withComponent:!0}),f}var YE=function(e){return function t(n,r,s){if(s===void 0&&(s=Ac),!UI.isValidElementType(r))return Oh(1,String(r));var a=function(){return n(r,s,rce.apply(void 0,arguments))};return a.withConfig=function(i){return t(n,r,$l({},s,{},i))},a.attrs=function(i){return t(n,r,$l({},s,{attrs:Array.prototype.concat(s.attrs,i).filter(Boolean)}))},a}(b6,e)};["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","marker","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","textPath","tspan"].forEach(function(e){YE[e]=YE(e)});const pe=YE,dce={colors:{primary:"#3498db",background:"#282728",foreground:"#30363d",error:"#c44569",typography:"#c8d6e5",input:"#484748",button_hover:"#3b3a3b"},media:{sm:900}},hce=()=>K("div",{style:{display:"flex",flexDirection:"row",alignItems:"center"},children:["Loading...",D(pce,{children:D(fce,{children:D(mce,{})})})]}),pce=pe.div.withConfig({displayName:"SpinnerBox",componentId:"sc-1kipg5y-0"})(["width:100px;height:100px;display:flex;justify-content:center;align-items:center;background-color:transparent;"]),fce=pe.div.withConfig({displayName:"CircleBorder",componentId:"sc-1kipg5y-1"})(["width:30px;height:30px;padding:3px;display:flex;justify-content:center;align-items:center;border-radius:50%;background:rgb(210,235,232);background:linear-gradient(0deg,rgba(63,249,220,0.1) 33%,#e0eceb 100%);animation:spin .8s linear 0s infinite;@keyframes spin{from{transform:rotate(0);}to{transform:rotate(359deg);}}"]),mce=pe.div.withConfig({displayName:"CircleCore",componentId:"sc-1kipg5y-2"})(["width:100%;height:100%;border-radius:50%;width:100%;height:100%;background-color:#1d2630;border-radius:50%;"]),Ue=pe.button.withConfig({displayName:"BestButton",componentId:"sc-1x6ofld-0"})(["padding:10px;margin:10px;text-align:center;font-weight:600;border-radius:8px;border:1px solid gray;color:",";background:transparent;cursor:pointer;&:hover{background-color:","};"],({theme:e})=>e.colors.typography,({theme:e})=>e.colors.foreground),co=pe.div.withConfig({displayName:"TableContainer",componentId:"sc-1x6ofld-1"})(["height:350px;overflow-y:scroll;border:1px solid;border-color:rgba(255,255,255,.15);background-color:#161b22;border-radius:10px;::-webkit-scrollbar{width:5px;background:grey;}::-webkit-scrollbar-thumb{background:#484748;}"]),vo=pe.div.withConfig({displayName:"ContainerP",componentId:"sc-1x6ofld-2"})(["color:",";display:flex;flex-direction:row;justify-content:center;flex:1;"],({theme:e})=>e.colors.typography),bi=pe.td.withConfig({displayName:"Td_image",componentId:"sc-1x6ofld-3"})(["justify-content:center;text-align:center;border:1px solid;border-color:rgba(255,255,255,.15);background-color:#161b22;border-radius:10px;width:50px;height:50px;cursor:pointer;"]),Uo=pe.img.withConfig({displayName:"MyImage",componentId:"sc-1x6ofld-4"})(["width:50px;height:50px;border:1px solid;border-color:rgba(255,255,255,.15);background-color:#161b22;justify-content:center;border-radius:10px;"]),Yo=pe.tr.withConfig({displayName:"Tr_sticky_row",componentId:"sc-1x6ofld-5"})(["position:-webkit-sticky;position:sticky;top:0;z-index:1;background-color:#6f6d6f;"]),Zo=pe.button.withConfig({displayName:"DeleteButton",componentId:"sc-1x6ofld-6"})(["padding:5px;margin:5px;text-align:center;font-weight:600;border-radius:8px;border:1px solid;border-color:rgba(255,255,255,.15);color:",";background-color:",";cursor:pointer;&:hover{background-color:","};"],({theme:e})=>e.colors.typography,({theme:e})=>e.colors.error,({theme:e})=>e.colors.button_hover),Jo=pe.button.withConfig({displayName:"OptionButton",componentId:"sc-1x6ofld-7"})(["padding:5px;justify-content:center;text-align:center;font-weight:600;border-radius:8px;border:none;color:",";background-color:",";cursor:pointer;&:hover{background-color:","};"],({theme:e})=>e.colors.typography,({theme:e})=>e.colors.background,({theme:e})=>e.colors.button_hover),BC=pe.button.withConfig({displayName:"ModifyButton",componentId:"sc-1x6ofld-8"})(["padding:5px;margin:5px;text-align:center;font-weight:600;border-radius:8px;border:1px solid;border-color:rgba(255,255,255,.15);color:",";background-color:",";cursor:pointer;&:hover{background-color:","};"],({theme:e})=>e.colors.typography,({theme:e})=>e.colors.foreground,({theme:e})=>e.colors.button_hover),Qo=pe.img.withConfig({displayName:"ButtonImage",componentId:"sc-1x6ofld-9"})(["height:10px;width:10px;justify-content:center;"]),wF=({children:e})=>{const t=J.useRef(null),n=J.useRef(null),r=()=>{t.current.style.display=n.current.style.display="none"};return J.useEffect(()=>{t.current.style.display=n.current.style.display="block"},[]),K("div",{children:[D(gce,{ref:t}),K(yce,{ref:n,children:[e||"Nic nie podano!",D(Ue,{style:{float:"right",backgroundColor:"black"},onClick:r,id:"close",children:"Close"})]})]})},gce=pe.div.withConfig({displayName:"Shade",componentId:"sc-193kkpo-0"})(["display:none;position:fixed;z-index:100;top:0;left:0;width:100%;height:100%;background:silver;opacity:0.5;filter:alpha(opacity=50);"]),yce=pe.div.withConfig({displayName:"Modal",componentId:"sc-193kkpo-1"})(["display:none;position:fixed;z-index:101;top:10%;left:center;"]),un={GITHUB_URL:"https://github.com/PanBard/anlit_typescript",MODELS_URL:"https://github.com/PanBard/model_host",LIBRE_TRANSLATE_URL:"https://libretranslate.com",API_URL:"https://libretranslate.com",TEXT_INPUT_LIMIT:50,GALAXY_START_IMAGE:"img/gala.jpg",LOGO_URL:"img/logo.svg",USER_IMG_URL:"img/user_icon.svg",FACEID_IMAGR:"img/faceid.svg",PROBE_GALAXY_URL:"img/galaxy.jpg",START_BACKGROUND_IMG_URL:"img/gala.jpg",ION_ANNALYS_IMAGE:"img/ionanalysis.svg",PH_ANALYS_IMAGE:"img/phanalysis.svg",HELP_IMAGE:"img/help.svg",SETTINGS_IMAGE:"img/settings.svg",USER_IMAGE_MENU:"img/user.svg",EDIT_BTN_IMG:"img/editing.png",MICROPHONE_IMAGE:"img/micro.svg",FACES_MODELS_URL:"face_recognition_model",OBJECT_DETECTION_MODEL_URL:"object_detection_model/model.json",OBJECT_CLASSIFICATION_MODEL_URL:"object_classifyication_model/model.json"},bce={common:{autoTranslate:"Auto ",companyName:"AnalysisAI",close:"Close",back:"Back",end:"End",begin:"Begin",save:"save",or:"OR",no_data:"No data"},supported_languages:{en:"EN",pl:"PL"},components:{app:{error:"Something went wrong",empty:"No supported language",loading:"Fetching supported languages..."},header:{title:"AnalysisAI",diskord:"Discord",github:"Github"},footer:{flaticons:"FlatIcons",libretranslate:"LibreTranslate",github:"GitHub",models:"Models"},message:{tryAgain:"Try again"},confidence:{error:"Something went wrong while auto detecting the language"}},screens:{translator:{sourceInputPlaceholder:"Type text here..."}},start_page:{button_about:"About project",button_sign_in:"Sign in",button_sign_up:"Sign up",welcome_text_1:"Hi there!",welcome_text_2:"Our AI-powered platform drives innovation with tools that boost Qualitative Chemical Analysis.",welcome_text_3:"To use the app's services, you must log in or register."},login_form:{succes_login:"Welcome!",header:"Sign in",username:"Username",password:"Password",button_sign_in:"Log in",button_scan:"Log in with face identification",warn_wrong_username:"Wrong username",warn_wrong_pass:"Wrong password"},registration_form:{succes_register_1:"User ",succes_register_2:" successfully registered!",header:"Create a new user",username:"Username",password:"Password",first_name:"First Name",last_name:"Last Name",email:"Email",confirm_password:"Confirm Password",button_register:"Register",warn_pass_not_match:"Password does not match",warn_username_taken:"Username is already taken",warn_pass_empty:"Enter password",warn_username_empty:"Enter username"},dashboard_header:{analysis:"Ion analysis",database:"Databsae",ph:"pH analysis",face_recognition:"Face recognition",others:"Other",user_id:"User: ",dropdown_profile:"Your profile",dropdown_faceid:"Your Face ID",dropdown_ion:"Your ion analysis",dropdown_ph:"Your pH analysis",dropdown_help:"Help",dropdown_Settings:"Settings",dropdown_signout:"Sign out"},analysis:{new_analysis:"New analysis",continue_analysis:"Continue previous",cation_analysis:"Cation analysis",anion_analysis:"Anion analysis",enter_analysis_name:"Custom analysis name",analysis_begin:"Begin",propability:"Probability:        ",webcam_detection:"Webcam detection",anion_identification:"Anion identification",cation_identification:"Cation identification",analysis_name:"Analysis name: ",analysis_progress:"Analysis progress:",fake_analysis:"Fake analysis",choose_img:"Choose img: ",test_image:"TEST IMAGES",end_analysis:"Analysis completed",end_of_analysis:"Congratulations, analysis completed successfully!",wrong_result:"Such a result should not appear at this stage of the analysis.",ion_found:"Found ion: ",chat_name:"Chat",default_message:"No messages"},database_buttons:{ion_analysis:"Ion analysis",dataflow:"Dataflow",anion:"Anions -",cation:"Cations +",voicescript:"VoiceScript",images:"Images",img_1:"Test images",img_2:"Images storage",img_3:"Face images",chat:"Chat messages",users:"Users",ph:"pH analysis"},databse:{clear_all_bt:"Clear all",remove_bt:"Remove",mod_bt:"Mod",entry_modification:"Modification of entry number ",anion_analisys:"Anion analysis",cation_analysis:"Cation analysis",anion_scriptflow:"Anion dataflow",cation_scriptflow:"Cation dataflow",anion_voicescript:"Anion voicescript",cation_voicescript:"Cation voicescript",update_data:"Update data",add_new:"Add new",submit_bt:"Submit data to database",all_data_del_confirm:"Are you sure you want to delete all history?"},ph:{new_calibrations:"New calibration",prevoius_calibrations:"Previous calibrations",saved_cal:"Saved pH calibrations:",cal_name:"Calibration name:",cal_begin:"Begin",take_screenshot:"Get frame sample",preview:"Preview: ",result:"Result: ",ph_table:"pH value table:",p_value:"Enter ph value",file_from_device:"Get file from device"},face_recognition:{start_scan:"Start scan",open_webcam:"Open Webcam",close_webcam:"Close Webcam",age:"Age: ",gender:"Gender: ",expression:"Expression: "},about_page:{text_1:"AnalysisAI is a one-page application that helps you in chemical analysis and allows you to better manage your laboratory. It uses custom image detection and image classification algorithms to distinguish chemical analysis results.",text_2:"The main functionality is a voice assistant that will guide you through the stages of chemical analysis. Everything you need in one place. Analysis progress is automatically saved in the database so you can always go back and re-trace the process. When you interrupt the analysis, you can resume it at any time.",text_3:"You can automate the comparison of pH test results obtained with test strips.",text_4:"The login system supports face recognition, so you can log in to the site only by scanning your face."},welcome_page:{text_1:"let's get started!",text_2:"To start chemical analysis of ions in solutions, select the Ion Analysis button in the top bar.",text_3:"Select pH Analysis to start comparing the acidity and alkalinity scales of aqueous solutions."},user_profile:{data_header:"Account information:",image_header:"Face photo:",username:"Username:",first_name:"Name:",last_name:"Surname:",emial:"Email:",phone:"Phone:",auth:"Authcode:",password:"Password:",date:"Registered at:",accout_type:"Account type"},analysis_results_names:{zolty_p:"yellow liquid",fioletowy_p:"purple liquid",pomaranczowy_p:"orange liquid",cielisty:"nude precipitate",nieb_rozowy:"blue-pink precipitate",niebieski:"blue precipitate",zielony:"green precipitate",pomaranczowy:"orange precipitate",zolty:"yellow precipitate",czarny:"dark precipitate",bialy:"white precipitate",brak:"no precipitate"},user_settings:{lang_btn:"Language",apperance_btn:"Apperance",lang_header:"Choose language:",apperance_header:"Apperance option:",EN_btn:"ENGLISH",PL_btn:"POLISH"},user_help:{system_info:"More information about the functionality and structure of the system: ",model_info:"Information about the custom models:"},user_faceid:{menu_btn:"Current scans",no_scan_btn:"Create a new scan",no_scan_text:"No Face ID",scan_exist_btn:"Change Scan",scan_exist_text:"Date of last scan: "}},xce={common:{autoTranslate:"Auto ",companyName:"Hog Ademy",close:"Zamknij",back:"Cofnij",end:"Zakończ",begin:"Rozpocznij",save:"Zapisz",or:"LUB",no_data:"Brak danych"},supported_languages:{en:"EN",pl:"PL"},components:{app:{error:"Something went wrong",empty:"No supported language",loading:"Fetching supported languages..."},header:{title:"AnalysisAI",diskord:"Discord",github:"Github"},footer:{flaticons:"FlatIcons",libretranslate:"LibreTranslate",github:"GitHub",models:"Models"},message:{tryAgain:"Try again"},confidence:{error:"Something went wrong while auto detecting the language"}},screens:{translator:{sourceInputPlaceholder:"Type text here..."}},start_page:{button_about:"O projekcie",button_sign_in:"Zaloguj",button_sign_up:"Rejestracja",welcome_text_1:"Witaj!",welcome_text_2:"Nasza platforma oparta na sztucznej inteligencji dostarcza narzędzia usprawniające jakościową analizę chemiczną.",welcome_text_3:"Aby skorzystać z usług aplikacji zaloguj się lub zarejestruj."},login_form:{succes_login:"Witaj!",header:"Zaloguj się",username:"Nazwa użytkownika",password:"Hasło",button_sign_in:"Zaloguj",button_scan:"Zaloguj się za pomocą rozpoznawania twarzy",warn_wrong_username:"Zła nazwa użytkownika",warn_wrong_pass:"Złe hasło"},registration_form:{succes_register_1:"Użytkownik ",succes_register_2:" zalogowany poprawnie!",header:"Zarejestruj się",username:"Nazwa użytkownika",password:"Hasło",first_name:"Imię",last_name:"Nazwisko",email:"Email",confirm_password:"Potwierdź hasło",button_register:"Utwórz nowe konto",warn_pass_not_match:"Hasła się nie zgadzają",warn_username_taken:"Użytkownik o takiej nazwie już istnieje",warn_pass_empty:"Wpisz hasło",warn_username_empty:"Wpisz nazwę użytkownika"},dashboard_header:{analysis:"Analiza jonów",database:"Baza danych",ph:"Analiza pH",face_recognition:"Rozpoznawanie twarzy",others:"Inne",user_id:"Użytkownik: ",dropdown_profile:"Twój profil",dropdown_faceid:"Logowanie twarzą",dropdown_ion:"Analizy jonów",dropdown_ph:"Analizy pH",dropdown_help:"Pomoc",dropdown_Settings:"Ustawienia",dropdown_signout:"Wyloguj się"},analysis:{new_analysis:"Nowa analiza",continue_analysis:"Kontynyuj poprzednie",cation_analysis:"Analiza kationów",anion_analysis:"Analiza anionów",enter_analysis_name:"Nazwa nowej analizy",analysis_begin:"Rozpocznij analizę",propability:"Mogą wystąpić: ",webcam_detection:"Wykryj automatycznie",anion_identification:"Identyfikacja kationu",cation_identification:"Identyfikacja kationu",analysis_name:"Nazwa analizy: ",analysis_progress:"Postęp analizy:",fake_analysis:"Test",choose_img:"Wybierz zdjęcie: ",test_image:"TESTOWE ZDJĘCIA",end_analysis:"Analiza została zakończona",wrong_result:"Taki wynik nie powinien się pojawić na tym etapie analizy.",end_of_analysis:"Analiza zakączona powodzeniem!",ion_found:"Znaleziony jon: ",chat_name:"Chat",default_message:"Brak wiadomości"},database_buttons:{ion_analysis:"Analizy jonów",dataflow:"Baza wiedzy",anion:"Aniony -",cation:"Kationy +",voicescript:"Skrypty głosowe",images:"Zdjęcia",img_1:"Testowe",img_2:"Bank zdjęć",img_3:"Rozpoznawanie twarzy",chat:"Wiadomości czatu",users:"Użytkownicy",ph:"Analizy pH"},databse:{clear_all_bt:"Usuń wszystkie",remove_bt:"Usuń",mod_bt:"Mod",entry_modification:"Modyfikacja wersetu nr: ",anion_analisys:"Analizy anionów",cation_analysis:"Analizy kationów",anion_scriptflow:"Baza wiedzy anionów",cation_scriptflow:"Baza wiedzy kationów",anion_voicescript:"Skrypt głosowy Anionów",cation_voicescript:"Skrypt głosowy Kationów",update_data:"Zmień",add_new:"Dodaj nowy",submit_bt:"Prześlij dane",all_data_del_confirm:"Na pewno chcesz usunąć całą historię?"},ph:{new_calibrations:"Nowa kalibracja",prevoius_calibrations:"Wcześniejsze kalibracje",saved_cal:"Zapisane kalibracje: ",cal_name:"Nazwa nowej kalibracji pH: ",cal_begin:"Rozpocznij",take_screenshot:"Pobierz próbkę zdjęcia",preview:"Podgląd: ",result:"Wynik: ",ph_table:"Tabela wartości pH:",p_value:"Wprowadź wartość pH",file_from_device:"Udostępnij z urządzenia"},face_recognition:{start_scan:"Wykonaj skan twarzy",open_webcam:"Włącz kamerę",close_webcam:"Zamknij kamerę",age:"Wiek: ",gender:"Płeć: ",expression:"Nastrój: "},about_page:{text_1:"AnalysisAI to aplikacja SPA, która pomaga w analizie chemicznej i pozwala lepiej zarządzać laboratorium. Wykorzystuje autorskie algorytmy wykrywania i klasyfikacji obrazów do rozróżniania wyników analizy chemicznej.",text_2:"Główna funkcjonalnośc to asystent głosowy który przeprowadzi cie poprzez etapy analizy chemicznej. Wszystko co potrzebujesz w jednym miejscu. Postępy w analizie są automatycznie zapisywane w bazie danych dzięki czemu zawsze możesz wrócić i ponownie prześledzić proces. Gdy przerwiesz analizę możesz wznowić ją w dowolnym momencie.",text_3:"Możesz zautomatyzować porównywanie wyników testów pH uzyskanych za pomocą pasków wskaźnikowych.",text_4:"System logowania wspiera rozpoznawanie twarzy, dzięki czemu możesz zalogować się do serwisu tylko za pomocą skanowania twarzy."},welcome_page:{text_1:"Zacznijmy!",text_2:"Aby rozpocząć analizę chemiczną jonów w roztworach, wybierz przycisk Analiza jonów w górnym pasku.",text_3:"Wybierz Analiza pH, aby rozpocząć porównywanie skali kwasowości i zasadowości roztworów wodnych."},user_profile:{data_header:"Informacje o koncie:",image_header:"Zdjęcie twarzy:",username:"Nazwa użytkownika:",first_name:"Imię:",last_name:"Nazwisko:",emial:"Email:",phone:"Telefon:",auth:"Authcode:",password:"Hasło:",date:"Data rejestracji:",accout_type:"Typ konta"},analysis_results_names:{zolty_p:"żółty płyn",fioletowy_p:"fioletowy płyn",pomaranczowy_p:"pomarańczowy płyn",cielisty:"sielisty osad",nieb_rozowy:"nieb-różowy osad",niebieski:"niebieski osad",zielony:"zielony osad",pomaranczowy:"pomarańczowy osad",zolty:"żółty osad",czarny:"czarny osad",bialy:"biały osad",brak:"brak osadu"},user_settings:{lang_btn:"Język",apperance_btn:"Wygląd",lang_header:"Wybierz język:",apperance_header:"Opcje wyglądu:",EN_btn:"ANGIELSKI",PL_btn:"POLSKI"},user_help:{system_info:"Więcej informacji dotyczących funkcjonalności i budowy systemu: ",model_info:"Informacje na temat użytych modeli: "},user_faceid:{menu_btn:"Aktualne skany  ",no_scan_btn:" Utwórz nowy skan ",no_scan_text:"Brak Face ID",scan_exist_btn:"Zmień skan",scan_exist_text:"Data ostatniego skanu: "}},fn=e=>e=="PL"?xce:bce,wce=({lang:e})=>{const t=fn(e),n=new Date().getFullYear();return K(vce,{children:[K(kce,{children:["© ",n," ",t.common.companyName]}),K(Ice,{children:[D(VW,{href:un.GITHUB_URL,target:"_blank",children:t.components.footer.github}),D(VW,{href:un.MODELS_URL,target:"_blank",children:t.components.footer.models})]})]})},vce=pe.div.withConfig({displayName:"FooterContainer",componentId:"sc-12euney-0"})(["padding:0 15px;margin:5px;display:flex;flex-direction:row;align-items:center;justify-content:space-between;position:absolute;top:95%;z-index:400;width:100%;"]),kce=pe.div.withConfig({displayName:"CodemaskContainer",componentId:"sc-12euney-1"})(["display:flex;flex-direction:row;align-items:center;color:",";"],({theme:e})=>e.colors.typography),Ice=pe.div.withConfig({displayName:"LinkContainer",componentId:"sc-12euney-2"})([""]),VW=pe.a.withConfig({displayName:"Link",componentId:"sc-12euney-3"})(["color:",";text-decoration:underline;cursor:pointer;padding:0 10px"],({theme:e})=>e.colors.typography),Sce=({lang:e})=>{const t=fn(e);return K(Nce,{children:[K(GW,{children:[D("h1",{children:t.welcome_page.text_1}),D(UW,{children:t.welcome_page.text_2}),D(UW,{children:t.welcome_page.text_3})]}),D(GW,{children:D(Cce,{src:un.PROBE_GALAXY_URL})})]})},UW=pe.h2.withConfig({displayName:"H2s",componentId:"sc-suo3mt-0"})(["width:40%;"]),Cce=pe.img.withConfig({displayName:"Imagee",componentId:"sc-suo3mt-1"})(["border-radius:10px;"]),Nce=pe.div.withConfig({displayName:"ContainerMain",componentId:"sc-suo3mt-2"})(["position:absolute;width:90%;top:20%;display:flex;flex-direction:row;align-items:center;justify-content:center;border:1px solid;border-color:rgba(255,255,255,.15);background-color:#161b22;"]),GW=pe.div.withConfig({displayName:"Container",componentId:"sc-suo3mt-3"})(["display:flex;flex-direction:column;align-items:center;justify-content:center;border:1px solid;border-color:rgba(255,255,255,.15);background-color:#161b22;"]),$ce=({choosenWeb:e,insideChoice:t,language:n})=>{const[r,s]=J.useState("EN"),a=fn(r),i=()=>K("div",{className:"dropdown",children:[r,K("div",{style:{width:"20px"},className:"dropdown-content-user",children:[D(jW,{style:{display:r=="EN"?"none":"block"},onClick:()=>{n("EN"),s("EN")},children:a.supported_languages.en}),D(jW,{style:{display:r=="EN"?"block":"none"},onClick:()=>{n("PL"),s("PL")},children:a.supported_languages.pl})]})]});return K(Tce,{children:[K(_ce,{onClick:()=>{t("Start")},children:[D(ZT,{children:D(Ece,{children:a.components.header.title})}),D("img",{onClick:()=>{e({result:"Login"})},src:un.LOGO_URL,alt:"",height:25,width:25})]}),D(HW,{children:K(Ue,{style:{background:"transparent"},onClick:()=>{t("AboutPage")},children:[" ",a.start_page.button_about," "]})}),K(HW,{children:[K(ZT,{onClick:()=>{t("Login")},children:["  ",a.start_page.button_sign_in]}),D(ZT,{onClick:()=>{t("Register")},children:a.start_page.button_sign_up}),D(Ace,{children:D(i,{})})]})]})},Tce=pe.div.withConfig({displayName:"HeaderContainer",componentId:"sc-68yuu5-0"})(["padding:0 15px;margin:5px;display:flex;flex-direction:row;align-items:center;justify-content:space-between;position:absolute;z-index:4;width:100%;"]),_ce=pe.div.withConfig({displayName:"LogoContainer",componentId:"sc-68yuu5-1"})(["display:flex;flex-direction:row;align-items:center;"]),Ece=pe.h1.withConfig({displayName:"Title",componentId:"sc-68yuu5-2"})(["display:inline;font-size:20px;color:",";"],({theme:e})=>e.colors.typography),HW=pe.div.withConfig({displayName:"LinkContainer",componentId:"sc-68yuu5-3"})(["display:flex;flex-direction:row;justify-content:center;"]),ZT=pe.a.withConfig({displayName:"Linkos",componentId:"sc-68yuu5-4"})(["color:",";text-decoration:underline;cursor:pointer;padding:0 10px;text-decoration:none;:hover{text-decoration:underline};font-size:large;display:flex;flex-direction:row;align-items:center;"],({theme:e})=>e.colors.typography),Ace=pe.div.withConfig({displayName:"Linkoss",componentId:"sc-68yuu5-5"})(["color:",";text-decoration:underline;cursor:pointer;padding:0 10px;text-decoration:none;:hover{text-decoration:underline};font-size:large;display:flex;flex-direction:row;align-items:center;"],({theme:e})=>e.colors.typography),jW=pe.div.withConfig({displayName:"Clk",componentId:"sc-68yuu5-6"})(["width:20px;height:20px;"]);function x6(e,t){return function(){return e.apply(t,arguments)}}const{toString:w6}=Object.prototype,{getPrototypeOf:vF}=Object,kF=(e=>t=>{const n=w6.call(t);return e[n]||(e[n]=n.slice(8,-1).toLowerCase())})(Object.create(null)),Wu=e=>(e=e.toLowerCase(),t=>kF(t)===e),WC=e=>t=>typeof t===e,{isArray:Zg}=Array,d0=WC("undefined");function Rce(e){return e!==null&&!d0(e)&&e.constructor!==null&&!d0(e.constructor)&&Vc(e.constructor.isBuffer)&&e.constructor.isBuffer(e)}const v6=Wu("ArrayBuffer");function Dce(e){let t;return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?t=ArrayBuffer.isView(e):t=e&&e.buffer&&v6(e.buffer),t}const Fce=WC("string"),Vc=WC("function"),k6=WC("number"),IF=e=>e!==null&&typeof e=="object",Oce=e=>e===!0||e===!1,nI=e=>{if(kF(e)!=="object")return!1;const t=vF(e);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)},Mce=Wu("Date"),Lce=Wu("File"),Pce=Wu("Blob"),zce=Wu("FileList"),Bce=e=>IF(e)&&Vc(e.pipe),Wce=e=>{const t="[object FormData]";return e&&(typeof FormData=="function"&&e instanceof FormData||w6.call(e)===t||Vc(e.toString)&&e.toString()===t)},Vce=Wu("URLSearchParams"),Uce=e=>e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");function J0(e,t,{allOwnKeys:n=!1}={}){if(e===null||typeof e>"u")return;let r,s;if(typeof e!="object"&&(e=[e]),Zg(e))for(r=0,s=e.length;r<s;r++)t.call(null,e[r],r,e);else{const a=n?Object.getOwnPropertyNames(e):Object.keys(e),i=a.length;let o;for(r=0;r<i;r++)o=a[r],t.call(null,e[o],o,e)}}function I6(e,t){t=t.toLowerCase();const n=Object.keys(e);let r=n.length,s;for(;r-- >0;)if(s=n[r],t===s.toLowerCase())return s;return null}const S6=(()=>typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:global)(),C6=e=>!d0(e)&&e!==S6;function ZE(){const{caseless:e}=C6(this)&&this||{},t={},n=(r,s)=>{const a=e&&I6(t,s)||s;nI(t[a])&&nI(r)?t[a]=ZE(t[a],r):nI(r)?t[a]=ZE({},r):Zg(r)?t[a]=r.slice():t[a]=r};for(let r=0,s=arguments.length;r<s;r++)arguments[r]&&J0(arguments[r],n);return t}const Gce=(e,t,n,{allOwnKeys:r}={})=>(J0(t,(s,a)=>{n&&Vc(s)?e[a]=x6(s,n):e[a]=s},{allOwnKeys:r}),e),Hce=e=>(e.charCodeAt(0)===65279&&(e=e.slice(1)),e),jce=(e,t,n,r)=>{e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},qce=(e,t,n,r)=>{let s,a,i;const o={};if(t=t||{},e==null)return t;do{for(s=Object.getOwnPropertyNames(e),a=s.length;a-- >0;)i=s[a],(!r||r(i,e,t))&&!o[i]&&(t[i]=e[i],o[i]=!0);e=n!==!1&&vF(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},Kce=(e,t,n)=>{e=String(e),(n===void 0||n>e.length)&&(n=e.length),n-=t.length;const r=e.indexOf(t,n);return r!==-1&&r===n},Xce=e=>{if(!e)return null;if(Zg(e))return e;let t=e.length;if(!k6(t))return null;const n=new Array(t);for(;t-- >0;)n[t]=e[t];return n},Yce=(e=>t=>e&&t instanceof e)(typeof Uint8Array<"u"&&vF(Uint8Array)),Zce=(e,t)=>{const r=(e&&e[Symbol.iterator]).call(e);let s;for(;(s=r.next())&&!s.done;){const a=s.value;t.call(e,a[0],a[1])}},Jce=(e,t)=>{let n;const r=[];for(;(n=e.exec(t))!==null;)r.push(n);return r},Qce=Wu("HTMLFormElement"),ede=e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,function(n,r,s){return r.toUpperCase()+s}),qW=(({hasOwnProperty:e})=>(t,n)=>e.call(t,n))(Object.prototype),tde=Wu("RegExp"),N6=(e,t)=>{const n=Object.getOwnPropertyDescriptors(e),r={};J0(n,(s,a)=>{t(s,a,e)!==!1&&(r[a]=s)}),Object.defineProperties(e,r)},nde=e=>{N6(e,(t,n)=>{if(Vc(e)&&["arguments","caller","callee"].indexOf(n)!==-1)return!1;const r=e[n];if(Vc(r)){if(t.enumerable=!1,"writable"in t){t.writable=!1;return}t.set||(t.set=()=>{throw Error("Can not rewrite read-only method '"+n+"'")})}})},rde=(e,t)=>{const n={},r=s=>{s.forEach(a=>{n[a]=!0})};return Zg(e)?r(e):r(String(e).split(t)),n},sde=()=>{},ade=(e,t)=>(e=+e,Number.isFinite(e)?e:t),JT="abcdefghijklmnopqrstuvwxyz",KW="0123456789",$6={DIGIT:KW,ALPHA:JT,ALPHA_DIGIT:JT+JT.toUpperCase()+KW},ide=(e=16,t=$6.ALPHA_DIGIT)=>{let n="";const{length:r}=t;for(;e--;)n+=t[Math.random()*r|0];return n};function ode(e){return!!(e&&Vc(e.append)&&e[Symbol.toStringTag]==="FormData"&&e[Symbol.iterator])}const lde=e=>{const t=new Array(10),n=(r,s)=>{if(IF(r)){if(t.indexOf(r)>=0)return;if(!("toJSON"in r)){t[s]=r;const a=Zg(r)?[]:{};return J0(r,(i,o)=>{const l=n(i,s+1);!d0(l)&&(a[o]=l)}),t[s]=void 0,a}}return r};return n(e,0)},Te={isArray:Zg,isArrayBuffer:v6,isBuffer:Rce,isFormData:Wce,isArrayBufferView:Dce,isString:Fce,isNumber:k6,isBoolean:Oce,isObject:IF,isPlainObject:nI,isUndefined:d0,isDate:Mce,isFile:Lce,isBlob:Pce,isRegExp:tde,isFunction:Vc,isStream:Bce,isURLSearchParams:Vce,isTypedArray:Yce,isFileList:zce,forEach:J0,merge:ZE,extend:Gce,trim:Uce,stripBOM:Hce,inherits:jce,toFlatObject:qce,kindOf:kF,kindOfTest:Wu,endsWith:Kce,toArray:Xce,forEachEntry:Zce,matchAll:Jce,isHTMLForm:Qce,hasOwnProperty:qW,hasOwnProp:qW,reduceDescriptors:N6,freezeMethods:nde,toObjectSet:rde,toCamelCase:ede,noop:sde,toFiniteNumber:ade,findKey:I6,global:S6,isContextDefined:C6,ALPHABET:$6,generateString:ide,isSpecCompliantForm:ode,toJSONObject:lde};function ln(e,t,n,r,s){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack,this.message=e,this.name="AxiosError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),s&&(this.response=s)}Te.inherits(ln,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:Te.toJSONObject(this.config),code:this.code,status:this.response&&this.response.status?this.response.status:null}}});const T6=ln.prototype,_6={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach(e=>{_6[e]={value:e}});Object.defineProperties(ln,_6);Object.defineProperty(T6,"isAxiosError",{value:!0});ln.from=(e,t,n,r,s,a)=>{const i=Object.create(T6);return Te.toFlatObject(e,i,function(l){return l!==Error.prototype},o=>o!=="isAxiosError"),ln.call(i,e.message,t,n,r,s),i.cause=e,i.name=e.name,a&&Object.assign(i,a),i};const ude=null;function JE(e){return Te.isPlainObject(e)||Te.isArray(e)}function E6(e){return Te.endsWith(e,"[]")?e.slice(0,-2):e}function XW(e,t,n){return e?e.concat(t).map(function(s,a){return s=E6(s),!n&&a?"["+s+"]":s}).join(n?".":""):t}function cde(e){return Te.isArray(e)&&!e.some(JE)}const dde=Te.toFlatObject(Te,{},null,function(t){return/^is[A-Z]/.test(t)});function VC(e,t,n){if(!Te.isObject(e))throw new TypeError("target must be an object");t=t||new FormData,n=Te.toFlatObject(n,{metaTokens:!0,dots:!1,indexes:!1},!1,function(m,g){return!Te.isUndefined(g[m])});const r=n.metaTokens,s=n.visitor||c,a=n.dots,i=n.indexes,l=(n.Blob||typeof Blob<"u"&&Blob)&&Te.isSpecCompliantForm(t);if(!Te.isFunction(s))throw new TypeError("visitor must be a function");function u(f){if(f===null)return"";if(Te.isDate(f))return f.toISOString();if(!l&&Te.isBlob(f))throw new ln("Blob is not supported. Use a Buffer instead.");return Te.isArrayBuffer(f)||Te.isTypedArray(f)?l&&typeof Blob=="function"?new Blob([f]):Buffer.from(f):f}function c(f,m,g){let y=f;if(f&&!g&&typeof f=="object"){if(Te.endsWith(m,"{}"))m=r?m:m.slice(0,-2),f=JSON.stringify(f);else if(Te.isArray(f)&&cde(f)||(Te.isFileList(f)||Te.endsWith(m,"[]"))&&(y=Te.toArray(f)))return m=E6(m),y.forEach(function(x,w){!(Te.isUndefined(x)||x===null)&&t.append(i===!0?XW([m],w,a):i===null?m:m+"[]",u(x))}),!1}return JE(f)?!0:(t.append(XW(g,m,a),u(f)),!1)}const d=[],h=Object.assign(dde,{defaultVisitor:c,convertValue:u,isVisitable:JE});function p(f,m){if(!Te.isUndefined(f)){if(d.indexOf(f)!==-1)throw Error("Circular reference detected in "+m.join("."));d.push(f),Te.forEach(f,function(y,b){(!(Te.isUndefined(y)||y===null)&&s.call(t,y,Te.isString(b)?b.trim():b,m,h))===!0&&p(y,m?m.concat(b):[b])}),d.pop()}}if(!Te.isObject(e))throw new TypeError("data must be an object");return p(e),t}function YW(e){const t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,function(r){return t[r]})}function SF(e,t){this._pairs=[],e&&VC(e,this,t)}const A6=SF.prototype;A6.append=function(t,n){this._pairs.push([t,n])};A6.toString=function(t){const n=t?function(r){return t.call(this,r,YW)}:YW;return this._pairs.map(function(s){return n(s[0])+"="+n(s[1])},"").join("&")};function hde(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function R6(e,t,n){if(!t)return e;const r=n&&n.encode||hde,s=n&&n.serialize;let a;if(s?a=s(t,n):a=Te.isURLSearchParams(t)?t.toString():new SF(t,n).toString(r),a){const i=e.indexOf("#");i!==-1&&(e=e.slice(0,i)),e+=(e.indexOf("?")===-1?"?":"&")+a}return e}class pde{constructor(){this.handlers=[]}use(t,n,r){return this.handlers.push({fulfilled:t,rejected:n,synchronous:r?r.synchronous:!1,runWhen:r?r.runWhen:null}),this.handlers.length-1}eject(t){this.handlers[t]&&(this.handlers[t]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(t){Te.forEach(this.handlers,function(r){r!==null&&t(r)})}}const ZW=pde,D6={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},fde=typeof URLSearchParams<"u"?URLSearchParams:SF,mde=typeof FormData<"u"?FormData:null,gde=typeof Blob<"u"?Blob:null,yde=(()=>{let e;return typeof navigator<"u"&&((e=navigator.product)==="ReactNative"||e==="NativeScript"||e==="NS")?!1:typeof window<"u"&&typeof document<"u"})(),bde=(()=>typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&typeof self.importScripts=="function")(),Tl={isBrowser:!0,classes:{URLSearchParams:fde,FormData:mde,Blob:gde},isStandardBrowserEnv:yde,isStandardBrowserWebWorkerEnv:bde,protocols:["http","https","file","blob","url","data"]};function xde(e,t){return VC(e,new Tl.classes.URLSearchParams,Object.assign({visitor:function(n,r,s,a){return Tl.isNode&&Te.isBuffer(n)?(this.append(r,n.toString("base64")),!1):a.defaultVisitor.apply(this,arguments)}},t))}function wde(e){return Te.matchAll(/\w+|\[(\w*)]/g,e).map(t=>t[0]==="[]"?"":t[1]||t[0])}function vde(e){const t={},n=Object.keys(e);let r;const s=n.length;let a;for(r=0;r<s;r++)a=n[r],t[a]=e[a];return t}function F6(e){function t(n,r,s,a){let i=n[a++];const o=Number.isFinite(+i),l=a>=n.length;return i=!i&&Te.isArray(s)?s.length:i,l?(Te.hasOwnProp(s,i)?s[i]=[s[i],r]:s[i]=r,!o):((!s[i]||!Te.isObject(s[i]))&&(s[i]=[]),t(n,r,s[i],a)&&Te.isArray(s[i])&&(s[i]=vde(s[i])),!o)}if(Te.isFormData(e)&&Te.isFunction(e.entries)){const n={};return Te.forEachEntry(e,(r,s)=>{t(wde(r),s,n,0)}),n}return null}const kde={"Content-Type":void 0};function Ide(e,t,n){if(Te.isString(e))try{return(t||JSON.parse)(e),Te.trim(e)}catch(r){if(r.name!=="SyntaxError")throw r}return(n||JSON.stringify)(e)}const UC={transitional:D6,adapter:["xhr","http"],transformRequest:[function(t,n){const r=n.getContentType()||"",s=r.indexOf("application/json")>-1,a=Te.isObject(t);if(a&&Te.isHTMLForm(t)&&(t=new FormData(t)),Te.isFormData(t))return s&&s?JSON.stringify(F6(t)):t;if(Te.isArrayBuffer(t)||Te.isBuffer(t)||Te.isStream(t)||Te.isFile(t)||Te.isBlob(t))return t;if(Te.isArrayBufferView(t))return t.buffer;if(Te.isURLSearchParams(t))return n.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),t.toString();let o;if(a){if(r.indexOf("application/x-www-form-urlencoded")>-1)return xde(t,this.formSerializer).toString();if((o=Te.isFileList(t))||r.indexOf("multipart/form-data")>-1){const l=this.env&&this.env.FormData;return VC(o?{"files[]":t}:t,l&&new l,this.formSerializer)}}return a||s?(n.setContentType("application/json",!1),Ide(t)):t}],transformResponse:[function(t){const n=this.transitional||UC.transitional,r=n&&n.forcedJSONParsing,s=this.responseType==="json";if(t&&Te.isString(t)&&(r&&!this.responseType||s)){const i=!(n&&n.silentJSONParsing)&&s;try{return JSON.parse(t)}catch(o){if(i)throw o.name==="SyntaxError"?ln.from(o,ln.ERR_BAD_RESPONSE,this,null,this.response):o}}return t}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:Tl.classes.FormData,Blob:Tl.classes.Blob},validateStatus:function(t){return t>=200&&t<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};Te.forEach(["delete","get","head"],function(t){UC.headers[t]={}});Te.forEach(["post","put","patch"],function(t){UC.headers[t]=Te.merge(kde)});const CF=UC,Sde=Te.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),Cde=e=>{const t={};let n,r,s;return e&&e.split(`
`).forEach(function(i){s=i.indexOf(":"),n=i.substring(0,s).trim().toLowerCase(),r=i.substring(s+1).trim(),!(!n||t[n]&&Sde[n])&&(n==="set-cookie"?t[n]?t[n].push(r):t[n]=[r]:t[n]=t[n]?t[n]+", "+r:r)}),t},JW=Symbol("internals");function Jb(e){return e&&String(e).trim().toLowerCase()}function rI(e){return e===!1||e==null?e:Te.isArray(e)?e.map(rI):String(e)}function Nde(e){const t=Object.create(null),n=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let r;for(;r=n.exec(e);)t[r[1]]=r[2];return t}function $de(e){return/^[-_a-zA-Z]+$/.test(e.trim())}function QT(e,t,n,r,s){if(Te.isFunction(r))return r.call(this,t,n);if(s&&(t=n),!!Te.isString(t)){if(Te.isString(r))return t.indexOf(r)!==-1;if(Te.isRegExp(r))return r.test(t)}}function Tde(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(t,n,r)=>n.toUpperCase()+r)}function _de(e,t){const n=Te.toCamelCase(" "+t);["get","set","has"].forEach(r=>{Object.defineProperty(e,r+n,{value:function(s,a,i){return this[r].call(this,t,s,a,i)},configurable:!0})})}class GC{constructor(t){t&&this.set(t)}set(t,n,r){const s=this;function a(o,l,u){const c=Jb(l);if(!c)throw new Error("header name must be a non-empty string");const d=Te.findKey(s,c);(!d||s[d]===void 0||u===!0||u===void 0&&s[d]!==!1)&&(s[d||l]=rI(o))}const i=(o,l)=>Te.forEach(o,(u,c)=>a(u,c,l));return Te.isPlainObject(t)||t instanceof this.constructor?i(t,n):Te.isString(t)&&(t=t.trim())&&!$de(t)?i(Cde(t),n):t!=null&&a(n,t,r),this}get(t,n){if(t=Jb(t),t){const r=Te.findKey(this,t);if(r){const s=this[r];if(!n)return s;if(n===!0)return Nde(s);if(Te.isFunction(n))return n.call(this,s,r);if(Te.isRegExp(n))return n.exec(s);throw new TypeError("parser must be boolean|regexp|function")}}}has(t,n){if(t=Jb(t),t){const r=Te.findKey(this,t);return!!(r&&this[r]!==void 0&&(!n||QT(this,this[r],r,n)))}return!1}delete(t,n){const r=this;let s=!1;function a(i){if(i=Jb(i),i){const o=Te.findKey(r,i);o&&(!n||QT(r,r[o],o,n))&&(delete r[o],s=!0)}}return Te.isArray(t)?t.forEach(a):a(t),s}clear(t){const n=Object.keys(this);let r=n.length,s=!1;for(;r--;){const a=n[r];(!t||QT(this,this[a],a,t,!0))&&(delete this[a],s=!0)}return s}normalize(t){const n=this,r={};return Te.forEach(this,(s,a)=>{const i=Te.findKey(r,a);if(i){n[i]=rI(s),delete n[a];return}const o=t?Tde(a):String(a).trim();o!==a&&delete n[a],n[o]=rI(s),r[o]=!0}),this}concat(...t){return this.constructor.concat(this,...t)}toJSON(t){const n=Object.create(null);return Te.forEach(this,(r,s)=>{r!=null&&r!==!1&&(n[s]=t&&Te.isArray(r)?r.join(", "):r)}),n}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map(([t,n])=>t+": "+n).join(`
`)}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(t){return t instanceof this?t:new this(t)}static concat(t,...n){const r=new this(t);return n.forEach(s=>r.set(s)),r}static accessor(t){const r=(this[JW]=this[JW]={accessors:{}}).accessors,s=this.prototype;function a(i){const o=Jb(i);r[o]||(_de(s,i),r[o]=!0)}return Te.isArray(t)?t.forEach(a):a(t),this}}GC.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]);Te.freezeMethods(GC.prototype);Te.freezeMethods(GC);const Su=GC;function e_(e,t){const n=this||CF,r=t||n,s=Su.from(r.headers);let a=r.data;return Te.forEach(e,function(o){a=o.call(n,a,s.normalize(),t?t.status:void 0)}),s.normalize(),a}function O6(e){return!!(e&&e.__CANCEL__)}function Q0(e,t,n){ln.call(this,e??"canceled",ln.ERR_CANCELED,t,n),this.name="CanceledError"}Te.inherits(Q0,ln,{__CANCEL__:!0});function Ede(e,t,n){const r=n.config.validateStatus;!n.status||!r||r(n.status)?e(n):t(new ln("Request failed with status code "+n.status,[ln.ERR_BAD_REQUEST,ln.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n))}const Ade=Tl.isStandardBrowserEnv?function(){return{write:function(n,r,s,a,i,o){const l=[];l.push(n+"="+encodeURIComponent(r)),Te.isNumber(s)&&l.push("expires="+new Date(s).toGMTString()),Te.isString(a)&&l.push("path="+a),Te.isString(i)&&l.push("domain="+i),o===!0&&l.push("secure"),document.cookie=l.join("; ")},read:function(n){const r=document.cookie.match(new RegExp("(^|;\\s*)("+n+")=([^;]*)"));return r?decodeURIComponent(r[3]):null},remove:function(n){this.write(n,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}();function Rde(e){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)}function Dde(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e}function M6(e,t){return e&&!Rde(t)?Dde(e,t):t}const Fde=Tl.isStandardBrowserEnv?function(){const t=/(msie|trident)/i.test(navigator.userAgent),n=document.createElement("a");let r;function s(a){let i=a;return t&&(n.setAttribute("href",i),i=n.href),n.setAttribute("href",i),{href:n.href,protocol:n.protocol?n.protocol.replace(/:$/,""):"",host:n.host,search:n.search?n.search.replace(/^\?/,""):"",hash:n.hash?n.hash.replace(/^#/,""):"",hostname:n.hostname,port:n.port,pathname:n.pathname.charAt(0)==="/"?n.pathname:"/"+n.pathname}}return r=s(window.location.href),function(i){const o=Te.isString(i)?s(i):i;return o.protocol===r.protocol&&o.host===r.host}}():function(){return function(){return!0}}();function Ode(e){const t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}function Mde(e,t){e=e||10;const n=new Array(e),r=new Array(e);let s=0,a=0,i;return t=t!==void 0?t:1e3,function(l){const u=Date.now(),c=r[a];i||(i=u),n[s]=l,r[s]=u;let d=a,h=0;for(;d!==s;)h+=n[d++],d=d%e;if(s=(s+1)%e,s===a&&(a=(a+1)%e),u-i<t)return;const p=c&&u-c;return p?Math.round(h*1e3/p):void 0}}function QW(e,t){let n=0;const r=Mde(50,250);return s=>{const a=s.loaded,i=s.lengthComputable?s.total:void 0,o=a-n,l=r(o),u=a<=i;n=a;const c={loaded:a,total:i,progress:i?a/i:void 0,bytes:o,rate:l||void 0,estimated:l&&i&&u?(i-a)/l:void 0,event:s};c[t?"download":"upload"]=!0,e(c)}}const Lde=typeof XMLHttpRequest<"u",Pde=Lde&&function(e){return new Promise(function(n,r){let s=e.data;const a=Su.from(e.headers).normalize(),i=e.responseType;let o;function l(){e.cancelToken&&e.cancelToken.unsubscribe(o),e.signal&&e.signal.removeEventListener("abort",o)}Te.isFormData(s)&&(Tl.isStandardBrowserEnv||Tl.isStandardBrowserWebWorkerEnv)&&a.setContentType(!1);let u=new XMLHttpRequest;if(e.auth){const p=e.auth.username||"",f=e.auth.password?unescape(encodeURIComponent(e.auth.password)):"";a.set("Authorization","Basic "+btoa(p+":"+f))}const c=M6(e.baseURL,e.url);u.open(e.method.toUpperCase(),R6(c,e.params,e.paramsSerializer),!0),u.timeout=e.timeout;function d(){if(!u)return;const p=Su.from("getAllResponseHeaders"in u&&u.getAllResponseHeaders()),m={data:!i||i==="text"||i==="json"?u.responseText:u.response,status:u.status,statusText:u.statusText,headers:p,config:e,request:u};Ede(function(y){n(y),l()},function(y){r(y),l()},m),u=null}if("onloadend"in u?u.onloadend=d:u.onreadystatechange=function(){!u||u.readyState!==4||u.status===0&&!(u.responseURL&&u.responseURL.indexOf("file:")===0)||setTimeout(d)},u.onabort=function(){u&&(r(new ln("Request aborted",ln.ECONNABORTED,e,u)),u=null)},u.onerror=function(){r(new ln("Network Error",ln.ERR_NETWORK,e,u)),u=null},u.ontimeout=function(){let f=e.timeout?"timeout of "+e.timeout+"ms exceeded":"timeout exceeded";const m=e.transitional||D6;e.timeoutErrorMessage&&(f=e.timeoutErrorMessage),r(new ln(f,m.clarifyTimeoutError?ln.ETIMEDOUT:ln.ECONNABORTED,e,u)),u=null},Tl.isStandardBrowserEnv){const p=(e.withCredentials||Fde(c))&&e.xsrfCookieName&&Ade.read(e.xsrfCookieName);p&&a.set(e.xsrfHeaderName,p)}s===void 0&&a.setContentType(null),"setRequestHeader"in u&&Te.forEach(a.toJSON(),function(f,m){u.setRequestHeader(m,f)}),Te.isUndefined(e.withCredentials)||(u.withCredentials=!!e.withCredentials),i&&i!=="json"&&(u.responseType=e.responseType),typeof e.onDownloadProgress=="function"&&u.addEventListener("progress",QW(e.onDownloadProgress,!0)),typeof e.onUploadProgress=="function"&&u.upload&&u.upload.addEventListener("progress",QW(e.onUploadProgress)),(e.cancelToken||e.signal)&&(o=p=>{u&&(r(!p||p.type?new Q0(null,e,u):p),u.abort(),u=null)},e.cancelToken&&e.cancelToken.subscribe(o),e.signal&&(e.signal.aborted?o():e.signal.addEventListener("abort",o)));const h=Ode(c);if(h&&Tl.protocols.indexOf(h)===-1){r(new ln("Unsupported protocol "+h+":",ln.ERR_BAD_REQUEST,e));return}u.send(s||null)})},sI={http:ude,xhr:Pde};Te.forEach(sI,(e,t)=>{if(e){try{Object.defineProperty(e,"name",{value:t})}catch{}Object.defineProperty(e,"adapterName",{value:t})}});const zde={getAdapter:e=>{e=Te.isArray(e)?e:[e];const{length:t}=e;let n,r;for(let s=0;s<t&&(n=e[s],!(r=Te.isString(n)?sI[n.toLowerCase()]:n));s++);if(!r)throw r===!1?new ln(`Adapter ${n} is not supported by the environment`,"ERR_NOT_SUPPORT"):new Error(Te.hasOwnProp(sI,n)?`Adapter '${n}' is not available in the build`:`Unknown adapter '${n}'`);if(!Te.isFunction(r))throw new TypeError("adapter is not a function");return r},adapters:sI};function t_(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new Q0(null,e)}function eV(e){return t_(e),e.headers=Su.from(e.headers),e.data=e_.call(e,e.transformRequest),["post","put","patch"].indexOf(e.method)!==-1&&e.headers.setContentType("application/x-www-form-urlencoded",!1),zde.getAdapter(e.adapter||CF.adapter)(e).then(function(r){return t_(e),r.data=e_.call(e,e.transformResponse,r),r.headers=Su.from(r.headers),r},function(r){return O6(r)||(t_(e),r&&r.response&&(r.response.data=e_.call(e,e.transformResponse,r.response),r.response.headers=Su.from(r.response.headers))),Promise.reject(r)})}const tV=e=>e instanceof Su?e.toJSON():e;function ug(e,t){t=t||{};const n={};function r(u,c,d){return Te.isPlainObject(u)&&Te.isPlainObject(c)?Te.merge.call({caseless:d},u,c):Te.isPlainObject(c)?Te.merge({},c):Te.isArray(c)?c.slice():c}function s(u,c,d){if(Te.isUndefined(c)){if(!Te.isUndefined(u))return r(void 0,u,d)}else return r(u,c,d)}function a(u,c){if(!Te.isUndefined(c))return r(void 0,c)}function i(u,c){if(Te.isUndefined(c)){if(!Te.isUndefined(u))return r(void 0,u)}else return r(void 0,c)}function o(u,c,d){if(d in t)return r(u,c);if(d in e)return r(void 0,u)}const l={url:a,method:a,data:a,baseURL:i,transformRequest:i,transformResponse:i,paramsSerializer:i,timeout:i,timeoutMessage:i,withCredentials:i,adapter:i,responseType:i,xsrfCookieName:i,xsrfHeaderName:i,onUploadProgress:i,onDownloadProgress:i,decompress:i,maxContentLength:i,maxBodyLength:i,beforeRedirect:i,transport:i,httpAgent:i,httpsAgent:i,cancelToken:i,socketPath:i,responseEncoding:i,validateStatus:o,headers:(u,c)=>s(tV(u),tV(c),!0)};return Te.forEach(Object.keys(e).concat(Object.keys(t)),function(c){const d=l[c]||s,h=d(e[c],t[c],c);Te.isUndefined(h)&&d!==o||(n[c]=h)}),n}const L6="1.3.4",NF={};["object","boolean","number","function","string","symbol"].forEach((e,t)=>{NF[e]=function(r){return typeof r===e||"a"+(t<1?"n ":" ")+e}});const nV={};NF.transitional=function(t,n,r){function s(a,i){return"[Axios v"+L6+"] Transitional option '"+a+"'"+i+(r?". "+r:"")}return(a,i,o)=>{if(t===!1)throw new ln(s(i," has been removed"+(n?" in "+n:"")),ln.ERR_DEPRECATED);return n&&!nV[i]&&(nV[i]=!0,console.warn(s(i," has been deprecated since v"+n+" and will be removed in the near future"))),t?t(a,i,o):!0}};function Bde(e,t,n){if(typeof e!="object")throw new ln("options must be an object",ln.ERR_BAD_OPTION_VALUE);const r=Object.keys(e);let s=r.length;for(;s-- >0;){const a=r[s],i=t[a];if(i){const o=e[a],l=o===void 0||i(o,a,e);if(l!==!0)throw new ln("option "+a+" must be "+l,ln.ERR_BAD_OPTION_VALUE);continue}if(n!==!0)throw new ln("Unknown option "+a,ln.ERR_BAD_OPTION)}}const QE={assertOptions:Bde,validators:NF},ec=QE.validators;let qI=class{constructor(t){this.defaults=t,this.interceptors={request:new ZW,response:new ZW}}request(t,n){typeof t=="string"?(n=n||{},n.url=t):n=t||{},n=ug(this.defaults,n);const{transitional:r,paramsSerializer:s,headers:a}=n;r!==void 0&&QE.assertOptions(r,{silentJSONParsing:ec.transitional(ec.boolean),forcedJSONParsing:ec.transitional(ec.boolean),clarifyTimeoutError:ec.transitional(ec.boolean)},!1),s!==void 0&&QE.assertOptions(s,{encode:ec.function,serialize:ec.function},!0),n.method=(n.method||this.defaults.method||"get").toLowerCase();let i;i=a&&Te.merge(a.common,a[n.method]),i&&Te.forEach(["delete","get","head","post","put","patch","common"],f=>{delete a[f]}),n.headers=Su.concat(i,a);const o=[];let l=!0;this.interceptors.request.forEach(function(m){typeof m.runWhen=="function"&&m.runWhen(n)===!1||(l=l&&m.synchronous,o.unshift(m.fulfilled,m.rejected))});const u=[];this.interceptors.response.forEach(function(m){u.push(m.fulfilled,m.rejected)});let c,d=0,h;if(!l){const f=[eV.bind(this),void 0];for(f.unshift.apply(f,o),f.push.apply(f,u),h=f.length,c=Promise.resolve(n);d<h;)c=c.then(f[d++],f[d++]);return c}h=o.length;let p=n;for(d=0;d<h;){const f=o[d++],m=o[d++];try{p=f(p)}catch(g){m.call(this,g);break}}try{c=eV.call(this,p)}catch(f){return Promise.reject(f)}for(d=0,h=u.length;d<h;)c=c.then(u[d++],u[d++]);return c}getUri(t){t=ug(this.defaults,t);const n=M6(t.baseURL,t.url);return R6(n,t.params,t.paramsSerializer)}};Te.forEach(["delete","get","head","options"],function(t){qI.prototype[t]=function(n,r){return this.request(ug(r||{},{method:t,url:n,data:(r||{}).data}))}});Te.forEach(["post","put","patch"],function(t){function n(r){return function(a,i,o){return this.request(ug(o||{},{method:t,headers:r?{"Content-Type":"multipart/form-data"}:{},url:a,data:i}))}}qI.prototype[t]=n(),qI.prototype[t+"Form"]=n(!0)});const aI=qI;class $F{constructor(t){if(typeof t!="function")throw new TypeError("executor must be a function.");let n;this.promise=new Promise(function(a){n=a});const r=this;this.promise.then(s=>{if(!r._listeners)return;let a=r._listeners.length;for(;a-- >0;)r._listeners[a](s);r._listeners=null}),this.promise.then=s=>{let a;const i=new Promise(o=>{r.subscribe(o),a=o}).then(s);return i.cancel=function(){r.unsubscribe(a)},i},t(function(a,i,o){r.reason||(r.reason=new Q0(a,i,o),n(r.reason))})}throwIfRequested(){if(this.reason)throw this.reason}subscribe(t){if(this.reason){t(this.reason);return}this._listeners?this._listeners.push(t):this._listeners=[t]}unsubscribe(t){if(!this._listeners)return;const n=this._listeners.indexOf(t);n!==-1&&this._listeners.splice(n,1)}static source(){let t;return{token:new $F(function(s){t=s}),cancel:t}}}const Wde=$F;function Vde(e){return function(n){return e.apply(null,n)}}function Ude(e){return Te.isObject(e)&&e.isAxiosError===!0}const eA={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(eA).forEach(([e,t])=>{eA[t]=e});const Gde=eA;function P6(e){const t=new aI(e),n=x6(aI.prototype.request,t);return Te.extend(n,aI.prototype,t,{allOwnKeys:!0}),Te.extend(n,t,null,{allOwnKeys:!0}),n.create=function(s){return P6(ug(e,s))},n}const as=P6(CF);as.Axios=aI;as.CanceledError=Q0;as.CancelToken=Wde;as.isCancel=O6;as.VERSION=L6;as.toFormData=VC;as.AxiosError=ln;as.Cancel=as.CanceledError;as.all=function(t){return Promise.all(t)};as.spread=Vde;as.isAxiosError=Ude;as.mergeConfig=ug;as.AxiosHeaders=Su;as.formToJSON=e=>F6(Te.isHTMLForm(e)?new FormData(e):e);as.HttpStatusCode=Gde;as.default=as;const it=as,Ye={cation_script_flow:{get:"http://localhost:4001/api/get/cation_script_flow",post:"http://localhost:4001/api/post/cation_script_flow",put:"http://localhost:4001/api/put/cation_script_flow",delete:"http://localhost:4001/api/delete/cation_script_flow"},anion_script_flow:{get:"http://localhost:4001/api/get/anion_script_flow",post:"http://localhost:4001/api/post/anion_script_flow",put:"http://localhost:4001/api/put/anion_script_flow",delete:"http://localhost:4001/api/delete/anion_script_flow"},cation_voice_script:{get:"http://localhost:4001/api/get/cation_voice_script",post:"http://localhost:4001/api/post/cation_voice_script",put:"http://localhost:4001/api/put/cation_voice_script",delete:"http://localhost:4001/api/delete/cation_voice_script",get_required_script:"http://localhost:4001/api/get/required_cation_voice_script"},cation_voice_script_en:{get:"http://localhost:4001/api/get/cation_voice_script_en",post:"http://localhost:4001/api/post/cation_voice_script_en",put:"http://localhost:4001/api/put/cation_voice_script_en",delete:"http://localhost:4001/api/delete/cation_voice_script_en",get_required_script:"http://localhost:4001/api/get/required_cation_voice_script_en"},anion_voice_script:{get:"http://localhost:4001/api/get/anion_voice_script",post:"http://localhost:4001/api/post/anion_voice_script",put:"http://localhost:4001/api/put/anion_voice_script",delete:"http://localhost:4001/api/delete/anion_voice_script",get_required_script:"http://localhost:4001/api/get/required_anion_voice_script"},anion_voice_script_en:{get:"http://localhost:4001/api/get/anion_voice_script_en",post:"http://localhost:4001/api/post/anion_voice_script_en",put:"http://localhost:4001/api/put/anion_voice_script_en",delete:"http://localhost:4001/api/delete/anion_voice_script_en",get_required_script:"http://localhost:4001/api/get/required_anion_voice_script_en"},cation_analysis_result:{get:"http://localhost:4001/api/get/cation_analysis_result",post:"http://localhost:4001/api/post/cation_analysis_result",put:"http://localhost:4001/api/put/cation_analysis_result",delete:"http://localhost:4001/api/delete/cation_analysis_result",set_end:"http://localhost:4001/api/put/cation_analysis_result/set_end",set_result:"http://localhost:4001/api/put/cation_analysis_result/set_result"},anion_analysis_result:{get:"http://localhost:4001/api/get/anion_analysis_result",post:"http://localhost:4001/api/post/anion_analysis_result",put:"http://localhost:4001/api/put/anion_analysis_result",delete:"http://localhost:4001/api/delete/anion_analysis_result",set_end:"http://localhost:4001/api/put/anion_analysis_result/set_end",set_result:"http://localhost:4001/api/put/anion_analysis_result/set_result"},shuffle_match:{get:"http://localhost:4001/api/get/shuffle",delete:"",post:"",put:""},custom_query:{get:"http://localhost:4001/api/get/custom_query",delete:"",post:"",put:""},test_images:{get:"http://localhost:4001/api/get/test_images",post:"http://localhost:4001/api/post/test_images",put:"http://localhost:4001/api/put/test_images",delete:"http://localhost:4001/api/delete/test_images"},chat_messages:{get_all:"http://localhost:4001/api/get/chat_messages",get_one_conversation:"http://localhost:4001/api/get/chat_messages",post:"http://localhost:4001/api/post/chat_messages",delete:"http://localhost:4001/api/delete/chat_messages",mark_message:"http://localhost:4001/api/put/chat_messages"},image_storage:{get:"http://localhost:4001/api/get/image_storage",post:"http://localhost:4001/api/post/image_storage",put:"http://localhost:4001/api/put/image_storage",delete:"http://localhost:4001/api/delete/image_storage"}},Hde=({result:e,lang:t})=>{const n=fn(t);J.useState(""),J.useState("");const[r,s]=J.useState(""),[a,i]=J.useState(""),[o,l]=J.useState(""),[u,c]=J.useState(""),[d,h]=J.useState(!1),[p,f]=J.useState(""),m=w=>{const{id:v,value:k}=w.target;v==="username"&&s(k),v==="email"&&i(k),v==="password"&&l(k),v==="confirmPassword"&&c(k)},g=async()=>{if(r=="")return f("enterUsername"),null;const w=`select username from account_credentials where username='${r}'`;await it.post(Ye.custom_query.get,{query:w}).then(v=>{if(typeof v.data[0]<"u")v.data[0].username==r&&(f("wrongUsername"),h(!1));else if(o==u){if(o=="")return f("enterPassword"),null;y()}else f("wrongPassword"),h(!1)})},y=async()=>{const w=`INSERT INTO account_credentials (username, password, status, date) VALUES ('${r}','${o}','employee',now()) `;await it.post(Ye.custom_query.get,{query:w}).then(e({result:"Login",userName:r})).catch(v=>{console.log("send status :(",v)})},b=()=>D("div",{style:{display:d?"":"none"},children:K("h1",{children:[n.registration_form.succes_register_1," ",r," ",n.registration_form.succes_register_2]})}),x=()=>K("div",{children:[K("div",{style:{display:p=="wrongPassword"?"":"none"},children:["    ",K("h3",{children:[n.registration_form.warn_pass_not_match," "]}),"   "]}),K("div",{style:{display:p=="wrongUsername"?"":"none"},children:["    ",D("h3",{children:n.registration_form.warn_username_taken}),"   "]}),K("div",{style:{display:p=="enterUsername"?"":"none"},children:["    ",D("h3",{children:n.registration_form.warn_username_empty}),"   "]}),K("div",{style:{display:p=="enterPassword"?"":"none"},children:["    ",D("h3",{children:n.registration_form.warn_pass_empty}),"   "]})]});return D(jde,{className:"form",children:D(vo,{children:K(qde,{children:[D(Ud,{children:D("h1",{children:n.registration_form.header})}),K(Ud,{children:[D("label",{children:n.registration_form.username}),D(am,{style:{borderColor:p=="wrongUsername"?"red":""},type:"text",id:"username",onChange:w=>m(w),placeholder:n.registration_form.username})]}),K(Ud,{children:[D("label",{children:n.registration_form.first_name}),D(am,{type:"text",onChange:w=>m(w),placeholder:"First Name"})]}),K(Ud,{children:[D("label",{children:n.registration_form.last_name}),D(am,{type:"text",name:"",onChange:w=>m(w),placeholder:"LastName"})]}),K(Ud,{children:[D("label",{children:n.registration_form.email}),D(am,{type:"email",id:"email",onChange:w=>m(w),placeholder:"Email"})]}),K(Ud,{children:[K("label",{children:[n.registration_form.password," "]}),D(am,{style:{borderColor:p=="wrongPassword"?"red":""},className:"form__input",type:"password",id:"password",onChange:w=>m(w),placeholder:n.registration_form.password})]}),K(Ud,{children:[K("label",{children:[n.registration_form.confirm_password," "]}),D(am,{style:{borderColor:p=="wrongPassword"?"red":""},className:"form__input",type:"password",id:"confirmPassword",onChange:w=>m(w),placeholder:n.registration_form.confirm_password})]}),x(),b(),D("div",{children:D(Ue,{onClick:()=>g(),type:"submit",children:n.registration_form.button_register})})]})})})},jde=pe.div.withConfig({displayName:"Container",componentId:"sc-fcyexc-0"})(["padding:0 15px;margin:5px;display:flex;flex-direction:column;align-items:center;justify-content:center;position:absolute;top:10%;z-index:4;width:100%;"]),am=pe.input.withConfig({displayName:"Input",componentId:"sc-fcyexc-1"})(["background-color:",";width:60%;color:",";height:30px;::placeholder{color:gray}border-radius:10px;border:1px solid;border-color:rgba(255,255,255,.35);"],({theme:e})=>e.colors.foreground,({theme:e})=>e.colors.typography),qde=pe.div.withConfig({displayName:"TableContainer",componentId:"sc-fcyexc-2"})(["border:1px solid;border-color:rgba(255,255,255,.55);border-radius:10px;justify-content:center;border-radius:5px;width:550px;margin:20px auto;padding:20px;"]),Ud=pe.div.withConfig({displayName:"Cell",componentId:"sc-fcyexc-3"})(["padding:5px;display:flex;flex-direction:row;justify-content:space-between;"]);var tA={},Kde={get exports(){return tA},set exports(e){tA=e}};(function(e,t){(function(r,s){e.exports=s(J)})(mi,function(n){return function(r){var s={};function a(i){if(s[i])return s[i].exports;var o=s[i]={i,l:!1,exports:{}};return r[i].call(o.exports,o,o.exports,a),o.l=!0,o.exports}return a.m=r,a.c=s,a.d=function(i,o,l){a.o(i,o)||Object.defineProperty(i,o,{enumerable:!0,get:l})},a.r=function(i){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})},a.t=function(i,o){if(o&1&&(i=a(i)),o&8||o&4&&typeof i=="object"&&i&&i.__esModule)return i;var l=Object.create(null);if(a.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:i}),o&2&&typeof i!="string")for(var u in i)a.d(l,u,function(c){return i[c]}.bind(null,u));return l},a.n=function(i){var o=i&&i.__esModule?function(){return i.default}:function(){return i};return a.d(o,"a",o),o},a.o=function(i,o){return Object.prototype.hasOwnProperty.call(i,o)},a.p="",a(a.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(r,s,a){a.r(s);var i=a("react"),o=function(){var h=function(p,f){return h=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(m,g){m.__proto__=g}||function(m,g){for(var y in g)g.hasOwnProperty(y)&&(m[y]=g[y])},h(p,f)};return function(p,f){h(p,f);function m(){this.constructor=p}p.prototype=f===null?Object.create(f):(m.prototype=f.prototype,new m)}}(),l=function(){return l=Object.assign||function(h){for(var p,f=1,m=arguments.length;f<m;f++){p=arguments[f];for(var g in p)Object.prototype.hasOwnProperty.call(p,g)&&(h[g]=p[g])}return h},l.apply(this,arguments)},u=function(h,p){var f={};for(var m in h)Object.prototype.hasOwnProperty.call(h,m)&&p.indexOf(m)<0&&(f[m]=h[m]);if(h!=null&&typeof Object.getOwnPropertySymbols=="function")for(var g=0,m=Object.getOwnPropertySymbols(h);g<m.length;g++)p.indexOf(m[g])<0&&Object.prototype.propertyIsEnumerable.call(h,m[g])&&(f[m[g]]=h[m[g]]);return f};(function(){typeof window>"u"||(navigator.mediaDevices===void 0&&(navigator.mediaDevices={}),navigator.mediaDevices.getUserMedia===void 0&&(navigator.mediaDevices.getUserMedia=function(p){var f=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return f?new Promise(function(m,g){f.call(navigator,p,m,g)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}))})();function c(){return!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)}var d=function(h){o(p,h);function p(f){var m=h.call(this,f)||this;return m.canvas=null,m.ctx=null,m.unmounted=!1,m.state={hasUserMedia:!1},m}return p.prototype.componentDidMount=function(){var f=this,m=f.state,g=f.props;if(!c()){g.onUserMediaError("getUserMedia not supported");return}m.hasUserMedia||this.requestUserMedia()},p.prototype.componentDidUpdate=function(f){var m=this.props;if(!c()){m.onUserMediaError("getUserMedia not supported");return}var g=JSON.stringify(f.audioConstraints)!==JSON.stringify(m.audioConstraints),y=JSON.stringify(f.videoConstraints)!==JSON.stringify(m.videoConstraints),b=f.minScreenshotWidth!==m.minScreenshotWidth,x=f.minScreenshotHeight!==m.minScreenshotHeight;(y||b||x)&&(this.canvas=null,this.ctx=null),(g||y)&&(this.stopAndCleanup(),this.requestUserMedia())},p.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},p.stopMediaStream=function(f){f&&(f.getVideoTracks&&f.getAudioTracks?(f.getVideoTracks().map(function(m){f.removeTrack(m),m.stop()}),f.getAudioTracks().map(function(m){f.removeTrack(m),m.stop()})):f.stop())},p.prototype.stopAndCleanup=function(){var f=this.state;f.hasUserMedia&&(p.stopMediaStream(this.stream),f.src&&window.URL.revokeObjectURL(f.src))},p.prototype.getScreenshot=function(f){var m=this,g=m.state,y=m.props;if(!g.hasUserMedia)return null;var b=this.getCanvas(f);return b&&b.toDataURL(y.screenshotFormat,y.screenshotQuality)},p.prototype.getCanvas=function(f){var m=this,g=m.state,y=m.props;if(!this.video||!g.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var b=this.video.videoWidth,x=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var w=b/x;b=y.minScreenshotWidth||this.video.clientWidth,x=b/w,y.minScreenshotHeight&&x<y.minScreenshotHeight&&(x=y.minScreenshotHeight,b=x*w)}this.canvas=document.createElement("canvas"),this.canvas.width=(f==null?void 0:f.width)||b,this.canvas.height=(f==null?void 0:f.height)||x,this.ctx=this.canvas.getContext("2d")}var v=this,k=v.ctx,I=v.canvas;return k&&I&&(y.mirrored&&(k.translate(I.width,0),k.scale(-1,1)),k.imageSmoothingEnabled=y.imageSmoothing,k.drawImage(this.video,0,0,(f==null?void 0:f.width)||I.width,(f==null?void 0:f.height)||I.height),y.mirrored&&(k.scale(-1,1),k.translate(-I.width,0))),I},p.prototype.requestUserMedia=function(){var f=this,m=this.props,g=function(x,w){var v={video:typeof w<"u"?w:!0};m.audio&&(v.audio=typeof x<"u"?x:!0),navigator.mediaDevices.getUserMedia(v).then(function(k){f.unmounted?p.stopMediaStream(k):f.handleUserMedia(null,k)}).catch(function(k){f.handleUserMedia(k)})};if("mediaDevices"in navigator)g(m.audioConstraints,m.videoConstraints);else{var y=function(x){return{optional:[{sourceId:x}]}},b=function(x){var w=x.deviceId;return typeof w=="string"?w:Array.isArray(w)&&w.length>0?w[0]:typeof w=="object"&&w.ideal?w.ideal:null};MediaStreamTrack.getSources(function(x){var w=null,v=null;x.forEach(function(S){S.kind==="audio"?w=S.id:S.kind==="video"&&(v=S.id)});var k=b(m.audioConstraints);k&&(w=k);var I=b(m.videoConstraints);I&&(v=I),g(y(w),y(v))})}},p.prototype.handleUserMedia=function(f,m){var g=this.props;if(f||!m){this.setState({hasUserMedia:!1}),g.onUserMediaError(f);return}this.stream=m;try{this.video&&(this.video.srcObject=m),this.setState({hasUserMedia:!0})}catch{this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(m)})}g.onUserMedia(m)},p.prototype.render=function(){var f=this,m=this,g=m.state,y=m.props,b=y.audio;y.forceScreenshotSourceSize,y.onUserMedia,y.onUserMediaError,y.screenshotFormat,y.screenshotQuality,y.minScreenshotWidth,y.minScreenshotHeight,y.audioConstraints,y.videoConstraints,y.imageSmoothing;var x=y.mirrored,w=y.style,v=w===void 0?{}:w,k=u(y,["audio","forceScreenshotSourceSize","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style"]),I=x?l(l({},v),{transform:(v.transform||"")+" scaleX(-1)"}):v;return i.createElement("video",l({autoPlay:!0,src:g.src,muted:b,playsInline:!0,ref:function(S){f.video=S},style:I},k))},p.defaultProps={audio:!0,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},p}(i.Component);s.default=d},react:function(r,s){r.exports=n}}).default})})(Kde);const Mh=QH(tA);var Xde=Object.defineProperty,Yde=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')}),TF=(e,t)=>{for(var n in t)Xde(e,n,{get:t[n],enumerable:!0})},Zde={};TF(Zde,{Abs:()=>Qg,Acos:()=>gp,Acosh:()=>yp,AdadeltaOptimizer:()=>KO,AdagradOptimizer:()=>XO,AdamOptimizer:()=>YO,AdamaxOptimizer:()=>ZO,Add:()=>gd,AddN:()=>bp,All:()=>ey,Any:()=>ty,ArgMax:()=>ny,ArgMin:()=>ry,Asin:()=>xp,Asinh:()=>wp,Atan:()=>vp,Atan2:()=>Ip,Atanh:()=>kp,AvgPool:()=>Sp,AvgPool3D:()=>sy,AvgPool3DGrad:()=>nw,AvgPoolGrad:()=>XC,BackendWasm:()=>fJ,BatchMatMul:()=>Cp,BatchToSpaceND:()=>ay,Bincount:()=>iy,BroadcastArgs:()=>rw,BroadcastTo:()=>J6,Callback:()=>kX,CallbackList:()=>NK,Cast:()=>Np,Ceil:()=>$p,ClipByValue:()=>yd,Complex:()=>YC,ComplexAbs:()=>sw,Concat:()=>oy,Conv2D:()=>Tp,Conv2DBackpropFilter:()=>ZC,Conv2DBackpropInput:()=>_p,Conv3D:()=>Ep,Conv3DBackpropFilterV2:()=>ly,Conv3DBackpropInputV2:()=>uy,Cos:()=>Ap,Cosh:()=>Rp,CropAndResize:()=>dy,Cumprod:()=>cy,Cumsum:()=>Dp,CustomCallback:()=>TK,DataStorage:()=>jC,DenseBincount:()=>aw,DepthToSpace:()=>hy,DepthwiseConv2dNative:()=>Fp,DepthwiseConv2dNativeBackpropFilter:()=>JC,DepthwiseConv2dNativeBackpropInput:()=>QC,Diag:()=>iw,Dilation2D:()=>Op,Dilation2DBackpropFilter:()=>hg,Dilation2DBackpropInput:()=>dg,ENV:()=>DF,EarlyStopping:()=>IX,Einsum:()=>eN,Elu:()=>Lp,EluGrad:()=>py,Environment:()=>Y6,Equal:()=>my,Erf:()=>fy,Exp:()=>Pp,ExpandDims:()=>gy,Expm1:()=>zp,FFT:()=>tN,Fill:()=>ow,FlipLeftRight:()=>yy,Floor:()=>Bp,FloorDiv:()=>Wp,FromPixels:()=>ZI,FusedBatchNorm:()=>Vp,FusedConv2D:()=>Ph,FusedDepthwiseConv2D:()=>zh,GPGPUContext:()=>pI,GatherNd:()=>xy,GatherV2:()=>by,GraphModel:()=>O3,Greater:()=>wy,GreaterEqual:()=>Up,History:()=>$K,IFFT:()=>nN,Identity:()=>Gp,Imag:()=>rN,InputSpec:()=>Cr,IsFinite:()=>Hp,IsInf:()=>jp,IsNan:()=>qp,KernelBackend:()=>ew,LRN:()=>Zp,LRNGrad:()=>$y,LayerVariable:()=>xK,LayersModel:()=>Nu,LeakyRelu:()=>Kp,Less:()=>vy,LessEqual:()=>ky,LinSpace:()=>Iy,Log:()=>Xp,Log1p:()=>Yp,LogSoftmax:()=>eq,LogicalAnd:()=>Sy,LogicalNot:()=>Cy,LogicalOr:()=>Ny,LogicalXor:()=>Q6,LowerBound:()=>Vhe,MathBackendCPU:()=>d2,MathBackendWebGL:()=>f2,MatrixBandPart:()=>Uhe,Max:()=>Jp,MaxPool:()=>ef,MaxPool3D:()=>Ty,MaxPool3DGrad:()=>lw,MaxPoolGrad:()=>sN,MaxPoolWithArgmax:()=>aN,Maximum:()=>Qp,Mean:()=>tf,Min:()=>nf,Minimum:()=>rf,MirrorPad:()=>sf,Mod:()=>_y,MomentumOptimizer:()=>JO,Multinomial:()=>Ey,Multiply:()=>af,Neg:()=>Ay,NonMaxSuppressionV3:()=>Dy,NonMaxSuppressionV4:()=>Fy,NonMaxSuppressionV5:()=>Oy,NotEqual:()=>Ry,OP_SCOPE_SUFFIX:()=>LF,OneHot:()=>of,OnesLike:()=>My,Optimizer:()=>Hu,OptimizerConstructors:()=>nK,Pack:()=>Ly,PadV2:()=>lf,Pool:()=>Ghe,Pow:()=>uf,Prelu:()=>cf,Prod:()=>df,RMSPropOptimizer:()=>QO,RNN:()=>Zl,RaggedGather:()=>iN,RaggedRange:()=>oN,RaggedTensorToTensor:()=>lN,Range:()=>uw,Rank:()=>sA,Real:()=>uN,RealDiv:()=>Mp,Reciprocal:()=>hf,Reduction:()=>Xs,Relu:()=>pf,Relu6:()=>gf,Reshape:()=>Py,ResizeBilinear:()=>mf,ResizeBilinearGrad:()=>By,ResizeNearestNeighbor:()=>ff,ResizeNearestNeighborGrad:()=>zy,Reverse:()=>yf,RotateWithOffset:()=>nb,Round:()=>bf,Rsqrt:()=>xf,SGDOptimizer:()=>HN,ScatterNd:()=>Wy,SearchSorted:()=>Uy,Select:()=>Gy,Selu:()=>wf,Sequential:()=>Sg,Sigmoid:()=>If,Sign:()=>kf,Sin:()=>vf,Sinh:()=>jy,Slice:()=>Hy,Softmax:()=>$f,Softplus:()=>Sf,SpaceToBatchND:()=>qy,SparseFillEmptyRows:()=>cw,SparseReshape:()=>Xy,SparseSegmentMean:()=>dw,SparseSegmentSum:()=>hw,SparseToDense:()=>Yy,SplitV:()=>Ky,Sqrt:()=>Cf,Square:()=>pw,SquaredDifference:()=>Tf,StaticRegexReplace:()=>fw,Step:()=>xd,StridedSlice:()=>Zy,StringNGrams:()=>mw,StringSplit:()=>gw,StringToHashBucketFast:()=>yw,Sub:()=>_f,Sum:()=>Nf,SymbolicTensor:()=>Bo,Tan:()=>Ef,Tanh:()=>Af,Tensor:()=>Tt,TensorBuffer:()=>Nr,TensorScatterUpdate:()=>Vy,Tile:()=>bd,TopK:()=>Jy,Transform:()=>Qy,Transpose:()=>Cu,Unique:()=>bw,Unpack:()=>eb,UnsortedSegmentSum:()=>xw,UpperBound:()=>Hhe,Variable:()=>Bh,ZerosLike:()=>tb,_FusedMatMul:()=>Lh,abs:()=>Ir,acos:()=>VF,acosh:()=>UF,add:()=>Ie,addN:()=>Cq,all:()=>fN,any:()=>y0,argMax:()=>Uh,argMin:()=>GF,asin:()=>HF,asinh:()=>jF,atan:()=>qF,atan2:()=>KF,atanh:()=>XF,avgPool:()=>Vu,avgPool3d:()=>ZF,backend:()=>Sq,backend_util:()=>W,basicLSTMCell:()=>_q,batchNorm:()=>Rf,batchNorm2d:()=>JF,batchNorm3d:()=>QF,batchNorm4d:()=>eO,batchToSpaceND:()=>Nw,bincount:()=>tO,booleanMaskAsync:()=>y8,broadcastArgs:()=>Eq,broadcastTo:()=>Sh,broadcast_util:()=>rb,browser:()=>Pw,buffer:()=>Ot,callbacks:()=>bCe,cast:()=>Me,ceil:()=>nO,clipByValue:()=>Ms,clone:()=>Fl,complex:()=>Fu,concat:()=>In,concat1d:()=>rO,concat2d:()=>sO,concat3d:()=>aO,concat4d:()=>iO,constraints:()=>kK,conv1d:()=>mN,conv2d:()=>ea,conv2dTranspose:()=>gN,conv3d:()=>lO,conv3dTranspose:()=>uO,copyRegisteredKernels:()=>Xhe,cos:()=>$w,cosh:()=>yN,cosineWindow:()=>BN,cumprod:()=>w0,cumsum:()=>bN,customGrad:()=>Gl,data:()=>jX,denseBincount:()=>rS,deprecationWarn:()=>Iq,depthToSpace:()=>cO,depthwiseConv2d:()=>Df,deregisterOp:()=>vCe,device_util:()=>Iw,diag:()=>Rq,dilation2d:()=>dO,disableDeprecationWarnings:()=>rfe,dispose:()=>St,disposeVariables:()=>sfe,div:()=>tt,divNoNan:()=>hO,dot:()=>pO,dropout:()=>UO,einsum:()=>Fq,elu:()=>sb,enableDebugMode:()=>nfe,enableProdMode:()=>tfe,enclosingPowerOfTwo:()=>GO,engine:()=>Xi,env:()=>me,equal:()=>Ja,erf:()=>fO,euclideanNorm:()=>yO,exp:()=>ta,expandDims:()=>ms,expm1:()=>bO,eye:()=>xN,fft:()=>Mw,fill:()=>Ya,findBackend:()=>dfe,findBackendFactory:()=>hfe,floor:()=>ib,floorDiv:()=>pN,forceHalfFloat:()=>dY,fused:()=>wg,gather:()=>ob,gatherND:()=>v8,gather_util:()=>nM,getBackend:()=>ufe,getGradient:()=>nA,getKernel:()=>JI,getKernelsForBackend:()=>QI,getThreadsCount:()=>e6e,gpgpu_util:()=>U9,grad:()=>ige,grads:()=>oge,greater:()=>la,greaterEqual:()=>Uu,ifft:()=>xg,imag:()=>Tw,image:()=>Po,inTopKAsync:()=>k8,initializers:()=>IK,input:()=>VK,io:()=>ws,irfft:()=>DN,isFinite:()=>xO,isInf:()=>wO,isNaN:()=>vO,keep:()=>Or,kernel_impls:()=>Yl,layers:()=>SK,leakyRelu:()=>_w,less:()=>mg,lessEqual:()=>vd,linalg:()=>qO,linspace:()=>zq,loadGraphModel:()=>$Ne,loadGraphModelSync:()=>TNe,loadLayersModel:()=>gIe,localResponseNormalization:()=>kO,log:()=>Qa,log1p:()=>Ew,logSigmoid:()=>IO,logSoftmax:()=>vN,logSumExp:()=>kN,logicalAnd:()=>yo,logicalNot:()=>Aw,logicalOr:()=>IN,logicalXor:()=>SO,losses:()=>F8,lowerBound:()=>Wq,matMul:()=>At,math:()=>G8,max:()=>Ci,maxPool:()=>Yr,maxPool3d:()=>CO,maxPoolWithArgmax:()=>Vq,maximum:()=>Xl,mean:()=>rr,memory:()=>nS,meshgrid:()=>Uq,metrics:()=>xX,min:()=>fg,minimum:()=>jc,mirrorPad:()=>NO,mod:()=>$O,model:()=>xIe,models:()=>wX,moments:()=>Rw,movingAverage:()=>b8,mul:()=>ae,multiRNNCell:()=>Gq,multinomial:()=>Hq,neg:()=>Mn,nextFrame:()=>rM,norm:()=>ab,notEqual:()=>qh,oneHot:()=>gg,ones:()=>Ha,onesLike:()=>ei,op:()=>re,outerProduct:()=>jq,pad:()=>ll,pad1d:()=>qq,pad2d:()=>Kq,pad3d:()=>Xq,pad4d:()=>Yq,pool:()=>TO,pow:()=>Ou,prelu:()=>Fw,print:()=>WF,prod:()=>_O,profile:()=>afe,raggedGather:()=>Zq,raggedRange:()=>Jq,raggedTensorToTensor:()=>Qq,rand:()=>e8,randomGamma:()=>s8,randomNormal:()=>CN,randomStandardNormal:()=>a8,randomUniform:()=>lb,range:()=>Kh,ready:()=>lfe,real:()=>yg,reciprocal:()=>FO,registerBackend:()=>hN,registerCallbackConstructor:()=>vIe,registerGradient:()=>tq,registerKernel:()=>ww,registerOp:()=>wCe,regularizers:()=>vX,relu:()=>yn,relu6:()=>NN,removeBackend:()=>cfe,reshape:()=>oe,reverse:()=>Ti,reverse1d:()=>i8,reverse2d:()=>o8,reverse3d:()=>l8,reverse4d:()=>u8,rfft:()=>Lw,round:()=>$N,rsqrt:()=>TN,scalar:()=>mt,scatterND:()=>x8,scatter_util:()=>MN,searchSorted:()=>SN,selu:()=>_N,separableConv2d:()=>ub,sequential:()=>wIe,serialization:()=>_e,setBackend:()=>ofe,setPlatform:()=>pfe,setThreadsCount:()=>Qje,setWasmPath:()=>Zje,setWasmPaths:()=>Jje,setWebGLContext:()=>p9,setdiff1dAsync:()=>c8,shared:()=>z3,sigmoid:()=>ho,sign:()=>OO,signal:()=>D8,sin:()=>EN,sinh:()=>AN,slice:()=>Vt,slice1d:()=>Ow,slice2d:()=>RN,slice3d:()=>cb,slice4d:()=>bg,slice_util:()=>Br,softmax:()=>kd,softplus:()=>Ff,spaceToBatchND:()=>Dw,sparse:()=>O8,sparseToDense:()=>w8,spectral:()=>R8,split:()=>Sa,sqrt:()=>ks,square:()=>vn,squaredDifference:()=>FN,squeeze:()=>Id,stack:()=>zr,step:()=>Of,stridedSlice:()=>MO,string:()=>M8,sub:()=>qe,sum:()=>st,sumOutType:()=>dN,tan:()=>LO,tanh:()=>Hh,tensor:()=>Js,tensor1d:()=>gn,tensor2d:()=>Ol,tensor3d:()=>ON,tensor4d:()=>qc,tensor5d:()=>d8,tensor6d:()=>h8,tensorScatterUpdate:()=>f8,tensor_util:()=>Go,test_util:()=>t8,tidy:()=>ue,tile:()=>Ga,time:()=>ife,topk:()=>zO,train:()=>rh,transpose:()=>Ft,truncatedNormal:()=>PN,unique:()=>BO,unregisterGradient:()=>Khe,unregisterKernel:()=>qhe,unsortedSegmentSum:()=>zN,unstack:()=>fr,upcastType:()=>$i,upperBound:()=>m8,util:()=>_,valueAndGrad:()=>lge,valueAndGrads:()=>uge,variable:()=>WO,variableGrads:()=>Bq,version:()=>o6e,version_converter:()=>ENe,version_core:()=>C0e,version_cpu:()=>N$e,version_layers:()=>CM,version_wasm:()=>t6e,version_webgl:()=>hOe,webgl:()=>pOe,webgl_util:()=>h9,where:()=>ss,whereAsync:()=>VO,zeros:()=>sr,zerosLike:()=>Ht});var Jde=Object.create,_F=Object.defineProperty,Qde=Object.getOwnPropertyDescriptor,ehe=Object.getOwnPropertyNames,the=Object.getPrototypeOf,nhe=Object.prototype.hasOwnProperty,_r=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Ct=(e,t)=>{for(var n in t)_F(e,n,{get:t[n],enumerable:!0})},rhe=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of ehe(t))!nhe.call(e,s)&&s!==n&&_F(e,s,{get:()=>t[s],enumerable:!(r=Qde(t,s))||r.enumerable});return e},fd=(e,t,n)=>(n=e!=null?Jde(the(e)):{},rhe(t||!e||!e.__esModule?_F(n,"default",{value:e,enumerable:!0}):n,e)),she=_r((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(C,E,M){this.low=C|0,this.high=E|0,this.unsigned=!!M}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function s(C){return(C&&C.__isLong__)===!0}r.isLong=s;var a={},i={};function o(C,E){var M,F,z;return E?(C>>>=0,(z=0<=C&&C<256)&&(F=i[C],F)?F:(M=u(C,(C|0)<0?-1:0,!0),z&&(i[C]=M),M)):(C|=0,(z=-128<=C&&C<128)&&(F=a[C],F)?F:(M=u(C,C<0?-1:0,!1),z&&(a[C]=M),M))}r.fromInt=o;function l(C,E){if(isNaN(C))return E?w:x;if(E){if(C<0)return w;if(C>=g)return $}else{if(C<=-y)return N;if(C+1>=y)return S}return C<0?l(-C,E).neg():u(C%m|0,C/m|0,E)}r.fromNumber=l;function u(C,E,M){return new r(C,E,M)}r.fromBits=u;var c=Math.pow;function d(C,E,M){if(C.length===0)throw Error("empty string");if(C==="NaN"||C==="Infinity"||C==="+Infinity"||C==="-Infinity")return x;if(typeof E=="number"?(M=E,E=!1):E=!!E,M=M||10,M<2||36<M)throw RangeError("radix");var F;if((F=C.indexOf("-"))>0)throw Error("interior hyphen");if(F===0)return d(C.substring(1),E,M).neg();for(var z=l(c(M,8)),H=x,P=0;P<C.length;P+=8){var O=Math.min(8,C.length-P),L=parseInt(C.substring(P,P+O),M);if(O<8){var V=l(c(M,O));H=H.mul(V).add(l(L))}else H=H.mul(z),H=H.add(l(L))}return H.unsigned=E,H}r.fromString=d;function h(C,E){return typeof C=="number"?l(C,E):typeof C=="string"?d(C,E):u(C.low,C.high,typeof E=="boolean"?E:C.unsigned)}r.fromValue=h;var p=1<<16,f=1<<24,m=p*p,g=m*m,y=g/2,b=o(f),x=o(0);r.ZERO=x;var w=o(0,!0);r.UZERO=w;var v=o(1);r.ONE=v;var k=o(1,!0);r.UONE=k;var I=o(-1);r.NEG_ONE=I;var S=u(-1,2147483647,!1);r.MAX_VALUE=S;var $=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=$;var N=u(0,-2147483648,!1);r.MIN_VALUE=N;var T=r.prototype;T.toInt=function(){return this.unsigned?this.low>>>0:this.low},T.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},T.toString=function(C){if(C=C||10,C<2||36<C)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(N)){var E=l(C),M=this.div(E),F=M.mul(E).sub(this);return M.toString(C)+F.toInt().toString(C)}else return"-"+this.neg().toString(C);for(var z=l(c(C,6),this.unsigned),H=this,P="";;){var O=H.div(z),L=H.sub(O.mul(z)).toInt()>>>0,V=L.toString(C);if(H=O,H.isZero())return V+P;for(;V.length<6;)V="0"+V;P=""+V+P}},T.getHighBits=function(){return this.high},T.getHighBitsUnsigned=function(){return this.high>>>0},T.getLowBits=function(){return this.low},T.getLowBitsUnsigned=function(){return this.low>>>0},T.getNumBitsAbs=function(){if(this.isNegative())return this.eq(N)?64:this.neg().getNumBitsAbs();for(var C=this.high!=0?this.high:this.low,E=31;E>0&&!(C&1<<E);E--);return this.high!=0?E+33:E+1},T.isZero=function(){return this.high===0&&this.low===0},T.eqz=T.isZero,T.isNegative=function(){return!this.unsigned&&this.high<0},T.isPositive=function(){return this.unsigned||this.high>=0},T.isOdd=function(){return(this.low&1)===1},T.isEven=function(){return(this.low&1)===0},T.equals=function(C){return s(C)||(C=h(C)),this.unsigned!==C.unsigned&&this.high>>>31===1&&C.high>>>31===1?!1:this.high===C.high&&this.low===C.low},T.eq=T.equals,T.notEquals=function(C){return!this.eq(C)},T.neq=T.notEquals,T.ne=T.notEquals,T.lessThan=function(C){return this.comp(C)<0},T.lt=T.lessThan,T.lessThanOrEqual=function(C){return this.comp(C)<=0},T.lte=T.lessThanOrEqual,T.le=T.lessThanOrEqual,T.greaterThan=function(C){return this.comp(C)>0},T.gt=T.greaterThan,T.greaterThanOrEqual=function(C){return this.comp(C)>=0},T.gte=T.greaterThanOrEqual,T.ge=T.greaterThanOrEqual,T.compare=function(C){if(s(C)||(C=h(C)),this.eq(C))return 0;var E=this.isNegative(),M=C.isNegative();return E&&!M?-1:!E&&M?1:this.unsigned?C.high>>>0>this.high>>>0||C.high===this.high&&C.low>>>0>this.low>>>0?-1:1:this.sub(C).isNegative()?-1:1},T.comp=T.compare,T.negate=function(){return!this.unsigned&&this.eq(N)?N:this.not().add(v)},T.neg=T.negate,T.add=function(C){s(C)||(C=h(C));var E=this.high>>>16,M=this.high&65535,F=this.low>>>16,z=this.low&65535,H=C.high>>>16,P=C.high&65535,O=C.low>>>16,L=C.low&65535,V=0,q=0,B=0,X=0;return X+=z+L,B+=X>>>16,X&=65535,B+=F+O,q+=B>>>16,B&=65535,q+=M+P,V+=q>>>16,q&=65535,V+=E+H,V&=65535,u(B<<16|X,V<<16|q,this.unsigned)},T.subtract=function(C){return s(C)||(C=h(C)),this.add(C.neg())},T.sub=T.subtract,T.multiply=function(C){if(this.isZero())return x;if(s(C)||(C=h(C)),n){var E=n.mul(this.low,this.high,C.low,C.high);return u(E,n.get_high(),this.unsigned)}if(C.isZero())return x;if(this.eq(N))return C.isOdd()?N:x;if(C.eq(N))return this.isOdd()?N:x;if(this.isNegative())return C.isNegative()?this.neg().mul(C.neg()):this.neg().mul(C).neg();if(C.isNegative())return this.mul(C.neg()).neg();if(this.lt(b)&&C.lt(b))return l(this.toNumber()*C.toNumber(),this.unsigned);var M=this.high>>>16,F=this.high&65535,z=this.low>>>16,H=this.low&65535,P=C.high>>>16,O=C.high&65535,L=C.low>>>16,V=C.low&65535,q=0,B=0,X=0,ee=0;return ee+=H*V,X+=ee>>>16,ee&=65535,X+=z*V,B+=X>>>16,X&=65535,X+=H*L,B+=X>>>16,X&=65535,B+=F*V,q+=B>>>16,B&=65535,B+=z*L,q+=B>>>16,B&=65535,B+=H*O,q+=B>>>16,B&=65535,q+=M*V+F*L+z*O+H*P,q&=65535,u(X<<16|ee,q<<16|B,this.unsigned)},T.mul=T.multiply,T.divide=function(C){if(s(C)||(C=h(C)),C.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&C.low===-1&&C.high===-1)return this;var E=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,C.low,C.high);return u(E,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?w:x;var M,F,z;if(this.unsigned){if(C.unsigned||(C=C.toUnsigned()),C.gt(this))return w;if(C.gt(this.shru(1)))return k;z=w}else{if(this.eq(N)){if(C.eq(v)||C.eq(I))return N;if(C.eq(N))return v;var H=this.shr(1);return M=H.div(C).shl(1),M.eq(x)?C.isNegative()?v:I:(F=this.sub(C.mul(M)),z=M.add(F.div(C)),z)}else if(C.eq(N))return this.unsigned?w:x;if(this.isNegative())return C.isNegative()?this.neg().div(C.neg()):this.neg().div(C).neg();if(C.isNegative())return this.div(C.neg()).neg();z=x}for(F=this;F.gte(C);){M=Math.max(1,Math.floor(F.toNumber()/C.toNumber()));for(var P=Math.ceil(Math.log(M)/Math.LN2),O=P<=48?1:c(2,P-48),L=l(M),V=L.mul(C);V.isNegative()||V.gt(F);)M-=O,L=l(M,this.unsigned),V=L.mul(C);L.isZero()&&(L=v),z=z.add(L),F=F.sub(V)}return z},T.div=T.divide,T.modulo=function(C){if(s(C)||(C=h(C)),n){var E=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,C.low,C.high);return u(E,n.get_high(),this.unsigned)}return this.sub(this.div(C).mul(C))},T.mod=T.modulo,T.rem=T.modulo,T.not=function(){return u(~this.low,~this.high,this.unsigned)},T.and=function(C){return s(C)||(C=h(C)),u(this.low&C.low,this.high&C.high,this.unsigned)},T.or=function(C){return s(C)||(C=h(C)),u(this.low|C.low,this.high|C.high,this.unsigned)},T.xor=function(C){return s(C)||(C=h(C)),u(this.low^C.low,this.high^C.high,this.unsigned)},T.shiftLeft=function(C){return s(C)&&(C=C.toInt()),(C&=63)===0?this:C<32?u(this.low<<C,this.high<<C|this.low>>>32-C,this.unsigned):u(0,this.low<<C-32,this.unsigned)},T.shl=T.shiftLeft,T.shiftRight=function(C){return s(C)&&(C=C.toInt()),(C&=63)===0?this:C<32?u(this.low>>>C|this.high<<32-C,this.high>>C,this.unsigned):u(this.high>>C-32,this.high>=0?0:-1,this.unsigned)},T.shr=T.shiftRight,T.shiftRightUnsigned=function(C){if(s(C)&&(C=C.toInt()),C&=63,C===0)return this;var E=this.high;if(C<32){var M=this.low;return u(M>>>C|E<<32-C,E>>>C,this.unsigned)}else return C===32?u(E,0,this.unsigned):u(E>>>C-32,0,this.unsigned)},T.shru=T.shiftRightUnsigned,T.shr_u=T.shiftRightUnsigned,T.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},T.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},T.toBytes=function(C){return C?this.toBytesLE():this.toBytesBE()},T.toBytesLE=function(){var C=this.high,E=this.low;return[E&255,E>>>8&255,E>>>16&255,E>>>24,C&255,C>>>8&255,C>>>16&255,C>>>24]},T.toBytesBE=function(){var C=this.high,E=this.low;return[C>>>24,C>>>16&255,C>>>8&255,C&255,E>>>24,E>>>16&255,E>>>8&255,E&255]},r.fromBytes=function(C,E,M){return M?r.fromBytesLE(C,E):r.fromBytesBE(C,E)},r.fromBytesLE=function(C,E){return new r(C[0]|C[1]<<8|C[2]<<16|C[3]<<24,C[4]|C[5]<<8|C[6]<<16|C[7]<<24,E)},r.fromBytesBE=function(C,E){return new r(C[4]<<24|C[5]<<16|C[6]<<8|C[7],C[0]<<24|C[1]<<16|C[2]<<8|C[3],E)}}),ahe=_r(()=>{}),ihe=_r(()=>{}),ohe=_r((e,t)=>{(function(n,r,s){function a(u){var c=this,d=l();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=d(" "),c.s1=d(" "),c.s2=d(" "),c.s0-=d(u),c.s0<0&&(c.s0+=1),c.s1-=d(u),c.s1<0&&(c.s1+=1),c.s2-=d(u),c.s2<0&&(c.s2+=1),d=null}function i(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function o(u,c){var d=new a(u),h=c&&c.state,p=d.next;return p.int32=function(){return d.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,h&&(typeof h=="object"&&i(h,d),p.state=function(){return i(d,{})}),p}function l(){var u=4022871197,c=function(d){d=String(d);for(var h=0;h<d.length;h++){u+=d.charCodeAt(h);var p=.02519603282416938*u;u=p>>>0,p-=u,p*=u,u=p>>>0,p-=u,u+=p*4294967296}return(u>>>0)*23283064365386963e-26};return c}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),lhe=_r((e,t)=>{(function(n,r,s){function a(l){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var h=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^h^h>>>8},l===(l|0)?u.x=l:c+=l;for(var d=0;d<c.length+64;d++)u.x^=c.charCodeAt(d)|0,u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function o(l,u){var c=new a(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,d&&(typeof d=="object"&&i(d,c),h.state=function(){return i(c,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),uhe=_r((e,t)=>{(function(n,r,s){function a(l){var u=this,c="";u.next=function(){var h=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(h^h<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(l|0)?u.x=l:c+=l;for(var d=0;d<c.length+64;d++)u.x^=c.charCodeAt(d)|0,d==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function o(l,u){var c=new a(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,d&&(typeof d=="object"&&i(d,c),h.state=function(){return i(c,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),che=_r((e,t)=>{(function(n,r,s){function a(l){var u=this;u.next=function(){var d=u.x,h=u.i,p,f;return p=d[h],p^=p>>>7,f=p^p<<24,p=d[h+1&7],f^=p^p>>>10,p=d[h+3&7],f^=p^p>>>3,p=d[h+4&7],f^=p^p<<7,p=d[h+7&7],p=p^p<<13,f^=p^p<<9,d[h]=f,u.i=h+1&7,f};function c(d,h){var p,f=[];if(h===(h|0))f[0]=h;else for(h=""+h,p=0;p<h.length;++p)f[p&7]=f[p&7]<<15^h.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?f[7]=-1:f[p],d.x=f,d.i=0,p=256;p>0;--p)d.next()}c(u,l)}function i(l,u){return u.x=l.x.slice(),u.i=l.i,u}function o(l,u){l==null&&(l=+new Date);var c=new a(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,d&&(d.x&&i(d,c),h.state=function(){return i(c,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),dhe=_r((e,t)=>{(function(n,r,s){function a(l){var u=this;u.next=function(){var d=u.w,h=u.X,p=u.i,f,m;return u.w=d=d+1640531527|0,m=h[p+34&127],f=h[p=p+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=h[p]=m^f,u.i=p,m+(d^d>>>16)|0};function c(d,h){var p,f,m,g,y,b=[],x=128;for(h===(h|0)?(f=h,h=null):(h=h+"\0",f=0,x=Math.max(x,h.length)),m=0,g=-32;g<x;++g)h&&(f^=h.charCodeAt((g+32)%h.length)),g===0&&(y=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,g>=0&&(y=y+1640531527|0,p=b[g&127]^=f+y,m=p==0?m+1:0);for(m>=128&&(b[(h&&h.length||0)&127]=-1),m=127,g=4*128;g>0;--g)f=b[m+34&127],p=b[m=m+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,b[m]=f^p;d.w=y,d.X=b,d.i=m}c(u,l)}function i(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function o(l,u){l==null&&(l=+new Date);var c=new a(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,d&&(d.X&&i(d,c),h.state=function(){return i(c,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),hhe=_r((e,t)=>{(function(n,r,s){function a(l){var u=this,c="";u.next=function(){var h=u.b,p=u.c,f=u.d,m=u.a;return h=h<<25^h>>>7^p,p=p-f|0,f=f<<24^f>>>8^m,m=m-h|0,u.b=h=h<<20^h>>>12^p,u.c=p=p-f|0,u.d=f<<16^p>>>16^m,u.a=m-h|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=l|0):c+=l;for(var d=0;d<c.length+20;d++)u.b^=c.charCodeAt(d)|0,u.next()}function i(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function o(l,u){var c=new a(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,d&&(typeof d=="object"&&i(d,c),h.state=function(){return i(c,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),phe=_r(()=>{}),fhe=_r((e,t)=>{(function(n,r,s){var a=256,i=6,o=52,l="random",u=s.pow(a,i),c=s.pow(2,o),d=c*2,h=a-1,p;function f(v,k,I){var S=[];k=k==!0?{entropy:!0}:k||{};var $=b(y(k.entropy?[v,w(r)]:v??x(),3),S),N=new m(S),T=function(){for(var C=N.g(i),E=u,M=0;C<c;)C=(C+M)*a,E*=a,M=N.g(1);for(;C>=d;)C/=2,E/=2,M>>>=1;return(C+M)/E};return T.int32=function(){return N.g(4)|0},T.quick=function(){return N.g(4)/4294967296},T.double=T,b(w(N.S),r),(k.pass||I||function(C,E,M,F){return F&&(F.S&&g(F,N),C.state=function(){return g(N,{})}),M?(s[l]=C,E):C})(T,$,"global"in k?k.global:this==s,k.state)}function m(v){var k,I=v.length,S=this,$=0,N=S.i=S.j=0,T=S.S=[];for(I||(v=[I++]);$<a;)T[$]=$++;for($=0;$<a;$++)T[$]=T[N=h&N+v[$%I]+(k=T[$])],T[N]=k;(S.g=function(C){for(var E,M=0,F=S.i,z=S.j,H=S.S;C--;)E=H[F=h&F+1],M=M*a+H[h&(H[F]=H[z=h&z+E])+(H[z]=E)];return S.i=F,S.j=z,M})(a)}function g(v,k){return k.i=v.i,k.j=v.j,k.S=v.S.slice(),k}function y(v,k){var I=[],S=typeof v,$;if(k&&S=="object")for($ in v)try{I.push(y(v[$],k-1))}catch{}return I.length?I:S=="string"?v:v+"\0"}function b(v,k){for(var I=v+"",S,$=0;$<I.length;)k[h&$]=h&(S^=k[h&$]*19)+I.charCodeAt($++);return w(k)}function x(){try{var v;return p&&(v=p.randomBytes)?v=v(a):(v=new Uint8Array(a),(n.crypto||n.msCrypto).getRandomValues(v)),w(v)}catch{var k=n.navigator,I=k&&k.plugins;return[+new Date,n,I,n.screen,w(r)]}}function w(v){return String.fromCharCode.apply(0,v)}if(b(s.random(),r),typeof t=="object"&&t.exports){t.exports=f;try{p=phe()}catch{}}else typeof define=="function"&&define.amd?define(function(){return f}):s["seed"+l]=f})(typeof self<"u"?self:e,[],Math)}),HC=_r((e,t)=>{var n=ohe(),r=lhe(),s=uhe(),a=che(),i=dhe(),o=hhe(),l=fhe();l.alea=n,l.xor128=r,l.xorwow=s,l.xorshift7=a,l.xor4096=i,l.tychei=o,t.exports=l}),z6=_r(()=>{}),EF=_r(()=>{}),B6=_r(()=>{}),mhe=_r(()=>{}),ghe=_r(()=>{}),yhe=_r(()=>{}),bhe=_r((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(s){s=s||{};function a(){return P.buffer!=Q&&He(P.buffer),be}function i(){return P.buffer!=Q&&He(P.buffer),we}function o(){return P.buffer!=Q&&He(P.buffer),Ne}function l(){return P.buffer!=Q&&He(P.buffer),$e}function u(){return P.buffer!=Q&&He(P.buffer),je}var c=typeof s<"u"?s:{},d,h;c.ready=new Promise(function(te,ye){d=te,h=ye});var p;typeof process<"u"&&process.listeners&&(p={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},c),m=(te,ye)=>{throw ye},g=typeof window=="object",y=typeof importScripts=="function",b=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x=c.ENVIRONMENT_IS_PTHREAD||!1,w="";function v(te){return c.locateFile?c.locateFile(te,w):w+te}var k,I,S;function $(te){te instanceof Zt||F("exiting due to exception: "+te)}if(b){var N=EF(),T=B6();y?w=T.dirname(w)+"/":w=__dirname+"/",k=(ye,ze)=>(ye=To(ye)?new URL(ye):T.normalize(ye),N.readFileSync(ye,ze?void 0:"utf8")),S=ye=>{var ze=k(ye,!0);return ze.buffer||(ze=new Uint8Array(ze)),ze},I=(ye,ze,wt)=>{ye=To(ye)?new URL(ye):T.normalize(ye),N.readFile(ye,function($t,Et){$t?wt($t):ze(Et.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(ye){if(!(ye instanceof Zt))throw ye}),process.on("unhandledRejection",function(ye){throw ye}),m=(ye,ze)=>{if(ct())throw process.exitCode=ye,ze;$(ze),process.exit(ye)},c.inspect=function(){return"[Emscripten Module object]"};let te;try{te=mhe()}catch(ye){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),ye}global.Worker=te.Worker}else(g||y)&&(y?w=self.location.href:typeof document<"u"&&document.currentScript&&(w=document.currentScript.src),typeof r<"u"&&r&&(w=r),w.indexOf("blob:")!==0?w=w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):w="",b||(k=te=>{var ye=new XMLHttpRequest;return ye.open("GET",te,!1),ye.send(null),ye.responseText},y&&(S=te=>{var ye=new XMLHttpRequest;return ye.open("GET",te,!1),ye.responseType="arraybuffer",ye.send(null),new Uint8Array(ye.response)}),I=(te,ye,ze)=>{var wt=new XMLHttpRequest;wt.open("GET",te,!0),wt.responseType="arraybuffer",wt.onload=()=>{if(wt.status==200||wt.status==0&&wt.response){ye(wt.response);return}ze()},wt.onerror=ze,wt.send(null)}));b&&typeof performance>"u"&&(global.performance=ghe().performance);var C=console.log.bind(console),E=console.warn.bind(console);b&&(C=te=>N.writeSync(1,te+`
`),E=te=>N.writeSync(2,te+`
`));var M=c.print||C,F=c.printErr||E;Object.assign(c,f),f=null,c.arguments&&c.arguments,c.thisProgram&&c.thisProgram,c.quit&&(m=c.quit);var z;c.wasmBinary&&(z=c.wasmBinary);var H=c.noExitRuntime||!0;typeof WebAssembly!="object"&&ha("no native wasm support detected");var P,O,L=!1,V;function q(te,ye){te||ha(ye)}var B=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function X(te,ye,ze){for(var wt=ye+ze,$t=ye;te[$t]&&!($t>=wt);)++$t;if($t-ye>16&&te.buffer&&B)return B.decode(te.buffer instanceof SharedArrayBuffer?te.slice(ye,$t):te.subarray(ye,$t));for(var Et="";ye<$t;){var et=te[ye++];if(!(et&128)){Et+=String.fromCharCode(et);continue}var gt=te[ye++]&63;if((et&224)==192){Et+=String.fromCharCode((et&31)<<6|gt);continue}var er=te[ye++]&63;if((et&240)==224?et=(et&15)<<12|gt<<6|er:et=(et&7)<<18|gt<<12|er<<6|te[ye++]&63,et<65536)Et+=String.fromCharCode(et);else{var hi=et-65536;Et+=String.fromCharCode(55296|hi>>10,56320|hi&1023)}}return Et}function ee(te,ye){return te?X(i(),te,ye):""}function Z(te,ye,ze,wt){if(!(wt>0))return 0;for(var $t=ze,Et=ze+wt-1,et=0;et<te.length;++et){var gt=te.charCodeAt(et);if(gt>=55296&&gt<=57343){var er=te.charCodeAt(++et);gt=65536+((gt&1023)<<10)|er&1023}if(gt<=127){if(ze>=Et)break;ye[ze++]=gt}else if(gt<=2047){if(ze+1>=Et)break;ye[ze++]=192|gt>>6,ye[ze++]=128|gt&63}else if(gt<=65535){if(ze+2>=Et)break;ye[ze++]=224|gt>>12,ye[ze++]=128|gt>>6&63,ye[ze++]=128|gt&63}else{if(ze+3>=Et)break;ye[ze++]=240|gt>>18,ye[ze++]=128|gt>>12&63,ye[ze++]=128|gt>>6&63,ye[ze++]=128|gt&63}}return ye[ze]=0,ze-$t}function fe(te,ye,ze){return Z(te,i(),ye,ze)}var Q,be,we,Ne,$e,je;x&&(Q=c.buffer);function He(te){Q=te,c.HEAP8=be=new Int8Array(te),c.HEAP16=new Int16Array(te),c.HEAP32=Ne=new Int32Array(te),c.HEAPU8=we=new Uint8Array(te),c.HEAPU16=new Uint16Array(te),c.HEAPU32=$e=new Uint32Array(te),c.HEAPF32=new Float32Array(te),c.HEAPF64=je=new Float64Array(te)}var Re=c.INITIAL_MEMORY||16777216;if(x)P=c.wasmMemory,Q=c.buffer;else if(c.wasmMemory)P=c.wasmMemory;else if(P=new WebAssembly.Memory({initial:Re/65536,maximum:32768,shared:!0}),!(P.buffer instanceof SharedArrayBuffer))throw F("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),b&&F("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");P&&(Q=P.buffer),Re=Q.byteLength,He(Q);var Fe,Pe=[],Je=[],pn=[];function ct(){return H}function an(){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)Qe(c.preRun.shift());Rn(Pe)}function Lt(){!x&&Rn(Je)}function Gt(){if(!x){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)mn(c.postRun.shift());Rn(pn)}}function Qe(te){Pe.unshift(te)}function It(te){Je.unshift(te)}function mn(te){pn.unshift(te)}var en=0,on=null;function Ws(te){en++,c.monitorRunDependencies&&c.monitorRunDependencies(en)}function Bi(te){if(en--,c.monitorRunDependencies&&c.monitorRunDependencies(en),en==0&&on){var ye=on;on=null,ye()}}function ha(te){c.onAbort&&c.onAbort(te),te="Aborted("+te+")",F(te),L=!0,V=1,te+=". Build with -sASSERTIONS for more info.";var ye=new WebAssembly.RuntimeError(te);throw h(ye),ye}var tu="data:application/octet-stream;base64,";function Es(te){return te.startsWith(tu)}function To(te){return te.startsWith("file://")}var De;De="tfjs-backend-wasm-threaded-simd.wasm",Es(De)||(De=v(De));function pt(te){try{if(te==De&&z)return new Uint8Array(z);if(S)return S(te);throw"both async and sync fetching of the wasm failed"}catch(ye){ha(ye)}}function tn(){if(!z&&(g||y)){if(typeof fetch=="function"&&!To(De))return fetch(De,{credentials:"same-origin"}).then(function(te){if(!te.ok)throw"failed to load wasm binary file at '"+De+"'";return te.arrayBuffer()}).catch(function(){return pt(De)});if(I)return new Promise(function(te,ye){I(De,function(ze){te(new Uint8Array(ze))},ye)})}return Promise.resolve().then(function(){return pt(De)})}function zn(){var te={env:p4,wasi_snapshot_preview1:p4};function ye(et,gt){var er=et.exports;if(c.asm=er,nu(c.asm._emscripten_tls_init),Fe=c.asm.__indirect_function_table,It(c.asm.__wasm_call_ctors),O=gt,!x){var hi=Ke.unusedWorkers.length;Ke.unusedWorkers.forEach(function(ru){Ke.loadWasmModuleToWorker(ru,function(){--hi||Bi()})})}}x||Ws();function ze(et){ye(et.instance,et.module)}function wt(et){return tn().then(function(gt){return WebAssembly.instantiate(gt,te)}).then(function(gt){return gt}).then(et,function(gt){F("failed to asynchronously prepare wasm: "+gt),ha(gt)})}function $t(){return!z&&typeof WebAssembly.instantiateStreaming=="function"&&!Es(De)&&!To(De)&&!b&&typeof fetch=="function"?fetch(De,{credentials:"same-origin"}).then(function(et){var gt=WebAssembly.instantiateStreaming(et,te);return gt.then(ze,function(er){return F("wasm streaming compile failed: "+er),F("falling back to ArrayBuffer instantiation"),wt(ze)})}):wt(ze)}if(c.instantiateWasm)try{var Et=c.instantiateWasm(te,ye);return Et}catch(et){F("Module.instantiateWasm callback failed with error: "+et),h(et)}return $t().catch(h),{}}var qr={};function Zt(te){this.name="ExitStatus",this.message="Program terminated with exit("+te+")",this.status=te}function Kr(te){var ye=Ke.pthreads[te];delete Ke.pthreads[te],ye.terminate(),wT(te),Ke.runningWorkers.splice(Ke.runningWorkers.indexOf(ye),1),ye.pthread_ptr=0}function pa(te){var ye=Ke.pthreads[te];ye.postMessage({cmd:"cancel"})}function ci(te){var ye=Ke.pthreads[te];q(ye),Ke.returnWorkerToPool(ye)}function hl(te){var ye=Ke.getNewWorker();if(!ye)return 6;Ke.runningWorkers.push(ye),Ke.pthreads[te.pthread_ptr]=ye,ye.pthread_ptr=te.pthread_ptr;var ze={cmd:"run",start_routine:te.startRoutine,arg:te.arg,pthread_ptr:te.pthread_ptr};return ye.runPthread=()=>{b&&ye.ref(),ye.postMessage(ze,te.transferList),delete ye.runPthread},ye.loaded&&ye.runPthread(),0}function fa(te){if(x)return nm(1,1,te);V=te,ct()||(Ke.terminateAllThreads(),c.onExit&&c.onExit(te),L=!0),m(te,new Zt(te))}function ke(te,ye){if(V=te,!ye&&x)throw Pt(te),"unwind";fa(te)}var Le=ke;function xt(te){if(te instanceof Zt||te=="unwind")return V;m(1,te)}var Ke={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){x?Ke.initWorker():Ke.initMainThread()},initMainThread:function(){for(var te=8;te--;)Ke.allocateUnusedWorker()},initWorker:function(){H=!1},setExitStatus:function(te){V=te},terminateAllThreads:function(){for(var te of Object.values(Ke.pthreads))Ke.returnWorkerToPool(te);for(var te of Ke.unusedWorkers)te.terminate();Ke.unusedWorkers=[]},returnWorkerToPool:function(te){var ye=te.pthread_ptr;delete Ke.pthreads[ye],Ke.unusedWorkers.push(te),Ke.runningWorkers.splice(Ke.runningWorkers.indexOf(te),1),te.pthread_ptr=0,b&&te.unref(),wT(ye)},receiveObjectTransfer:function(te){},threadInitTLS:function(){Ke.tlsInitFunctions.forEach(te=>te())},loadWasmModuleToWorker:function(te,ye){te.onmessage=Et=>{var et=Et.data,gt=et.cmd;if(te.pthread_ptr&&(Ke.currentProxiedOperationCallerThread=te.pthread_ptr),et.targetThread&&et.targetThread!=Av()){var er=Ke.pthreads[et.targetThread];er?er.postMessage(et,et.transferList):F('Internal error! Worker sent a message "'+gt+'" to target pthread '+et.targetThread+", but that thread no longer exists!"),Ke.currentProxiedOperationCallerThread=void 0;return}gt==="processProxyingQueue"?yT(et.queue):gt==="spawnThread"?hl(et):gt==="cleanupThread"?ci(et.thread):gt==="killThread"?Kr(et.thread):gt==="cancelThread"?pa(et.thread):gt==="loaded"?(te.loaded=!0,b&&te.unref(),ye&&ye(te),te.runPthread&&te.runPthread()):gt==="print"?M("Thread "+et.threadId+": "+et.text):gt==="printErr"?F("Thread "+et.threadId+": "+et.text):gt==="alert"?alert("Thread "+et.threadId+": "+et.text):et.target==="setimmediate"?te.postMessage(et):gt==="callHandler"?c[et.handler](...et.args):gt&&F("worker sent an unknown command "+gt),Ke.currentProxiedOperationCallerThread=void 0},te.onerror=Et=>{var et="worker sent an error!";throw F(et+" "+Et.filename+":"+Et.lineno+": "+Et.message),Et},b&&(te.on("message",function(Et){te.onmessage({data:Et})}),te.on("error",function(Et){te.onerror(Et)}),te.on("detachedExit",function(){}));var ze=[],wt=["onExit","onAbort","print","printErr"];for(var $t of wt)c.hasOwnProperty($t)&&ze.push($t);te.postMessage({cmd:"load",handlers:ze,urlOrBlob:c.mainScriptUrlOrBlob||r,wasmMemory:P,wasmModule:O})},allocateUnusedWorker:function(){var te,ye=v("tfjs-backend-wasm-threaded-simd.worker.js");te=new Worker(ye),Ke.unusedWorkers.push(te)},getNewWorker:function(){return Ke.unusedWorkers.length==0&&(Ke.allocateUnusedWorker(),Ke.loadWasmModuleToWorker(Ke.unusedWorkers[0])),Ke.unusedWorkers.pop()}};c.PThread=Ke;function Rn(te){for(;te.length>0;)te.shift()(c)}function jn(){var te=Av(),ye=o()[te+52>>2],ze=o()[te+56>>2],wt=ye-ze;b4(ye,wt),Rv(ye)}c.establishStackSpace=jn;function Pt(te){if(x)return nm(2,0,te);try{Le(te)}catch(ye){xt(ye)}}var _t=[];function kr(te){var ye=_t[te];return ye||(te>=_t.length&&(_t.length=te+1),_t[te]=ye=Fe.get(te)),ye}function di(te,ye){var ze=kr(te)(ye);ct()?Ke.setExitStatus(ze):y4(ze)}c.invokeEntryPoint=di;function nu(te){Ke.tlsInitFunctions.push(te)}function Tv(te){f4(te,!y,1,!g),Ke.threadInitTLS()}function Vb(te){x?postMessage({cmd:"cleanupThread",thread:te}):ci(te)}function _v(te,ye,ze,wt){return x?nm(3,1,te,ye,ze,wt):Vs(te,ye,ze,wt)}function Vs(te,ye,ze,wt){if(typeof SharedArrayBuffer>"u")return F("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var $t=[],Et=0;if(x&&($t.length===0||Et))return _v(te,ye,ze,wt);var et={startRoutine:ze,pthread_ptr:te,arg:wt,transferList:$t};return x?(et.cmd="spawnThread",postMessage(et,$t),0):hl(et)}function Ju(){return 65536}var Ev=!0;function die(){return Ev}function yT(te){Atomics.store(o(),te>>2,1),Av()&&g4(te),Atomics.compareExchange(o(),te>>2,1,0)}c.executeNotifiedProxyingQueue=yT;function hie(te,ye,ze,wt){if(te==ye)setTimeout(()=>yT(wt));else if(x)postMessage({targetThread:te,cmd:"processProxyingQueue",queue:wt});else{var $t=Ke.pthreads[te];if(!$t)return;$t.postMessage({cmd:"processProxyingQueue",queue:wt})}return 1}function pie(te,ye,ze){return-1}function fie(){ha("")}function Ub(te){Ub.shown||(Ub.shown={}),Ub.shown[te]||(Ub.shown[te]=1,b&&(te="warning: "+te),F(te))}function mie(){b||y||Ub("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function gie(){return Date.now()}function l4(){return 2147483648}function yie(){return l4()}var bT;b?bT=()=>{var te=process.hrtime();return te[0]*1e3+te[1]/1e6}:bT=()=>performance.timeOrigin+performance.now();function bie(te,ye,ze){i().copyWithin(te,ye,ye+ze)}function xie(){return b?yhe().cpus().length:navigator.hardwareConcurrency}function wie(te){var ye=vT(),ze=te();return Rv(ye),ze}function nm(te,ye){var ze=arguments.length-2,wt=arguments;return wie(()=>{for(var $t=ze,Et=Dv($t*8),et=Et>>3,gt=0;gt<ze;gt++){var er=wt[2+gt];u()[et+gt]=er}return m4(te,$t,Et,ye)})}var xT=[];function vie(te,ye,ze){xT.length=ye;for(var wt=ze>>3,$t=0;$t<ye;$t++)xT[$t]=u()[wt+$t];var Et=te<0,et=Et?qr[-te-1]:Eie[te];return et.apply(null,xT)}function kie(te){try{return P.grow(te-Q.byteLength+65535>>>16),He(P.buffer),1}catch{}}function Iie(te){var ye=i().length;if(te=te>>>0,te<=ye)return!1;var ze=l4();if(te>ze)return!1;let wt=(er,hi)=>er+(hi-er%hi)%hi;for(var $t=1;$t<=4;$t*=2){var Et=ye*(1+.2/$t);Et=Math.min(Et,te+100663296);var et=Math.min(ze,wt(Math.max(te,Et),65536)),gt=kie(et);if(gt)return!0}return!1}function Sie(){throw"unwind"}function u4(te){return x?nm(4,1,te):52}function c4(te,ye,ze,wt,$t){return x?nm(5,1,te,ye,ze,wt,$t):70}var Cie=[null,[],[]];function Nie(te,ye){var ze=Cie[te];ye===0||ye===10?((te===1?M:F)(X(ze,0)),ze.length=0):ze.push(ye)}function d4(te,ye,ze,wt){if(x)return nm(6,1,te,ye,ze,wt);for(var $t=0,Et=0;Et<ze;Et++){var et=l()[ye>>2],gt=l()[ye+4>>2];ye+=8;for(var er=0;er<gt;er++)Nie(te,i()[et+er]);$t+=gt}return l()[wt>>2]=$t,0}function h4(te){var ye=c["_"+te];return ye}function $ie(te,ye){a().set(te,ye)}function Tie(te,ye,ze,wt,$t){var Et={string:pi=>{var rm=0;if(pi!=null&&pi!==0){var v4=(pi.length<<2)+1;rm=Dv(v4),fe(pi,rm,v4)}return rm},array:pi=>{var rm=Dv(pi.length);return $ie(pi,rm),rm}};function et(pi){return ye==="string"?ee(pi):ye==="boolean"?!!pi:pi}var gt=h4(te),er=[],hi=0;if(wt)for(var ru=0;ru<wt.length;ru++){var w4=Et[ze[ru]];w4?(hi===0&&(hi=vT()),er[ru]=w4(wt[ru])):er[ru]=wt[ru]}var kT=gt.apply(null,er);function Rie(pi){return hi!==0&&Rv(hi),et(pi)}return kT=Rie(kT),kT}function _ie(te,ye,ze,wt){ze=ze||[];var $t=ze.every(et=>et==="number"||et==="boolean"),Et=ye!=="string";return Et&&$t&&!wt?h4(te):function(){return Tie(te,ye,ze,arguments)}}Ke.init();var Eie=[null,fa,Pt,_v,u4,c4,d4],p4={__emscripten_init_main_thread_js:Tv,__emscripten_thread_cleanup:Vb,__pthread_create_js:Vs,_emscripten_default_pthread_stack_size:Ju,_emscripten_get_now_is_monotonic:die,_emscripten_notify_task_queue:hie,_emscripten_set_offscreencanvas_size:pie,abort:fie,emscripten_check_blocking_allowed:mie,emscripten_date_now:gie,emscripten_get_heap_max:yie,emscripten_get_now:bT,emscripten_memcpy_big:bie,emscripten_num_logical_cores:xie,emscripten_receive_on_main_thread_js:vie,emscripten_resize_heap:Iie,emscripten_unwind_to_js_event_loop:Sie,exit:Le,fd_close:u4,fd_seek:c4,fd_write:d4,memory:P||c.wasmMemory};zn(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Acos=function(){return(c._Acos=c.asm.Acos).apply(null,arguments)},c._Acosh=function(){return(c._Acosh=c.asm.Acosh).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._ArgMin=function(){return(c._ArgMin=c.asm.ArgMin).apply(null,arguments)},c._Asin=function(){return(c._Asin=c.asm.Asin).apply(null,arguments)},c._Asinh=function(){return(c._Asinh=c.asm.Asinh).apply(null,arguments)},c._Atan=function(){return(c._Atan=c.asm.Atan).apply(null,arguments)},c._Atan2=function(){return(c._Atan2=c.asm.Atan2).apply(null,arguments)},c._Atanh=function(){return(c._Atanh=c.asm.Atanh).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._AvgPool3D=function(){return(c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},c._AvgPool3DGrad=function(){return(c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Bincount=function(){return(c._Bincount=c.asm.Bincount).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Conv3D=function(){return(c._Conv3D=c.asm.Conv3D).apply(null,arguments)},c._Conv3DBackpropFilterV2=function(){return(c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},c._Conv3DBackpropInputV2=function(){return(c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DenseBincount=function(){return(c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Diag=function(){return(c._Diag=c.asm.Diag).apply(null,arguments)},c._Dilation2D=function(){return(c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},c._Dilation2DBackpropFilter=function(){return(c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},c._Dilation2DBackpropInput=function(){return(c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._EluGrad=function(){return(c._EluGrad=c.asm.EluGrad).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._Expm1=function(){return(c._Expm1=c.asm.Expm1).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._IsFinite=function(){return(c._IsFinite=c.asm.IsFinite).apply(null,arguments)},c._IsInf=function(){return(c._IsInf=c.asm.IsInf).apply(null,arguments)},c._IsNan=function(){return(c._IsNan=c.asm.IsNan).apply(null,arguments)},c._LRN=function(){return(c._LRN=c.asm.LRN).apply(null,arguments)},c._LRNGrad=function(){return(c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._LinSpace=function(){return(c._LinSpace=c.asm.LinSpace).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._Log1p=function(){return(c._Log1p=c.asm.Log1p).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._MaxPool3D=function(){return(c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},c._MaxPool3DGrad=function(){return(c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Multinomial=function(){return(c._Multinomial=c.asm.Multinomial).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Reciprocal=function(){return(c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeBilinearGrad=function(){return(c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._ResizeNearestNeighborGrad=function(){return(c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SearchSorted=function(){return(c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Selu=function(){return(c._Selu=c.asm.Selu).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sign=function(){return(c._Sign=c.asm.Sign).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._Softplus=function(){return(c._Softplus=c.asm.Softplus).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._SparseToDense=function(){return(c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._TensorScatterUpdate=function(){return(c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(c._malloc=c.asm.malloc).apply(null,arguments)},c._free=function(){return(c._free=c.asm.free).apply(null,arguments)},c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)};var Av=c._pthread_self=function(){return(Av=c._pthread_self=c.asm.pthread_self).apply(null,arguments)};c.___errno_location=function(){return(c.___errno_location=c.asm.__errno_location).apply(null,arguments)};var f4=c.__emscripten_thread_init=function(){return(f4=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)};c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c._emscripten_main_thread_process_queued_calls=function(){return(c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var m4=c._emscripten_run_in_main_runtime_thread_js=function(){return(m4=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};c._emscripten_dispatch_to_thread_=function(){return(c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var g4=c.__emscripten_proxy_execute_task_queue=function(){return(g4=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},wT=c.__emscripten_thread_free_data=function(){return(wT=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},y4=c.__emscripten_thread_exit=function(){return(y4=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},b4=c._emscripten_stack_set_limits=function(){return(b4=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},vT=c.stackSave=function(){return(vT=c.stackSave=c.asm.stackSave).apply(null,arguments)},Rv=c.stackRestore=function(){return(Rv=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},Dv=c.stackAlloc=function(){return(Dv=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)};c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)},c.keepRuntimeAlive=ct,c.wasmMemory=P,c.cwrap=_ie,c.ExitStatus=Zt,c.PThread=Ke;var Fv;on=function te(){Fv||x4(),Fv||(on=te)};function x4(te){if(en>0)return;if(x){d(c),Lt(),startWorker(c);return}if(an(),en>0)return;function ye(){Fv||(Fv=!0,c.calledRun=!0,!L&&(Lt(),d(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),Gt()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),ye()},1)):ye()}if(c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();x4();var Ov;p&&(Ov={uncaughtException:process.listeners("uncaughtException").filter(function(te){return!p.uncaughtException.indexOf(te)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(te){return!p.unhandledRejection.indexOf(te)>-1})});var Mv;if(typeof WasmBackendModule<"u")Mv=WasmBackendModule;else if(typeof s<"u")Mv=s;else throw new Error("Could not find wasm module in post.js");if(Ov){var Aie=Mv._dispose;Mv._dispose=function(){Aie(),Ov.uncaughtException.forEach(function(te){process.removeListener("uncaughtException",te)}),Ov.unhandledRejection.forEach(function(te){process.removeListener("unhandledRejection",te)})}}return s.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),xhe=_r((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),whe=_r((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(s){s=s||{};var a=typeof s<"u"?s:{},i,o;a.ready=new Promise(function(ke,Le){i=ke,o=Le});var l;typeof process<"u"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var u=Object.assign({},a),c=typeof window=="object",d=typeof importScripts=="function",h=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",p="";function f(ke){return a.locateFile?a.locateFile(ke,p):p+ke}var m,g,y;if(h){var b=EF(),x=B6();d?p=x.dirname(p)+"/":p=__dirname+"/",m=(ke,Le)=>(ke=Re(ke)?new URL(ke):x.normalize(ke),b.readFileSync(ke,Le?void 0:"utf8")),y=ke=>{var Le=m(ke,!0);return Le.buffer||(Le=new Uint8Array(Le)),Le},g=(ke,Le,xt)=>{ke=Re(ke)?new URL(ke):x.normalize(ke),b.readFile(ke,function(Ke,Rn){Ke?xt(Ke):Le(Rn.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(ke){if(!(ke instanceof ct))throw ke}),process.on("unhandledRejection",function(ke){throw ke}),a.inspect=function(){return"[Emscripten Module object]"}}else(c||d)&&(d?p=self.location.href:typeof document<"u"&&document.currentScript&&(p=document.currentScript.src),r&&(p=r),p.indexOf("blob:")!==0?p=p.substr(0,p.replace(/[?#].*/,"").lastIndexOf("/")+1):p="",m=ke=>{var Le=new XMLHttpRequest;return Le.open("GET",ke,!1),Le.send(null),Le.responseText},d&&(y=ke=>{var Le=new XMLHttpRequest;return Le.open("GET",ke,!1),Le.responseType="arraybuffer",Le.send(null),new Uint8Array(Le.response)}),g=(ke,Le,xt)=>{var Ke=new XMLHttpRequest;Ke.open("GET",ke,!0),Ke.responseType="arraybuffer",Ke.onload=()=>{if(Ke.status==200||Ke.status==0&&Ke.response){Le(Ke.response);return}xt()},Ke.onerror=xt,Ke.send(null)});var w=a.print||console.log.bind(console),v=a.printErr||console.warn.bind(console);Object.assign(a,u),u=null,a.arguments&&a.arguments,a.thisProgram&&a.thisProgram,a.quit&&a.quit;var k;a.wasmBinary&&(k=a.wasmBinary),a.noExitRuntime,typeof WebAssembly!="object"&&$e("no native wasm support detected");var I,S=!1,$=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function N(ke,Le,xt){for(var Ke=Le+xt,Rn=Le;ke[Rn]&&!(Rn>=Ke);)++Rn;if(Rn-Le>16&&ke.buffer&&$)return $.decode(ke.subarray(Le,Rn));for(var jn="";Le<Rn;){var Pt=ke[Le++];if(!(Pt&128)){jn+=String.fromCharCode(Pt);continue}var _t=ke[Le++]&63;if((Pt&224)==192){jn+=String.fromCharCode((Pt&31)<<6|_t);continue}var kr=ke[Le++]&63;if((Pt&240)==224?Pt=(Pt&15)<<12|_t<<6|kr:Pt=(Pt&7)<<18|_t<<12|kr<<6|ke[Le++]&63,Pt<65536)jn+=String.fromCharCode(Pt);else{var di=Pt-65536;jn+=String.fromCharCode(55296|di>>10,56320|di&1023)}}return jn}function T(ke,Le){return ke?N(z,ke,Le):""}function C(ke,Le,xt,Ke){if(!(Ke>0))return 0;for(var Rn=xt,jn=xt+Ke-1,Pt=0;Pt<ke.length;++Pt){var _t=ke.charCodeAt(Pt);if(_t>=55296&&_t<=57343){var kr=ke.charCodeAt(++Pt);_t=65536+((_t&1023)<<10)|kr&1023}if(_t<=127){if(xt>=jn)break;Le[xt++]=_t}else if(_t<=2047){if(xt+1>=jn)break;Le[xt++]=192|_t>>6,Le[xt++]=128|_t&63}else if(_t<=65535){if(xt+2>=jn)break;Le[xt++]=224|_t>>12,Le[xt++]=128|_t>>6&63,Le[xt++]=128|_t&63}else{if(xt+3>=jn)break;Le[xt++]=240|_t>>18,Le[xt++]=128|_t>>12&63,Le[xt++]=128|_t>>6&63,Le[xt++]=128|_t&63}}return Le[xt]=0,xt-Rn}function E(ke,Le,xt){return C(ke,z,Le,xt)}var M,F,z,H;function P(ke){M=ke,a.HEAP8=F=new Int8Array(ke),a.HEAP16=new Int16Array(ke),a.HEAP32=new Int32Array(ke),a.HEAPU8=z=new Uint8Array(ke),a.HEAPU16=new Uint16Array(ke),a.HEAPU32=H=new Uint32Array(ke),a.HEAPF32=new Float32Array(ke),a.HEAPF64=new Float64Array(ke)}a.INITIAL_MEMORY;var O=[],L=[],V=[];function q(){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)ee(a.preRun.shift());an(O)}function B(){an(L)}function X(){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;)fe(a.postRun.shift());an(V)}function ee(ke){O.unshift(ke)}function Z(ke){L.unshift(ke)}function fe(ke){V.unshift(ke)}var Q=0,be=null;function we(ke){Q++,a.monitorRunDependencies&&a.monitorRunDependencies(Q)}function Ne(ke){if(Q--,a.monitorRunDependencies&&a.monitorRunDependencies(Q),Q==0&&be){var Le=be;be=null,Le()}}function $e(ke){a.onAbort&&a.onAbort(ke),ke="Aborted("+ke+")",v(ke),S=!0,ke+=". Build with -sASSERTIONS for more info.";var Le=new WebAssembly.RuntimeError(ke);throw o(Le),Le}var je="data:application/octet-stream;base64,";function He(ke){return ke.startsWith(je)}function Re(ke){return ke.startsWith("file://")}var Fe;Fe="tfjs-backend-wasm.wasm",He(Fe)||(Fe=f(Fe));function Pe(ke){try{if(ke==Fe&&k)return new Uint8Array(k);if(y)return y(ke);throw"both async and sync fetching of the wasm failed"}catch(Le){$e(Le)}}function Je(){if(!k&&(c||d)){if(typeof fetch=="function"&&!Re(Fe))return fetch(Fe,{credentials:"same-origin"}).then(function(ke){if(!ke.ok)throw"failed to load wasm binary file at '"+Fe+"'";return ke.arrayBuffer()}).catch(function(){return Pe(Fe)});if(g)return new Promise(function(ke,Le){g(Fe,function(xt){ke(new Uint8Array(xt))},Le)})}return Promise.resolve().then(function(){return Pe(Fe)})}function pn(){var ke={env:tn,wasi_snapshot_preview1:tn};function Le(Pt,_t){var kr=Pt.exports;a.asm=kr,I=a.asm.memory,P(I.buffer),a.asm.__indirect_function_table,Z(a.asm.__wasm_call_ctors),Ne()}we();function xt(Pt){Le(Pt.instance)}function Ke(Pt){return Je().then(function(_t){return WebAssembly.instantiate(_t,ke)}).then(function(_t){return _t}).then(Pt,function(_t){v("failed to asynchronously prepare wasm: "+_t),$e(_t)})}function Rn(){return!k&&typeof WebAssembly.instantiateStreaming=="function"&&!He(Fe)&&!Re(Fe)&&!h&&typeof fetch=="function"?fetch(Fe,{credentials:"same-origin"}).then(function(Pt){var _t=WebAssembly.instantiateStreaming(Pt,ke);return _t.then(xt,function(kr){return v("wasm streaming compile failed: "+kr),v("falling back to ArrayBuffer instantiation"),Ke(xt)})}):Ke(xt)}if(a.instantiateWasm)try{var jn=a.instantiateWasm(ke,Le);return jn}catch(Pt){v("Module.instantiateWasm callback failed with error: "+Pt),o(Pt)}return Rn().catch(o),{}}function ct(ke){this.name="ExitStatus",this.message="Program terminated with exit("+ke+")",this.status=ke}function an(ke){for(;ke.length>0;)ke.shift()(a)}function Lt(){$e("")}function Gt(){return 2147483648}function Qe(){return Gt()}function It(ke,Le,xt){z.copyWithin(ke,Le,Le+xt)}function mn(ke){try{return I.grow(ke-M.byteLength+65535>>>16),P(I.buffer),1}catch{}}function en(ke){var Le=z.length;ke=ke>>>0;var xt=Gt();if(ke>xt)return!1;let Ke=(kr,di)=>kr+(di-kr%di)%di;for(var Rn=1;Rn<=4;Rn*=2){var jn=Le*(1+.2/Rn);jn=Math.min(jn,ke+100663296);var Pt=Math.min(xt,Ke(Math.max(ke,jn),65536)),_t=mn(Pt);if(_t)return!0}return!1}function on(ke){return 52}function Ws(ke,Le,xt,Ke,Rn){return 70}var Bi=[null,[],[]];function ha(ke,Le){var xt=Bi[ke];Le===0||Le===10?((ke===1?w:v)(N(xt,0)),xt.length=0):xt.push(Le)}function tu(ke,Le,xt,Ke){for(var Rn=0,jn=0;jn<xt;jn++){var Pt=H[Le>>2],_t=H[Le+4>>2];Le+=8;for(var kr=0;kr<_t;kr++)ha(ke,z[Pt+kr]);Rn+=_t}return H[Ke>>2]=Rn,0}function Es(ke){var Le=a["_"+ke];return Le}function To(ke,Le){F.set(ke,Le)}function De(ke,Le,xt,Ke,Rn){var jn={string:Vs=>{var Ju=0;if(Vs!=null&&Vs!==0){var Ev=(Vs.length<<2)+1;Ju=Zt(Ev),E(Vs,Ju,Ev)}return Ju},array:Vs=>{var Ju=Zt(Vs.length);return To(Vs,Ju),Ju}};function Pt(Vs){return Le==="string"?T(Vs):Le==="boolean"?!!Vs:Vs}var _t=Es(ke),kr=[],di=0;if(Ke)for(var nu=0;nu<Ke.length;nu++){var Tv=jn[xt[nu]];Tv?(di===0&&(di=zn()),kr[nu]=Tv(Ke[nu])):kr[nu]=Ke[nu]}var Vb=_t.apply(null,kr);function _v(Vs){return di!==0&&qr(di),Pt(Vs)}return Vb=_v(Vb),Vb}function pt(ke,Le,xt,Ke){xt=xt||[];var Rn=xt.every(Pt=>Pt==="number"||Pt==="boolean"),jn=Le!=="string";return jn&&Rn&&!Ke?Es(ke):function(){return De(ke,Le,xt,arguments)}}var tn={abort:Lt,emscripten_get_heap_max:Qe,emscripten_memcpy_big:It,emscripten_resize_heap:en,fd_close:on,fd_seek:Ws,fd_write:tu};pn(),a.___wasm_call_ctors=function(){return(a.___wasm_call_ctors=a.asm.__wasm_call_ctors).apply(null,arguments)},a._init=function(){return(a._init=a.asm.init).apply(null,arguments)},a._init_with_threads_count=function(){return(a._init_with_threads_count=a.asm.init_with_threads_count).apply(null,arguments)},a._get_threads_count=function(){return(a._get_threads_count=a.asm.get_threads_count).apply(null,arguments)},a._register_tensor=function(){return(a._register_tensor=a.asm.register_tensor).apply(null,arguments)},a._dispose_data=function(){return(a._dispose_data=a.asm.dispose_data).apply(null,arguments)},a._dispose=function(){return(a._dispose=a.asm.dispose).apply(null,arguments)},a._Abs=function(){return(a._Abs=a.asm.Abs).apply(null,arguments)},a._Acos=function(){return(a._Acos=a.asm.Acos).apply(null,arguments)},a._Acosh=function(){return(a._Acosh=a.asm.Acosh).apply(null,arguments)},a._Add=function(){return(a._Add=a.asm.Add).apply(null,arguments)},a._AddN=function(){return(a._AddN=a.asm.AddN).apply(null,arguments)},a._All=function(){return(a._All=a.asm.All).apply(null,arguments)},a._Any=function(){return(a._Any=a.asm.Any).apply(null,arguments)},a._ArgMax=function(){return(a._ArgMax=a.asm.ArgMax).apply(null,arguments)},a._ArgMin=function(){return(a._ArgMin=a.asm.ArgMin).apply(null,arguments)},a._Asin=function(){return(a._Asin=a.asm.Asin).apply(null,arguments)},a._Asinh=function(){return(a._Asinh=a.asm.Asinh).apply(null,arguments)},a._Atan=function(){return(a._Atan=a.asm.Atan).apply(null,arguments)},a._Atan2=function(){return(a._Atan2=a.asm.Atan2).apply(null,arguments)},a._Atanh=function(){return(a._Atanh=a.asm.Atanh).apply(null,arguments)},a._AvgPool=function(){return(a._AvgPool=a.asm.AvgPool).apply(null,arguments)},a._AvgPool3D=function(){return(a._AvgPool3D=a.asm.AvgPool3D).apply(null,arguments)},a._AvgPool3DGrad=function(){return(a._AvgPool3DGrad=a.asm.AvgPool3DGrad).apply(null,arguments)},a._BatchMatMul=function(){return(a._BatchMatMul=a.asm.BatchMatMul).apply(null,arguments)},a._Bincount=function(){return(a._Bincount=a.asm.Bincount).apply(null,arguments)},a._Ceil=function(){return(a._Ceil=a.asm.Ceil).apply(null,arguments)},a._ClipByValue=function(){return(a._ClipByValue=a.asm.ClipByValue).apply(null,arguments)},a._Conv2D=function(){return(a._Conv2D=a.asm.Conv2D).apply(null,arguments)},a._Conv2DBackpropInput=function(){return(a._Conv2DBackpropInput=a.asm.Conv2DBackpropInput).apply(null,arguments)},a._Conv3D=function(){return(a._Conv3D=a.asm.Conv3D).apply(null,arguments)},a._Conv3DBackpropFilterV2=function(){return(a._Conv3DBackpropFilterV2=a.asm.Conv3DBackpropFilterV2).apply(null,arguments)},a._Conv3DBackpropInputV2=function(){return(a._Conv3DBackpropInputV2=a.asm.Conv3DBackpropInputV2).apply(null,arguments)},a._Cos=function(){return(a._Cos=a.asm.Cos).apply(null,arguments)},a._Cosh=function(){return(a._Cosh=a.asm.Cosh).apply(null,arguments)},a._CropAndResize=function(){return(a._CropAndResize=a.asm.CropAndResize).apply(null,arguments)},a._Cumprod=function(){return(a._Cumprod=a.asm.Cumprod).apply(null,arguments)},a._Cumsum=function(){return(a._Cumsum=a.asm.Cumsum).apply(null,arguments)},a._DenseBincount=function(){return(a._DenseBincount=a.asm.DenseBincount).apply(null,arguments)},a._DepthToSpace=function(){return(a._DepthToSpace=a.asm.DepthToSpace).apply(null,arguments)},a._DepthwiseConv2dNative=function(){return(a._DepthwiseConv2dNative=a.asm.DepthwiseConv2dNative).apply(null,arguments)},a._Diag=function(){return(a._Diag=a.asm.Diag).apply(null,arguments)},a._Dilation2D=function(){return(a._Dilation2D=a.asm.Dilation2D).apply(null,arguments)},a._Dilation2DBackpropFilter=function(){return(a._Dilation2DBackpropFilter=a.asm.Dilation2DBackpropFilter).apply(null,arguments)},a._Dilation2DBackpropInput=function(){return(a._Dilation2DBackpropInput=a.asm.Dilation2DBackpropInput).apply(null,arguments)},a._Elu=function(){return(a._Elu=a.asm.Elu).apply(null,arguments)},a._EluGrad=function(){return(a._EluGrad=a.asm.EluGrad).apply(null,arguments)},a._Equal=function(){return(a._Equal=a.asm.Equal).apply(null,arguments)},a._Exp=function(){return(a._Exp=a.asm.Exp).apply(null,arguments)},a._Expm1=function(){return(a._Expm1=a.asm.Expm1).apply(null,arguments)},a._FlipLeftRight=function(){return(a._FlipLeftRight=a.asm.FlipLeftRight).apply(null,arguments)},a._Floor=function(){return(a._Floor=a.asm.Floor).apply(null,arguments)},a._FloorDiv=function(){return(a._FloorDiv=a.asm.FloorDiv).apply(null,arguments)},a._FusedBatchNorm=function(){return(a._FusedBatchNorm=a.asm.FusedBatchNorm).apply(null,arguments)},a._FusedConv2D=function(){return(a._FusedConv2D=a.asm.FusedConv2D).apply(null,arguments)},a._FusedDepthwiseConv2D=function(){return(a._FusedDepthwiseConv2D=a.asm.FusedDepthwiseConv2D).apply(null,arguments)},a._Gather=function(){return(a._Gather=a.asm.Gather).apply(null,arguments)},a._GatherNd=function(){return(a._GatherNd=a.asm.GatherNd).apply(null,arguments)},a._Greater=function(){return(a._Greater=a.asm.Greater).apply(null,arguments)},a._GreaterEqual=function(){return(a._GreaterEqual=a.asm.GreaterEqual).apply(null,arguments)},a._IsFinite=function(){return(a._IsFinite=a.asm.IsFinite).apply(null,arguments)},a._IsInf=function(){return(a._IsInf=a.asm.IsInf).apply(null,arguments)},a._IsNan=function(){return(a._IsNan=a.asm.IsNan).apply(null,arguments)},a._LRN=function(){return(a._LRN=a.asm.LRN).apply(null,arguments)},a._LRNGrad=function(){return(a._LRNGrad=a.asm.LRNGrad).apply(null,arguments)},a._LeakyRelu=function(){return(a._LeakyRelu=a.asm.LeakyRelu).apply(null,arguments)},a._Less=function(){return(a._Less=a.asm.Less).apply(null,arguments)},a._LessEqual=function(){return(a._LessEqual=a.asm.LessEqual).apply(null,arguments)},a._LinSpace=function(){return(a._LinSpace=a.asm.LinSpace).apply(null,arguments)},a._Log=function(){return(a._Log=a.asm.Log).apply(null,arguments)},a._Log1p=function(){return(a._Log1p=a.asm.Log1p).apply(null,arguments)},a._LogicalAnd=function(){return(a._LogicalAnd=a.asm.LogicalAnd).apply(null,arguments)},a._LogicalNot=function(){return(a._LogicalNot=a.asm.LogicalNot).apply(null,arguments)},a._LogicalOr=function(){return(a._LogicalOr=a.asm.LogicalOr).apply(null,arguments)},a._LogicalXor=function(){return(a._LogicalXor=a.asm.LogicalXor).apply(null,arguments)},a._Max=function(){return(a._Max=a.asm.Max).apply(null,arguments)},a._MaxPool=function(){return(a._MaxPool=a.asm.MaxPool).apply(null,arguments)},a._MaxPool3D=function(){return(a._MaxPool3D=a.asm.MaxPool3D).apply(null,arguments)},a._MaxPool3DGrad=function(){return(a._MaxPool3DGrad=a.asm.MaxPool3DGrad).apply(null,arguments)},a._Maximum=function(){return(a._Maximum=a.asm.Maximum).apply(null,arguments)},a._Mean=function(){return(a._Mean=a.asm.Mean).apply(null,arguments)},a._Min=function(){return(a._Min=a.asm.Min).apply(null,arguments)},a._Minimum=function(){return(a._Minimum=a.asm.Minimum).apply(null,arguments)},a._MirrorPad=function(){return(a._MirrorPad=a.asm.MirrorPad).apply(null,arguments)},a._Multinomial=function(){return(a._Multinomial=a.asm.Multinomial).apply(null,arguments)},a._Multiply=function(){return(a._Multiply=a.asm.Multiply).apply(null,arguments)},a._Neg=function(){return(a._Neg=a.asm.Neg).apply(null,arguments)},a._NonMaxSuppressionV3=function(){return(a._NonMaxSuppressionV3=a.asm.NonMaxSuppressionV3).apply(null,arguments)},a._NonMaxSuppressionV4=function(){return(a._NonMaxSuppressionV4=a.asm.NonMaxSuppressionV4).apply(null,arguments)},a._NonMaxSuppressionV5=function(){return(a._NonMaxSuppressionV5=a.asm.NonMaxSuppressionV5).apply(null,arguments)},a._NotEqual=function(){return(a._NotEqual=a.asm.NotEqual).apply(null,arguments)},a._OneHot=function(){return(a._OneHot=a.asm.OneHot).apply(null,arguments)},a._PadV2=function(){return(a._PadV2=a.asm.PadV2).apply(null,arguments)},a._Pow=function(){return(a._Pow=a.asm.Pow).apply(null,arguments)},a._Prelu=function(){return(a._Prelu=a.asm.Prelu).apply(null,arguments)},a._Prod=function(){return(a._Prod=a.asm.Prod).apply(null,arguments)},a._RealDiv=function(){return(a._RealDiv=a.asm.RealDiv).apply(null,arguments)},a._Reciprocal=function(){return(a._Reciprocal=a.asm.Reciprocal).apply(null,arguments)},a._Relu=function(){return(a._Relu=a.asm.Relu).apply(null,arguments)},a._Relu6=function(){return(a._Relu6=a.asm.Relu6).apply(null,arguments)},a._ResizeBilinear=function(){return(a._ResizeBilinear=a.asm.ResizeBilinear).apply(null,arguments)},a._ResizeBilinearGrad=function(){return(a._ResizeBilinearGrad=a.asm.ResizeBilinearGrad).apply(null,arguments)},a._ResizeNearestNeighbor=function(){return(a._ResizeNearestNeighbor=a.asm.ResizeNearestNeighbor).apply(null,arguments)},a._ResizeNearestNeighborGrad=function(){return(a._ResizeNearestNeighborGrad=a.asm.ResizeNearestNeighborGrad).apply(null,arguments)},a._Reverse=function(){return(a._Reverse=a.asm.Reverse).apply(null,arguments)},a._RotateWithOffset=function(){return(a._RotateWithOffset=a.asm.RotateWithOffset).apply(null,arguments)},a._Round=function(){return(a._Round=a.asm.Round).apply(null,arguments)},a._Rsqrt=function(){return(a._Rsqrt=a.asm.Rsqrt).apply(null,arguments)},a._ScatterNd=function(){return(a._ScatterNd=a.asm.ScatterNd).apply(null,arguments)},a._SearchSorted=function(){return(a._SearchSorted=a.asm.SearchSorted).apply(null,arguments)},a._SelectV2=function(){return(a._SelectV2=a.asm.SelectV2).apply(null,arguments)},a._Selu=function(){return(a._Selu=a.asm.Selu).apply(null,arguments)},a._Sigmoid=function(){return(a._Sigmoid=a.asm.Sigmoid).apply(null,arguments)},a._Sign=function(){return(a._Sign=a.asm.Sign).apply(null,arguments)},a._Sin=function(){return(a._Sin=a.asm.Sin).apply(null,arguments)},a._Softmax=function(){return(a._Softmax=a.asm.Softmax).apply(null,arguments)},a._Softplus=function(){return(a._Softplus=a.asm.Softplus).apply(null,arguments)},a._SparseFillEmptyRows=function(){return(a._SparseFillEmptyRows=a.asm.SparseFillEmptyRows).apply(null,arguments)},a._SparseReshape=function(){return(a._SparseReshape=a.asm.SparseReshape).apply(null,arguments)},a._SparseSegmentReduction=function(){return(a._SparseSegmentReduction=a.asm.SparseSegmentReduction).apply(null,arguments)},a._SparseToDense=function(){return(a._SparseToDense=a.asm.SparseToDense).apply(null,arguments)},a._Sqrt=function(){return(a._Sqrt=a.asm.Sqrt).apply(null,arguments)},a._Square=function(){return(a._Square=a.asm.Square).apply(null,arguments)},a._SquaredDifference=function(){return(a._SquaredDifference=a.asm.SquaredDifference).apply(null,arguments)},a._Step=function(){return(a._Step=a.asm.Step).apply(null,arguments)},a._StridedSlice=function(){return(a._StridedSlice=a.asm.StridedSlice).apply(null,arguments)},a._Sub=function(){return(a._Sub=a.asm.Sub).apply(null,arguments)},a._Sum=function(){return(a._Sum=a.asm.Sum).apply(null,arguments)},a._Tan=function(){return(a._Tan=a.asm.Tan).apply(null,arguments)},a._Tanh=function(){return(a._Tanh=a.asm.Tanh).apply(null,arguments)},a._TensorScatterUpdate=function(){return(a._TensorScatterUpdate=a.asm.TensorScatterUpdate).apply(null,arguments)},a._Tile=function(){return(a._Tile=a.asm.Tile).apply(null,arguments)},a._TopK=function(){return(a._TopK=a.asm.TopK).apply(null,arguments)},a._Transform=function(){return(a._Transform=a.asm.Transform).apply(null,arguments)},a._Transpose=function(){return(a._Transpose=a.asm.Transpose).apply(null,arguments)},a.__FusedMatMul=function(){return(a.__FusedMatMul=a.asm._FusedMatMul).apply(null,arguments)},a._malloc=function(){return(a._malloc=a.asm.malloc).apply(null,arguments)},a._free=function(){return(a._free=a.asm.free).apply(null,arguments)},a.___errno_location=function(){return(a.___errno_location=a.asm.__errno_location).apply(null,arguments)};var zn=a.stackSave=function(){return(zn=a.stackSave=a.asm.stackSave).apply(null,arguments)},qr=a.stackRestore=function(){return(qr=a.stackRestore=a.asm.stackRestore).apply(null,arguments)},Zt=a.stackAlloc=function(){return(Zt=a.stackAlloc=a.asm.stackAlloc).apply(null,arguments)};a.dynCall_iijjiiii=function(){return(a.dynCall_iijjiiii=a.asm.dynCall_iijjiiii).apply(null,arguments)},a.dynCall_jiji=function(){return(a.dynCall_jiji=a.asm.dynCall_jiji).apply(null,arguments)},a.cwrap=pt;var Kr;be=function ke(){Kr||pa(),Kr||(be=ke)};function pa(ke){if(Q>0||(q(),Q>0))return;function Le(){Kr||(Kr=!0,a.calledRun=!0,!S&&(B(),i(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),X()))}a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),Le()},1)):Le()}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();pa();var ci;l&&(ci={uncaughtException:process.listeners("uncaughtException").filter(function(ke){return!l.uncaughtException.indexOf(ke)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(ke){return!l.unhandledRejection.indexOf(ke)>-1})});var hl;if(typeof s<"u")hl=s;else if(typeof WasmBackendModuleThreadedSimd<"u")hl=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(ci){var fa=hl._dispose;hl._dispose=function(){fa(),ci.uncaughtException.forEach(function(ke){process.removeListener("uncaughtException",ke)}),ci.unhandledRejection.forEach(function(ke){process.removeListener("unhandledRejection",ke)})}}return s.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),jC=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},ew=class{refCount(e){return Oa("refCount")}incRef(e){return Oa("incRef")}timerAvailable(){return!0}time(e){return Oa("time")}read(e){return Oa("read")}readSync(e){return Oa("readSync")}readToGPU(e,t){return Oa("readToGPU")}numDataIds(){return Oa("numDataIds")}disposeData(e,t){return Oa("disposeData")}write(e,t,n){return Oa("write")}move(e,t,n,r,s){return Oa("move")}createTensorFromGPUData(e,t,n){return Oa("createTensorFromGPUData")}memory(){return Oa("memory")}floatPrecision(){return Oa("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Oa("dispose")}};function Oa(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function W6(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,KI(e,t,n)}function vhe(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,KI(e,n,r),KI(t,n,r)}function h0(e,t,n){return Math.max(e,Math.min(t,n))}function khe(e){return e%2===0?e:e+1}function KI(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function Ihe(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function She(e,t){let n=Math.random();return t*n+(1-n)*e}function Che(e,t){let n=0;for(let r=0;r<e.length;r++){let s=Number(e[r])-Number(t[r]);n+=s*s}return n}function Y(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function ia(e,t,n=""){Y(md(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function mp(e){Y(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function On(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Nhe(e){return e.length===0}function md(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function cg(e){return e%1===0}function $he(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function The(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function _he(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return W6(t),t}function Bx(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Ehe(e,t=s=>0,n,r){return new Promise((s,a)=>{let i=0,o=()=>{if(e()){s();return}i++;let l=t(i);if(n!=null&&i>=n){a();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function Ahe(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(e[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let s=e.slice();return s[r]=t/n,s}function ko(e,t){let n=t.length;return e=e==null?t.map((r,s)=>s):[].concat(e),Y(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),Y(e.every(r=>cg(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function V6(e,t){let n=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||s?null:ko(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(a!=null){if(a[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(a[i]==null||a[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function U6(e,t){return AF(e,t)}function AF(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function G6(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function H6(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function Rhe(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function XI(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function j6(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function mc(e){return typeof e=="string"||e instanceof String}function q6(e){return typeof e=="boolean"}function K6(e){return typeof e=="number"}function tw(e){return Array.isArray(e)?tw(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":K6(e)?"float32":mc(e)?"string":q6(e)?"bool":"float32"}function Uc(e){return!!(e&&e.constructor&&e.call&&e.apply)}function YI(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Jg(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function X6(e,t,n,r=!1){let s=new Array;if(t.length===1){let a=t[0]*(r?2:1);for(let i=0;i<a;i++)s[i]=n[e+i]}else{let a=t[0],i=t.slice(1),o=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<a;l++)s[l]=X6(e+l*o,i,n,r)}return s}function Vm(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return X6(0,e,t,n)}function Dhe(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function RF(e,t){let n=qC(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function qC(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Fhe(e,t){let n=e.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return Vm(e,new Float32Array(n));if(t==="int32")return Vm(e,new Int32Array(n));if(t==="bool")return Vm(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function ii(e){e.forEach(t=>{Y(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function Ohe(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function Mhe(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function KC(e){return e&&e.then&&typeof e.then=="function"}var rV="tfjsflags",Y6=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Lhe,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(me().getBool("IS_TEST")||me().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let r=this.urlFlags[e];me().getBool("IS_TEST")||me().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(KC(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);rV in e&&e[rV].split(",").forEach(t=>{let[n,r]=t.split(":");this.urlFlags[n]=zhe(n,r)})}};function Lhe(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(Phe(t,r[0],r[1]),r.join("="))),t}function Phe(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function zhe(e,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function me(){return DF}var DF=null;function Bhe(e){DF=e}var n_;function Z6(){if(n_==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");n_=e}return n_}function Whe(){let e=Z6();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function FF(e,t){let n=Whe();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var Qg="Abs",gp="Acos",yp="Acosh",gd="Add",bp="AddN",ey="All",ty="Any",ny="ArgMax",ry="ArgMin",xp="Asin",wp="Asinh",vp="Atan",kp="Atanh",Ip="Atan2",Sp="AvgPool",XC="AvgPoolGrad",sy="AvgPool3D",nw="AvgPool3DGrad",Cp="BatchMatMul",ay="BatchToSpaceND",iy="Bincount",J6="BroadcastTo",rw="BroadcastArgs",Np="Cast",$p="Ceil",yd="ClipByValue",YC="Complex",sw="ComplexAbs",oy="Concat",Tp="Conv2D",ZC="Conv2DBackpropFilter",_p="Conv2DBackpropInput",Ep="Conv3D",ly="Conv3DBackpropFilterV2",uy="Conv3DBackpropInputV2",Ap="Cos",Rp="Cosh",cy="Cumprod",Dp="Cumsum",dy="CropAndResize",aw="DenseBincount",hy="DepthToSpace",Fp="DepthwiseConv2dNative",JC="DepthwiseConv2dNativeBackpropFilter",QC="DepthwiseConv2dNativeBackpropInput",iw="Diag",Op="Dilation2D",dg="Dilation2DBackpropInput",hg="Dilation2DBackpropFilter",Mp="RealDiv",eN="Einsum",Lp="Elu",py="EluGrad",fy="Erf",my="Equal",Pp="Exp",gy="ExpandDims",zp="Expm1",tN="FFT",ow="Fill",yy="FlipLeftRight",Bp="Floor",Wp="FloorDiv",Vp="FusedBatchNorm",by="GatherV2",xy="GatherNd",wy="Greater",Up="GreaterEqual",Gp="Identity",nN="IFFT",rN="Imag",Hp="IsFinite",jp="IsInf",qp="IsNan",Kp="LeakyRelu",vy="Less",ky="LessEqual",Iy="LinSpace",Xp="Log",Yp="Log1p",Sy="LogicalAnd",Cy="LogicalNot",Ny="LogicalOr",Q6="LogicalXor",eq="LogSoftmax",Vhe="LowerBound",Zp="LRN",$y="LRNGrad",Uhe="MatrixBandPart",Jp="Max",Qp="Maximum",ef="MaxPool",sN="MaxPoolGrad",Ty="MaxPool3D",lw="MaxPool3DGrad",aN="MaxPoolWithArgmax",tf="Mean",nf="Min",rf="Minimum",sf="MirrorPad",_y="Mod",Ey="Multinomial",af="Multiply",Ay="Neg",Ry="NotEqual",Dy="NonMaxSuppressionV3",Fy="NonMaxSuppressionV4",Oy="NonMaxSuppressionV5",My="OnesLike",of="OneHot",Ly="Pack",lf="PadV2",Ghe="Pool",uf="Pow",cf="Prelu",df="Prod",iN="RaggedGather",oN="RaggedRange",lN="RaggedTensorToTensor",uw="Range",uN="Real",hf="Reciprocal",pf="Relu",Py="Reshape",ff="ResizeNearestNeighbor",zy="ResizeNearestNeighborGrad",mf="ResizeBilinear",By="ResizeBilinearGrad",gf="Relu6",yf="Reverse",bf="Round",xf="Rsqrt",Wy="ScatterNd",Vy="TensorScatterUpdate",Uy="SearchSorted",Gy="Select",wf="Selu",Hy="Slice",vf="Sin",jy="Sinh",kf="Sign",If="Sigmoid",Sf="Softplus",Cf="Sqrt",Nf="Sum",qy="SpaceToBatchND",Ky="SplitV",$f="Softmax",cw="SparseFillEmptyRows",Xy="SparseReshape",dw="SparseSegmentMean",hw="SparseSegmentSum",Yy="SparseToDense",Tf="SquaredDifference",pw="Square",fw="StaticRegexReplace",Zy="StridedSlice",mw="StringNGrams",gw="StringSplit",yw="StringToHashBucketFast",_f="Sub",Ef="Tan",Af="Tanh",bd="Tile",Jy="TopK",Qy="Transform",Cu="Transpose",bw="Unique",eb="Unpack",xw="UnsortedSegmentSum",Hhe="UpperBound",tb="ZerosLike",xd="Step",ZI="FromPixels",nb="RotateWithOffset",Lh="_FusedMatMul",Ph="FusedConv2D",zh="FusedDepthwiseConv2D";function hc(...e){me().getBool("IS_TEST")||me().getBool("PROD")||console.warn(...e)}function jhe(...e){me().getBool("IS_TEST")||me().getBool("PROD")||console.log(...e)}var pg=FF("kernelRegistry",()=>new Map),p0=FF("gradRegistry",()=>new Map);function JI(e,t){let n=OF(e,t);return pg.get(n)}function nA(e){return p0.get(e)}function QI(e){let t=pg.entries(),n=[];for(;;){let{done:r,value:s}=t.next();if(r)break;let[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function ww(e){let{kernelName:t,backendName:n}=e,r=OF(t,n);pg.has(r)&&hc(`The kernel '${t}' for backend '${n}' is already registered`),pg.set(r,e)}function tq(e){let{kernelName:t}=e;p0.has(t)&&me().getBool("DEBUG")&&hc(`Overriding the gradient for '${t}'`),p0.set(t,e)}function qhe(e,t){let n=OF(e,t);if(!pg.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);pg.delete(n)}function Khe(e){if(!p0.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);p0.delete(e)}function Xhe(e,t){QI(e).forEach(n=>{let r=Object.assign({},n,{backendName:t});ww(r)})}function OF(e,t){return`${t}_${e}`}var _={};Ct(_,{arraysEqual:()=>md,assert:()=>Y,assertNonNegativeIntegerDimensions:()=>ii,assertNonNull:()=>mp,assertShapesMatch:()=>ia,bytesFromStringArray:()=>j6,bytesPerElement:()=>XI,checkConversionForErrors:()=>G6,clamp:()=>h0,computeStrides:()=>Jg,convertBackendValuesAndArrayBuffer:()=>Dhe,createScalarValue:()=>tpe,createShuffledIndices:()=>_he,decodeString:()=>eS,distSquared:()=>Che,encodeString:()=>kw,fetch:()=>rpe,fingerPrint64:()=>epe,flatten:()=>Gc,getArrayFromDType:()=>AF,getTypedArrayFromDType:()=>U6,hasEncodingLoss:()=>Rhe,hexToLong:()=>vw,indexToLoc:()=>Mhe,inferDtype:()=>tw,inferFromImplicitShape:()=>Ahe,isBoolean:()=>q6,isFunction:()=>Uc,isInt:()=>cg,isNumber:()=>K6,isPromise:()=>KC,isScalarShape:()=>Nhe,isString:()=>mc,isTypedArray:()=>fs,isValidDtype:()=>H6,locToIndex:()=>Ohe,makeOnesTypedArray:()=>RF,makeZerosNestedTypedArray:()=>Fhe,makeZerosTypedArray:()=>qC,nearestDivisor:()=>YI,nearestLargerEven:()=>khe,now:()=>f0,parseAxisParam:()=>ko,randUniform:()=>She,repeatedTry:()=>Ehe,rightPad:()=>Bx,shuffle:()=>W6,shuffleCombo:()=>vhe,sizeFromShape:()=>On,sizeToSquarishShape:()=>The,squeezeShape:()=>V6,sum:()=>Ihe,swap:()=>KI,tanh:()=>$he,toNestedArray:()=>Vm,toTypedArray:()=>cN});var sV=fd(she()),ah=sV.default||sV;function vw(e){return ah.fromString(e,!0,16)}var nq=vw("c3a5c85c97cb3127"),nh=vw("b492b66fbe98f273"),qs=vw("9ae16a3b2f90404f");function rA(e){return e.xor(e.shru(47))}function rq(e,t,n){let r=e.slice(t,t+n);return ah.fromBytes(Array.from(r),!0,!0)}function Dn(e,t){return rq(e,t,8)}function aV(e,t){return rq(e,t,4)}function Jr(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Rc(e,t,n=vw("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Yhe(e,t,n,r,s,a){s=s.add(e),a=Jr(a.add(s).add(r),21);let i=s;return s=s.add(t),s=s.add(n),a=a.add(Jr(s,44)),[s.add(r),a.add(i)]}function nk(e,t,n,r){return Yhe(Dn(e,t),Dn(e,t+8),Dn(e,t+16),Dn(e,t+24),n,r)}function Zhe(e,t=e.length){if(t>=8){let n=qs.add(t*2),r=Dn(e,0).add(qs),s=Dn(e,t-8),a=Jr(s,37).mul(n).add(r),i=Jr(r,25).add(s).mul(n);return Rc(a,i,n)}if(t>=4){let n=qs.add(t*2),r=aV(e,0);return Rc(r.shl(3).add(t),aV(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],s=e[t-1],a=n+(r<<8),i=t+(s<<2);return rA(qs.mul(a).xor(nq.mul(i))).mul(qs)}return qs}function Jhe(e,t=e.length){let n=qs.add(t*2),r=Dn(e,0).mul(nh),s=Dn(e,8),a=Dn(e,t-8).mul(n),i=Dn(e,t-16).mul(qs);return Rc(Jr(r.add(s),43).add(Jr(a,30)).add(i),r.add(Jr(s.add(qs),18)).add(a),n)}function Qhe(e,t=e.length){let n=qs.add(t*2),r=Dn(e,0).mul(qs),s=Dn(e,8),a=Dn(e,t-8).mul(n),i=Dn(e,t-16).mul(qs),o=Jr(r.add(s),43).add(Jr(a,30)).add(i),l=Rc(o,r.add(Jr(s.add(qs),18)).add(a),n),u=Dn(e,16).mul(n),c=Dn(e,24),d=o.add(Dn(e,t-32)).mul(n),h=l.add(Dn(e,t-24)).mul(n);return Rc(Jr(u.add(c),43).add(Jr(d,30)).add(h),u.add(Jr(c.add(r),18)).add(d),n)}function epe(e,t=e.length){let n=ah.fromNumber(81,!0);if(t<=32)return t<=16?Zhe(e,t):Jhe(e,t);if(t<=64)return Qhe(e,t);let r=n,s=n.mul(nh).add(113),a=rA(s.mul(qs).add(113)).mul(qs),i=[ah.UZERO,ah.UZERO],o=[ah.UZERO,ah.UZERO];r=r.mul(qs).add(Dn(e,0));let l=0,u=(t-1>>6)*64,c=u+(t-1&63)-63;do r=Jr(r.add(s).add(i[0]).add(Dn(e,l+8)),37).mul(nh),s=Jr(s.add(i[1]).add(Dn(e,l+48)),42).mul(nh),r=r.xor(o[1]),s=s.add(i[0]).add(Dn(e,l+40)),a=Jr(a.add(o[0]),33).mul(nh),i=nk(e,l,i[1].mul(nh),r.add(o[0])),o=nk(e,l+32,a.add(o[1]),s.add(Dn(e,l+16))),[a,r]=[r,a],l+=64;while(l!==u);let d=nh.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Jr(r.add(s).add(i[0]).add(Dn(e,l+8)),37).mul(d),s=Jr(s.add(i[1]).add(Dn(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Dn(e,l+40))),a=Jr(a.add(o[0]),33).mul(d),i=nk(e,l,i[1].mul(d),r.add(o[0])),o=nk(e,l+32,a.add(o[1]),s.add(Dn(e,l+16))),[a,r]=[r,a],Rc(Rc(i[0],o[0],d).add(rA(s).mul(nq)).add(a),Rc(i[1],o[1],d).add(r),d)}function tpe(e,t){return t==="string"?kw(e):cN([e],t)}function npe(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function cN(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Gc(e)),me().getBool("DEBUG")&&G6(e,t),npe(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function f0(){return me().platform.now()}function rpe(e,t){return me().platform.fetch(e,t)}function kw(e,t="utf-8"){return t=t||"utf-8",me().platform.encode(e,t)}function eS(e,t="utf-8"){return t=t||"utf-8",me().platform.decode(e,t)}function fs(e){return me().platform.isTypedArray(e)}function Gc(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||KC(e)||e==null||fs(e)&&n)t.push(e);else if(Array.isArray(e)||fs(e))for(let r=0;r<e.length;++r)Gc(e[r],t,n);else{let r=-1;for(let s of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Gc(e[s],t,n)}return t}var spe=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new ipe)}profileKernel(e,t,n){let r,s=()=>{r=n()},a,i=f0();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let o of r)o.dataSync();a=Promise.resolve({kernelMs:f0()-i})}if(me().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let l=r[o];l.data().then(u=>{ape(u,l.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(o=>o.kernelMs),extraInfo:a.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach(i=>{Promise.all([i.data(),r,a]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],s,o[2])})})}};function ape(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}var ipe=class{logKernelProfile(e,t,n,r,s,a){let i=typeof r=="number"?Bx(`${r}ms`,9):r.error,o=Bx(e,25),l=t.rank,u=t.size,c=Bx(t.shape.toString(),14),d="";for(let h in s){let p=s[h];if(p!=null){let f=p.shape||t.shape,m=f.length;d+=`${h}: ${m}D ${m>0?f:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${c}	%c${u}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function ope(e,t,n){let r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let u=e[l],c=u.inputs;for(let d in c){let h=c[d],p=!1;for(let f=0;f<t.length;f++)if(r[h.id]){u.outputs.forEach(m=>r[m.id]=!0),p=!0,s[u.id]=!0;break}if(p)break}}let a={};a[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let u=e[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(a[u.outputs[d].id]){for(let h in c)a[c[h].id]=!0,i[u.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let u=e[l];if(s[u.id]&&i[u.id]){let c={};for(let h in u.inputs){let p=u.inputs[h];r[p.id]&&(c[h]=p)}let d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,o.push(d)}}return o}function lpe(e,t,n,r){for(let s=t.length-1;s>=0;s--){let a=t[s],i=[];if(a.outputs.forEach(l=>{let u=e[l.id];u!=null?i.push(u):i.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);let o=a.gradient(i);for(let l in a.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let u=n(()=>o[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=a.inputs[l];if(!md(u.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=u;else{let d=e[c.id];e[c.id]=r(d,u),d.dispose()}}}}var iV=20,Qb=3,r_=7;function upe(e,t,n,r){let s=Jg(t),a=cpe(e,t,n,s),i=t.length,o=iI(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join(`
`)),l.join(`
`)}function cpe(e,t,n,r){let s=On(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l=n==="complex64"?mx(e):e;if(o>1)for(let u=0;u<s/a;u++){let c=u*a;for(let d=0;d<a;d++)i[d]=Math.max(i[d],fx(l[c+d],0,n).length)}return i}function fx(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(r_))} + ${parseFloat(e[1].toFixed(r_))}j`:mc(e)?r=`'${e}'`:n==="bool"?r=sq(e):r=parseFloat(e.toFixed(r_)).toString(),Bx(r,t)}function sq(e){return e===0?"false":"true"}function iI(e,t,n,r,s,a=!0){let i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){let m=mx(e);return[fx(m[0],0,n)]}return n==="bool"?[sq(e[0])]:[e[0].toString()]}if(l===1){if(o>iV){let m=Qb*i,g=Array.from(e.slice(0,m)),y=Array.from(e.slice((o-Qb)*i,o*i));return n==="complex64"&&(g=mx(g),y=mx(y)),["["+g.map((b,x)=>fx(b,s[x],n)).join(", ")+", ..., "+y.map((b,x)=>fx(b,s[o-Qb+x],n)).join(", ")+"]"]}return["["+(n==="complex64"?mx(e):Array.from(e)).map((m,g)=>fx(m,s[g],n)).join(", ")+"]"]}let u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>iV){for(let m=0;m<Qb;m++){let g=m*d,y=g+d;h.push(...iI(e.slice(g,y),u,n,c,s,!1))}h.push("...");for(let m=o-Qb;m<o;m++){let g=m*d,y=g+d;h.push(...iI(e.slice(g,y),u,n,c,s,m===o-1))}}else for(let m=0;m<o;m++){let g=m*d,y=g+d;h.push(...iI(e.slice(g,y),u,n,c,s,m===o-1))}let p=l===2?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(a?"":f),h}function mx(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Nr=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=On(e),n!=null){let r=n.length;Y(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||AF(t,this.size),this.strides=Jg(e)}set(e,...t){t.length===0&&(t=[0]),Y(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Oo().makeTensor(this.values,this.shape,this.dtype)}},Oo=null,mm=null;function dpe(e){Oo=e}function hpe(e){mm=e}var Tt=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=On(e),this.strides=Jg(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return mm.buffer(this.shape,this.dtype,e)}bufferSync(){return mm.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Vm(this.shape,e,this.dtype==="complex64")}arraySync(){return Vm(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=Oo().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>eS(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Oo().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Oo().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>eS(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await Oo().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Oo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return mm.print(this,e)}clone(){return this.throwIfDisposed(),mm.clone(this)}toString(e=!1){let t=this.dataSync();return upe(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),mm.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Oo().makeVariable(this,e,t,n)}};Object.defineProperty(Tt,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Se(){return FF("Tensor",()=>Tt)}Se();var Bh=class extends Tt{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!md(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Oo().disposeTensor(this),this.dataId=e.dataId,Oo().incRef(this,null)}dispose(){Oo().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Bh,Symbol.hasInstance,{value:e=>e instanceof Tt&&e.assign!=null&&e.assign instanceof Function});var Go={};Ct(Go,{assertTypesMatch:()=>oq,getTensorsInContainer:()=>MF,isTensorInList:()=>fpe,makeTypesMatch:()=>or});var sA;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(sA||(sA={}));var aA;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(aA||(aA={}));var iA;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(iA||(iA={}));var oA;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(oA||(oA={}));var lA;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(lA||(lA={}));var ppe={float32:oA,int32:aA,bool:iA,complex64:lA};function $i(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return ppe[e][t]}function dN(e){return $i(e,"int32")}function aq(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function iq(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function or(e,t){if(e.dtype===t.dtype)return[e,t];let n=$i(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function oq(e,t){Y(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function fpe(e,t){return t.some(n=>n.id===e.id)}function MF(e){let t=[];return lq(e,t,new Set),t}function lq(e,t,n){if(e==null)return;if(e instanceof Tt){t.push(e);return}if(!mpe(e))return;let r=e;for(let s in r){let a=r[s];n.has(a)||(n.add(a),lq(a,t,n))}}function mpe(e){return Array.isArray(e)||typeof e=="object"}function s_(e){return e.kernelName!=null}var oV=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},m0=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new oV}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(hc(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new spe(this.backendInstance),!0}setupRegisteredKernels(){QI(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){QI(e).forEach(t=>{t.disposeFunc!=null&&t.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(n&&!(n instanceof ew)&&typeof n.then=="function"){let r=++this.pendingBackendInitId,s=n.then(a=>r<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,hc(`Initialization of backend ${e} failed`),hc(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return hc(`Initialization of backend ${e} failed`),hc(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let r;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,n){e();try{let r=n();return t(),r}catch(r){throw t(),r}}nextTensorId(){return m0.nextTensorId++}nextVariableId(){return m0.nextVariableId++}clone(e){let t=ne.runKernel(Gp,{x:e}),n={x:e},r=a=>({x:()=>{let i="float32",o={x:a},l={dtype:i};return ne.runKernel(Np,o,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],r,s,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,JI(e,this.backendName)==null)throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),s=0;n.forEach(o=>{s+=o.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[],r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let o,l=s_(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(s_(e)){let{kernelName:p,inputs:f,attrs:m}=e;this.backendName==null&&this.backend;let g=JI(p,this.backendName);Y(g!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),i=()=>{let y=this.backend.numDataIds();o=g.kernelFunc({inputs:f,attrs:m,backend:this.backend});let b=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,y,b);let x=b.map(w=>w.rank!=null?w:this.makeTensorFromTensorInfo(w));if(r){let w=this.getTensorsForGradient(p,f,x);n=this.saveTensorsForBackwardMode(w)}return x}}else{let{forwardFunc:p}=e,f=m=>{r&&(n=m.map(g=>this.keep(this.clone(g))))};i=()=>{let m=this.backend.numDataIds();o=this.tidy(()=>p(this.backend,f));let g=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,m,g),g}}let{inputs:u,attrs:c}=e,d=s_(e)?null:e.backwardsFunc,h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(h=this.profiler.profileKernel(l,u,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs)}),r&&this.addTapeNode(l,u,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(p=>u[p]!=null?u[p].shape:null),outputShapes:t.map(p=>p.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(e,t,n){let r=nA(e);if(r!=null){let s=r.inputsToSave||[],a=r.outputsToSave||[],i;r.saveAllInputs?(Y(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(l=>t[l])):i=s.map(l=>t[l]);let o=n.filter((l,u)=>a[u]);return i.concat(o)}return[]}makeTensor(e,t,n,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;n==="string"&&mc(e[0])&&(s=e.map(o=>kw(o)));let a=r.write(s,t,n),i=new Tt(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),n==="string"){let o=this.state.tensorInfo.get(a),l=j6(s);this.state.numBytes+=l-o.bytes,o.bytes=l}return i}makeTensorFromDataId(e,t,n,r){n=n||"float32";let s={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:s}=e,a=new Tt(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));let s=new Bh(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*XI(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Bh||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let n=e.size*XI(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,r,s,a){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=nA(e);o!=null&&(r=o.gradFunc),r!=null&&(i.gradient=l=>(l=l.map((u,c)=>{if(u==null){let d=n[c],h=qC(d.size,d.dtype);return this.makeTensor(h,d.shape,d.dtype)}return u}),r(l.length>1?l:l[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=MF(e),n=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let a=this.state.activeScope.track[s];!a.kept&&!n.has(a.id)&&a.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(e,t,n,r=!1){if(Y(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Y(s instanceof Tt,()=>"The result y returned by f() must be a tensor.");let a=ope(this.state.activeTape,t,s);if(!r&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let i={};i[s.id]=n??gpe(s.shape),lpe(i,a,l=>this.tidy(l),ype);let o=t.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let u of l.saved)u.dispose()}),this.state.activeTape=null),{value:s,grads:o}})}customGrad(e){return Y(Uc(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{Y(t.every(i=>i instanceof Tt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,r={};t.forEach((i,o)=>{r[o]=i});let s=(i,o)=>(n=e(...t,o),Y(n.value instanceof Tt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Y(Uc(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(i,o)=>{let l=n.gradFunc(i,o),u=Array.isArray(l)?l:[l];Y(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Y(u.every(d=>d instanceof Tt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let c={};return u.forEach((d,h)=>{c[h]=()=>d}),c};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=f0(),n=await this.backend.time(e);return n.wallMs=f0()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new oV;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};m0.nextTensorId=0;m0.nextVariableId=0;function gpe(e){let t=RF(On(e),"float32");return ne.makeTensor(t,e,"float32")}function uq(){let e=Z6();if(e._tfengine==null){let t=new Y6(e);e._tfengine=new m0(t)}return Bhe(e._tfengine.ENV),dpe(()=>e._tfengine),e._tfengine}var ne=uq();function ype(e,t){let n={a:e,b:t};return ne.runKernel(gd,n)}var Iw={};Ct(Iw,{isBrowser:()=>cq,isMobile:()=>wpe,mockIsMobile:()=>xpe});function bpe(){return typeof navigator<"u"&&navigator!=null}var uA;function xpe(e){uA=e}function wpe(e){if(uA!==void 0)return uA;if(e||bpe()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function cq(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Na=me();Na.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Na.registerFlag("IS_BROWSER",()=>cq());Na.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Na.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Na.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Na.registerFlag("PROD",()=>!1);Na.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Na.getBool("DEBUG"));Na.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Na.registerFlag("IS_TEST",()=>!1);Na.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Na.getBool("DEBUG"));Na.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Na.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Na.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Ul(e,t){let n=e;if(fs(e))return t==="string"?[]:[e.length];if(aq(e)){let s=e.channels||"RGBA";return[e.height,e.width*s.length]}else if(iq(e))return[e.buffer.size/(t==null?4:XI(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||fs(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&me().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&dq(e,r,[]),r}function dq(e,t,n){if(n=n||[],!Array.isArray(e)&&!fs(e)){Y(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}Y(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Y(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let s=0;s<e.length;++s)dq(e[s],r,n.concat(s))}function lV(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function G(e,t,n,r="numeric"){if(e instanceof Tt)return lV(r,e.dtype,t,n),e;let s=tw(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),lV(r,s,t,n),e==null||!fs(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let a=Ul(e,s);!fs(e)&&!Array.isArray(e)&&(e=[e]);let i=s!=="string"?cN(e,s):Gc(e,[],!0);return ne.makeTensor(i,a,s)}function g0(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((s,a)=>G(s,`${t}[${a}]`,n,r))}var LF="__op";function re(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+LF;let s=(...a)=>{ne.startScope(n);try{let i=r(...a);return KC(i)&&console.error("Cannot return a Promise inside of tidy."),ne.endScope(i),i}catch(i){throw ne.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}function vpe(e,t){let n=G(e,"real","complex"),r=G(t,"imag","complex");ia(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let s={real:n,imag:r};return ne.runKernel(YC,s)}var Fu=re({complex_:vpe});function wd(e,t,n,r){if(r==null)r=tw(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(iq(e)||aq(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ne.backend.createTensorFromGPUData(e,t||n,r)}if(!fs(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){ii(t);let s=On(t),a=On(n);Y(s===a,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${a}`);for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1?o!==On(t.slice(i)):!0;Y(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!fs(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?cN(e,r):Gc(e,[],!0),ne.makeTensor(e,t,r)}function Js(e,t,n){let r=Ul(e,n);return wd(e,t,r,n)}var cA={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},tS=4;async function kpe(e,t){let n=[],r=[],s=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<s.length;++i){let o=s[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let c=new Promise(async d=>{let h=await l.bytes(),p=h.reduce((g,y)=>g+y.length,0)+tS*h.length,f=new Uint8Array(p),m=0;for(let g=0;g<h.length;g++){let y=h[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(b,m),m+=tS,f.set(y,m),m+=y.length}d(f)});r.push(c)}else r.push(l.data());t!=null&&(u.group=t),n.push(u)}let a=await Promise.all(r);return{data:Ipe(a),specs:n}}function hq(e,t){let n={},r,s=0;for(let a of t){let i=a.name,o=a.dtype,l=a.shape,u=On(l),c;if("quantization"in a){let d=a.quantization;if(d.dtype==="uint8"||d.dtype==="uint16"){if(!("min"in d&&"scale"in d))throw new Error(`Weight ${a.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else if(d.dtype==="float16"){if(o!=="float32")throw new Error(`Weight ${a.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${o}.`)}else throw new Error(`Weight ${a.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let h=cA[d.dtype],p=e.slice(s,s+u*h),f=d.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(o==="float32")if(d.dtype==="uint8"||d.dtype==="uint16"){c=new Float32Array(f.length);for(let m=0;m<f.length;m++){let g=f[m];c[m]=g*d.scale+d.min}}else if(d.dtype==="float16")r===void 0&&(r=_pe()),c=r(f);else throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);else if(o==="int32"){if(d.dtype!=="uint8"&&d.dtype!=="uint16")throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);c=new Int32Array(f.length);for(let m=0;m<f.length;m++){let g=f[m];c[m]=Math.round(g*d.scale+d.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${o}`);s+=u*h}else if(o==="string"){let d=On(a.shape);c=[];for(let h=0;h<d;h++){let p=new Uint32Array(e.slice(s,s+tS))[0];s+=tS;let f=new Uint8Array(e.slice(s,s+p));c.push(f),s+=p}}else{let d=cA[o],h=e.slice(s,s+u*d);if(o==="float32")c=new Float32Array(h);else if(o==="int32")c=new Int32Array(h);else if(o==="bool")c=new Uint8Array(h);else if(o==="complex64"){c=new Float32Array(h);let p=new Float32Array(c.length/2),f=new Float32Array(c.length/2);for(let y=0;y<p.length;y++)p[y]=c[y*2],f[y]=c[y*2+1];let m=Js(p,l,"float32"),g=Js(f,l,"float32");n[i]=Fu(m,g),m.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${o}`);s+=u*d}o!=="complex64"&&(n[i]=Js(c,l,o))}return n}function Ipe(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});let r=new Uint8Array(t),s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}var PF=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function uV(e){return PF?Buffer.byteLength(e):new Blob([e]).size}function Spe(e){if(PF)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function Cpe(e){if(PF){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function zF(e){if(e.length===1)return e[0];let t=0;e.forEach(s=>{t+=s.byteLength});let n=new Uint8Array(t),r=0;return e.forEach(s=>{n.set(new Uint8Array(s),r),r+=s.byteLength}),n.buffer}function cV(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function pq(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function fq(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function BF(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),fq(e,n,r)}function Sw(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:uV(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:uV(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:e.weightData.byteLength}}function mq(e){let t=[];for(let n of e)t.push(...n.weights);return t}function Npe(){let e=n=>{let r=n<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function $pe(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function Tpe(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function _pe(){let e=Npe(),t=$pe(),n=Tpe();return r=>{let s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){let o=r[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];a[i]=l}return new Float32Array(s)}}var ur=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ur.instance==null&&(ur.instance=new ur),ur.instance}static registerSaveRouter(e){ur.getInstance().saveRouters.push(e)}static registerLoadRouter(e){ur.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return ur.getHandlers(e,"save")}static getLoadHandlers(e,t){return ur.getHandlers(e,"load",t)}static getHandlers(e,t,n){let r=[];return(t==="load"?ur.getInstance().loadRouters:ur.getInstance().saveRouters).forEach(s=>{let a=s(e,n);a!==null&&r.push(a)}),r}},Epe=e=>ur.registerSaveRouter(e),Ape=e=>ur.registerLoadRouter(e),Rpe=e=>ur.getSaveHandlers(e),Dpe=(e,t)=>ur.getLoadHandlers(e,t),dA="tensorflowjs",hA=1,gh="models_store",gc="model_info_store";function gq(){if(!me().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function pA(e){let t=e.result;t.createObjectStore(gh,{keyPath:"modelPath"}),t.createObjectStore(gc,{keyPath:"modelPath"})}var Wh=class{constructor(e){if(this.indexedDB=gq(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{let s=this.indexedDB.open(dA,hA);s.onupgradeneeded=()=>pA(s),s.onsuccess=()=>{let a=s.result;if(t==null){let i=a.transaction(gh,"readonly"),o=i.objectStore(gh).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(a.close(),r(o.error)),i.oncomplete=()=>a.close()}else{let i=Sw(t),o=a.transaction(gc,"readwrite"),l=o.objectStore(gc),u;try{u=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(d){return r(d)}let c;u.onsuccess=()=>{c=a.transaction(gh,"readwrite");let d=c.objectStore(gh),h;try{h=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(p){return r(p)}h.onsuccess=()=>n({modelArtifactsInfo:i}),h.onerror=p=>{l=o.objectStore(gc);let f=l.delete(this.modelPath);f.onsuccess=()=>(a.close(),r(h.error)),f.onerror=m=>(a.close(),r(h.error))}},u.onerror=d=>(a.close(),r(u.error)),o.oncomplete=()=>{c==null?a.close():c.oncomplete=()=>a.close()}}},s.onerror=a=>r(s.error)})}};Wh.URL_SCHEME="indexeddb://";var yq=e=>me().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Wh.URL_SCHEME)?Fpe(e.slice(Wh.URL_SCHEME.length)):null;ur.registerSaveRouter(yq);ur.registerLoadRouter(yq);function Fpe(e){return new Wh(e)}function Ope(e){return e.startsWith(Wh.URL_SCHEME)?e.slice(Wh.URL_SCHEME.length):e}var Mpe=class{constructor(){this.indexedDB=gq()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(dA,hA);n.onupgradeneeded=()=>pA(n),n.onsuccess=()=>{let r=n.result,s=r.transaction(gc,"readonly"),a=s.objectStore(gc).getAll();a.onsuccess=()=>{let i={};for(let o of a.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},a.onerror=i=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=Ope(e),new Promise((t,n)=>{let r=this.indexedDB.open(dA,hA);r.onupgradeneeded=()=>pA(r),r.onsuccess=()=>{let s=r.result,a=s.transaction(gc,"readwrite"),i=a.objectStore(gc),o=i.get(e),l;o.onsuccess=()=>{if(o.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let u=i.delete(e),c=()=>{l=s.transaction(gh,"readwrite");let d=l.objectStore(gh).delete(e);d.onsuccess=()=>t(o.result.modelArtifactsInfo),d.onerror=h=>n(o.error)};u.onsuccess=c,u.onerror=d=>(c(),s.close(),n(o.error))}},o.onerror=u=>(s.close(),n(o.error)),a.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},r.onerror=s=>n(r.error)})}},xu="/",gm="tensorflowjs_models",bq="info",Lpe="model_topology",Ppe="weight_specs",zpe="weight_data",Bpe="model_metadata";function xq(e){return{info:[gm,e,bq].join(xu),topology:[gm,e,Lpe].join(xu),weightSpecs:[gm,e,Ppe].join(xu),weightData:[gm,e,zpe].join(xu),modelMetadata:[gm,e,Bpe].join(xu)}}function wq(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function Wpe(e){let t=e.split(xu);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(xu)}function Vpe(e){return e.startsWith(Vh.URL_SCHEME)?e.slice(Vh.URL_SCHEME.length):e}var Vh=class{constructor(e){if(!me().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=xq(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=Sw(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,Spe(e.weightData));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch{throw wq(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let i=JSON.parse(s);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Cpe(a),t}};Vh.URL_SCHEME="localstorage://";var vq=e=>me().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Vh.URL_SCHEME)?Upe(e.slice(Vh.URL_SCHEME.length)):null;ur.registerSaveRouter(vq);ur.registerLoadRouter(vq);function Upe(e){return new Vh(e)}var Gpe=class{constructor(){Y(me().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Y(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=gm+xu,n=xu+bq;for(let r=0;r<this.LS.length;++r){let s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){let a=Wpe(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=Vpe(e);let t=xq(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return wq(t),n}},Um="://",ga=class{constructor(){this.managers={}}static getInstance(){return ga.instance==null&&(ga.instance=new ga),ga.instance}static registerManager(e,t){Y(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Um)&&(e=e.slice(0,e.indexOf(Um))),Y(e.length>0,()=>"scheme must not be an empty string.");let n=ga.getInstance();Y(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=ga.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(ga.getInstance().managers)}};function oI(e){if(e.indexOf(Um)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ga.getSchemes().join(",")}`);return{scheme:e.split(Um)[0],path:e.split(Um)[1]}}async function kq(e,t,n=!1){Y(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=ur.getLoadHandlers(e);Y(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),Y(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let s=r[0],a=ur.getSaveHandlers(t);Y(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),Y(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let i=a[0],o=oI(e).scheme,l=oI(e).path,u=o===oI(e).scheme,c=await s.load();n&&u&&await ga.getManager(o).removeModel(l);let d=await i.save(c);return n&&!u&&await ga.getManager(o).removeModel(l),d.modelArtifactsInfo}async function Hpe(){let e=ga.getSchemes(),t={};for(let n of e){let r=await ga.getManager(n).listModels();for(let s in r){let a=n+Um+s;t[a]=r[s]}}return t}async function jpe(e){let t=oI(e);return ga.getManager(t.scheme).removeModel(t.path)}async function qpe(e,t){return kq(e,t,!1)}async function Kpe(e,t){return kq(e,t,!0)}var Xpe=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!me().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let r=this.functionRefs[n.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}};if(me().get("IS_BROWSER")){me().setPlatform("browser",new Xpe);try{ga.registerManager(Vh.URL_SCHEME,new Gpe)}catch{}try{ga.registerManager(Wh.URL_SCHEME,new Mpe)}catch{}}var Ype={importFetch:()=>ahe()},a_,Zpe=class{constructor(){this.util=ihe(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return me().global.fetch!=null?me().global.fetch(e,t):(a_==null&&(a_=Ype.importFetch()),a_(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};me().get("IS_NODE")&&!me().get("IS_BROWSER")&&me().setPlatform("node",new Zpe);function Ot(e,t="float32",n){return t=t||"float32",ii(e),new Nr(e,t,n)}function Jpe(e,t){let n=G(e,"x","cast");if(!H6(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},s={dtype:t};return ne.runKernel(Np,r,s)}var Me=re({cast_:Jpe});function Qpe(e){let t={x:G(e,"x","clone","string_or_numeric")};return ne.runKernel(Gp,t)}var Fl=re({clone_:Qpe});function WF(e,t=!1){console.log(e.toString(t))}uq();var efe={buffer:Ot,cast:Me,clone:Fl,print:WF};hpe(efe);function tfe(){me().set("PROD",!0)}function nfe(){me().set("DEBUG",!0)}function rfe(){me().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Iq(e){me().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function sfe(){ne.disposeVariables()}function Xi(){return ne}function nS(){return ne.memory()}function afe(e){return ne.profile(e)}function ue(e,t){return ne.tidy(e,t)}function St(e){MF(e).forEach(t=>t.dispose())}function Or(e){return ne.keep(e)}function ife(e){return ne.time(e)}function ofe(e){return ne.setBackend(e)}function lfe(){return ne.ready()}function ufe(){return ne.backendName}function cfe(e){ne.removeBackend(e)}function dfe(e){return ne.findBackend(e)}function hfe(e){return ne.findBackendFactory(e)}function hN(e,t,n=1){return ne.registerBackend(e,t,n)}function Sq(){return ne.backend}function pfe(e,t){me().setPlatform(e,t)}function ffe(e,t){let n=G(e,"a","add"),r=G(t,"b","add");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(gd,s)}var Ie=re({add_:ffe});function mfe(e,t){let n=G(e,"a","floorDiv"),r=G(t,"b","floorDiv");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(Wp,s)}var pN=re({floorDiv_:mfe});function gfe(e,t){let n=G(e,"a","div"),r=G(t,"b","div");if([n,r]=or(n,r),n.dtype==="int32"&&r.dtype==="int32")return pN(n,r);let s={a:n,b:r},a={};return ne.runKernel(Mp,s,a)}var tt=re({div_:gfe});function yfe(e,t){let n=G(e,"a","mul"),r=G(t,"b","mul");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(af,s)}var ae=re({mul_:yfe});function bfe(e){let t=G(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return ne.runKernel(sw,n)}else{let n={x:t};return ne.runKernel(Qg,n)}}var Ir=re({abs_:bfe});function xfe(e){let t={x:G(e,"x","acos")};return ne.runKernel(gp,t)}var VF=re({acos_:xfe});function wfe(e){let t={x:G(e,"x","acosh")};return ne.runKernel(yp,t)}var UF=re({acosh_:wfe});function vfe(e){Y(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),Y(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((s,a)=>G(s,`tensors${a}`,"addN")),n=t[0];t.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!md(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return ne.runKernel(bp,r)}var Cq=re({addN_:vfe});function kfe(e,t=null,n=!1){let r={x:G(e,"x","all","bool")},s={axis:t,keepDims:n};return ne.runKernel(ey,r,s)}var fN=re({all_:kfe});function Ife(e,t=null,n=!1){let r={x:G(e,"x","any","bool")},s={axis:t,keepDims:n};return ne.runKernel(ty,r,s)}var y0=re({any_:Ife});function Sfe(e,t=0){let n={x:G(e,"x","argMax")},r={axis:t};return ne.runKernel(ny,n,r)}var Uh=re({argMax_:Sfe});function Cfe(e,t=0){let n={x:G(e,"x","argMin")},r={axis:t};return ne.runKernel(ry,n,r)}var GF=re({argMin_:Cfe});function Nfe(e){let t={x:G(e,"x","asin")};return ne.runKernel(xp,t)}var HF=re({asin_:Nfe});function $fe(e){let t={x:G(e,"x","asinh")};return ne.runKernel(wp,t)}var jF=re({asinh_:$fe});function Tfe(e){let t={x:G(e,"x","atan")};return ne.runKernel(vp,t)}var qF=re({atan_:Tfe});function _fe(e,t){let n=G(e,"a","atan2"),r=G(t,"b","atan2");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(Ip,s)}var KF=re({atan2_:_fe});function Efe(e){let t={x:G(e,"x","atanh")};return ne.runKernel(kp,t)}var XF=re({atanh_:Efe});function Afe(e,t,n,r,s="NHWC",a){let i=e[3],o=[...t,i],l=Tq(s);return Cw(e,o,n,a,r,null,null,l)}function Nq(e,t,n,r,s,a,i="channelsLast"){let[o,l]=b0(t),u;if(i==="channelsLast")u=[o,l,e[3],e[3]];else if(i==="channelsFirst")u=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return Cw(e,u,n,r,s,a,!1,i)}function Rfe(e,t,n,r,s,a,i="NDHWC"){let[o,l,u]=fA(t),c,d;if(i==="NDHWC")d="channelsLast",c=[o,l,u,e[4],e[4]];else if(i==="NCDHW")d="channelsFirst",c=[o,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return $q(e,c,n,r,s,!1,d,a)}function Cw(e,t,n,r,s,a,i=!1,o="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,d]=e;else if(o==="channelsFirst")[l,d,u,c]=e;else throw new Error(`Unknown dataFormat ${o}`);let[h,p,,f]=t,[m,g]=b0(n),[y,b]=b0(r),x=Gm(h,y),w=Gm(p,b),{padInfo:v,outHeight:k,outWidth:I}=Ofe(s,u,c,m,g,x,w,a,o),S=i?f*d:f,$;return o==="channelsFirst"?$=[l,S,k,I]:o==="channelsLast"&&($=[l,k,I,S]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:k,outWidth:I,outChannels:S,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:e,outShape:$,filterShape:t}}function $q(e,t,n,r,s,a=!1,i="channelsLast",o){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,d,h]=e;else if(i==="channelsFirst")[l,h,u,c,d]=e;else throw new Error(`Unknown dataFormat ${i}`);let[p,f,m,,g]=t,[y,b,x]=fA(n),[w,v,k]=fA(r),I=Gm(p,w),S=Gm(f,v),$=Gm(m,k),{padInfo:N,outDepth:T,outHeight:C,outWidth:E}=Mfe(s,u,c,d,y,b,x,I,S,$,o),M=a?g*h:g,F;return i==="channelsFirst"?F=[l,M,T,C,E]:i==="channelsLast"&&(F=[l,T,C,E,M]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:T,outHeight:C,outWidth:E,outChannels:M,padInfo:N,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:S,effectiveFilterWidth:$,dilationDepth:w,dilationHeight:v,dilationWidth:k,inShape:e,outShape:F,filterShape:t}}function Dfe(e,t,n,r,s){r==null&&(r=YF(e,t,n));let a=e[0],i=e[1],o=x0((a-t+2*r)/n+1,s),l=x0((i-t+2*r)/n+1,s);return[o,l]}function Ffe(e,t,n,r,s,a){s==null&&(s=YF(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=x0((e[o]-t[o]+2*s)/r[o]+1,a));return i}function YF(e,t,n,r=1){let s=Gm(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function b0(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function fA(e){return typeof e=="number"?[e,e,e]:e}function Gm(e,t){return t<=1?e:e+(e-1)*(t-1)}function Ofe(e,t,n,r,s,a,i,o,l){let u,c,d;if(typeof e=="number"){u={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let h=Dfe([t,n],a,r,e,o);c=h[0],d=h[1]}else if(e==="same"){c=Math.ceil(t/r),d=Math.ceil(n/s);let h=Math.max(0,(c-1)*r+a-t),p=Math.max(0,(d-1)*s+i-n),f=Math.floor(h/2),m=h-f,g=Math.floor(p/2),y=p-g;u={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(e==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),d=Math.ceil((n-i+1)/s);else if(typeof e=="object"){let h=l==="channelsLast"?e[1][0]:e[2][0],p=l==="channelsLast"?e[1][1]:e[2][1],f=l==="channelsLast"?e[2][0]:e[3][0],m=l==="channelsLast"?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:h===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},c=x0((t-a+h+p)/r+1,o),d=x0((n-i+f+m)/s+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:c,outWidth:d}}function Mfe(e,t,n,r,s,a,i,o,l,u,c){let d,h,p,f;if(e==="valid"&&(e=0),typeof e=="number"){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let m=Ffe([t,n,r,1],[o,l,u],1,[s,a,i],e,c);h=m[0],p=m[1],f=m[2]}else if(e==="same"){h=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);let m=(h-1)*s+o-t,g=(p-1)*a+l-n,y=(f-1)*i+u-r,b=Math.floor(m/2),x=m-b,w=Math.floor(g/2),v=g-w,k=Math.floor(y/2),I=y-k;d={top:w,bottom:v,left:k,right:I,front:b,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}function x0(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Hc(e){let[t,n,r]=b0(e);return t===1&&n===1&&r===1}function Kl(e,t){return Hc(e)||Hc(t)}function Gh(e){return b0(e).every(t=>t>0)}function Tq(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function oa(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")Y(cg(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(s=>{Y(cg(s),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function Lfe(e,t){let n={x:G(e,"x","reshape","string_or_numeric")},r={shape:t};return ne.runKernel(Py,n,r)}var oe=re({reshape_:Lfe});function Pfe(e,t,n,r,s){let a=G(e,"x","avgPool","float32"),i=1;Y(Kl(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=a,l=!1;a.rank===3&&(l=!0,o=oe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Y(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),oa("avgPool",r,s);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=ne.runKernel(Sp,u,c);return d=Me(d,a.dtype),l?oe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Vu=re({avgPool_:Pfe});function zfe(e,t,n,r,s,a="NDHWC"){let i=G(e,"x","avgPool3d","float32"),o=i,l=!1;i.rank===4&&(l=!0,o=oe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),Y(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Y(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),oa("avgPool3d",r,s);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=ne.runKernel(sy,u,c);return d=Me(d,o.dtype),l?oe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var ZF=re({avgPool3d_:zfe});function Bfe(e,t=0){Y(e.length>=1,()=>"Pass at least one tensor to concat");let n=g0(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return Fl(n[0]);let r=n,s={axis:t};return ne.runKernel(oy,r,s)}var In=re({concat_:Bfe});function Wfe(e,t,n=!1,r=!1){let s=G(e,"a","matMul"),a=G(t,"b","matMul");[s,a]=or(s,a);let i={a:s,b:a},o={transposeA:n,transposeB:r};return ne.runKernel(Cp,i,o)}var At=re({matMul_:Wfe});function Vfe(e){let t={x:G(e,"x","sigmoid","float32")};return ne.runKernel(If,t)}var ho=re({sigmoid_:Vfe});function Ufe(e,t,n){let r=G(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let s={x:r},a={begin:t,size:n};return ne.runKernel(Hy,s,a)}var Vt=re({slice_:Ufe});function Gfe(e){let t={x:G(e,"x","tanh","float32")};return ne.runKernel(Af,t)}var Hh=re({tanh_:Gfe});function Hfe(e,t,n,r,s,a){let i=G(e,"forgetBias","basicLSTMCell"),o=G(t,"lstmKernel","basicLSTMCell"),l=G(n,"lstmBias","basicLSTMCell"),u=G(r,"data","basicLSTMCell"),c=G(s,"c","basicLSTMCell"),d=G(a,"h","basicLSTMCell"),h=In([u,d],1),p=At(h,o),f=Ie(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Vt(f,[0,0],y),x=Vt(f,[0,g],y),w=Vt(f,[0,g*2],y),v=Vt(f,[0,g*3],y),k=Ie(ae(ho(b),Hh(x)),ae(c,ho(Ie(i,w)))),I=ae(Hh(k),ho(v));return[k,I]}var _q=re({basicLSTMCell_:Hfe});function jfe(e,t,n){let r=G(e,"x","batchToSpaceND"),s=t.reduce((o,l)=>o*l);Y(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),Y(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Y(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);let a={x:r},i={blockShape:t,crops:n};return ne.runKernel(ay,a,i)}var Nw=re({batchToSpaceND_:jfe});function qfe(e){let t;return e.rank===0||e.rank===1?t=oe(e,[1,1,1,e.size]):e.rank===2?t=oe(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=oe(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function Kfe(e,t,n,r,s,a){a==null&&(a=.001);let i=G(e,"x","batchNorm"),o=G(t,"mean","batchNorm"),l=G(n,"variance","batchNorm"),u;s!=null&&(u=G(s,"scale","batchNorm"));let c;r!=null&&(c=G(r,"offset","batchNorm")),Y(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Y(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Y(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:qfe(i),scale:u,offset:c,mean:o,variance:l},h={varianceEpsilon:a},p=ne.runKernel(Vp,d,h);return oe(p,i.shape)}var Rf=re({batchNorm_:Kfe});function Xfe(e,t,n,r,s,a){let i=G(e,"x","batchNorm"),o=G(t,"mean","batchNorm"),l=G(n,"variance","batchNorm"),u;s!=null&&(u=G(s,"scale","batchNorm"));let c;return r!=null&&(c=G(r,"offset","batchNorm")),Y(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),Y(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),Y(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&Y(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&Y(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Rf(i,o,l,c,u,a)}var JF=re({batchNorm2d_:Xfe});function Yfe(e,t,n,r,s,a){let i=G(e,"x","batchNorm"),o=G(t,"mean","batchNorm"),l=G(n,"variance","batchNorm"),u;s!=null&&(u=G(s,"scale","batchNorm"));let c;return r!=null&&(c=G(r,"offset","batchNorm")),Y(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),Y(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),Y(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&Y(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&Y(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Rf(i,o,l,c,u,a)}var QF=re({batchNorm3d_:Yfe});function Zfe(e,t,n,r,s,a){let i=G(e,"x","batchNorm"),o=G(t,"mean","batchNorm"),l=G(n,"variance","batchNorm"),u;s!=null&&(u=G(s,"scale","batchNorm"));let c;return r!=null&&(c=G(r,"offset","batchNorm")),Y(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),Y(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),Y(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&Y(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&Y(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Rf(i,o,l,c,u,a)}var eO=re({batchNorm4d_:Zfe});function Jfe(e,t,n){let r=G(e,"x","bincount"),s=G(t,"weights","bincount");Y(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),Y(n>=0,()=>`size must be non-negative, but got ${n}.`),Y(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);let a={x:r,weights:s},i={size:n};return ne.runKernel(iy,a,i)}var tO=re({bincount_:Jfe});function Qfe(e,t){let n=G(e,"s0","broadcastArgs","int32"),r=G(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let s={s0:n,s1:r};return ne.runKernel(rw,s)}var Eq=re({broadcastArgs_:Qfe});function eme(e,t){let n=G(e,"broadcastTo","x"),r=n.shape;if(ii(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=oe(n,l)}let s=n.shape,a=Array.from(t);for(let l=t.length-1;l>=0;l--)if(s[l]===t[l])a[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(a.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return Fl(n);let i={x:n},o={reps:a};return ne.runKernel(bd,i,o)}var Sh=re({broadcastTo_:eme});function tme(e){let t={x:G(e,"x","ceil","float32")};return ne.runKernel($p,t)}var nO=re({ceil_:tme});function Ya(e,t,n){ii(e),n=n||tw(t);let r={shape:e,value:t,dtype:n};return ne.runKernel(ow,{},r)}function nme(e,t,n){let r=G(e,"x","clipByValue");if(Y(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Ya(r.shape,t,r.dtype);let s={x:r},a={clipValueMin:t,clipValueMax:n};return ne.runKernel(yd,s,a)}var Ms=re({clipByValue_:nme});function rme(e){return In(e,0)}var rO=re({concat1d_:rme});function sme(e,t){return In(e,t)}var sO=re({concat2d_:sme});function ame(e,t){return In(e,t)}var aO=re({concat3d_:ame});function ime(e,t){return In(e,t)}var iO=re({concat4d_:ime});function ome(e,t,n,r,s="NHWC",a=[1,1],i){let o=G(e,"x","conv2d","float32"),l=G(t,"filter","conv2d","float32"),u=o,c=!1;o.rank===3&&(c=!0,u=oe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),Y(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),oa("conv2d",r,i);let d=s==="NHWC"?u.shape[3]:u.shape[1];Y(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),Y(Kl(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Y(Gh(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),Y(Gh(n),()=>"Error in conv2D: Strides should be larger than 0.");let h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=ne.runKernel(Tp,h,p);return c?oe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var ea=re({conv2d_:ome});function lme(e,t,n,r,s="NWC",a=1,i){let o=G(e,"x","conv1d"),l=G(t,"filter","conv1d"),u=o,c=!1;o.rank===2&&(c=!0,u=oe(o,[1,o.shape[0],o.shape[1]])),Y(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),Y(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),oa("conv1d",r,i),Y(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),Y(Kl(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),Y(Gh(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),Y(Gh(n),()=>"Error in conv1D: Stride should be larger than 0."),Y(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);let d=oe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=oe(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=ea(h,d,[1,n],r,"NHWC",[1,a],i);return c?oe(p,[p.shape[2],p.shape[3]]):oe(p,[p.shape[0],p.shape[2],p.shape[3]])}var mN=re({conv1d_:lme});function ume(e,t,n,r,s,a="NHWC",i){Y(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;t.rank===3&&(u=!0,l=oe(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Y(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),Y(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),Y(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let c=a==="NHWC"?o[3]:o[1],d=a==="NHWC"?l.shape[3]:l.shape[1];Y(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),Y(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),oa("conv2dDerInput",s,i);let h={dy:l,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=ne.runKernel(_p,h,p);return u?oe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var oO=re({conv2DBackpropInput_:ume});function cme(e,t,n,r,s,a){let i=G(e,"x","conv2dTranspose"),o=G(t,"filter","conv2dTranspose");return oO(n,i,o,r,s,"NHWC",a)}var gN=re({conv2dTranspose_:cme});function dme(e,t,n,r,s="NDHWC",a=[1,1,1]){let i=G(e,"x","conv3d"),o=G(t,"filter","conv3d"),l=i,u=!1;i.rank===4&&(u=!0,l=oe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),Y(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),Y(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),Y(Kl(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Y(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),Y(Gh(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),Y(Gh(n),()=>"Error in conv3D: Strides should be larger than 0.");let c={x:l,filter:o},d={strides:n,pad:r,dataFormat:s,dilations:a},h=ne.runKernel(Ep,c,d);return u?oe(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var lO=re({conv3d_:dme});function hme(e,t,n,r,s){Y(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,i=t,o=!1;t.rank===4&&(o=!0,i=oe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);let l=a[4],u=i.shape[4];Y(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),Y(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),Y(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),Y(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),Y(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);let c={dy:i,filter:n},d={pad:s,strides:r,inputShape:a},h=ne.runKernel(uy,c,d);return o?oe(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var Aq=re({conv3DBackpropInput_:hme});function pme(e,t,n,r,s){let a=G(e,"x","conv3dTranspose"),i=G(t,"filter","conv3dTranspose");return Aq(n,a,i,r,s)}var uO=re({conv3dTranspose_:pme});function fme(e){let t={x:G(e,"x","cos","float32")};return ne.runKernel(Ap,t)}var $w=re({cos_:fme});function mme(e){let t={x:G(e,"x","cosh","float32")};return ne.runKernel(Rp,t)}var yN=re({cosh_:mme});function gme(e,t=0,n=!1,r=!1){let s={x:G(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return ne.runKernel(cy,s,a)}var w0=re({cumprod_:gme});function yme(e,t=0,n=!1,r=!1){let s={x:G(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return ne.runKernel(Dp,s,a)}var bN=re({cumsum_:yme});function bme(e,t,n,r=!1){let s=G(e,"x","denseBincount"),a=G(t,"weights","denseBincount");Y(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),Y(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),Y(n>=0,()=>`size must be non-negative, but got ${n}.`),Y(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);let i={x:s,weights:a},o={size:n,binaryOutput:r};return ne.runKernel(aw,i,o)}var rS=re({denseBincount_:bme});function xme(e,t,n="NHWC"){let r=G(e,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];Y(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),Y(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),Y(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${r.shape}`),Y(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);let o={x:r},l={blockSize:t,dataFormat:n};return ne.runKernel(hy,o,l)}var cO=re({depthToSpace_:xme});function wme(e,t,n,r,s="NHWC",a=[1,1],i){let o=G(e,"x","depthwiseConv2d","float32"),l=G(t,"filter","depthwiseConv2d","float32"),u=o,c=!1;o.rank===3&&(c=!0,u=oe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),Y(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let d=s==="NHWC"?u.shape[3]:u.shape[1];Y(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),oa("depthwiseConv2d",r,i);let h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=ne.runKernel(Fp,h,p);return c?oe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Df=re({depthwiseConv2d_:wme});function vme(e){let t={x:G(e,"x","diag")};return ne.runKernel(iw,t)}var Rq=re({diag_:vme});function kme(e,t,n,r,s=[1,1],a="NHWC"){let i=G(e,"x","dilation2d"),o=G(t,"filter","dilation2d");Y(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),Y(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),Y(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=i,u=!1;i.rank===3&&(l=oe(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Y(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let c={x:l,filter:o},d={strides:n,pad:r,dilations:s},h=ne.runKernel(Op,c,d);return u?oe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var dO=re({dilation2d_:kme}),rb={};Ct(rb,{assertAndGetBroadcastShape:()=>Sn,getBroadcastDims:()=>Dq,getReductionAxes:()=>Tr});function Dq(e,t){let n=e.length,r=[];for(let s=0;s<n;s++){let a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&i===1&&r.unshift(a)}return r}function Tr(e,t){let n=[];for(let r=0;r<t.length;r++){let s=e[e.length-r-1],a=t.length-r-1,i=t[a];(s==null||s===1&&i>1)&&n.unshift(a)}return n}function Sn(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];a==null&&(a=1);let i=t[t.length-s-1];if(i==null&&(i=1),a===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=a;else if(a!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else r[n-s-1]=a}return r}function Ime(e,t){let n=G(e,"a","equal","string_or_numeric"),r=G(t,"b","equal","string_or_numeric");[n,r]=or(n,r),Sn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(my,s)}var Ja=re({equal_:Ime});function Sme(e,t,n){let r=G(t,"a","where"),s=G(n,"b","where"),a=G(e,"condition","where","bool"),i=Sn(Sn(a.shape,r.shape),s.shape),o=Sh(a,i),l=Sh(r,i),u=Sh(s,i),c={condition:o,t:l,e:u};return ne.runKernel(Gy,c)}var ss=re({where_:Sme});function Cme(e){let t={x:G(e,"x","zerosLike")};return ne.runKernel(tb,t)}var Ht=re({zerosLike_:Cme});function Nme(e,t){let n=G(e,"a","div"),r=G(t,"b","div");[n,r]=or(n,r);let s=tt(n,r),a=Ht(s),i=Ja(r,a);return ss(i,a,s)}var hO=re({divNoNan_:Nme});function $me(e,t){let n=G(e,"t1","dot"),r=G(t,"t2","dot");Y((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(Y(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){let i=oe(n,[1,-1]),o=oe(r,[-1,1]),l=At(i,o);return oe(l,[])}else if(n.rank===1&&r.rank===2){let i=oe(n,[1,-1]),o=oe(r,[r.shape[0],r.shape[1]]),l=At(i,o);return oe(l,[l.size])}else if(n.rank===2&&r.rank===1){let i=oe(r,[-1,1]),o=At(n,i);return oe(o,[o.size])}else{let i=oe(r,[r.shape[0],r.shape[1]]);return At(n,i)}}var pO=re({dot_:$me});function Tme(e,...t){let n=t.map((s,a)=>G(s,`tensors${a}`,"einsum")),r={equation:e};return ne.runKernel(eN,n,r)}var Fq=re({einsum_:Tme});function _me(e){let t={x:G(e,"x","elu","float32")};return ne.runKernel(Lp,t)}var sb=re({elu_:_me});function Eme(e){let t=G(e,"x","erf");Y(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Me(t,"float32"));let n={x:t};return ne.runKernel(fy,n)}var fO=re({erf_:Eme});function mO(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Oq(e,t,n){let r=e.length+t.length,s=[],a=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?s.push(e[a++]):s.push(t[i++]);return s}function Mq(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);let s=t.map(a=>e[a]);return[n,s]}function jh(e,t){let n=t.map(r=>1);return Oq(e,n,t)}function Ame(e,t,n){Y(mO(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function Lq(e,t){if(mO(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function gO(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function Rme(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function Dme(e,t=null,n=!1){let r={x:G(e,"x","max")},s={reductionIndices:t,keepDims:n};return ne.runKernel(Jp,r,s)}var Ci=re({max_:Dme});function Fme(e,t=null,n=!1){let r={x:G(e,"x","min")},s={axis:t,keepDims:n};return ne.runKernel(nf,r,s)}var fg=re({min_:Fme});function Ome(e,t){let n=G(e,"base","pow"),r=G(t,"exp","pow");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(uf,s)}var Ou=re({pow_:Ome});function mt(e,t){if((fs(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&fs(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return wd(e,[],[],t)}function Mme(e){let t={x:G(e,"x","sqrt","float32")};return ne.runKernel(Cf,t)}var ks=re({sqrt_:Mme});function Lme(e){let t=G(e,"x","square"),n={};return ne.runKernel("Square",{x:t},n)}var vn=re({square_:Lme});function Pme(e,t=null,n=!1){let r=G(e,"x","sum");r.dtype==="bool"&&(r=Me(r,"int32"));let s={x:r},a={axis:t,keepDims:n};return ne.runKernel(Nf,s,a)}var st=re({sum_:Pme});function zme(e,t="euclidean",n=null,r=!1){e=G(e,"x","norm");let s=Pq(e,t,n),a=s.shape;if(r){let i=ko(n,e.shape);a=jh(s.shape,i)}return oe(s,a)}function Pq(e,t,n=null){if(e.rank===0)return Ir(e);if(e.rank!==1&&n===null)return Pq(oe(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return st(Ir(e),n);if(t===1/0)return Ci(Ir(e),n);if(t===-1/0)return fg(Ir(e),n);if(t==="euclidean"||t===2)return ks(st(Ou(Ir(e),mt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Ci(st(Ir(e),n[0]),n[1]-1);if(t===1/0)return Ci(st(Ir(e),n[1]),n[0]);if(t===-1/0)return fg(st(Ir(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return ks(st(vn(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var ab=re({norm_:zme});function Bme(e,t=null,n=!1){return ab(e,"euclidean",t,n)}var yO=re({euclideanNorm_:Bme});function Wme(e){let t={x:G(e,"x","exp")};return ne.runKernel(Pp,t)}var ta=re({exp_:Wme});function Vme(e,t=0){let n=G(e,"x","expandDims","string_or_numeric");Y(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},s={dim:t};return ne.runKernel(gy,r,s)}var ms=re({expandDims_:Vme});function Ume(e){let t={x:G(e,"x","expm1")};return ne.runKernel(zp,t)}var bO=re({expm1_:Ume});function Gme(e,t){let n=G(e,"x","tile","string_or_numeric");Y(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},s={reps:t};return ne.runKernel(bd,r,s)}var Ga=re({tile_:Gme});function Hme(e,t,n,r="float32"){t==null&&(t=e);let s=Ot([e,t],r),a=e<=t?e:t;for(let o=0;o<a;++o)s.set(1,o,o);let i=oe(s.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Ga(ms(i,0),[n[0],1,1]);if(n.length===2)return Ga(ms(ms(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Ga(ms(ms(ms(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var xN=re({eye_:Hme});function jme(e){let t={x:G(e,"x","floor","float32")};return ne.runKernel(Bp,t)}var ib=re({floor_:jme});function qme(e,t,n=0,r=0){let s=G(e,"x","gather"),a=G(t,"indices","gather","int32"),i={x:s,indices:a},o={axis:n,batchDims:r};return ne.runKernel(by,i,o)}var ob=re({gather_:qme});function Kme(e,t){let n=G(e,"a","greater","string_or_numeric"),r=G(t,"b","greater","string_or_numeric");[n,r]=or(n,r),Sn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(wy,s)}var la=re({greater_:Kme});function Xme(e,t){let n=G(e,"a","greaterEqual","string_or_numeric"),r=G(t,"b","greaterEqual","string_or_numeric");[n,r]=or(n,r),Sn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(Up,s)}var Uu=re({greaterEqual_:Xme});function Yme(e){let t={input:G(e,"input","imag")};return ne.runKernel(rN,t)}var Tw=re({imag_:Yme});function Zme(e){let t={x:G(e,"x","isFinite")};return ne.runKernel(Hp,t)}var xO=re({isFinite_:Zme});function Jme(e){let t={x:G(e,"x","isInf")};return ne.runKernel(jp,t)}var wO=re({isInf_:Jme});function Qme(e){let t={x:G(e,"x","isNaN")};return ne.runKernel(qp,t)}var vO=re({isNaN_:Qme});function ege(e,t=.2){let n={x:G(e,"x","leakyRelu")},r={alpha:t};return ne.runKernel(Kp,n,r)}var _w=re({leakyRelu_:ege});function tge(e,t){let n=G(e,"a","less","string_or_numeric"),r=G(t,"b","less","string_or_numeric");[n,r]=or(n,r),Sn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(vy,s)}var mg=re({less_:tge});function nge(e,t){let n=G(e,"a","lessEqual","string_or_numeric"),r=G(t,"b","lessEqual","string_or_numeric");[n,r]=or(n,r),Sn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(ky,s)}var vd=re({lessEqual_:nge});function zq(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return ne.runKernel(Iy,{},r)}function rge(e,t=5,n=1,r=1,s=.5){let a=G(e,"x","localResponseNormalization");Y(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),Y(cg(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=a,o=!1;a.rank===3&&(o=!0,i=oe(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:s},c=ne.runKernel(Zp,l,u);return o?oe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var kO=re({localResponseNormalization_:rge});function sge(e){let t={x:G(e,"x","log","float32")};return ne.runKernel(Xp,t)}var Qa=re({log_:sge});function age(e){let t={x:G(e,"x","log1p")};return ne.runKernel(Yp,t)}var Ew=re({log1p_:age});function ige(e){return Y(Uc(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=G(t,"x","tf.grad","string_or_numeric"),s=n!=null?G(n,"dy","tf.grad"):null;return ne.tidy(()=>{let{value:a,grads:i}=ne.gradients(()=>e(r),[r],s);return s!=null&&ia(a.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),wN(i),i[0]})}}function oge(e){return Y(Uc(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{Y(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=g0(t,"args","tf.grads","string_or_numeric"),s=n!=null?G(n,"dy","tf.grads"):null;return ne.tidy(()=>{let{value:a,grads:i}=ne.gradients(()=>e(...r),r,s);return s!=null&&ia(a.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),wN(i),i})}}function lge(e){return Y(Uc(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{Y(t instanceof Tt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),Y(n==null||n instanceof Tt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:s}=ne.gradients(()=>e(t),[t],n);return wN(r),{grad:r[0],value:s}}}function uge(e){return Y(Uc(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{Y(Array.isArray(t)&&t.every(s=>s instanceof Tt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),Y(n==null||n instanceof Tt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=ne.gradients(()=>e(...t),t,n);return n!=null&&ia(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),wN(r.grads),r}}function Bq(e,t){Y(Uc(e),()=>"The f passed in variableGrads(f) must be a function"),Y(t==null||Array.isArray(t)&&t.every(u=>u instanceof Bh),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let u in ne.registeredVariables)t.push(ne.registeredVariables[u])}let r=n?t.filter(u=>!u.trainable):null,s=t.length;t=t.filter(u=>u.trainable),Y(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);let a=!0,{value:i,grads:o}=ne.gradients(e,t,null,a);Y(o.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Y(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((u,c)=>{o[c]!=null&&(l[u.name]=o[c])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:i,grads:l}}function Gl(e){return ne.customGrad(e)}function wN(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function cge(e){let t={x:G(e,"x","neg")};return ne.runKernel(Ay,t)}var Mn=re({neg_:cge});function dge(e){let t={x:G(e,"x","softplus")};return ne.runKernel(Sf,t)}var Ff=re({softplus_:dge});function hge(e){let t=G(e,"x","logSigmoid");return Gl(n=>({value:Mn(Ff(Mn(n))),gradFunc:r=>ae(r,ho(Mn(n)))}))(t)}var IO=re({logSigmoid_:hge});function pge(e,t){let n=G(e,"a","sub"),r=G(t,"b","sub");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(_f,s)}var qe=re({sub_:pge});function fge(e,t=-1){let n=G(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Gl((r,s)=>{let a=Ci(r,t,!0),i=qe(r,a),o=qe(Me(i,"float32"),Qa(st(ta(i),t,!0)));return s([o]),{value:o,gradFunc:(l,u)=>{let[c]=u,d=!0,h=ta(c);return qe(l,ae(st(l,t,d),h))}}})(n)}var vN=re({logSoftmax_:fge});function mge(e,t=null,n=!1){let r=G(e,"x","logSumExp"),s=ko(t,r.shape),a=Ci(r,s,!0),i=qe(r,a),o=ta(i),l=st(o,s),u=Qa(l),c=Ie(oe(a,u.shape),u);if(n){let d=jh(c.shape,s);return oe(c,d)}return c}var kN=re({logSumExp_:mge});function gge(e,t){let n=G(e,"a","logicalAnd","bool"),r=G(t,"b","logicalAnd","bool");Sn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(Sy,s)}var yo=re({logicalAnd_:gge});function yge(e){let t={x:G(e,"x","logicalNot","bool")};return ne.runKernel(Cy,t)}var Aw=re({logicalNot_:yge});function bge(e,t){let n=G(e,"a","logicalOr","bool"),r=G(t,"b","logicalOr","bool");Sn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(Ny,s)}var IN=re({logicalOr_:bge});function xge(e,t){let n=G(e,"a","logicalXor","bool"),r=G(t,"b","logicalXor","bool");return Sn(n.shape,r.shape),yo(IN(e,t),Aw(yo(e,t)))}var SO=re({logicalXor_:xge}),rk=2147483648;function wge(e,t,n="left"){let r=G(e,"sortedSequence","searchSorted"),s=G(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=oe(r,[-1,a]),l=oe(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(On(l.shape)>=rk)throw new Error(`values tensor size must less than ${rk}`);if(o.shape[1]>=rk)throw new Error(`trailing dim_size must less than ${rk} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},c={side:n};return ne.runKernel(Uy,u,c)}var SN=re({searchSorted_:wge});function Wq(e,t){return SN(e,t,"left")}function vge(e,t,n,r,s){let a=G(e,"x","maxPool"),i=1,o=a,l=!1;a.rank===3&&(l=!0,o=oe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Y(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),Y(Kl(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),oa("maxPool",r,s);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=ne.runKernel(ef,u,c);return l?oe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Yr=re({maxPool_:vge});function kge(e,t=[1,1,1],n,r,s,a="NDHWC"){let i=G(e,"x","maxPool3d"),o=i,l=!1;i.rank===4&&(l=!0,o=oe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),Y(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),oa("maxPool3d",r,s);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=ne.runKernel(Ty,u,c);return l?oe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var CO=re({maxPool3d_:kge});function Ige(e,t,n,r,s=!1){let a={x:G(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=ne.runKernel(aN,a,i);return{result:o[0],indexes:o[1]}}var Vq=re({maxPoolWithArgmax_:Ige});function Sge(e,t){let n=G(e,"a","maximum"),r=G(t,"b","maximum");[n,r]=or(n,r),n.dtype==="bool"&&(n=Me(n,"int32"),r=Me(r,"int32")),Sn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(Qp,s)}var Xl=re({maximum_:Sge});function Cge(e,t=null,n=!1){let r={x:G(e,"x","mean")},s={axis:t,keepDims:n};return ne.runKernel(tf,r,s)}var rr=re({mean_:Cge});function sr(e,t="float32"){if(ii(e),t==="complex64"){let r=sr(e,"float32"),s=sr(e,"float32");return Fu(r,s)}let n=qC(On(e),t);return ne.makeTensor(n,e,t)}function Ha(e,t="float32"){if(ii(e),t==="complex64"){let r=Ha(e,"float32"),s=sr(e,"float32");return Fu(r,s)}let n=RF(On(e),t);return ne.makeTensor(n,e,t)}function Uq(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=G(e,"x","meshgrid",e instanceof Tt?e.dtype:"float32");if(t===void 0)return[r];let s=G(t,"y","meshgrid",t instanceof Tt?t.dtype:"float32"),a=On(r.shape),i=On(s.shape);return n==="xy"?(r=oe(r,[1,-1]),s=oe(s,[-1,1]),[At(Ha([i,1],r.dtype),r),At(s,Ha([1,a],s.dtype))]):(r=oe(r,[-1,1]),s=oe(s,[1,-1]),[At(r,Ha([1,i],r.dtype)),At(Ha([a,1],s.dtype),s)])}function Nge(e,t){let n=G(e,"a","minimum"),r=G(t,"b","minimum");[n,r]=or(n,r),n.dtype==="bool"&&(n=Me(n,"int32"),r=Me(r,"int32")),Sn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(rf,s)}var jc=re({minimum_:Nge});function $ge(e,t,n){Y(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=G(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Y(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let s=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)Y(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Y(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`);let a={paddings:t,mode:n},i={x:r};return ne.runKernel(sf,i,a)}var NO=re({mirrorPad_:$ge});function Tge(e,t){let n=G(e,"a","mod"),r=G(t,"b","mod");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(_y,s)}var $O=re({mod_:Tge});function _ge(e,t=null,n=!1){e=G(e,"x","moments");let r=ko(t,e.shape),s=rr(e,r,n),a=s.shape;n||(a=jh(s.shape,r));let i=vn(qe(Me(e,"float32"),oe(s,a))),o=rr(i,r,n);return{mean:s,variance:o}}var Rw=re({moments_:_ge});function Ege(e,t,n,r){let s=G(t,"data","multiRNNCell"),a=g0(n,"c","multiRNNCell"),i=g0(r,"h","multiRNNCell"),o=s,l=[];for(let d=0;d<e.length;d++){let h=e[d](o,a[d],i[d]);l.push(h[0]),l.push(h[1]),o=h[1]}let u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}var Gq=re({multiRNNCell_:Ege});function Age(e,t,n,r=!1){let s=G(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?oe(s,[1,-1]):s},l={numSamples:t,seed:n,normalized:r},u=ne.runKernel(Ey,o,l);return i===1?oe(u,[u.size]):u}var Hq=re({multinomial_:Age});function Rge(e,t){let n=G(e,"a","notEqual","string_or_numeric"),r=G(t,"b","notEqual","string_or_numeric");[n,r]=or(n,r),Sn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(Ry,s)}var qh=re({notEqual_:Rge});function Dge(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let a={indices:G(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return ne.runKernel(of,a,i)}var gg=re({oneHot_:Dge});function Fge(e){let t={x:G(e,"x","onesLike")};return ne.runKernel(My,t)}var ei=re({onesLike_:Fge});function Oge(e,t){let n=G(e,"v1","outerProduct"),r=G(t,"v2","outerProduct");Y(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let s=oe(n,[-1,1]),a=oe(r,[1,-1]);return At(s,a)}var jq=re({outerProduct_:Oge});function Mge(e,t,n=0){let r=G(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let s={paddings:t,constantValue:n},a={x:r};return ne.runKernel(lf,a,s)}var ll=re({pad_:Mge});function Lge(e,t,n=0){return Y(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),ll(e,[t],n)}var qq=re({pad1d_:Lge});function Pge(e,t,n=0){return Y(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ll(e,t,n)}var Kq=re({pad2d_:Pge});function zge(e,t,n=0){return Y(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ll(e,t,n)}var Xq=re({pad3d_:zge});function Bge(e,t,n=0){return Y(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ll(e,t,n)}var Yq=re({pad4d_:Bge});function Wge(e,t,n){let r=G(e,"x","spaceToBatchND");Y(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),Y(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Y(r.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let s={x:r},a={blockShape:t,paddings:n};return ne.runKernel(qy,s,a)}var Dw=re({spaceToBatchND_:Wge});function Vge(e,t,n,r,s,a,i){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");let o=G(e,"x","maxPool"),l=o,u=!1;o.rank===3&&(u=!0,l=oe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(Kl(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);let c=Nq(l.shape,t,a,s,r),d=[c.dilationHeight,c.dilationWidth],h;r==="same"?h=Gge([c.filterHeight,c.filterWidth],d):h=[[0,0],[0,0]];let p=d[0]===1&&d[1]===1,[f,m]=Uge([c.inHeight,c.inWidth],d,h),g=p?r:"valid",y=p?l:Dw(l,d,f),b=(n==="avg"?()=>Vu(y,t,a,g,i):()=>Yr(y,t,a,g,i))(),x=p?b:Nw(b,d,m);return u?oe(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function Uge(e,t,n){let r=n.map(c=>c[0]),s=n.map(c=>c[1]),a=e.concat(r,s),i=t.map((c,d)=>(c-a[d]%c)%c),o=s.map((c,d)=>c+i[d]),l=t.map((c,d)=>[r[d],o[d]]),u=t.map((c,d)=>[0,i[d]]);return[l,u]}function Gge(e,t){let n=e.map((a,i)=>a+(a-1)*(t[i]-1)).map(a=>a-1),r=n.map(a=>Math.floor(a/2)),s=n.map((a,i)=>a-r[i]);return n.map((a,i)=>[r[i],s[i]])}var TO=re({pool_:Vge});function Hge(e,t){let n=G(e,"x","prelu"),r=G(t,"alpha","prelu"),s={x:n,alpha:r};return ne.runKernel(cf,s)}var Fw=re({prelu_:Hge});function jge(e,t=null,n=!1){let r=G(e,"x","prod");r.dtype==="bool"&&(r=Me(r,"int32"));let s={x:r},a={axis:t,keepDims:n};return ne.runKernel(df,s,a)}var _O=re({prod_:jge});function qge(e,t,n,r){let s=e.map((c,d)=>G(c,`tensors${d}`,"raggedGather","int32")),a=G(t,"paramsDenseValues","raggedGather"),i=G(n,"indices","raggedGather","int32"),o={paramsNestedSplits:s,paramsDenseValues:a,indices:i},l={outputRaggedRank:r},u=ne.runKernel(iN,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var Zq=re({raggedGather_:qge});function Kge(e,t,n){let r=G(e,"starts","raggedRange"),s=G(t,"limits","raggedRange",r.dtype),a=G(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:s,deltas:a},o=ne.runKernel(oN,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var Jq=re({raggedRange_:Kge});function Xge(e,t,n,r,s){let a=G(e,"shape","raggedTensorToTensor","int32"),i=G(t,"values","raggedTensorToTensor"),o=G(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((d,h)=>G(d,`tensors${h}`,"raggedTensorToTensor","int32")),u={shape:a,values:i,defaultValue:o,rowPartitionTensors:l},c={rowPartitionTypes:s};return ne.runKernel(lN,u,c)}var Qq=re({raggedTensorToTensor_:Xge});function Yge(e,t,n){ii(e);let r=On(e),s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<r;a++)s[a]=t();return ne.makeTensor(s,e,n)}var e8=re({rand_:Yge}),EO=fd(HC()),t8={};Ct(t8,{TEST_EPSILON_FLOAT16:()=>n8,createVideoElement:()=>sye,encodeStrings:()=>r8,expectArrayBuffersEqual:()=>rye,expectArraysClose:()=>Jge,expectArraysEqual:()=>eye,expectNumbersClose:()=>tye,expectPromiseToFail:()=>Qge,expectValuesInRange:()=>nye,play:()=>aye,testEpsilon:()=>AO});var Zge=.001,n8=.1;function Jge(e,t,n){return n==null&&(n=AO()),mA(e,t,(r,s)=>RO(r,s,n))}function AO(){return ne.backend.floatPrecision()===32?Zge:n8}function mA(e,t,n){let r=!0;if((fs(e)||fs(t))&&(r=!1),fs(e)&&fs(t)&&(r=!0),r){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=Ul(e),o=Ul(t);if(!md(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let s=fs(e)?e:Gc(e),a=fs(t)?t:Gc(t);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.
Actual:   ${s}.
Expected: ${a}.`);for(let i=0;i<a.length;++i){let o=s[i],l=a[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.
Actual:   ${s}.
Expected: ${a}.`)}typeof expect<"u"&&expect().nothing()}function Qge(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function eye(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return mc(e)||mc(e[0])||mc(t)||mc(t[0])?mA(e,n,(r,s)=>r==s):mA(e,t,(r,s)=>RO(r,s,0))}function tye(e,t,n){if(n==null&&(n=AO()),!RO(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function RO(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function nye(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function rye(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let s=0;s<r.length;s++)if(n[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${n[s]} instead`)}function r8(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?r8(n):e[t]=kw(n)}return e}function sye(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",r=>n(t)),t.load()})}async function aye(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var DO=class{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=s||Math.random();this.random=EO.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,s,a;do r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s;while(a>=1||a===0);let i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},iye=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let s=r||Math.random();this.randu=EO.alea(s.toString()),this.randn=new DO(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},oye=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=EO.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function lye(e,t,n=1,r="float32",s){if(ii(e),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let a=new iye(t,n,r,s),i=Ot(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}var s8=re({randomGamma_:lye});function uye(e,t=0,n=1,r,s){if(ii(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let a=new DO(t,n,r,!1,s),i=Ot(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}var CN=re({randomNormal_:uye});function cye(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return CN(e,0,1,t,n)}var a8=re({randomStandardNormal_:cye});function dye(e,t=0,n=1,r="float32",s){ii(e);let a=Ot(e,r),i=new oye(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}var lb=re({randomUniform_:dye});function Kh(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let s={start:e,stop:t,step:n,dtype:r};return ne.runKernel(uw,{},s)}function hye(e){let t={input:G(e,"input","real")};return ne.runKernel(uN,t)}var yg=re({real_:hye});function pye(e){let t={x:G(e,"x","reciprocal")};return ne.runKernel(hf,t)}var FO=re({reciprocal_:pye});function fye(e){let t={x:G(e,"x","relu")};return ne.runKernel(pf,t)}var yn=re({relu_:fye});function mye(e){let t={x:G(e,"x","relu6")};return ne.runKernel(gf,t)}var NN=re({relu6_:mye});function gye(e,t){let n={x:G(e,"x","reverse")},r={dims:t};return ne.runKernel(yf,n,r)}var Ti=re({reverse_:gye});function yye(e){let t=G(e,"x","reverse");return Y(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Ti(t,0)}var i8=re({reverse1d_:yye});function bye(e,t){let n=G(e,"x","reverse");return Y(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Ti(n,t)}var o8=re({reverse2d_:bye});function xye(e,t){let n=G(e,"x","reverse");return Y(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Ti(n,t)}var l8=re({reverse3d_:xye});function wye(e,t){let n=G(e,"x","reverse");return Y(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Ti(n,t)}var u8=re({reverse4d_:wye});function vye(e){let t={x:G(e,"x","round")};return ne.runKernel(bf,t)}var $N=re({round_:vye});function kye(e){let t={x:G(e,"x","rsqrt","float32")};return ne.runKernel(xf,t)}var TN=re({rsqrt_:kye});function Iye(e){let t={x:G(e,"x","selu")};return ne.runKernel(wf,t)}var _N=re({selu_:Iye});function Sye(e,t,n,r,s,a=[1,1],i="NHWC"){let o=G(e,"x","separableConv2d"),l=G(t,"depthwiseFilter","separableConv2d"),u=G(n,"pointwiseFilter","separableConv2d"),c=o,d=!1;if(o.rank===3&&(d=!0,c=oe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Y(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),Y(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),Y(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),Y(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),Y(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let h=l.shape[2],p=l.shape[3];Y(u.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`);let f=Df(c,l,r,s,i,a),m=ea(f,u,1,"valid",i);return d?oe(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var ub=re({separableConv2d_:Sye});async function Cye(e,t){let n=G(e,"x","setdiff1d"),r=G(t,"y","setdiff1d");Y(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),Y(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),Y(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let s=await n.data(),a=await r.data(),i=new Set(a),o=0;for(let c=0;c<s.length;c++)i.has(s[c])||o++;let l=new Nr([o],n.dtype),u=new Nr([o],"int32");for(let c=0,d=0;c<s.length;c++)i.has(s[c])||(l.values[d]=s[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]}var c8=Cye;function Nye(e){let t={x:G(e,"x","sign")};return ne.runKernel(kf,t)}var OO=re({sign_:Nye});function $ye(e){let t={x:G(e,"x","sin","float32")};return ne.runKernel(vf,t)}var EN=re({sin_:$ye});function Tye(e){let t={x:G(e,"x","sinh")};return ne.runKernel(jy,t)}var AN=re({sinh_:Tye});function _ye(e,t,n){let r=G(e,"x","slice1d");return Y(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Vt(r,[t],[n])}var Ow=re({slice1d_:_ye});function Eye(e,t,n){let r=G(e,"x","slice2d");return Y(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Vt(r,t,n)}var RN=re({slice2d_:Eye});function Aye(e,t,n){let r=G(e,"x","slice3d");return Y(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Vt(r,t,n)}var cb=re({slice3d_:Aye});function Rye(e,t,n){let r=G(e,"x","slice4d");return Y(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Vt(r,t,n)}var bg=re({slice4d_:Rye});function Dye(e,t=-1){let n=G(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},s={dim:t};return ne.runKernel($f,r,s)}var kd=re({softmax_:Dye});function Fye(e){Y(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return ne.runKernel(tN,t)}var Mw=re({fft_:Fye});function Oye(e){Y(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return ne.runKernel(nN,t)}var xg=re({ifft_:Oye});function Mye(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let s=oe(e,[n,t]);r=xg(s)}else{let s=[n,2*(t-1)],a=oe(yg(e),[n,t]),i=oe(Tw(e),[n,t]),o=Ti(Vt(a,[0,1],[n,t-2]),1),l=ae(Ti(Vt(i,[0,1],[n,t-2]),1),mt(-1)),u=In([a,o],1),c=In([i,l],1),d=oe(Fu(u,c),[s[0],s[1]]);r=xg(d)}if(r=yg(r),e.rank===3&&e.shape[0]!==0){let s=r,a=e.shape[0];r=oe(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}var DN=re({irfft_:Mye});function Lye(e,t,n=0){let r={x:G(e,"x","split")},s={numOrSizeSplits:t,axis:n};return ne.runKernel(Ky,r,s)}var Sa=re({split_:Lye});function Pye(e,t){Y(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,s;if(t!=null&&t<n){let f=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,s=Vt(e,f,m),n=t}else if(t!=null&&t>n){let f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,s=In([e,sr(f)],e.shape.length-1),n=t}else s=e;let a=Ht(s),i=oe(Fu(s,a),[r,n]),o=Mw(i),l=Math.floor(n/2)+1,u=yg(o),c=Tw(o),d=Sa(u,[l,n-l],u.shape.length-1),h=Sa(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,oe(Fu(d[0],h[0]),p)}var Lw=re({rfft_:Pye});function zye(e,t){let n=G(e,"a","squaredDifference"),r=G(t,"b","squaredDifference");[n,r]=or(n,r),Sn(n.shape,r.shape);let s={a:n,b:r},a={};return ne.runKernel(Tf,s,a)}var FN=re({squaredDifference_:zye});function Bye(e,t){let n=G(e,"x","squeeze","string_or_numeric");return oe(n,V6(n.shape,t).newShape)}var Id=re({squeeze_:Bye});function Wye(e,t=0){let n=g0(e,"tensors","stack","string_or_numeric");Y(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Y(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,s={axis:t};return ne.runKernel(Ly,r,s)}var zr=re({stack_:Wye});function Vye(e,t=0){let n={x:G(e,"x","step")},r={alpha:t};return ne.runKernel(xd,n,r)}var Of=re({step_:Vye});function Uye(e,t,n,r,s=0,a=0,i=0,o=0,l=0){let u={x:G(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return ne.runKernel(Zy,u,c)}var MO=re({stridedSlice_:Uye});function Gye(e){let t={x:G(e,"x","tan","float32")};return ne.runKernel(Ef,t)}var LO=re({tan_:Gye});function gn(e,t){mp(e);let n=Ul(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return wd(e,null,n,t)}function Ol(e,t,n){if(mp(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=Ul(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return wd(e,t,r,n)}function ON(e,t,n){if(mp(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=Ul(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return wd(e,t,r,n)}function qc(e,t,n){if(mp(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=Ul(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return wd(e,t,r,n)}function d8(e,t,n){if(mp(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=Ul(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return wd(e,t,r,n)}function h8(e,t,n){if(mp(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=Ul(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,wd(e,t,r,n)}var MN={};Ct(MN,{calculateShapes:()=>p8,validateInput:()=>LN,validateUpdateShape:()=>PO});function PO(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+` update.rank != ${s+e.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function LN(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}PO(n,t,e)}function p8(e,t,n){let r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length,i=1;for(let d=s;d<a;++d)i*=n[d];let o=s<1?1:s,l=On(t.shape)/o,u=[...Jg(n.slice(0,s)),1],c=On(n);return{sliceRank:s,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}function Hye(e,t,n){let r=G(e,"tensor","tensorScatterupdate"),s=G(t,"indices","tensorScatterupdate","int32"),a=G(n,"updates","tensorScatterupdate");if(LN(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);let i={tensor:r,indices:s,updates:a},o={};return ne.runKernel(Vy,i,o)}var f8=re({tensorScatterUpdate_:Hye});function jye(e,t=1,n=!0){let r=G(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);let a={x:r},i={k:t,sorted:n},[o,l]=ne.runKernel(Jy,a,i);return{values:o,indices:l}}var zO=re({topk_:jye});function qye(e,t=0,n=1,r,s){if(ii(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let a=new DO(t,n,r,!0,s),i=Ot(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}var PN=re({truncatedNormal_:qye});function Kye(e,t=0){let n=G(e,"x","unique","string_or_numeric");Y(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},s={axis:t},[a,i]=ne.runKernel(bw,r,s);return{values:a,indices:i}}var BO=re({unique_:Kye});function Xye(e,t,n){let r=G(e,"x","unsortedSegmentSum"),s=G(t,"segmentIds","unsortedSegmentSum","int32");Y(cg(n),()=>"numSegments must be of dtype int");let a={x:r,segmentIds:s},i={numSegments:n};return ne.runKernel(xw,a,i)}var zN=re({unsortedSegmentSum_:Xye});function Yye(e,t=0){let n=G(e,"x","unstack","string_or_numeric");Y(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},s={axis:t};return ne.runKernel(eb,r,s)}var fr=re({unstack_:Yye});function m8(e,t){return SN(e,t,"right")}function WO(e,t=!0,n,r){return ne.makeVariable(e,t,n,r)}function g8(e,t){let n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);let r=Ot(e,"int32"),s=Ot([n.length,e.length],"int32");for(let a=0;a<n.length;a++){let i=r.indexToLoc(n[a]),o=a*e.length;s.values.set(i,o)}return s.toTensor()}async function Zye(e){let t=G(e,"condition","whereAsync","bool"),n=await t.data(),r=g8(t.shape,n);return e!==t&&t.dispose(),r}var VO=Zye;async function Jye(e,t,n){let r=G(e,"tensor","boolMask"),s=G(t,"mask","boolMask","bool"),a=n??0,i=s.rank,o=r.shape;Y(i>0,()=>"mask cannot be scalar"),ia(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=a;m<a+i;m++)l*=o[m];let u=o.slice(0,a).concat([l],o.slice(a+i)),c=oe(r,u),d=oe(s,[-1]),h=await VO(d),p=Id(h,[1]),f=ob(c,p,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f}var y8=Jye;function Qye(e,t,n){let r=G(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),Y(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{Y(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let s={x:r},a={perm:t};return r.dtype==="complex64"?ue(()=>{let i=yg(r),o=Tw(r);return i=ne.runKernel(Cu,{x:i},a),o=ne.runKernel(Cu,{x:o},a),n&&(o=Mn(o)),Fu(i,o)}):ne.runKernel(Cu,s,a)}var Ft=re({transpose_:Qye});function ebe(e,t,n,r,s=!0){let a=G(e,"v","movingAverage"),i=G(t,"x","movingAverage"),o=G(n,"decay","movingAverage");oq(a,i),Y(md(a.shape,i.shape),()=>"Shape mismatch in v and x");let l=mt(1),u=qe(l,o),c=ae(qe(i,a),u);if(s){Y(r!=null,()=>"When using zeroDebias: true, step is required.");let d=G(r,"step","movingAverage");c=tt(c,qe(l,Ou(o,d)))}return Ie(a,c)}var b8=re({movingAverage_:ebe});function tbe(e,t,n){ii(n);let r=G(e,"indices","scatterND","int32"),s=G(t,"updates","scatterND");LN(s,r,n);let a={indices:r,updates:s},i={shape:n};return ne.runKernel(Wy,a,i)}var x8=re({scatterND_:tbe});function nbe(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function rbe(e,t,n,r=0){ii(n);let s=G(e,"sparseIndices","sparseToDense","int32"),a=G(t,"sparseValues","sparseToDense","string_or_numeric"),i=G(r,"defaultValue","sparseToDense",a.dtype);nbe(s,a,n,i);let o={sparseIndices:s,sparseValues:a,defaultValue:i},l={outputShape:n};return ne.runKernel(Yy,o,l)}var w8=re({sparseToDense_:rbe});function sbe(e,t){let n=G(t,"indices","gatherND","int32"),r={params:G(e,"x","gatherND","string_or_numeric"),indices:n};return ne.runKernel(xy,r)}var v8=re({gatherND_:sbe});function abe(e,t){if(t==null)return e.shape.slice();if(md(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function ibe(e,t,n,r){let s=G(e,"x","dropout");if(Y(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),Y(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Tt?s.clone():s;let a=abe(s,n),i=1-t,o=tt(ib(Ie(lb(a,0,1,"float32",r),i)),i);return ae(s,o)}var UO=re({dropout_:ibe});function GO(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function BN(e,t,n){let r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){let i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return gn(s,"float32")}async function obe(e,t,n=1){let r=G(e,"predictions","inTopK"),s=G(t,"targets","inTopK");Y(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),Y(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),ia(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let a=r.shape[r.shape.length-1];Y(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);let i=await r.data(),o=await s.data(),[l,u]=[i.length/a,a],c=U6("bool",l);for(let d=0;d<l;d++){let h=d*u,p=i.subarray(h,h+u),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,g)=>g.value-m.value),c[d]=0;for(let m=0;m<n;m++)if(f[m].index===o[d]){c[d]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),Js(c,s.shape,"bool")}var k8=obe,wg={};Ct(wg,{conv2d:()=>cbe,depthwiseConv2d:()=>fbe,matMul:()=>gbe});function lbe(e,t,n,r,s,a="NHWC",i){let o=e;e.rank===3&&(o=oe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=oe(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Y(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),Y(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),Y(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let u=a==="NHWC"?o.shape[3]:o.shape[1],c=a==="NHWC"?l.shape[3]:l.shape[1];Y(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),Y(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),oa("conv2dDerFilter",s,i);let d={x:o,dy:l},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return ne.runKernel(ZC,d,h)}var HO=re({conv2DBackpropFilter_:lbe});function WN(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return ae(e,Of(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function VN(e,t){let n=t,r=Tr(e.shape,t.shape);return r.length>0&&(n=st(n,r)),oe(n,e.shape)}function UN(e,t,n,r){if(t==="linear")return e;if(t==="relu")return yn(e);if(t==="elu")return sb(e);if(t==="relu6")return NN(e);if(t==="prelu")return Fw(e,n);if(t==="leakyrelu")return _w(e,r);if(t==="sigmoid")return ho(e);throw new Error(`Unknown fused activation ${t}.`)}var GN=(e,t)=>!(e>0)||t==="linear";function ube({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",GN(ne.state.gradientDepth,l)===!1){Y(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=ea(e,t,n,r,s,a,i);return o!=null&&(k=Ie(k,o)),UN(k,l,u,c)}let d=G(e,"x","conv2d","float32"),h=G(t,"filter","conv2d","float32"),p=d,f=!1;d.rank===3&&(f=!0,p=oe(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Y(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),Y(h.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),oa("fused conv2d",r,i);let m=s==="NHWC"?p.shape[3]:p.shape[1];Y(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),Y(Kl(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let g=Cw(p.shape,h.shape,n,a,r,i),y;o!=null&&(y=G(o,"bias","fused conv2d"),[y]=or(y,d),s==="NHWC"?Sn(g.outShape,y.shape):(Y(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),Y(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(u!=null){let k=u.shape;if(Y(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)Y(k[0]===1||k[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${g.outChannels}).`);else if(k.length===3)try{Sn(k,g.outShape)}catch{let S=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(S)}b=G(u,"prelu weights","fused conv2d")}let x=(k,I)=>{Y(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);let[S,$,N,T]=I,C=WN(k,N,l);Y(Hc(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let E=oO($.shape,C,S,n,r),M=HO($,C,S.shape,n,r),F=[E,M];if(T!=null){let z=VN(T,C);F.push(z)}return F},w={x:p,filter:h,bias:y,preluActivationWeights:b},v={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?Gl((k,I,S)=>{let $=ne.runKernel(Ph,w,v);return S([I,k,$]),f&&($=oe($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:x}})(p,h):Gl((k,I,S,$)=>{let N=ne.runKernel(Ph,w,v);return $([I,k,N,S]),f&&(N=oe(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:x}})(p,h,y)}var cbe=re({fusedConv2d_:ube});function dbe(e,t,n,r,s,a=[1,1],i){let o=e;e.rank===3&&(o=oe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=oe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return ne.runKernel(JC,u,c)}var I8=re({depthwiseConv2dNativeBackpropFilter_:dbe});function hbe(e,t,n,r,s,a=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=oe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},d=ne.runKernel(QC,u,c);return l?oe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var S8=re({depthwiseConv2dNativeBackpropInput_:hbe});function pbe({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(GN(ne.state.gradientDepth,l)===!1){let v=Df(e,t,n,r,s,a,i);return o!=null&&(v=Ie(v,o)),UN(v,l,u,c)}let d=G(e,"x","depthwiseConv2d","float32"),h=G(t,"filter","depthwiseConv2d","float32"),p=d,f=!1;d.rank===3&&(f=!0,p=oe(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Y(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),Y(h.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),Y(p.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),a==null&&(a=[1,1]),Y(Kl(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),oa("fused depthwiseConv2d",r,i);let m=Cw(p.shape,h.shape,n,a,r,i,!0),g;o!=null&&(g=G(o,"bias","fused conv2d"),[g]=or(g,d),Sn(m.outShape,g.shape));let y;u!=null&&(y=G(u,"prelu weights","fused depthwiseConv2d"));let b=(v,k)=>{Y(Hc(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[I,S,$,N]=k,T=WN(v,$,l),C=S8(S.shape,T,I,n,r,a,i),E=I8(S,T,I.shape,n,r,a,i);if(N!=null){let M=VN(g,T);return[C,E,M]}return[C,E]},x={x:p,filter:h,bias:g,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?Gl((v,k,I)=>{let S=ne.runKernel(zh,x,w);return I([k,v,S]),f&&(S=oe(S,[S.shape[1],S.shape[2],S.shape[3]])),{value:S,gradFunc:b}})(p,h):Gl((v,k,I,S)=>{let $=ne.runKernel(zh,x,w);return S([k,v,$,I]),f&&($=oe($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:b}})(p,h,g)}var fbe=re({fusedDepthwiseConv2d_:pbe});function mbe({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(GN(ne.state.gradientDepth,a)===!1){let N=At(e,t,n,r);return s!=null&&(N=Ie(N,s)),UN(N,a,i,o)}let l=G(e,"a","fused matMul"),u=G(t,"b","fused matMul");[l,u]=or(l,u);let c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=On(f),y=On(m);Y(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);let b=Sn(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),x=n?oe(l,[g,c,h]):oe(l,[g,h,c]),w=r?oe(u,[y,p,d]):oe(u,[y,d,p]),v;s!=null&&(v=G(s,"bias","fused matMul"),[v]=or(v,l),Sn(b,v.shape));let k;i!=null&&(k=G(i,"prelu weights","fused matMul"));let I=(N,T)=>{let[C,E,M,F]=T,z=WN(oe(N,M.shape),M,a),H,P;if(!n&&!r?(H=At(z,E,!1,!0),P=At(C,z,!0,!1)):!n&&r?(H=At(z,E,!1,!1),P=At(z,C,!0,!1)):n&&!r?(H=At(E,z,!1,!0),P=At(C,z,!1,!1)):(H=At(E,z,!0,!0),P=At(z,C,!0,!0)),s!=null){let O=VN(F,z);return[H,P,O]}else return[H,P]},S={a:x,b:w,bias:v,preluActivationWeights:k},$={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};return s==null?Gl((N,T,C)=>{let E=ne.runKernel(Lh,S,$);return C([N,T,E]),{value:oe(E,b),gradFunc:I}})(x,w):Gl((N,T,C,E)=>{let M=ne.runKernel(Lh,S,$);return E([N,T,M,C]),{value:oe(M,b),gradFunc:I}})(x,w,v)}var gbe=re({fusedMatMul_:mbe});function ybe(e){return BN(e,.54,.46)}var bbe=re({hammingWindow_:ybe});function xbe(e){return BN(e,.5,.5)}var C8=re({hannWindow_:xbe});function wbe(e,t,n,r=!1,s=0){let a=0,i=[];for(;a+t<=e.size;)i.push(Vt(e,a,t)),a+=n;if(r)for(;a<e.size;){let o=a+t-e.size,l=In([Vt(e,a,t-o),Ya([o],s)]);i.push(l),a+=n}return i.length===0?Ol([],[0,t]):oe(In(i),[i.length,t])}var N8=re({frame_:wbe});function vbe(e,t,n,r,s=C8){r==null&&(r=GO(t));let a=N8(e,t,n),i=ae(a,s(t));return Lw(i,r)}var kbe=re({stft_:vbe});function Ibe(e,t,n,r,s="bilinear",a=0){let i=G(e,"image","cropAndResize"),o=G(t,"boxes","cropAndResize","float32"),l=G(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Y(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),Y(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),Y(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),Y(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),Y(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),Y(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);let c={image:i,boxes:o,boxInd:l},d={method:s,extrapolationValue:a,cropSize:r};return ne.runKernel(dy,c,d)}var Sbe=re({cropAndResize_:Ibe});function Cbe(e){let t=G(e,"image","flipLeftRight","float32");Y(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return ne.runKernel(yy,n,{})}var Nbe=re({flipLeftRight_:Cbe});function $be(e){let t=G(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Y(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),Y(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,Ga(t,s)}var Tbe=re({grayscaleToRGB_:$be});function _be(e,t,n=0,r=.5){let s=G(e,"image","rotateWithOffset","float32");Y(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);let a={image:s},i={radians:t,fillValue:n,center:r};return ne.runKernel(nb,a,i)}var Ebe=re({rotateWithOffset_:_be});function db(e,t,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);let i=e.shape[0];return n=Math.min(n,i),Y(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),Y(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),Y(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),Y(t.rank===1,()=>"scores must be a 1D tensor"),Y(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),Y(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}function Abe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let a=G(e,"boxes","nonMaxSuppression","float32"),i=G(t,"scores","nonMaxSuppression","float32"),o=db(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return ne.runKernel(Dy,{boxes:a,scores:i},l)}var Rbe=re({nonMaxSuppression_:Abe});function Dbe(e,t,n){let r=Fbe(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function Fbe(e,t,n){return Mbe(e,t,n||Obe)}function Obe(e,t){return e>t?1:e<t?-1:0}function Mbe(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);let o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}function $8(e,t,n,r,s){return jO(e,t,n,r,s,0)}function T8(e,t,n,r,s,a){return jO(e,t,n,r,s,0,!1,a,!0)}function _8(e,t,n,r,s,a){return jO(e,t,n,r,s,a,!0)}function jO(e,t,n,r,s,a,i=!1,o=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>s&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(dV);let c=a>0?-.5/a:0,d=[],h=[];for(;d.length<n&&u.length>0;){let g=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:x}=g;if(y<s)break;let w=!1;for(let v=d.length-1;v>=x;--v){let k=Lbe(e,b,d[v]);if(k>=r){w=!0;break}if(g.score=g.score*Pbe(r,c,k),g.score<=s)break}g.suppressBeginIndex=d.length,w||(g.score===y?(d.push(b),h.push(g.score)):g.score>s&&Dbe(u,g,dV))}let p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));let m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function Lbe(e,t,n){let r=e.subarray(t*4,t*4+4),s=e.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;let m=Math.max(a,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(p+f-x)}function Pbe(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function dV(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function zbe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let a=G(e,"boxes","nonMaxSuppressionAsync"),i=G(t,"scores","nonMaxSuppressionAsync"),o=db(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;let l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=$8(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),gn(d,"int32")}var Bbe=zbe;function Wbe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){let i=G(e,"boxes","nonMaxSuppression"),o=G(t,"scores","nonMaxSuppression"),l=db(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;let u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},d=ne.runKernel(Oy,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}var Vbe=re({nonMaxSuppressionWithScore_:Wbe});async function Ube(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){let i=G(e,"boxes","nonMaxSuppressionAsync"),o=G(t,"scores","nonMaxSuppressionAsync"),l=db(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=_8(c,d,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:gn(h,"int32"),selectedScores:gn(p)}}var Gbe=Ube;function Hbe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){let i=G(e,"boxes","nonMaxSuppression"),o=G(t,"scores","nonMaxSuppression"),l=db(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,h={boxes:i,scores:o},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:a},f=ne.runKernel(Fy,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}var jbe=re({nonMaxSuppressionPadded_:Hbe});async function qbe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){let i=G(e,"boxes","nonMaxSuppressionAsync"),o=G(t,"scores","nonMaxSuppressionAsync"),l=db(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=T8(h,p,u,c,d,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:gn(f,"int32"),validOutputs:mt(m,"int32")}}var Kbe=qbe;function Xbe(e,t,n=!1,r=!1){let s=G(e,"images","resizeBilinear");Y(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),Y(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Y(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=oe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=ne.runKernel(mf,o,l);return i?oe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var E8=re({resizeBilinear_:Xbe});function Ybe(e,t,n=!1,r=!1){let s=G(e,"images","resizeNearestNeighbor");Y(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),Y(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Y(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),Y(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=oe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=ne.runKernel(ff,o,l);return i?oe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var A8=re({resizeNearestNeighbor_:Ybe});function Zbe(e,t="binary",n=!1,r=.5){let s=G(e,"image","threshold"),a=.2989,i=.587,o=.114,l=s.shape[0]*s.shape[1],u=ae(gn([r]),255),c,d,h,p;if(Y(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),Y(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),Y(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),Y(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),s.shape[2]===3){[c,d,h]=Sa(s,[1,1,1],-1);let m=ae(c,a),g=ae(d,i),y=ae(h,o);p=Ie(Ie(m,g),y)}else p=e;if(t==="otsu"){let m=tO(Me($N(p),"int32"),Js([]),256);u=Jbe(m,l)}let f=n?vd(p,u):la(p,u);return Me(ae(f,255),"int32")}function Jbe(e,t){let n=gn([-1]),r=gn([0]),s=gn([0]),a,i,o,l,u,c;for(let d=0;d<e.size-1;d++){a=Vt(e,0,d+1),i=Vt(e,d+1),u=tt(st(a),t),c=tt(st(i),t);let h=st(ae(a,Kh(0,a.size)));o=tt(h,st(a));let p=Ya(i.shape,a.size),f=Ie(Kh(0,i.size),p),m=ae(i,f);l=tt(st(m),st(i));let g=qe(o,l),y=qe(o,l),b=ae(u,c);s=ae(ae(b,g),y);let x=la(s,r);r=ss(x,s,r),n=ss(x,gn([d]),n)}return n}var Qbe=re({threshold_:Zbe});function exe(e,t,n="nearest",r="constant",s=0,a){let i=G(e,"image","transform","float32"),o=G(t,"transforms","transform","float32");Y(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),Y(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Y(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);let l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return ne.runKernel(Qy,l,u)}var txe=re({transform_:exe});function nxe(e,t,n){let r=G(e,"a","bandPart");Y(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let s=r.shape,[a,i]=r.shape.slice(-2),o,l;typeof t=="number"?(Y(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Y(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),o=G(t<0?a:t,"numLower","bandPart")):(Y(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=ss(mg(t,0),a,jc(t,a))),typeof n=="number"?(Y(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),Y(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=G(n<0?i:n,"numUpper","bandPart")):(Y(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=ss(mg(n,0),i,jc(n,i)));let u=oe(Kh(0,a,1,"int32"),[-1,1]),c=Kh(0,i,1,"int32"),d=qe(u,c),h=yo(vd(d,o),Uu(d,Mn(l))),p=sr([a,i],r.dtype);return oe(zr(fr(oe(r,[-1,a,i])).map(f=>ss(h,f,p))),s)}var rxe=re({bandPart_:nxe});function sxe(e){let t;if(Array.isArray(e)){t=!1,Y(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let s=e[0].shape[0];for(let a=1;a<e.length;++a)Y(e[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${s})`)}else t=!0,e=Sa(e,e.shape[0],0).map(s=>Id(s,[0]));Y(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let s=0;s<e.length;++s)n.push(ne.tidy(()=>{let a=r[s];if(s>0)for(let i=0;i<s;++i){let o=ae(st(ae(n[i],a)),n[i]);a=qe(a,o)}return tt(a,ab(a,"euclidean"))}));return t?zr(n,0):n}var axe=re({gramSchmidt_:sxe});function ixe(e,t=!1){if(Y(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return hV(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),r=fr(oe(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach(l=>{let[u,c]=hV(l,t);s.push(u),a.push(c)});let i=oe(zr(s,0),e.shape),o=oe(zr(a,0),e.shape);return[i,o]}}function hV(e,t=!1){return ne.tidy(()=>{Y(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],s=xN(n),a=Fl(e),i=Ol([[1]],[1,1]),o=Fl(i),l=n>=r?r:n;for(let u=0;u<l;++u){let c=a,d=o,h=s;[o,a,s]=ne.tidy(()=>{let p=Vt(a,[u,u],[n-u,1]),f=ab(p),m=Vt(a,[u,u],[1,1]),g=ss(la(m,0),Ol([[-1]]),Ol([[1]])),y=qe(m,ae(g,f)),b=tt(p,y);b.shape[0]===1?o=Fl(i):o=In([i,Vt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let x=Mn(tt(At(g,y),f)),w=Vt(a,[u,0],[n-u,r]),v=ae(x,o),k=Ft(o);if(u===0)a=qe(w,At(v,At(k,w)));else{let $=qe(w,At(v,At(k,w)));a=In([Vt(a,[0,0],[u,r]),$],0)}let I=Ft(v),S=Vt(s,[0,u],[n,s.shape[1]-u]);if(u===0)s=qe(S,At(At(S,o),I));else{let $=qe(S,At(At(S,o),I));s=In([Vt(s,[0,0],[n,u]),$],1)}return[o,a,s]}),St([c,d,h])}return!t&&n>r&&(s=Vt(s,[0,0],[n,r]),a=Vt(a,[0,0],[r,r])),[s,a]})}var oxe=re({qr_:ixe}),Xs;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Xs||(Xs={}));function lxe(e,t,n=Xs.SUM_BY_NONZERO_WEIGHTS){let r=G(e,"losses","computeWeightedLoss"),s=null;t!=null&&(s=G(t,"weights","computeWeightedLoss"));let a=s==null?r:ae(r,s);if(n===Xs.NONE)return a;if(n===Xs.SUM)return st(a);if(n===Xs.MEAN){if(s==null)return rr(a);{let i=r.size/s.size,o=tt(st(a),st(s));return i>1?tt(o,mt(i)):o}}if(n===Xs.SUM_BY_NONZERO_WEIGHTS){if(s==null)return tt(st(a),mt(r.size));{let i=ae(s,Ha(r.shape)),o=Me(st(qh(i,mt(0))),"float32");return tt(st(a),o)}}throw Error(`Unknown reduction: ${n}`)}var Gu=re({computeWeightedLoss_:lxe});function uxe(e,t,n,r=Xs.SUM_BY_NONZERO_WEIGHTS){let s=G(e,"labels","absoluteDifference"),a=G(t,"predictions","absoluteDifference"),i=null;n!=null&&(i=G(n,"weights","absoluteDifference")),ia(s.shape,a.shape,"Error in absoluteDifference: ");let o=Ir(qe(s,a));return Gu(o,i,r)}var cxe=re({absoluteDifference_:uxe});function dxe(e,t,n,r,s=Xs.SUM_BY_NONZERO_WEIGHTS){let a=G(e,"labels","cosineDistance"),i=G(t,"predictions","cosineDistance"),o=null;r!=null&&(o=G(r,"weights","cosineDistance")),ia(a.shape,i.shape,"Error in cosineDistance: ");let l=mt(1),u=qe(l,st(ae(a,i),n,!0));return Gu(u,o,s)}var hxe=re({cosineDistance_:dxe});function pxe(e,t,n,r=Xs.SUM_BY_NONZERO_WEIGHTS){let s=G(e,"labels","hingeLoss"),a=G(t,"predictions","hingeLoss"),i=null;n!=null&&(i=G(n,"weights","hingeLoss")),ia(s.shape,a.shape,"Error in hingeLoss: ");let o=mt(1);s=qe(ae(mt(2),s),o);let l=yn(qe(o,ae(s,a)));return Gu(l,i,r)}var fxe=re({hingeLoss_:pxe});function mxe(e,t,n,r=1,s=Xs.SUM_BY_NONZERO_WEIGHTS){let a=G(e,"labels","huberLoss"),i=G(t,"predictions","huberLoss"),o=null;n!=null&&(o=G(n,"weights","huberLoss")),ia(a.shape,i.shape,"Error in huberLoss: ");let l=mt(r),u=Ir(qe(i,a)),c=jc(u,l),d=qe(u,c),h=Ie(ae(mt(.5),vn(c)),ae(l,d));return Gu(h,o,s)}var gxe=re({huberLoss_:mxe});function yxe(e,t,n,r=1e-7,s=Xs.SUM_BY_NONZERO_WEIGHTS){let a=G(e,"labels","logLoss"),i=G(t,"predictions","logLoss"),o=null;n!=null&&(o=G(n,"weights","logLoss")),ia(a.shape,i.shape,"Error in logLoss: ");let l=mt(1),u=mt(r),c=Mn(ae(a,Qa(Ie(i,u)))),d=ae(qe(l,a),Qa(Ie(qe(l,i),u))),h=qe(c,d);return Gu(h,o,s)}var bxe=re({logLoss_:yxe});function xxe(e,t,n,r=Xs.SUM_BY_NONZERO_WEIGHTS){let s=G(e,"labels","meanSquaredError"),a=G(t,"predictions","meanSquaredError"),i=null;n!=null&&(i=G(n,"weights","meanSquaredError")),ia(s.shape,a.shape,"Error in meanSquaredError: ");let o=FN(s,a);return Gu(o,i,r)}var wxe=re({meanSquaredError_:xxe});function vxe(e,t){let n=G(e,"labels","sigmoidCrossEntropyWithLogits"),r=G(t,"logits","sigmoidCrossEntropyWithLogits");ia(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let s=yn(r),a=ae(r,n),i=Ew(ta(Mn(Ir(r))));return Ie(qe(s,a),i)}function kxe(e,t,n,r=0,s=Xs.SUM_BY_NONZERO_WEIGHTS){let a=G(e,"multiClassLabels","sigmoidCrossEntropy"),i=G(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=G(n,"weights","sigmoidCrossEntropy")),ia(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let u=mt(r),c=mt(1),d=mt(.5);a=Ie(ae(a,qe(c,u)),ae(d,u))}let l=vxe(a,i);return Gu(l,o,s)}var Ixe=re({sigmoidCrossEntropy_:kxe});function Sxe(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Gl((r,s,a)=>{let i=kN(s,[n],!0),o=qe(Me(s,"float32"),i);a([r,o]);let l=Mn(ae(o,r));return{value:st(l,[n]),gradFunc:(u,c)=>{let[d,h]=c,p=jh(u.shape,[n]);return[ae(oe(u,p),qe(Me(d,"float32"),ta(h))),ae(oe(u,p),qe(ta(h),Me(d,"float32")))]}}})(e,t)}function Cxe(e,t,n,r=0,s=Xs.SUM_BY_NONZERO_WEIGHTS){let a=G(e,"onehotLabels","softmaxCrossEntropy"),i=G(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=G(n,"weights","softmaxCrossEntropy")),ia(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let u=mt(r),c=mt(1),d=mt(a.shape[1]);a=Ie(ae(a,qe(c,u)),tt(u,d))}let l=Sxe(a,i);return Gu(l,o,s)}var Nxe=re({softmaxCrossEntropy_:Cxe});function $xe(e,t,n,r){let s=G(e,"indices","sparseFillEmptyRows","int32"),a=G(t,"values","sparseFillEmptyRows"),i=G(n,"denseShape","sparseFillEmptyRows","int32"),o=G(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:s,values:a,denseShape:i,defaultValue:o},u=ne.runKernel(cw,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var Txe=re({sparseFillEmptyRows_:$xe});function _xe(e,t,n){let r=G(e,"inputIndices","sparseReshape","int32"),s=G(t,"inputShape","sparseReshape","int32"),a=G(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);let i={inputIndices:r,inputShape:s,newShape:a},o=ne.runKernel(Xy,i);return{outputIndices:o[0],outputShape:o[1]}}var Exe=re({sparseReshape_:_xe});function Axe(e,t,n){let r=G(e,"data","sparseSegmentMean"),s=G(t,"indices","sparseSegmentMean","int32"),a=G(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);let i={data:r,indices:s,segmentIds:a};return ne.runKernel(dw,i)}var Rxe=re({sparseSegmentMean_:Axe});function Dxe(e,t,n){let r=G(e,"data","sparseSegmentSum"),s=G(t,"indices","sparseSegmentSum","int32"),a=G(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);let i={data:r,indices:s,segmentIds:a};return ne.runKernel(hw,i)}var Fxe=re({sparseSegmentSum_:Dxe});function Oxe(e,t,n,r,s,a,i,o){let l=G(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=G(t,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},h=ne.runKernel(mw,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}var Mxe=re({stringNGrams_:Oxe});function Lxe(e,t,n=!0){let r=G(e,"input","stringSplit","string"),s=G(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);let a={skipEmpty:n},i={input:r,delimiter:s},o=ne.runKernel(gw,i,a);return{indices:o[0],values:o[1],shape:o[2]}}var Pxe=re({stringSplit_:Lxe});function zxe(e,t){let n=G(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let s={input:n};return ne.runKernel(yw,s,r)}var Bxe=re({stringToHashBucketFast_:zxe});function Wxe(e,t,n,r=!0){let s=G(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return ne.runKernel(fw,{x:s},a)}var Vxe=re({staticRegexReplace_:Wxe}),R8={fft:Mw,ifft:xg,rfft:Lw,irfft:DN},D8={hammingWindow:bbe,hannWindow:C8,frame:N8,stft:kbe},Po={flipLeftRight:Nbe,grayscaleToRGB:Tbe,resizeNearestNeighbor:A8,resizeBilinear:E8,rotateWithOffset:Ebe,cropAndResize:Sbe,nonMaxSuppression:Rbe,nonMaxSuppressionAsync:Bbe,nonMaxSuppressionWithScore:Vbe,nonMaxSuppressionWithScoreAsync:Gbe,nonMaxSuppressionPadded:jbe,nonMaxSuppressionPaddedAsync:Kbe,threshold:Qbe,transform:txe},qO={bandPart:rxe,gramSchmidt:axe,qr:oxe},F8={absoluteDifference:cxe,computeWeightedLoss:Gu,cosineDistance:hxe,hingeLoss:fxe,huberLoss:gxe,logLoss:bxe,meanSquaredError:wxe,sigmoidCrossEntropy:Ixe,softmaxCrossEntropy:Nxe},O8={sparseFillEmptyRows:Txe,sparseReshape:Exe,sparseSegmentMean:Rxe,sparseSegmentSum:Fxe},M8={stringNGrams:Mxe,stringSplit:Pxe,stringToHashBucketFast:Bxe,staticRegexReplace:Vxe},_e={};Ct(_e,{Serializable:()=>L8,SerializationMap:()=>ih,registerClass:()=>P8});var L8=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},ih=class{constructor(){this.classNameMap={}}static getMap(){return ih.instance==null&&(ih.instance=new ih),ih.instance}static register(e){ih.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function P8(e){Y(e.className!=null,()=>"Class being registered does not have the static className property defined."),Y(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),Y(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),ih.register(e)}var Hu=class extends L8{minimize(e,t=!1,n){let{value:r,grads:s}=this.computeGradients(e,n);if(n!=null){let a=n.map(i=>({name:i.name,tensor:s[i.name]}));this.applyGradients(a)}else this.applyGradients(s);return St(s),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Bq(e,t)}dispose(){this.iterations_!=null&&St(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:mt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Hu,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var KO=class extends Hu{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=ne.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=ne.registeredVariables[t],s=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:ue(()=>Ht(r).variable(s))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:ue(()=>Ht(r).variable(s))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;ue(()=>{let l=Ie(ae(i,this.rho),ae(vn(a),1-this.rho)),u=ae(tt(ks(Ie(o,this.epsilon)),ks(Ie(i,this.epsilon))),a),c=Ie(ae(o,this.rho),ae(vn(u),1-this.rho));i.assign(l),o.assign(c);let d=Ie(ae(u,-this.learningRate),r);r.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(St(this.accumulatedGrads.map(e=>e.variable)),St(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},XO=class extends Hu{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=ne.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:ue(()=>Ya(r.shape,this.initialAccumulatorValue).variable(!1))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let a=this.accumulatedGrads[n].variable;ue(()=>{let i=Ie(a,vn(s));a.assign(i);let o=Ie(ae(tt(s,ks(Ie(i,ne.backend.epsilon()))),-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&St(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},YO=class extends Hu{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ue(()=>{this.accBeta1=mt(t).variable(),this.accBeta2=mt(n).variable()}),r==null&&(this.epsilon=ne.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ue(()=>{let n=qe(1,this.accBeta1),r=qe(1,this.accBeta2);t.forEach((s,a)=>{let i=ne.registeredVariables[s],o=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:ue(()=>Ht(i).variable(o))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${s}/v`,variable:ue(()=>Ht(i).variable(o))});let l=Array.isArray(e)?e[a].tensor:e[s];if(l==null)return;let u=this.accumulatedFirstMoment[a].variable,c=this.accumulatedSecondMoment[a].variable,d=Ie(ae(u,this.beta1),ae(l,1-this.beta1)),h=Ie(ae(c,this.beta2),ae(vn(l),1-this.beta2)),p=tt(d,n),f=tt(h,r);u.assign(d),c.assign(h);let m=Ie(ae(tt(p,Ie(ks(f),this.epsilon)),-this.learningRate),i);i.assign(m)}),this.accBeta1.assign(ae(this.accBeta1,this.beta1)),this.accBeta2.assign(ae(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&St(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&St(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),ue(()=>{this.accBeta1.assign(Ou(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ou(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},ZO=class extends Hu{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ue(()=>{this.iteration=mt(0).variable(),this.accBeta1=mt(t).variable()}),r==null&&(this.epsilon=ne.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ue(()=>{let n=qe(1,this.accBeta1),r=tt(-this.learningRate,Ie(ae(this.iteration,this.decay),1));t.forEach((s,a)=>{let i=ne.registeredVariables[s],o=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:Ht(i).variable(o)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${s}/v`,variable:Ht(i).variable(o)});let l=Array.isArray(e)?e[a].tensor:e[s];if(l==null)return;let u=this.accumulatedFirstMoment[a].variable,c=this.accumulatedWeightedInfNorm[a].variable,d=Ie(ae(u,this.beta1),ae(l,1-this.beta1)),h=ae(c,this.beta2),p=Ir(l),f=Xl(h,p);u.assign(d),c.assign(f);let m=Ie(ae(tt(r,n),tt(d,Ie(f,this.epsilon))),i);i.assign(m)}),this.iteration.assign(Ie(this.iteration,1)),this.accBeta1.assign(ae(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&St(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&St(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},HN=class extends Hu{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let s=ne.registeredVariables[t];ue(()=>{let a=Ie(ae(this.c,r),s);s.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Or(mt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},JO=class extends HN{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=mt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=ne.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:ue(()=>Ht(r).variable(!1))});let s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];a!=null&&ue(()=>{let i,o=Ie(ae(this.m,s),a);this.useNesterov?i=Ie(ae(this.c,Ie(a,ae(o,this.m))),r):i=Ie(ae(this.c,o),r),s.assign(o),r.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&St(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},QO=class extends Hu{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,r==null&&(this.epsilon=ne.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=ne.registeredVariables[t],s=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:ue(()=>Ht(r).variable(s))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:ue(()=>Ht(r).variable(s))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:ue(()=>Ht(r).variable(s))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;ue(()=>{let l=Ie(ae(i,this.decay),ae(vn(a),1-this.decay));if(this.centered){let u=this.accumulatedMeanGrads[n].variable,c=Ie(ae(u,this.decay),ae(a,1-this.decay)),d=tt(ae(a,this.learningRate),ks(qe(l,Ie(vn(c),this.epsilon)))),h=Ie(ae(o,this.momentum),d);i.assign(l),u.assign(c),o.assign(h);let p=qe(r,h);r.assign(p)}else{let u=Ie(ae(i,this.decay),ae(vn(a),1-this.decay)),c=Ie(ae(o,this.momentum),tt(ae(a,this.learningRate),ks(Ie(u,this.epsilon))));i.assign(u),o.assign(c);let d=qe(r,c);r.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&St(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&St(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&St(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},Uxe=[KO,XO,YO,ZO,JO,QO,HN];function Gxe(){for(let e of Uxe)P8(e)}var ws={};Ct(ws,{browserFiles:()=>Zxe,browserHTTPRequest:()=>n0e,concatenateArrayBuffers:()=>zF,copyModel:()=>qpe,decodeWeights:()=>hq,encodeWeights:()=>kpe,fromMemory:()=>s0e,fromMemorySync:()=>U8,getLoadHandlers:()=>Dpe,getModelArtifactsForJSON:()=>BF,getModelArtifactsForJSONSync:()=>fq,getModelArtifactsInfoForJSON:()=>Sw,getSaveHandlers:()=>Rpe,getWeightSpecs:()=>mq,http:()=>tM,isHTTPScheme:()=>gA,listModels:()=>Hpe,loadWeights:()=>Jxe,moveModel:()=>Kpe,registerLoadRouter:()=>Ape,registerSaveRouter:()=>Epe,removeModel:()=>jpe,weightsLoaderFactory:()=>B8,withSaveHandler:()=>a0e,withSaveHandlerSync:()=>i0e});var Hxe="model",jxe=".json",qxe=".weights.bin";function pV(e){return new Promise(t=>setTimeout(t)).then(e)}var vg=class{constructor(e){if(!me().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(vg.URL_SCHEME)&&(e=e.slice(vg.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Hxe),this.modelJsonFileName=e+jxe,this.weightDataFileName=e+qxe}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=pq(e,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=s,await pV(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=t,await pV(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Sw(e)}}}};vg.URL_SCHEME="downloads://";var Kxe=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=r=>{let s=JSON.parse(r.target.result),a=s.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}let i=BF(s,o=>this.loadWeights(o));e(i)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let a of e)t.push(...a.weights),n.push(...a.paths);let r=this.checkManifestAndWeightFiles(e),s=n.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(s).then(a=>[t,zF(a)])}loadWeightsFile(e,t){return new Promise((n,r)=>{let s=new FileReader;s.onload=a=>{let i=a.target.result;n(i)},s.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(s=>cV(s.name)),r={};for(let s of e)s.paths.forEach(a=>{let i=cV(a);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[a]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},Xxe=e=>me().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(vg.URL_SCHEME)?Yxe(e.slice(vg.URL_SCHEME.length)):null;ur.registerSaveRouter(Xxe);function Yxe(e="model"){return new vg(e)}function Zxe(e){return new Kxe(e)}function fV(e,t,n,r){i(e),n=n??0,r=r??1,o(n,r);let s=0,a=l=>(l.then(u=>{let c=n+ ++s/e.length*(r-n);return t(c),u}),l);function i(l){Y(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,u){Y(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),Y(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),Y(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(a))}async function z8(e,t){t==null&&(t={});let n=t.fetchFunc==null?me().platform.fetch:t.fetchFunc,r=e.map(u=>n(u,t.requestInit,{isBinary:!0})),s=0,a=.5,i=(t.onProgress==null?await Promise.all(r):await fV(r,t.onProgress,s,a)).map(u=>u.arrayBuffer()),o=.5,l=1;return t.onProgress==null?await Promise.all(i):await fV(i,t.onProgress,o,l)}async function Jxe(e,t="",n,r){return B8(s=>z8(s,{requestInit:r}))(e,t,n)}function B8(e){return async(t,n="",r)=>{let s=t.map(()=>!1),a={},i=r!=null?r.map(()=>!1):[],o=[];if(t.forEach((p,f)=>{let m=0;p.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,b=cA[y]*On(g.shape),x=()=>{s[f]=!0,a[f]==null&&(a[f]=[]),a[f].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};r!=null?r.forEach((w,v)=>{w===g.name&&(x(),i[v]=!0)}):x(),o.push(g.name),m+=b})}),!i.every(p=>p)){let p=r.filter((f,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=s.reduce((p,f,m)=>(f&&p.push(m),p),[]),u=[];l.forEach(p=>{t[p].paths.forEach(f=>{let m=n+(n.endsWith("/")?"":"/")+f;u.push(m)})});let c=await e(u),d={},h=0;return l.forEach(p=>{let f=t[p].paths.length,m=0;for(let x=0;x<f;x++)m+=c[h+x].byteLength;let g=new ArrayBuffer(m),y=new Uint8Array(g),b=0;for(let x=0;x<f;x++){let w=new Uint8Array(c[h+x]);y.set(w,b),b+=w.byteLength}a[p].forEach(x=>{let w=g.slice(x.groupOffset,x.groupOffset+x.sizeBytes),v=hq(w,[x.manifestEntry]);for(let k in v)d[k]=v[k]}),h+=f}),d}}var Qxe="application/octet-stream",e0e="application/json",eM=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(Y(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=me().platform.fetch,Y(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Y(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=pq(e,n);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:e0e}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:Qxe}),"model.weights.bin");let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:Sw(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return BF(t,s=>this.loadWeights(s))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=t0e(t),s=this.weightPathPrefix||n,a=mq(e),i=[],o=[];for(let u of e)for(let c of u.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(c)):i.push(s+c+r);this.weightUrlConverter&&i.push(...await Promise.all(o));let l=await z8(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,zF(l)]}};eM.URL_SCHEME_REGEX=/^https?:\/\//;function t0e(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}function gA(e){return e.match(eM.URL_SCHEME_REGEX)!=null}var W8=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>gA(r)):n=gA(e),n)return tM(e,t)}return null};ur.registerSaveRouter(W8);ur.registerLoadRouter(W8);function tM(e,t){return new eM(e,t)}function n0e(e,t){return tM(e,t)}var i_=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},V8=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},r0e=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function s0e(e,t,n,r){let s=arguments;return new r0e(U8(...s))}function U8(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new i_(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new i_({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new i_({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function a0e(e){return new V8(e)}function i0e(e){return new V8(e)}var G8={};Ct(G8,{confusionMatrix:()=>l0e});function o0e(e,t,n){let r=G(e,"labels","confusionMatrix"),s=G(t,"predictions","confusionMatrix");Y(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),Y(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),Y(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),Y(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),Y(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let a=gg(Me(r,"int32"),n),i=gg(Me(s,"int32"),n),o=Ft(a),l=At(o,i);return Me(l,"int32")}var l0e=re({confusionMatrix_:o0e}),Pw={};Ct(Pw,{fromPixels:()=>m0e,fromPixelsAsync:()=>p0e,toPixels:()=>f0e});var Gd;function H8(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)a=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(JI(ZI,ne.backendName)!=null){let h={pixels:e},p={numChannels:t};return ne.runKernel(ZI,h,p)}let[l,u]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height],c;if(i)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(a||s||o){if(Gd==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Gd=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Gd=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Gd.canvas.width=l,Gd.canvas.height=u,Gd.drawImage(e,0,0,l,u),c=Gd.getImageData(0,0,l,u).data}let d;if(t===4)d=new Int32Array(c);else{let h=l*u;d=new Int32Array(h*t);for(let p=0;p<h;p++)for(let f=0;f<t;++f)d[p*t+f]=c[p*4+f]}return ON(d,[u,l,t],"int32")}function u0e(e){return e!=null&&e.data instanceof Uint8Array}function c0e(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function d0e(e){return e!=null&&e.width!==0&&e.height!==0}function h0e(e){return c0e()&&!(e instanceof ImageBitmap)&&d0e(e)&&!u0e(e)}async function p0e(e,t=3){let n=null;if(me().getBool("WRAP_TO_IMAGEBITMAP")&&h0e(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===e.width&&r.height===e.height?n=r:n=e}else n=e;return H8(n,t)}async function f0e(e,t){let n=G(e,"img","toPixels");if(!(e instanceof Tt)){let u=n;n=Me(u,"int32"),u.dispose()}if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);let[r,s]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2];if(a>4||a===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${a}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);let i=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let u=0;u<r*s;++u){let c=[0,0,0,255];for(let h=0;h<a;h++){let p=i[u*a+h];if(n.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(n.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);a===1?(c[0]=p*o,c[1]=p*o,c[2]=p*o):c[h]=p*o}let d=u*4;l[d+0]=Math.round(c[0]),l[d+1]=Math.round(c[1]),l[d+2]=Math.round(c[2]),l[d+3]=Math.round(c[3])}if(t!=null){t.width=s,t.height=r;let u=t.getContext("2d"),c=new ImageData(l,s,r);u.putImageData(c,0,0)}return n!==e&&n.dispose(),l}var m0e=re({fromPixels_:H8}),nM={};Ct(nM,{prepareAndValidate:()=>j8});function j8(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(On(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let s=t.shape,a=s[s.length-1],i=1;for(let d=0;d<s.length-1;++d)i*=s[d];let o=e.shape,l=s.slice();l.pop();let u=1;for(let d=a;d<n;++d)u*=o[d],l.push(o[d]);let c=[...Jg(e.shape).map(d=>d/u),1].slice(0,a);return[l,i,u,c]}var Br={};Ct(Br,{assertParamsValid:()=>y0e,computeFlatOffset:()=>k0e,computeOutShape:()=>x0e,getNormalizedAxes:()=>w0e,isSliceContinous:()=>v0e,maskToAxes:()=>b0e,parseSliceParams:()=>tK,sliceInfo:()=>I0e,startForAxis:()=>Q8,startIndicesWithElidedDims:()=>Y8,stopForAxis:()=>eK,stopIndicesWithElidedDims:()=>Z8,stridesForAxis:()=>J8,stridesWithElidedDims:()=>q8});var yA=-2,g0e=-1;function y0e(e,t,n){let r=e.shape.length;Y(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),Y(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)Y(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function b0e(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function x0e(e,t,n){let r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function q8(e,t,n,r){let s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function K8(e,t,n){return n<=e?n:n-(t-1)}function X8(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function w0e(e,t,n,r,s,a,i,o,l){let u=e.length,c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){let p=t[0],f=n+1;c=Y8(i,p,f,r,e),d=Z8(o,p,f,s,e),h=q8(a,p,f,e)}else for(let p=0;p<u;p++)c[p]=Q8(i,r,a,e,p,l),d[p]=eK(o,s,a,e,p,l),h[p]=J8(a,p,l);return{begin:c,end:d,strides:h}}function Y8(e,t,n,r,s){let a=[...s],i=X8(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{let l=K8(t,n,o),u=r[l];e&1<<l&&(u=0),a[o]=u}return a}function Z8(e,t,n,r,s){let a=[...s],i=X8(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{let l=K8(t,n,o),u=r[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),a[o]=u}for(let o=0;o<a.length;o++){let l=s[o];a[o]<0&&(a[o]+=l),a[o]=h0(0,a[o],s[o])}return a}function J8(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function Q8(e,t,n,r,s,a){let i=t[s],o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=r[s];return i<0&&(i+=l),i=h0(0,i,l-1),i}function eK(e,t,n,r,s,a){let i=t[s],o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=r[s];return i<0&&(i+=l),o>0?i=h0(0,i,l):i=h0(-1,i,l-1),i}function v0e(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function k0e(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function tK(e,t,n){let r,s=e.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(i=>{Y(i!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((i,o)=>i>=0?i:(Y(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,a]}function I0e(e,t,n,r,s,a,i,o,l){let u;if(r==null?(u=new Array(t.length),u.fill(1)):u=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&1<<b&o&&d.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);let h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};S0e(d,h);let p=!0,f=!0,m=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(h.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);let x=!!(h.shrinkAxisMask&1<<b),w=e[b];if(w===-1){g.push(x?1:-1);continue}let v=[h.beginMask&1<<b,h.endMask&1<<b],k=[h.strides[b]>0?0:-1,h.strides[b]>0?w:w-1];if(x&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&h.strides[b]===1;let I=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(x){let T=h.begin[b]<0?w+h.begin[b]:h.begin[b];if(h.begin[b]=T,h.end[b]=h.begin[b]+1,T<0||T>=w)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=mV(h.begin[b],0,h.strides[b],w,v,k),h.end[b]=mV(h.end[b],1,h.strides[b],w,v,k);let N=h.strides[b]===1&&h.begin[b]===0&&h.end[b]===w;p=p&&N,f=f&&(b===0&&h.strides[b]===1||N)}else p=p&&h.strides[b]===1&&I,f=f&&(b===0&&h.strides[b]===1||I);let S,$=!1;if(h.beginValid&&h.endValid?(S=h.end[b]-h.begin[b],$=!0):x?(S=1,$=!0):I&&w>=0&&(h.strides[b]<0?S=-w:S=w,$=!0),$){let N;S===0||S<0!=h.strides[b]<0?N=0:N=Math.trunc(S/h.strides[b])+(S%h.strides[b]!==0?1:0),g.push(N)}else g.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){let x=h.finalShapeGatherIndices[b];x>=0?y.push(g[x]):x===yA&&y.push(1)}return{finalShapeSparse:y.filter((b,x)=>h.finalShapeGatherIndices[x]!==yA),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function S0e(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(yA),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(g0e),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function mV(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{let i=e<0?r+e:e;return i<a[0]?a[0]:i>a[1]?a[1]:i}}var C0e="4.3.0",nK=class{static sgd(e){return new HN(e)}static momentum(e,t,n=!1){return new JO(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new QO(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new YO(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new KO(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new ZO(e,t,n,r,s)}static adagrad(e,t=.1){return new XO(e,t)}},rh=nK,N0e=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e())();function rM(){return new Promise(e=>N0e(()=>e()))}var W={};Ct(W,{ERF_A1:()=>W0e,ERF_A2:()=>V0e,ERF_A3:()=>U0e,ERF_A4:()=>G0e,ERF_A5:()=>H0e,ERF_P:()=>B0e,PARALLELIZE_THRESHOLD:()=>sM,RowPartitionType:()=>wl,SELU_SCALE:()=>sK,SELU_SCALEALPHA:()=>rK,applyActivation:()=>UN,assertAndGetBroadcastShape:()=>Sn,assertAxesAreInnerMostDims:()=>Ame,assertParamsConsistent:()=>$0e,assignToTypedArray:()=>Z0e,axesAreInnerMostDims:()=>mO,calculateShapes:()=>p8,checkEinsumDimSizes:()=>rwe,checkPadOnDimRoundingMode:()=>oa,combineLocations:()=>Oq,combineRaggedTensorToTensorShapes:()=>_0e,complexWithEvenIndex:()=>K0e,complexWithOddIndex:()=>X0e,computeConv2DInfo:()=>Cw,computeConv3DInfo:()=>$q,computeDefaultPad:()=>YF,computeDilation2DInfo:()=>Afe,computeOptimalWindowSize:()=>D0e,computeOutAndReduceShapes:()=>Mq,computeOutShape:()=>T0e,computePool2DInfo:()=>Nq,computePool3DInfo:()=>Rfe,convertConv2DDataFormat:()=>Tq,decodeEinsumEquation:()=>twe,eitherStridesOrDilationsAreOne:()=>Kl,expandShapeToKeepDim:()=>jh,exponent:()=>Q0e,exponents:()=>J0e,fromStringArrayToUint8:()=>Swe,fromUint8ToStringArray:()=>Iwe,getAxesPermutation:()=>Lq,getBroadcastDims:()=>Dq,getComplexWithIndex:()=>Y0e,getEinsumComputePath:()=>swe,getEinsumPermutation:()=>nwe,getFusedBiasGradient:()=>VN,getFusedDyActivation:()=>WN,getImageCenter:()=>F0e,getInnerMostAxes:()=>Rme,getPermuted:()=>M0e,getRaggedRank:()=>A0e,getReductionAxes:()=>Tr,getReshaped:()=>O0e,getReshapedPermuted:()=>L0e,getRowPartitionTypesHelper:()=>E0e,getSliceBeginCoords:()=>P0e,getSliceSize:()=>z0e,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>lwe,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>uwe,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>cwe,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>pwe,getSparseReshapeInputOutputMismatchErrorMessage:()=>mwe,getSparseReshapeInputOutputMultipleErrorMessage:()=>fwe,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>dwe,getSparseReshapeNegativeOutputDimErrorMessage:()=>hwe,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>xwe,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>gwe,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>ywe,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>bwe,getUndoAxesPermutation:()=>gO,isIdentityPermutation:()=>awe,log:()=>jhe,mergeRealAndImagArrays:()=>j0e,prepareAndValidate:()=>j8,prepareSplitSize:()=>owe,segment_util:()=>aK,shouldFuse:()=>GN,slice_util:()=>Br,splitRealAndImagArrays:()=>q0e,stridesOrDilationsArePositive:()=>Gh,tupleValuesAreOne:()=>Hc,upcastType:()=>$i,validateDefaultValueShape:()=>R0e,validateInput:()=>LN,validateUpdateShape:()=>PO,warn:()=>hc});function $0e(e,t){let n=e[0].length;e.forEach((s,a)=>{Y(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),Y(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((s,a)=>{for(let i=0;i<n;i++)Y(i===t||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function T0e(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var wl;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(wl||(wl={}));function _0e(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){let a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function E0e(e){let t={FIRST_DIM_SIZE:wl.FIRST_DIM_SIZE,VALUE_ROWIDS:wl.VALUE_ROWIDS,ROW_LENGTHS:wl.ROW_LENGTHS,ROW_SPLITS:wl.ROW_SPLITS,ROW_LIMITS:wl.ROW_LIMITS,ROW_STARTS:wl.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function A0e(e){return e.length===0?0:e[0]===wl.FIRST_DIM_SIZE?e.length-1:e.length}function R0e(e,t){if(e==null||t==null)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){let a=e[s],i=t[s+1];if(a>=0&&i>=0&&a!==1&&a!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${a} but ragged tensor input.flatValues.shape[${s-e.length}] = ${i}`)}}var sM=30;function D0e(e){return e<=sM?e:YI(e,Math.floor(Math.sqrt(e)))}function F0e(e,t,n){let r=n*(typeof e=="number"?e:e[0]),s=t*(typeof e=="number"?e:e[1]);return[r,s]}function O0e(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);let a=t.length;for(let i=0;i<a;++i)s=s.concat([e[i+1]/t[i],t[i]]);s=s.concat(e.slice(a+1))}return s}function M0e(e,t,n=!0){let r=[];if(n){r.push(t);for(let s=t+1;s<e;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{let s=[],a=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?a.push(i):s.push(i);r.push(...s),r.push(0),r.push(...a)}return r}function L0e(e,t,n,r=!0){let s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function P0e(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function z0e(e,t,n){let r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}var rK=1.7580993408473768,sK=1.0507009873554805,B0e=.3275911,W0e=.254829592,V0e=-.284496736,U0e=1.421413741,G0e=-1.453152027,H0e=1.061405429;function j0e(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function q0e(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function K0e(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function X0e(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function Y0e(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function Z0e(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function J0e(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){let a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function Q0e(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}var o_="->",ewe=/->/g,gV=",",yV="...";function twe(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(ewe,"").length)/o_.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${o_}").`);let[r,s]=e.split(o_);Y(r.indexOf(yV)===-1,()=>`The ellipsis notation ("${yV}") is not supported yet.`);let a=r.split(gV),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let h=0;h<s.length;++h){let p=s[h];if(!a.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);o.indexOf(p)===-1&&o.push(p)}for(let h=0;h<r.length;++h){let p=r[h];o.indexOf(p)===-1&&p!==gV&&o.push(p)}let l=new Array(a.length);for(let h=0;h<i;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let p=0;p<a[h].length;++p)l[h].push(o.indexOf(a[h][p]))}let u=o.length,c=s.length,d=[];for(let h=c;h<u;++h)d.push(h);return{allDims:o,summedDims:d,idDims:l}}function nwe(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;let r=[];for(let s=0;s<e;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function rwe(e,t,n){let r=new Array(e);for(let s=0;s<n.length;++s){let a=n[s].shape;for(let i=0;i<t[s].length;++i)r[t[s][i]]===void 0?r[t[s][i]]=a[i]:Y(r[t[s][i]]===a[i],()=>`Expected dimension ${r[t[s][i]]} at axis ${i} of input shaped ${JSON.stringify(a)}, but got dimension ${a[i]}`)}}function swe(e,t){let n=e,r=[],s=0;e.length===0&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);let a=[];for(let i=0;i<n.length;++i){let o=n[i],l=iwe(t,o);for(let u of l)a.indexOf(u)===-1&&(r[i].push(u),a.push(u))}return{path:n,steps:r}}function awe(e){return e.every((t,n)=>t===n)}function iwe(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function owe(e,t,n=0){let r=[];if(typeof t=="number")Y(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let s=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);Y(s<=1,()=>"There should be only one negative value in split array.");let a=t.indexOf(-1);if(a!==-1){let i=t.reduce((o,l)=>l>0?o+l:o);t[a]=e.shape[n]-i}Y(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function lwe(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function uwe(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function cwe(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function dwe(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function hwe(e,t){return`size ${e} must be non-negative, not ${t}`}function pwe(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function fwe(e,t){let n=On(e),r=On(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function mwe(e,t){let n=On(e),r=On(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function gwe(){return"segment ids must be >= 0"}function ywe(){return"segment ids are not increasing"}function bwe(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function xwe(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var aK={};Ct(aK,{collectGatherOpShapeInfo:()=>kwe,computeOutShape:()=>vwe,segOpComputeOptimalWindowSize:()=>wwe});function wwe(e,t){let n=!1,r;for(e<=sM?(r=e,n=!0):r=YI(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=YI(e,r+1);return r}function vwe(e,t,n){let r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function kwe(e,t,n,r){let s=t.shape.length,a=e.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let i=e.shape[n],o=[],l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<s;d++)o.push(t.shape[d]);for(let d=n+1;d<a;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function Iwe(e){try{return e.map(t=>eS(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Swe(e){return e.map(t=>kw(t))}var Yl={};Ct(Yl,{nonMaxSuppressionV3Impl:()=>$8,nonMaxSuppressionV4Impl:()=>T8,nonMaxSuppressionV5Impl:()=>_8,whereImpl:()=>g8});Gxe();var iK={kernelName:Qg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae(e,Of(Me(n,"float32"),-1))}}},Cwe={kernelName:gp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=vn(Me(n,"float32")),s=ks(qe(mt(1),r));return Mn(tt(e,s))}}}},Nwe={kernelName:yp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=ks(qe(vn(Me(n,"float32")),1));return tt(e,r)}}}},$we={kernelName:gd,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Sn(n.shape,r.shape);return{a:()=>{let a=e,i=Tr(n.shape,s);return i.length>0&&(a=st(a,i)),oe(a,n.shape)},b:()=>{let a=e,i=Tr(r.shape,s);return i.length>0&&(a=st(a,i)),oe(a,r.shape)}}}},Twe={kernelName:bp,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,s)=>{n[s]=()=>e.clone()}),n}},_we={kernelName:ny,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ht(n)}}},Ewe={kernelName:ry,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ht(n)}}},Awe={kernelName:xp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>tt(e,ks(qe(mt(1),vn(Me(n,"float32")))))}}},Rwe={kernelName:wp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=ks(Ie(mt(1),vn(Me(n,"float32"))));return tt(e,r)}}}},Dwe={kernelName:Ip,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Sn(n.shape,r.shape);return{a:()=>{let a=Ie(vn(n),vn(r)),i=ae(e,tt(r,a)),o=Tr(n.shape,s);return o.length>0&&(i=st(i,o)),oe(i,n.shape)},b:()=>{let a=Ie(vn(n),vn(r)),i=Mn(ae(e,tt(n,a))),o=Tr(r.shape,s);return o.length>0&&(i=st(i,o)),oe(i,r.shape)}}}},Fwe={kernelName:vp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>tt(e,Ie(vn(Me(n,"float32")),1))}}},Owe={kernelName:kp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>tt(e,qe(mt(1),vn(Me(n,"float32"))))}}};function Mwe(e,t,n,r,s,a){let i=G(e,"dy","avgPool3dGrad"),o=G(t,"input","avgPool3dGrad"),l=i,u=o,c=!1;o.rank===4&&(c=!0,l=oe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=oe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Y(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),Y(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),oa("avgPool3dGrad",s,a);let d={dy:l,input:u},h={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=ne.runKernel(nw,d,h);return c?oe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Lwe=re({avgPool3dGrad_:Mwe}),Pwe={kernelName:sy,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>Lwe(e,r,s,a,i,o)}}};function zwe(e,t,n,r,s){let a=G(e,"dy","avgPoolGrad"),i=G(t,"input","avgPoolGrad");Y(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,l=a,u=!1;i.rank===3&&(u=!0,o=oe(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=oe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Y(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),Y(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let c={dy:l,input:o},d={filterSize:n,strides:r,pad:s},h=ne.runKernel(XC,c,d);return u?oe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Bwe=re({avgPoolGrad_:zwe}),Wwe={kernelName:Sp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>Bwe(e,r,s,a,i)}}},Vwe={kernelName:Cp,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,s]=t,{transposeA:a,transposeB:i}=n;return!a&&!i?{a:()=>At(e,s,!1,!0),b:()=>At(r,e,!0,!1)}:!a&&i?{a:()=>At(e,s,!1,!1),b:()=>At(e,r,!0,!1)}:a&&!i?{a:()=>At(s,e,!1,!0),b:()=>At(r,e,!1,!1)}:{a:()=>At(s,e,!0,!0),b:()=>At(e,r,!0,!0)}}},Uwe={kernelName:ay,gradFunc:(e,t,n)=>{let{blockShape:r,crops:s}=n;return{x:()=>Dw(e,r,s)}}},Gwe={kernelName:J6,gradFunc:(e,t,n)=>{let r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let l=s.length-1;l>=0;l--)if(s[l]===a[l])i[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>st(e,o,!0)}}},Hwe={kernelName:Np,gradFunc:e=>({x:()=>e.clone()})},jwe={kernelName:$p,gradFunc:e=>({x:()=>Ht(e)})},qwe={kernelName:yd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>ss(yo(Uu(r,s),vd(r,a)),e,Ht(e))}}},Kwe={kernelName:sw,inputsToSave:["x"],gradFunc:iK.gradFunc},Xwe={kernelName:oy,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(o=>o.shape),{axis:s}=n,a=ko(s,t[0].shape)[0],i=r.map(o=>o[a]);return Sa(e,i,a).map(o=>()=>o)}},Ywe={kernelName:Tp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return Y(Hc(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>oO(r.shape,e,s,i,o,l),filter:()=>HO(r,e,s.shape,i,o,l)}}},Zwe={kernelName:_p,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>ea(e,s,a,i,o,1,l),filter:()=>HO(e,r,s.shape,a,i,o,l)}}};function Jwe(e,t,n,r,s){let a=e;e.rank===4&&(a=oe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=oe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Y(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),Y(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),Y(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),Y(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),Y(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return ne.runKernel(ly,o,l)}var Qwe=re({conv3DBackpropFilter_:Jwe}),e1e={kernelName:Ep,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:a}=n;Y(Hc(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,o]=t;return{x:()=>Aq(i.shape,e,o,s,a),filter:()=>Qwe(i,e,o.shape,s,a)}}},t1e={kernelName:Ap,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae(Mn(EN(Me(n,"float32"))),e)}}},n1e={kernelName:Rp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae(AN(Me(n,"float32")),e)}}},r1e={kernelName:Dp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{let o=Lq([s],r.rank),l=bN(e,s,a,!i);return o!=null&&(l=Ft(l,o)),l}}}},s1e={kernelName:Fp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=r??[1,1];Y(Hc(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,u]=t;return Y(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),Y(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),Y(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Y(Kl(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),oa("depthwiseConv2d",a,i),{x:()=>S8(l.shape,e,u,s,a,o,i),filter:()=>I8(l,e,u.shape,s,a,o,i)}}},a1e={kernelName:Op,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>ne.runKernel(dg,a,n),filter:()=>ne.runKernel(hg,i,n)}}},i1e={kernelName:Lp,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>ne.runKernel(py,r)}}},o1e={kernelName:fy,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=ae(ta(Mn(vn(n))),2/Math.sqrt(Math.PI));return{x:()=>ae(e,r)}}},l1e={kernelName:Pp,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae(e,n)}}},u1e={kernelName:gy,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>oe(e,n.shape)}}},c1e={kernelName:zp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae(e,ta(n))}}},d1e={kernelName:Bp,gradFunc:e=>({x:()=>Ht(e)})},h1e={kernelName:Wp,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Sn(n.shape,r.shape);return{a:()=>{let a=tt(e,Me(r,"float32")),i=Tr(n.shape,s);return i.length>0?oe(st(a,i),n.shape):a},b:()=>{let a=ae(e,Me(n,"float32")),i=Tr(r.shape,s);i.length>0&&(a=oe(st(a,i),r.shape));let o=vn(r);return Mn(tt(a,Me(o,"float32")))}}}},p1e={kernelName:Vp,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[s,a,i,o]=t,l=o??mt(1),u=Tr(a.shape,s.shape),c=[];if(a.rank===1){for(let m=0;m<s.shape.length-1;++m)c.push(s.shape[m]);c.push(1)}let d=qe(s,a),h=ae(e,l),p=TN(Ie(i,mt(r))),f=ae(ae(ae(p,p),p),mt(-.5));return{x:()=>a.rank===1?oe(ae(ae(e,Ga(oe(p,[1,1,1,a.shape[0]]),c)),l),s.shape):oe(ae(ae(e,p),l),s.shape),mean:()=>{let m=ae(ae(p,mt(-1)),h);return a.rank===1&&(m=st(m,u)),oe(m,a.shape)},variance:()=>{let m=ae(ae(f,d),h);return a.rank===1&&(m=st(m,u)),oe(m,a.shape)},scale:()=>{let m=ae(d,p),g=ae(e,m);return a.rank===1&&(g=st(g,u)),oe(g,a.shape)},offset:()=>{let m=e;return a.rank===1&&(m=st(m,u)),oe(m,a.shape)}}}},f1e={kernelName:by,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,s]=t,{axis:a}=n,i=ko(a,r.shape)[0];return{x:()=>{let o=r.shape,l=s.size,u=o.slice(0,i),c=u.length,d=o.slice(a,o.length).slice(1),h=d.length,p=bV(0,c),f=bV(c+1,c+1+h),m=xV([u,[l],d]),g=oe(e,m),y=oe(s,[l]),b=xV([[c],p,f]),x=Ft(g,b),w=zN(x,y,r.shape[i]),v=gO(b);return w=Ft(w,v),w},indices:()=>s}}};function bV(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function xV(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var m1e={kernelName:Up,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Ht(n),b:()=>Ht(r)}}},g1e={kernelName:Gp,gradFunc:e=>({x:()=>Me(e,"float32")})},y1e={kernelName:Hp,gradFunc:e=>({x:()=>Ht(e)})},b1e={kernelName:jp,gradFunc:e=>({x:()=>Ht(e)})},x1e={kernelName:qp,gradFunc:e=>({x:()=>Ht(e)})},w1e={kernelName:Kp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:s}=n,a=la(r,0);return{x:()=>ss(a,e,ae(e,s))}}},v1e={kernelName:Yp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>tt(e,Ie(n,1))}}},k1e={kernelName:Xp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>tt(e,Me(n,"float32"))}}},I1e={kernelName:eq,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n;return{logits:()=>{let a=ta(r);return qe(e,ae(st(e,s,!0),a))}}}};function S1e(e,t,n,r=5,s=1,a=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:r,bias:s,alpha:a,beta:i};return ne.runKernel($y,o,l)}var C1e=re({localResponseNormalizationBackprop_:S1e}),N1e={kernelName:Zp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>C1e(r,s,e,a,i,o,l)}}};function oK(e,t,n,r){return t.rank<n.rank&&(t=oe(t,jh(t.shape,r))),e.rank<n.rank&&(e=oe(e,jh(e.shape,r))),{x:()=>ae(e,Me(Ja(n,t),e.dtype))}}var wV={kernelName:Jp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:s}=r,a=t[0],i=t[1],o=ko(s,a.shape),l=oK(e,i,a,o);return{x:()=>l.x()}}},$1e={kernelName:Qp,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>ae(e,Me(Uu(n,r),"float32")),b:()=>ae(e,Me(mg(n,r),"float32"))}}};function T1e(e,t,n,r,s,a,i){let o=G(e,"dy","maxPool3dGrad"),l=G(t,"input","maxPool3dGrad"),u=G(n,"output","maxPool3dGrad"),c=o,d=l,h=u,p=!1;l.rank===4&&(p=!0,c=oe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=oe(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=oe(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Y(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),Y(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),Y(h.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),oa("maxPool3dGrad",a,i);let f={dy:c,input:d,output:h},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=ne.runKernel(lw,f,m);return p?oe(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var _1e=re({maxPool3dGrad_:T1e}),E1e={kernelName:Ty,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>_1e(e,r,s,a,i,o,l)}}};function A1e(e,t,n,r,s,a,i){let o=G(e,"dy","maxPoolGrad"),l=G(t,"input","maxPoolGrad"),u=G(n,"output","maxPoolGrad");Y(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),Y(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),Y(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),oa("maxPoolGrad",a,i);let c={dy:o,input:l,output:u},d={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return ne.runKernel(sN,c,d)}var R1e=re({maxPoolGrad_:A1e}),D1e={kernelName:ef,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>R1e(e,r,s,a,i,o)}}},F1e={kernelName:tf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,a=ko(s,r.shape),i=Mq(r.shape,a)[1],o=On(i);return{x:()=>{let l=r.shape.slice();a.forEach(c=>{l[c]=1});let u=oe(e,l);return tt(ae(u,Ha(r.shape,"float32")),o)}}}},O1e={kernelName:nf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:s}=r,[a,i]=t,o=ko(s,a.shape),l=oK(e,i,a,o);return{x:()=>l.x()}}},M1e={kernelName:rf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>ae(e,Me(vd(n,r),"float32")),b:()=>ae(e,Me(la(n,r),"float32"))}}},L1e={kernelName:sf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>Vt(e,a,r.shape)}}},P1e={kernelName:_y,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Sn(n.shape,r.shape);return{a:()=>{let a=Tr(n.shape,s);return a.length>0?oe(st(e,a),n.shape):e},b:()=>{let a=ae(e,Mn(ib(tt(n,r)))),i=Tr(r.shape,s);return i.length>0?oe(st(a,i),r.shape):a}}}},z1e={kernelName:af,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Sn(n.shape,r.shape);return{a:()=>{let a=ae(e,Me(r,"float32")),i=Tr(n.shape,s);return i.length>0?oe(st(a,i),n.shape):a},b:()=>{let a=ae(e,Me(n,"float32")),i=Tr(r.shape,s);return i.length>0?oe(st(a,i),r.shape):a}}}},B1e={kernelName:Ay,gradFunc:e=>({x:()=>Mn(e)})},W1e={kernelName:of,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>sr(n.shape,"float32")}}},V1e={kernelName:My,gradFunc:e=>({x:()=>Ht(e)})},U1e={kernelName:Ly,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return fr(e,r).map(s=>()=>s)}},vV={kernelName:lf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>Vt(e,a,r.shape)}}},G1e={kernelName:uf,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,s]=t,a=n,i=r,o=Sn(a.shape,i.shape);return{a:()=>{let l=Me(i,"float32"),u=ae(e,ae(l,Ou(a,qe(l,mt(1))))),c=Tr(a.shape,o);return c.length>0&&(u=st(u,c)),oe(u,a.shape)},b:()=>{let l=la(a,0),u=ss(l,Qa(a),Ht(a)),c=ae(e,ae(s,u)),d=Tr(i.shape,o);return d.length>0&&(c=st(c,d)),oe(c,i.shape)}}}},H1e={kernelName:cf,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,s=la(n,0);return{x:()=>ss(s,e,ae(e,r)),alpha:()=>{let a=ss(s,Ht(e),ae(e,n)),i=Tr(r.shape,e.shape);return i.length>0&&(a=st(a,i)),oe(a,r.shape)}}}};function j1e(e,t,n){let r=e.shape.slice();r[n]=1;let s=oe(t,r),a=w0(e,n,!0,!1),i=w0(e,n,!0,!0),o=ae(a,i);return ae(s,o)}function q1e(e,t,n){let r=e.shape.length,s=r-n.length,a=W.getAxesPermutation(n,r),i=e;a!=null&&(i=Ft(e,a));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce((d,h)=>d*h,1);o.push(l);let u=i.reshape(o),c=j1e(u,t,s);if(c=c.reshape(i.shape),a!=null){let d=W.getUndoAxesPermutation(a);c=Ft(c,d)}return c}var K1e={kernelName:df,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,a=[];return s==null?a=r.shape.map((i,o)=>o):typeof s=="number"?a=[s]:a=s,{x:()=>q1e(r,e,a)}}},X1e={kernelName:Mp,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Sn(n.shape,r.shape);return{a:()=>{let a=tt(e,Me(r,"float32")),i=Tr(n.shape,s);return i.length>0?oe(st(a,i),n.shape):a},b:()=>{let a=ae(e,Me(n,"float32")),i=Tr(r.shape,s);i.length>0&&(a=oe(st(a,i),r.shape));let o=vn(r);return Mn(tt(a,Me(o,"float32")))}}}},Y1e={kernelName:hf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>tt(e,Mn(vn(n)))}}},Z1e={kernelName:gf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=ae(vd(n,6),Of(n));return{x:()=>ae(e,Me(r,"float32"))}}},J1e={kernelName:pf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae(e,Me(Of(n),"float32"))}}},Q1e={kernelName:Py,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,n.shape)}}},eve={kernelName:mf,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>ne.runKernel(By,s,n)}}},tve={kernelName:ff,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>ne.runKernel(zy,s,n)}}},nve={kernelName:yf,gradFunc:(e,t,n)=>{let{dims:r}=n,s=ko(r,e.shape);return{x:()=>Ti(e,s)}}},rve={kernelName:bf,gradFunc:e=>({x:()=>Ht(e)})},sve={kernelName:xf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Mn(tt(e,ae(Ou(n,1.5),2)))}}},ave={kernelName:Gy,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>Me(Ht(n),"float32"),t:()=>ae(e,Me(n,e.dtype)),e:()=>ae(e,Me(Aw(n),e.dtype))}}},ive={kernelName:wf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=la(n,mt(0)),s=mt(rK),a=mt(sK),i=ae(e,a),o=ae(ae(e,s),ta(Me(n,"float32")));return ss(r,i,o)}}}},ove={kernelName:If,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae(e,ae(n,qe(mt(1),n)))}}},lve={kernelName:kf,gradFunc:e=>({x:()=>Ht(e)})},uve={kernelName:vf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae($w(Me(n,"float32")),e)}}},cve={kernelName:jy,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae(yN(Me(n,"float32")),e)}}},dve={kernelName:Hy,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=tK(r,s,a),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>ll(e,u)}}},hve={kernelName:$f,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:s}=n,a=!0,i=ae(e,r);return{logits:()=>qe(i,ae(st(i,[s],a),r))}}},pve={kernelName:Sf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae(e,ho(n))}}},kV={kernelName:qy,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:s}=n;return{x:()=>Nw(e,r,s)}}},IV={kernelName:Ky,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>In(e,r)}}},fve={kernelName:Cf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>tt(e,ae(ks(Me(n,"float32")),2))}}},mve={kernelName:pw,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae(e,ae(Me(n,"float32"),2))}}},gve={kernelName:Tf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=mt(2);return{a:()=>ae(e,ae(s,qe(n,r))),b:()=>ae(e,ae(s,qe(r,n)))}}},yve={kernelName:xd,gradFunc:e=>({x:()=>Ht(e)})},bve={kernelName:_f,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Sn(n.shape,r.shape);return{a:()=>{let a=e,i=Tr(n.shape,s);return i.length>0&&(a=st(a,i)),oe(a,n.shape)},b:()=>{let a=e,i=Tr(r.shape,s);return i.length>0&&(a=st(a,i)),oe(Mn(a),r.shape)}}}},xve={kernelName:Nf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,s=r.shape.slice(),{axis:a}=n;ko(a,r.shape).forEach(l=>{s[l]=1});let i=oe(e,s),o=ae(i,Ha(r.shape,"float32"));return{x:()=>o}}},wve={kernelName:Ef,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>tt(e,vn($w(n)))}}},vve={kernelName:Af,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae(qe(mt(1),vn(n)),e)}}},kve={kernelName:bd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:s}=n;return{x:()=>{let a=Ht(r);if(r.rank===1)for(let i=0;i<s[0];++i)a=Ie(a,Vt(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)a=Ie(a,Vt(e,[i*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)for(let l=0;l<s[2];++l)a=Ie(a,Vt(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)for(let l=0;l<s[2];++l)for(let u=0;u<s[3];++u)a=Ie(a,Vt(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return a}}}},Ive={kernelName:Cu,gradFunc:(e,t,n)=>{let r=n,{perm:s}=r,a=gO(s);return{x:()=>Ft(e,a)}}},Sve={kernelName:eb,gradFunc:(e,t,n)=>{let r=n,{axis:s}=r;return{value:()=>zr(e,s)}}},Cve={kernelName:xw,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Nve(e,n)}}};function Nve(e,t){let n=Xl(t,Ht(t)),r=ob(e,n),s=Uu(t,mt(0,"int32")),a=r.rank-s.rank;for(let o=0;o<a;++o)s=ms(s,o+1);s=yo(s,Ha(r.shape,"bool"));let i=Ht(r);return ss(s,r,i)}var $ve={kernelName:tb,gradFunc:e=>({x:()=>Ht(e)})},Tve=[iK,Cwe,Nwe,$we,Twe,_we,Ewe,Awe,Rwe,Dwe,Fwe,Owe,Pwe,Wwe,Vwe,Uwe,Gwe,Hwe,jwe,qwe,Kwe,Xwe,Zwe,Ywe,e1e,t1e,n1e,r1e,s1e,a1e,X1e,i1e,o1e,l1e,u1e,c1e,h1e,d1e,p1e,f1e,m1e,g1e,y1e,b1e,x1e,w1e,v1e,k1e,I1e,N1e,wV,wV,$1e,E1e,D1e,F1e,O1e,M1e,L1e,P1e,z1e,B1e,W1e,V1e,U1e,vV,vV,G1e,H1e,K1e,Y1e,Z1e,J1e,Q1e,eve,tve,nve,rve,sve,ave,ive,ove,lve,uve,cve,dve,hve,pve,kV,kV,IV,IV,fve,gve,mve,yve,bve,xve,wve,vve,kve,Ive,Sve,Cve,$ve];for(let e of Tve)tq(e);Se().prototype.abs=function(){return this.throwIfDisposed(),Ir(this)};Se().prototype.acos=function(){return this.throwIfDisposed(),VF(this)};Se().prototype.acosh=function(){return this.throwIfDisposed(),UF(this)};Se().prototype.add=function(e){return this.throwIfDisposed(),Ie(this,e)};Se().prototype.all=function(e,t){return this.throwIfDisposed(),fN(this,e,t)};Se().prototype.any=function(e,t){return this.throwIfDisposed(),y0(this,e,t)};Se().prototype.argMax=function(e){return this.throwIfDisposed(),Uh(this,e)};Se().prototype.argMin=function(e){return this.throwIfDisposed(),GF(this,e)};Se().prototype.asScalar=function(){return this.throwIfDisposed(),Y(this.size===1,()=>"The array must have only 1 element."),oe(this,[])};Se().prototype.asType=function(e){return this.throwIfDisposed(),Me(this,e)};Se().prototype.as1D=function(){return this.throwIfDisposed(),oe(this,[this.size])};Se().prototype.as2D=function(e,t){return this.throwIfDisposed(),oe(this,[e,t])};Se().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),oe(this,[e,t,n])};Se().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),oe(this,[e,t,n,r])};Se().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),oe(this,[e,t,n,r,s])};Se().prototype.asin=function(){return this.throwIfDisposed(),HF(this)};Se().prototype.asinh=function(){return this.throwIfDisposed(),jF(this)};Se().prototype.atan=function(){return this.throwIfDisposed(),qF(this)};Se().prototype.atan2=function(e){return this.throwIfDisposed(),KF(this,e)};Se().prototype.atanh=function(){return this.throwIfDisposed(),XF(this)};Se().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Vu(this,e,t,n,r)};Se().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Nw(this,e,t)};Se().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),Rf(this,e,t,n,r,s)};Se().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Sh(this,e)};Se().prototype.cast=function(e){return this.throwIfDisposed(),Me(this,e)};Se().prototype.ceil=function(){return this.throwIfDisposed(),nO(this)};Se().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Ms(this,e,t)};Se().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Tt&&(e=[e]),In([this,...e],t)};Se().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),mN(this,e,t,n,r,s,a)};Se().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),gN(this,e,t,n,r,s)};Se().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),ea(this,e,t,n,r,s,a)};Se().prototype.cos=function(){return this.throwIfDisposed(),$w(this)};Se().prototype.cosh=function(){return this.throwIfDisposed(),yN(this)};Se().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),w0(this,e,t,n)};Se().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),bN(this,e,t,n)};Se().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),cO(this,e,t)};Se().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Df(this,e,t,n,r,s,a)};Se().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),dO(this,e,t,n,r,s)};Se().prototype.divNoNan=function(e){return this.throwIfDisposed(),hO(this,e)};Se().prototype.div=function(e){return this.throwIfDisposed(),tt(this,e)};Se().prototype.dot=function(e){return this.throwIfDisposed(),pO(this,e)};Se().prototype.elu=function(){return this.throwIfDisposed(),sb(this)};Se().prototype.equal=function(e){return this.throwIfDisposed(),Ja(this,e)};Se().prototype.erf=function(){return this.throwIfDisposed(),fO(this)};Se().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),yO(this,e,t)};Se().prototype.exp=function(){return this.throwIfDisposed(),ta(this)};Se().prototype.expandDims=function(e){return this.throwIfDisposed(),ms(this,e)};Se().prototype.expm1=function(){return this.throwIfDisposed(),bO(this)};Se().prototype.fft=function(){return this.throwIfDisposed(),Mw(this)};Se().prototype.flatten=function(){return this.throwIfDisposed(),oe(this,[this.size])};Se().prototype.floor=function(){return this.throwIfDisposed(),ib(this)};Se().prototype.floorDiv=function(e){return this.throwIfDisposed(),pN(this,e)};Se().prototype.gather=function(e,t,n){return this.throwIfDisposed(),ob(this,e,t,n)};Se().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Uu(this,e)};Se().prototype.greater=function(e){return this.throwIfDisposed(),la(this,e)};Se().prototype.ifft=function(){return this.throwIfDisposed(),xg(this)};Se().prototype.irfft=function(){return this.throwIfDisposed(),DN(this)};Se().prototype.isFinite=function(){return this.throwIfDisposed(),xO(this)};Se().prototype.isInf=function(){return this.throwIfDisposed(),wO(this)};Se().prototype.isNaN=function(){return this.throwIfDisposed(),vO(this)};Se().prototype.leakyRelu=function(e){return this.throwIfDisposed(),_w(this,e)};Se().prototype.lessEqual=function(e){return this.throwIfDisposed(),vd(this,e)};Se().prototype.less=function(e){return this.throwIfDisposed(),mg(this,e)};Se().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),kO(this,e,t,n,r)};Se().prototype.logSigmoid=function(){return this.throwIfDisposed(),IO(this)};Se().prototype.logSoftmax=function(e){return this.throwIfDisposed(),vN(this,e)};Se().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),kN(this,e,t)};Se().prototype.log=function(){return this.throwIfDisposed(),Qa(this)};Se().prototype.log1p=function(){return this.throwIfDisposed(),Ew(this)};Se().prototype.logicalAnd=function(e){return this.throwIfDisposed(),yo(this,e)};Se().prototype.logicalNot=function(){return this.throwIfDisposed(),Aw(this)};Se().prototype.logicalOr=function(e){return this.throwIfDisposed(),IN(this,e)};Se().prototype.logicalXor=function(e){return this.throwIfDisposed(),SO(this,e)};Se().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),At(this,e,t,n)};Se().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),Yr(this,e,t,n,r)};Se().prototype.max=function(e,t){return this.throwIfDisposed(),Ci(this,e,t)};Se().prototype.maximum=function(e){return this.throwIfDisposed(),Xl(this,e)};Se().prototype.mean=function(e,t){return this.throwIfDisposed(),rr(this,e,t)};Se().prototype.min=function(e,t){return this.throwIfDisposed(),fg(this,e,t)};Se().prototype.minimum=function(e){return this.throwIfDisposed(),jc(this,e)};Se().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),NO(this,e,t)};Se().prototype.mod=function(e){return this.throwIfDisposed(),$O(this,e)};Se().prototype.mul=function(e){return this.throwIfDisposed(),ae(this,e)};Se().prototype.neg=function(){return this.throwIfDisposed(),Mn(this)};Se().prototype.norm=function(e,t,n){return this.throwIfDisposed(),ab(this,e,t,n)};Se().prototype.notEqual=function(e){return this.throwIfDisposed(),qh(this,e)};Se().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),gg(this,e,t,n)};Se().prototype.onesLike=function(){return this.throwIfDisposed(),ei(this)};Se().prototype.pad=function(e,t){return this.throwIfDisposed(),ll(this,e,t)};Se().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),TO(this,e,t,n,r,s,a)};Se().prototype.pow=function(e){return this.throwIfDisposed(),Ou(this,e)};Se().prototype.prelu=function(e){return this.throwIfDisposed(),Fw(this,e)};Se().prototype.prod=function(e,t){return this.throwIfDisposed(),_O(this,e,t)};Se().prototype.reciprocal=function(){return this.throwIfDisposed(),FO(this)};Se().prototype.relu=function(){return this.throwIfDisposed(),yn(this)};Se().prototype.relu6=function(){return this.throwIfDisposed(),NN(this)};Se().prototype.reshapeAs=function(e){return this.throwIfDisposed(),oe(this,e.shape)};Se().prototype.reshape=function(e){return this.throwIfDisposed(),oe(this,e)};Se().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),E8(this,e,t,n)};Se().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),A8(this,e,t,n)};Se().prototype.reverse=function(e){return this.throwIfDisposed(),Ti(this,e)};Se().prototype.rfft=function(){return this.throwIfDisposed(),Lw(this)};Se().prototype.round=function(){return this.throwIfDisposed(),$N(this)};Se().prototype.rsqrt=function(){return this.throwIfDisposed(),TN(this)};Se().prototype.selu=function(){return this.throwIfDisposed(),_N(this)};Se().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),ub(this,e,t,n,r,s,a)};Se().prototype.sigmoid=function(){return this.throwIfDisposed(),ho(this)};Se().prototype.sign=function(){return this.throwIfDisposed(),OO(this)};Se().prototype.sin=function(){return this.throwIfDisposed(),EN(this)};Se().prototype.sinh=function(){return this.throwIfDisposed(),AN(this)};Se().prototype.slice=function(e,t){return this.throwIfDisposed(),Vt(this,e,t)};Se().prototype.softmax=function(e){return this.throwIfDisposed(),kd(this,e)};Se().prototype.softplus=function(){return this.throwIfDisposed(),Ff(this)};Se().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Dw(this,e,t)};Se().prototype.split=function(e,t){return this.throwIfDisposed(),Sa(this,e,t)};Se().prototype.sqrt=function(){return this.throwIfDisposed(),ks(this)};Se().prototype.square=function(){return this.throwIfDisposed(),vn(this)};Se().prototype.squaredDifference=function(e){return this.throwIfDisposed(),FN(this,e)};Se().prototype.squeeze=function(e){return this.throwIfDisposed(),Id(this,e)};Se().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Tt?[this,e]:[this,...e];return zr(n,t)};Se().prototype.step=function(e){return this.throwIfDisposed(),Of(this,e)};Se().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),MO(this,e,t,n,r,s,a,i,o)};Se().prototype.sub=function(e){return this.throwIfDisposed(),qe(this,e)};Se().prototype.sum=function(e,t){return this.throwIfDisposed(),st(this,e,t)};Se().prototype.tan=function(){return this.throwIfDisposed(),LO(this)};Se().prototype.tanh=function(){return this.throwIfDisposed(),Hh(this)};Se().prototype.tile=function(e){return this.throwIfDisposed(),Ga(this,e)};Se().prototype.toBool=function(){return this.throwIfDisposed(),Me(this,"bool")};Se().prototype.toFloat=function(){return this.throwIfDisposed(),Me(this,"float32")};Se().prototype.toInt=function(){return this.throwIfDisposed(),Me(this,"int32")};Se().prototype.topk=function(e,t){return this.throwIfDisposed(),zO(this,e,t)};Se().prototype.transpose=function(e){return this.throwIfDisposed(),Ft(this,e)};Se().prototype.unique=function(e){return this.throwIfDisposed(),BO(this,e)};Se().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),zN(this,e,t)};Se().prototype.unstack=function(e){return this.throwIfDisposed(),fr(this,e)};Se().prototype.where=function(e,t){return this.throwIfDisposed(),ss(e,this,t)};Se().prototype.zerosLike=function(){return this.throwIfDisposed(),Ht(this)};var hu=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,hu.prototype)}},zo=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,zo.prototype)}},he=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,he.prototype)}},Rt=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Rt.prototype)}},lK=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,lK.prototype)}},uK=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function Xh(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function vl(e,t){if(!e)throw new lK(t)}function SV(e,t){let n=0;for(let r of e)r===t&&n++;return n}function ba(e){return e.length===1?e[0]:e}function Bn(e){return Array.isArray(e)?e:[e]}function pu(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function oh(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var Wi={};function aM(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function bA(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>bA(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:bA(r))}}}function zw(e,t={},n={},r="object",s=!1){if(typeof e=="string"){let a=e,i;if(a in n)i=n[a];else if(a in Wi)i=Wi[a];else if(i=t[a],i==null)throw new he(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let a=e;if(a.className==null||a.config==null)throw new he(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);let i=a.className,o,l;if(i in n?[o,l]=n[i]:i in Wi?[o,l]=Wi.className:i in t&&([o,l]=t[i]),o==null)throw new he(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let p of Object.keys(Wi))u[p]=Wi[p];for(let p of Object.keys(n))u[p]=n[p];let c=a.config;c.customObjects=u;let d=Object.assign({},Wi);for(let p of Object.keys(n))Wi[p]=n[p];bA(a.config);let h=l(o,a.config,n,s);return Wi=Object.assign({},d),h}else{let u=Object.assign({},Wi);for(let d of Object.keys(n))Wi[d]=n[d];let c=new o(a.config);return Wi=Object.assign({},u),c}}}function _ve(e,t){return e<t?-1:e>t?1:0}function sk(e,t){return-1*_ve(e,t)}function Dc(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function Eve(e){if(e==null)throw new he(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Mf(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new he(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function iM(e,t,n=0,r=1/0){return vl(n>=0),vl(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(s=>typeof s===t)}function ts(e,t){Array.isArray(e)?(_.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>ts(n,`element ${r+1} of ${t}`))):_.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${cK(e)}.`)}function cK(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>cK(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function Ave(e,t,n){let r=n!=null?n():_.now(),s;return(...a)=>{let i=n!=null?n():_.now();return i-r<t||(r=i,s=e(...a)),s}}function dK(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var Rve=0;function hK(){return Rve++}var ak={};function jN(e=""){return e in ak||(ak[e]=0),ak[e]+=1,e+ak[e].toString()}var Dve=["channelsFirst","channelsLast"],Fve=["nearest","bilinear"],Ove=["valid","same","causal"],Mve=["max","avg"],Lve=["sum","mul","concat","ave"],im=new Map;function xr(e){Mf(Dve,"DataFormat",e)}function Pve(e){Mf(Fve,"InterpolationFormat",e)}function Li(e){Mf(Ove,"PaddingMode",e)}function pK(e){Mf(Mve,"PoolMode",e)}var Wx=[],CV="/";function Ch(e,t){Wx.push(e);try{let n=t();return Wx.pop(),n}catch(n){throw Wx.pop(),n}}function zve(){return Wx.length===0?"":Wx.join(CV)+CV}function fK(e){if(!gK(e))throw new Error("Not a valid tensor name: '"+e+"'");return zve()+e}function mK(e){if(!gK(e))throw new Error("Not a valid tensor name: '"+e+"'");im.has(e)||im.set(e,0);let t=im.get(e);if(im.set(e,im.get(e)+1),t>0){let n=`${e}_${t}`;return im.set(n,1),n}else return e}var Bve=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function gK(e){return!!e.match(Bve)}function Wve(e){return e===parseInt(e.toString(),10)}function Fc(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function kg(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function Kc(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function el(e,t){if(t<e)throw new he(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}var l_;function Mr(){return l_==null&&(l_=Sq().epsilon()),l_}function tl(){return"channelsLast"}function Mu(e,t){return Me(e,t)}function Bw(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),oe(e,n)}function Vve(e,t){return ue(()=>{if(e.shape.length!==2)throw new he(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=Bw(e,1);return xA(n,[1,t,1])})}function Uve(e){let t=[Fc(e.shape)];return oe(e,t)}function Gve(e){if(e.rank<=1)throw new he(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],Fc(e.shape,1)];return oe(e,t)}function Nh(e,t,n){return ue(()=>{switch(e.rank){case 1:return Ow(e,t,n);case 2:return RN(e,[t,0],[n,e.shape[1]]);case 3:return cb(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return bg(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Vt(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Vt(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new he(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function u_(e,t,n){return ue(()=>{switch(e.rank){case 1:return Ow(e,t,n);case 2:return RN(e,[0,t],[e.shape[0],n]);case 3:return cb(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return bg(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new he(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function ik(e,t,n,r){return ue(()=>{switch(e.rank){case 1:return Ow(e,t,n);case 2:switch(r){case 1:return Nh(e,t,n);case 2:return u_(e,t,n);default:throw new he(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Nh(e,t,n);case 2:return cb(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return u_(e,t,n);default:throw new he(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Nh(e,t,n);case 2:return bg(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return bg(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return u_(e,t,n);default:throw new he(`The axis is not within the rank of the tensor ${r}`)}default:throw new he(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function oM(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),In(e,t)}function NV(e,t){switch(e.rank){case 1:return rO([e,t]);case 2:return sO([e,t],0);case 3:return aO([e,t],0);case 4:return iO([e,t],0);default:throw new he(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function xA(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new he(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Ga(e,t)}function qN(e,t=0,n=1,r,s){return CN(e,t,n,r,s)}function Ml(e,t,n,r){if(e.rank<2||t.rank<2)throw new Rt(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let s=e.shape.slice(-1)[0],a=t.shape.slice(-2)[0];if(s!==a)throw new Rt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return wg.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?wA(e.rank,r,tl()):null,activation:n});{let s=e.shape.slice(),a=s.pop();e=oe(e,[-1,a]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},(f,m)=>m===0?t.rank-2:m<=t.rank-2?m-1:m);t=oe(Ft(t,c),[l,-1]);let d=[...s,...u],h=!1,p=!1;return oe(wg.matMul({a:e,b:t,transposeA:h,transposeB:p,bias:r?wA(e.rank,r,tl()):null,activation:n}),d)}}function yK(e,t,n){return ue(()=>(Array.isArray(t)?t=gn(t,"int32"):t=Me(t,"int32"),ob(e,t,n)))}function Ww(e){return ae(e,e)}function wA(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new he(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?oe(t,[1,r[0],1,1,1]):oe(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?oe(t,[1,1,1,1,r[0]]):oe(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?oe(t,[1,r[0],1,1]):oe(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?oe(t,[1,1,1,r[0]]):oe(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?oe(t,[1,r[0],1]):oe(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?oe(t,[1,1,r[0]]):oe(t,[1].concat(r))}else if(e<3)return t;throw new he(`Unsupported input rank by biasAdd: ${t.rank}`)}function ul(e,t,n){return ue(()=>(n==null&&(n=tl()),xr(n),Ie(e,wA(e.rank,t,n))))}function Hve(e,t=1){if(t!==1)throw new Rt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return sb(e)}function jve(e){return ue(()=>tt(e,Ie(Ir(e),1)))}function bK(e,t,n,r){return ue(()=>UO(e,t,n,r))}function qve(e){return ue(()=>{let t=Ie(.5,ae(.2,e));return Ms(t,0,1)})}function Vw(e,t,n=!1){return n?e():t()}var Kve=["fanIn","fanOut","fanAvg"],Xve=["normal","uniform","truncatedNormal"];function Yve(e){Mf(Kve,"FanMode",e)}function Zve(e){Mf(Xve,"Distribution",e)}var Io=class extends _e.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},lM=class extends Io{apply(e,t){return sr(e,t)}};lM.className="Zeros";_e.registerClass(lM);var KN=class extends Io{apply(e,t){return Ha(e,t)}};KN.className="Ones";_e.registerClass(KN);var uM=class extends Io{constructor(e){if(super(),typeof e!="object")throw new he(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new he(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ue(()=>ae(mt(this.value),Ha(e,t)))}getConfig(){return{value:this.value}}};uM.className="Constant";_e.registerClass(uM);var cM=class extends Io{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return lb(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};cM.className="RandomUniform";_e.registerClass(cM);var dM=class extends Io{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Rt(`randomNormal does not support dType ${t}.`);return qN(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};dM.className="RandomNormal";_e.registerClass(dM);var hM=class extends Io{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Rt(`truncatedNormal does not support dType ${t}.`);return PN(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};hM.className="TruncatedNormal";_e.registerClass(hM);var pM=class extends Io{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return ue(()=>{if(e.length!==2||e[0]!==e[1])throw new he("Identity matrix initializer can only be used for 2D square matrices.");return ae(this.gain,xN(e[0]))})}getConfig(){return{gain:this.gain}}};pM.className="Identity";_e.registerClass(pM);function Jve(e,t="channelsLast"){let n,r;if(xr(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let s=Fc(e,2);n=e[1]*s,r=e[0]*s}else if(t==="channelsLast"){let s=Fc(e,0,e.length-2);n=e[e.length-2]*s,r=e[e.length-1]*s}}else{let s=Fc(e);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}var $a=class extends Io{constructor(e){if(super(),e.scale<0)throw new he(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Yve(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Zve(this.distribution),this.seed=e.seed}apply(e,t){let n=Jve(e),r=n[0],s=n[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),this.distribution==="normal"){let i=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Rt(`${this.getClassName()} does not support dType ${t}.`);return PN(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*a);return lb(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};$a.className="VarianceScaling";_e.registerClass($a);var XN=class extends $a{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return $a.className}};XN.className="GlorotUniform";_e.registerClass(XN);var YN=class extends $a{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return $a.className}};YN.className="GlorotNormal";_e.registerClass(YN);var ZN=class extends $a{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return $a.className}};ZN.className="HeNormal";_e.registerClass(ZN);var JN=class extends $a{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return $a.className}};JN.className="HeUniform";_e.registerClass(JN);var QN=class extends $a{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return $a.className}};QN.className="LeCunNormal";_e.registerClass(QN);var e2=class extends $a{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return $a.className}};e2.className="LeCunUniform";_e.registerClass(e2);var fM=class extends Io{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return ue(()=>{if(e.length<2)throw new Rt("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=_.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);let a=[Math.max(r,n),Math.min(r,n)],i=qN(a,0,1,t,this.seed),o=qO.qr(i,!1),l=o[0],u=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return l=ae(l,u.sign()),n<r&&(l=l.transpose()),ae(mt(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};fM.className="Orthogonal";_e.registerClass(fM);var $V={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function TV(e,t={}){return zw(e,_e.SerializationMap.getMap().classNameMap,t,"initializer")}function ar(e){return aM(e)}function Yn(e){if(typeof e=="string"){let t=e in $V?$V[e]:e;if(t==="GlorotNormal")return new YN;if(t==="GlorotUniform")return new XN;if(t==="HeNormal")return new ZN;if(t==="HeUniform")return new JN;if(t==="LeCunNormal")return new QN;if(t==="LeCunUniform")return new e2;{let n={};return n.className=t,n.config={},TV(n)}}else return e instanceof Io?e:TV(e)}function vA(e){return Array.isArray(e)&&Array.isArray(e[0])}function sS(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function kt(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new he(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function dn(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new he(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function aS(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,s)=>r*s);return t}var _V="Variable",xK=class{constructor(e,t="float32",n=_V,r=!0,s=null){this.dtype=t??"float32",this.shape=e.shape,this.id=hK(),n=n??_V,this.originalName=fK(n),this.name=mK(this.originalName),this.trainable_=r,this.constraint=s,this.val=WO(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Qve(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function Qve(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function kA(e){return e.map(t=>t.read())}function mM(e){e.forEach(t=>{t[0].write(t[1])})}var Cr=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},Bo=class{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=hK(),a!=null&&(this.originalName=fK(a),this.name=mK(this.originalName)),this.rank=t.length}},eke=0,t2=class{constructor(e,t){this.callArgs=t,this.id=eke++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},tke=0,zt=class extends _e.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=tke++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=pu(n)+"_"+jN(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),n=[s].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new zo(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new he(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return ba(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return ba(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new hu(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new hu(`Layer ${this.name} is not connected, no input to return.`);return ba(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new hu(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new hu(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ba(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=Bn(e),this.inputSpec==null||this.inputSpec.length===0)return;let t=Bn(this.inputSpec);if(e.length!==t.length)throw new he(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let r=e[n],s=t[n];if(s==null)continue;let a=r.rank;if(s.ndim!=null&&a!==s.ndim)throw new he(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(s.maxNDim!=null&&a>s.maxNDim)throw new he(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(s.minNDim!=null&&a<s.minNDim)throw new he(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(s.dtype!=null&&r.dtype!==s.dtype)throw new he(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){let i=r.shape;for(let o in s.axes){let l=Number(o),u=s.axes[o],c=l>=0?i[l]:i[i.length+l];if(u!=null&&[u,null].indexOf(c)===-1)throw new he(`Input ${n} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${u} but got shape ${i}.`)}}if(s.shape!=null)for(let i=0;i<s.shape.length;++i){let o=s.shape[i],l=r.shape[i];if(o!=null&&l!=null&&o!==l)throw new he(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=Bn(e),r=!0;for(let a of n)if(!(a instanceof Bo)){r=!1;break}let s=!0;for(let a of n)if(a instanceof Bo){s=!1;break}if(r===s)throw new he("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ch(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let a=[];for(let i of Bn(e))a.push(i.shape);this.build(ba(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t),i=Bn(a),o=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(a=ba(o),this.activityRegularizer!=null)throw new Rt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=nke(e),i=this.computeOutputShape(a),o,l=rke(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((u,c)=>new Bo(l,u,this,Bn(e),t,this.name,c)):o=new Bo(l,i,this,Bn(e),t,this.name),this.addInboundNode(e,o,null,null,a,i,t),this._refCount++,this.activityRegularizer!=null)throw new Rt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new hu(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new hu(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new zo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return aS(this.weights)}build(e){this.built=!0}getWeights(e=!1){return kA(e?this.trainableWeights:this.weights)}setWeights(e){ue(()=>{let t=this.weights;if(t.length!==e.length)throw new he(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=kA(t);for(let s=0;s<r.length;++s){let a=r[s],i=t[s],o=e[s];if(!_.arraysEqual(a.shape,o.shape))throw new he(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}mM(n)})}addWeight(e,t,n,r,s,a,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new he(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=o!=null?o():Yn("zeros"));let l=r.apply(t,n),u=new xK(l,n,e,a,i);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(u.read())),a==null&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Bn(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,n,r,s,a,i=null){let o=Bn(e);t=Bn(t),n=Bn(n),r=Bn(r),s=sS(s),a=sS(a);let l=[],u=[],c=[];for(let d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex);new t2({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function nke(e){e=Bn(e);let t=[];for(let n of e)t.push(n.shape);return ba(t)}function rke(e){return"float32"}function wK(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let s=[];for(let a=0;a<r.inboundLayers.length;a++){let i=r.inputTensors[a],o=r.inboundLayers[a],l=r.nodeIndices[a],u=wK(i,o,l);for(let c of u)s.indexOf(c)===-1&&s.push(c)}return s}}}var hb=class extends zt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:jN("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new he("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new he("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new he("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new Bo(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new t2({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new he(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};hb.className="InputLayer";_e.registerClass(hb);function vK(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new he("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new hb({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function ske(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return Me(t,e.dtype)}catch{throw new he(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var yh=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof yh)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=ske(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new he(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Bo){if(this.id2Value[e.id]==null)throw new he(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{let t=this.name2Id[e];if(t==null)throw new he(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Bo){if(this.id2Value[e.id]==null)throw new he(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{let t=this.name2Id[e];if(t==null)throw new he(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&St(this.id2Mask)}},iS=new uK,oS=new uK;function ake(e){iS!=null&&iS.setMaxEntries(e),oS!=null&&oS.setMaxEntries(e)}function gx(e,t,n,r){let s=n==null?!1:n.training,a=Array.isArray(e),i=a?e:[e],o=i.map(f=>f.name),l=[],u=t.names();for(let f of o)u.indexOf(f)!==-1?l.push(t.getValue(f)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let c=o.join(",")+"|"+t.names().sort().join(","),d=iS.get(c),h;if(d==null){let f=ike(i,t);d=f.sorted,h=f.recipientCounts,iS.put(c,d),oS.put(c,h)}h={},s||Object.assign(h,oS.get(c));let p=new yh(t);for(let f=0;f<d.length;++f){if(r!=null){let $=nS().numTensors;$>r.maxNumTensors&&(r.maxNumTensors=$),$<r.minNumTensors&&(r.minNumTensors=$)}let m=d[f],g=m.sourceLayer;if(g instanceof hb)continue;let y=[],b=[],x=[],w=!1;for(let $ of m.inputs){let N=p.getValue($),T=p.getMask($);y.push(N),b.push(T),T!=null&&(w=!0),s||(h[$.name]--,h[$.name]===0&&!t.hasKey($)&&o.indexOf($.name)===-1&&!N.isDisposed&&$.sourceLayer.stateful!==!0&&x.push(N))}w&&(n=n||{},n.mask=b[0]);let v=Bn(g.apply(y,n)),k=null;g.supportsMasking&&(k=g.computeMask(y,b));let I=lke(m),S=Array.isArray(I)?I:[I];for(let $=0;$<S.length;++$){p.hasKey(S[$])||p.add(S[$],v[$],Array.isArray(k)?k[0]:k);let N=o.indexOf(S[$].name);N!==-1&&(l[N]=v[$])}s||St(x)}return p.disposeMasks(),a?l:l[0]}function ike(e,t){_.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let s=EV(e[0],t);n=s.sorted,r=s.recipientMap}else{let s=new Set;for(let a of e){let{sorted:i,recipientMap:o}=EV(a,t);for(let l of i)s.has(l.name)||(n.push(l),s.add(l.name));for(let l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:oke(r)}}function oke(e){let t={};for(let n in e)t[n]=e[n].size;return t}function EV(e,t){let n=new Set,r=[],s={};for(let o of t.names())n.add(o);let a=[],i=[];for(a.push(e);a.length>0;){let o=a[a.length-1];if(n.has(o.name)){a.pop();continue}let l=i[i.length-1]===a.length-1;if(o.inputs.length===0||l)a.pop(),r.push(o),n.add(o.name),l&&i.pop();else{i.push(a.length-1);for(let u of o.inputs)s[u.name]==null&&(s[u.name]=new Set),s[u.name].add(o.name),!n.has(u.name)&&a.push(u)}}return{sorted:r,recipientMap:s}}function lke(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var uke=me();uke.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,ake);var kK={};Ct(kK,{maxNorm:()=>cke,minMaxNorm:()=>pke,nonNeg:()=>hke,unitNorm:()=>dke});function gM(e,t){return ue(()=>ks(st(ae(e,e),t,!0)))}var Uw=class extends _e.Serializable{getConfig(){return{}}},yM=class extends Uw{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ue(()=>{let t=gM(e,this.axis),n=Ms(t,0,this.maxValue);return ae(e,tt(n,Ie(Mr(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};yM.className="MaxNorm";_e.registerClass(yM);var bM=class extends Uw{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ue(()=>tt(e,Ie(Mr(),gM(e,this.axis))))}getConfig(){return{axis:this.axis}}};bM.className="UnitNorm";_e.registerClass(bM);var xM=class extends Uw{apply(e){return yn(e)}};xM.className="NonNeg";_e.registerClass(xM);var wM=class extends Uw{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ue(()=>{let t=gM(e,this.axis),n=Ie(ae(this.rate,Ms(t,this.minValue,this.maxValue)),ae(1-this.rate,t));return ae(e,tt(n,Ie(Mr(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};wM.className="MinMaxNorm";_e.registerClass(wM);var AV={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Wr(e){return aM(e)}function RV(e,t={}){return zw(e,_e.SerializationMap.getMap().classNameMap,t,"constraint")}function Vr(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in AV?AV[e]:e,config:{}};return RV(t)}else return e instanceof Uw?e:RV(e)}function cke(e){return new yM(e)}function dke(e){return new bM(e)}function hke(){return new xM}function pke(e){return new wM(e)}var IK={};Ct(IK,{constant:()=>gke,glorotNormal:()=>Ike,glorotUniform:()=>kke,heNormal:()=>Ske,heUniform:()=>Cke,identity:()=>wke,leCunNormal:()=>Nke,leCunUniform:()=>$ke,ones:()=>mke,orthogonal:()=>Tke,randomNormal:()=>bke,randomUniform:()=>yke,truncatedNormal:()=>xke,varianceScaling:()=>vke,zeros:()=>fke});function fke(){return new lM}function mke(){return new KN}function gke(e){return new uM(e)}function yke(e){return new cM(e)}function bke(e){return new dM(e)}function xke(e){return new hM(e)}function wke(e){return new pM(e)}function vke(e){return new $a(e)}function kke(e){return new XN(e)}function Ike(e){return new YN(e)}function Ske(e){return new ZN(e)}function Cke(e){return new JN(e)}function Nke(e){return new QN(e)}function $ke(e){return new e2(e)}function Tke(e){return new fM(e)}var SK={};Ct(SK,{Layer:()=>zt,RNN:()=>Zl,RNNCell:()=>Kw,activation:()=>tSe,add:()=>cSe,alphaDropout:()=>qSe,average:()=>dSe,averagePooling1d:()=>E3,averagePooling2d:()=>A3,averagePooling3d:()=>R3,avgPool1d:()=>wSe,avgPool2d:()=>kSe,avgPool3d:()=>SSe,avgPooling1d:()=>vSe,avgPooling2d:()=>ISe,avgPooling3d:()=>CSe,batchNormalization:()=>ySe,bidirectional:()=>zSe,categoryEncoding:()=>JSe,centerCrop:()=>YSe,concatenate:()=>hSe,conv1d:()=>jIe,conv2d:()=>qIe,conv2dTranspose:()=>KIe,conv3d:()=>XIe,conv3dTranspose:()=>YIe,convLstm2d:()=>OSe,convLstm2dCell:()=>MSe,cropping2D:()=>JIe,dense:()=>nSe,depthwiseConv2d:()=>eSe,dot:()=>gSe,dropout:()=>rSe,elu:()=>BIe,embedding:()=>uSe,flatten:()=>aSe,gaussianDropout:()=>jSe,gaussianNoise:()=>HSe,globalAveragePooling1d:()=>NSe,globalAveragePooling2d:()=>$Se,globalMaxPool1d:()=>WSe,globalMaxPool2d:()=>VSe,globalMaxPooling1d:()=>mX,globalMaxPooling2d:()=>gX,gru:()=>_Se,gruCell:()=>ESe,input:()=>VK,inputLayer:()=>zIe,layerNormalization:()=>bSe,leakyReLU:()=>VIe,lstm:()=>ASe,lstmCell:()=>RSe,masking:()=>KSe,maxPool1d:()=>USe,maxPool2d:()=>GSe,maxPooling1d:()=>yX,maxPooling2d:()=>bX,maxPooling3d:()=>TSe,maximum:()=>pSe,minimum:()=>fSe,multiply:()=>mSe,permute:()=>lSe,prelu:()=>UIe,reLU:()=>WIe,repeatVector:()=>iSe,rescaling:()=>XSe,reshape:()=>oSe,resizing:()=>ZSe,rnn:()=>LSe,separableConv2d:()=>ZIe,simpleRNN:()=>DSe,simpleRNNCell:()=>FSe,softmax:()=>GIe,spatialDropout1d:()=>sSe,stackedRNNCells:()=>PSe,thresholdedReLU:()=>HIe,timeDistributed:()=>BSe,upSampling2d:()=>QIe,zeroPadding2d:()=>xSe});async function sc(e){if(e==null)return;let t=[],n=[],r=[];for(let s in e){let a=e[s];if(typeof a!="number"){let i=a;t.push(i.data()),n.push(s),r.push(i)}}if(t.length>0){let s=await Promise.all(t);for(let a=0;a<s.length;++a)e[n[a]]=s[a][0];St(r)}}function CK(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var DV;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(DV||(DV={}));var _ke=125,Ig=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},NK=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},Eke=class extends Ig{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let r in t){let s=t[r];if(typeof s=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+s*n;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;let i=ue(()=>Ie(this.totals[r],ae(s,n)));this.totals[r]=i,a!=null&&a.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:ue(()=>{let r=ae(tt(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),Or(t[n])}))}},$K=class extends Ig{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let s in this.history){let a=this.history[s];for(let i=0;i<a.length;++i)if(typeof a[i]!="number"){let o=a[i];e.push(o.data()),t.push(s),n.push(i)}}let r=await Promise.all(e);for(let s=0;s<r.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=r[s][0]}},TK=class extends Ig{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||rM,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=_ke),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");_.isNumber(this.yieldEvery)&&(this.maybeWait=Ave(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await sc(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await sc(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await sc(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await sc(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await sc(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):_.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await sc(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await sc(e),await this.trainEnd(e))}};function _K(e,t){return e==null&&(e={}),e instanceof Ig?[e]:Array.isArray(e)&&e[0]instanceof Ig?e:Bn(e).map(n=>new TK(n,t))}var qi=class{constructor(){}static registerCallbackConstructor(e,t){_.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),qi.checkForDuplicate(t),qi.constructors[e]==null&&(qi.constructors[e]=[]),qi.constructors[e].push(t)}static checkForDuplicate(e){for(let t in qi.constructors)qi.constructors[+t].forEach(n=>{if(n===e)throw new he("Duplicate callback constructor.")})}static clear(){qi.constructors={}}static createCallbacks(e){let t=[];for(let n in qi.constructors){let r=+n;e>=r&&t.push(...qi.constructors[r])}return t.map(n=>new n)}};qi.constructors={};function EK(e,t,n,r,s,a,i,o,l){let u=new $K,c=[new Eke,...qi.createCallbacks(t)];e!=null&&c.push(...e),c.push(u);let d=new NK(c);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function Ho(e,t={},n=!1){return zw(e,_e.SerializationMap.getMap().classNameMap,t,"layer",n)}function lS(e,t){return ue(()=>{e.dtype!=="float32"&&(e=Me(e,"float32"));let n=st(Ww(e),t,!0),r=Ya(n.shape,Mr()),s=ks(Xl(n,r));return tt(e,s)})}function Lf(e,t){return ue(()=>rr(Ww(qe(t,e)),-1))}function n2(e,t){return ue(()=>rr(Ir(qe(t,e)),-1))}function pb(e,t){return ue(()=>{let n=qe(e,t),r=Ms(Ir(e),Mr(),Number.MAX_VALUE),s=Ir(tt(n,r));return ae(100,rr(s,-1))})}function Ake(e,t){return ue(()=>{let n=Ms(t,Mr(),Number.MAX_VALUE),r=Qa(Ie(1,n)),s=Ms(e,Mr(),Number.MAX_VALUE),a=Qa(Ie(1,s));return rr(Ww(qe(r,a)),-1)})}function Rke(e,t){return ue(()=>{let n=Xl(0,qe(1,ae(e,t)));return rr(Ww(n),-1)})}function Dke(e,t){return ue(()=>{let n=Xl(0,qe(1,ae(e,t)));return rr(n,-1)})}function Fke(e,t){return ue(()=>{let n=st(ae(e,t),-1),r=Ci(ae(qe(1,e),t),-1);return Xl(0,Ie(1,qe(r,n)))})}function Oke(e,t){return ue(()=>{let n=Math.log(2),r=qe(t,e),s=qe(Ie(r,Ff(ae(-2,r))),n);return rr(s,-1)})}function v0(e,t,n=!1){return ue(()=>{if(n)t=kd(t);else{let r=st(t,t.shape.length-1,!0);t=tt(t,r)}return t=Ms(t,Mr(),1-Mr()),Mn(st(ae(Me(e,"float32"),Qa(t)),t.shape.length-1))})}function uS(e,t,n=!1){return ue(()=>{let r=Me(ib(Uve(e)),"int32");t=Ms(t,Mr(),1-Mr());let s=t.shape,a=oe(gg(r,s[s.length-1]),s);return v0(a,t,n)})}function Mke(e,t){if(!_.arraysEqual(e.shape,t.shape))throw new he(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return ue(()=>{let n=yn(t),r=Mn(Ir(t));return Ie(qe(n,ae(t,e)),Ew(ta(r)))})}function r2(e,t){return ue(()=>{let n;return n=Ms(t,Mr(),1-Mr()),n=Qa(tt(n,qe(1,n))),rr(Mke(e,n),-1)})}function Lke(e,t){return ue(()=>{let n=Ms(e,Mr(),1),r=Ms(t,Mr(),1);return st(ae(e,Qa(tt(n,r))),-1)})}function Pke(e,t){return ue(()=>{let n=Qa(Ie(Mr(),t));return rr(qe(t,ae(e,n)),-1)})}function vM(e,t){return ue(()=>{let n=lS(e,-1),r=lS(t,-1),s=ae(n,r);return Mn(st(s,-1))})}var cS={meanSquaredError:Lf,meanAbsoluteError:n2,meanAbsolutePercentageError:pb,meanSquaredLogarithmicError:Ake,squaredHinge:Rke,hinge:Dke,categoricalHinge:Fke,logcosh:Oke,categoricalCrossentropy:v0,sparseCategoricalCrossentropy:uS,binaryCrossentropy:r2,kullbackLeiblerDivergence:Lke,poisson:Pke,cosineProximity:vM};function c_(e){if(typeof e=="string"){if(e in cS)return cS[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new he(t)}else return e}function kM(e,t){return ue(()=>{let n=ae(.5,ei(t)),r=Mu(la(t,n),e.dtype);return rr(Ja(e,r),-1)})}function IM(e,t){return ue(()=>Mu(Ja(Uh(e,-1),Uh(t,-1)),"float32"))}function AK(e,t){return ue(()=>Me(st(yo(Ja(e,1),Ja(t,1))),"float32"))}function zke(e,t){return ue(()=>Me(st(yo(Ja(e,1),Ja(t,0))),"float32"))}function Bke(e,t){return ue(()=>Me(st(yo(Ja(e,0),Ja(t,1))),"float32"))}function RK(e,t){return ue(()=>{let n=AK(e,t),r=Bke(e,t),s=Ie(n,r);return Me(ss(la(s,0),tt(n,s),0),"float32")})}function Wke(e,t){return ue(()=>{let n=AK(e,t),r=zke(e,t),s=Ie(n,r);return Me(ss(la(s,0),tt(n,s),0),"float32")})}function DK(e,t){return r2(e,t)}function FK(e,t){return e.rank===t.rank&&(e=Id(e,[e.rank-1])),t=Uh(t,-1),t.dtype!==e.dtype&&(t=Me(t,e.dtype)),Me(Ja(e,t),"float32")}var Vke=Lf,Uke=Lf,Gke=n2,Hke=n2,jke=pb,qke=pb,SM=v0,Kke=vM,OK=uS,dS={binaryAccuracy:kM,categoricalAccuracy:IM,precision:RK,categoricalCrossentropy:SM,sparseCategoricalCrossentropy:OK,mse:Vke,MSE:Uke,mae:Gke,MAE:Hke,mape:jke,MAPE:qke,cosine:Kke};function Xke(e){if(typeof e=="string"&&e in dS)return dS[e];if(typeof e!="string"&&e!=null)return e;throw new he(`Unknown metric ${e}`)}function ok(e){if(vl(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(cS))if(cS[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(dS))if(dS[n]===e){t=n;break}return t!==void 0?t:e.name}}function Yke(e){let t={Adagrad:()=>rh.adagrad(.01),Adadelta:()=>rh.adadelta(1,.95,Mr()),Adam:()=>rh.adam(.001,.9,.999,Mr()),Adamax:()=>rh.adamax(.002,.9,.999,Mr(),0),RMSProp:()=>rh.rmsprop(.001,.9,0,Mr()),SGD:()=>rh.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new he(`Unknown Optimizer ${e}`)}function FV(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!IA(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function IA(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!IA(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!IA(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function Zke(e,t,n,r=console.log){let s=Qke(e),a=["Layer (type)","Input Shape","Output shape","Param #"];s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let i;if(!s){a.push("Receives inputs"),i=[];for(let c in e.nodesByDepth)i.push(...e.nodesByDepth[c])}r("_".repeat(t)),hS(a,n,r),r("=".repeat(t));let o=e.layers;for(let c=0;c<o.length;++c)s?eIe(o[c],n,r):tIe(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=Jke(e),u=aS(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function Jke(e){let t;return e.collectedTrainableWeights!=null?t=aS(e.collectedTrainableWeights):t=aS(e.trainableWeights),t}function Qke(e){let t=!0,n=[],r=[];for(let s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(let s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(let s of e.layers){let a=!1;for(let i of s.inboundNodes)if(r.indexOf(i)!==-1)if(a){t=!1;break}else a=!0;if(!t)break}return t}function hS(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function eIe(e,t,n){let r,s;try{s=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let a=e.name,i=e.getClassName(),o=[`${a} (${i})`,s,r,e.countParams().toString()];hS(o,t,n)}function tIe(e,t,n,r){let s,a;try{a=e.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{a="multiple"}try{s=JSON.stringify(e.outputShape)}catch{s="multiple"}let i=[];for(let d of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let h=0;h<d.inboundLayers.length;++h){let p=d.inboundLayers[h].name,f=d.nodeIndices[h],m=d.tensorIndices[h];i.push(`${p}[${f}][${m}]`)}let o=e.name,l=e.getClassName(),u=i.length===0?"":i[0],c=[`${o} (${l})`,a,s,e.countParams().toString(),u];hS(c,t,r);for(let d=1;d<i.length;++d)hS(["","","","",i[d]],t,r)}function MK(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function k0(e,t){if(e===null)return null;if(typeof e=="string")return oh(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let a=e[s];MK(t,s,a)?n.push(a):n.push(k0(a,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r];if(r==="name"&&typeof s=="string")n[r]=s;else{let a=oh(r);n[a]=k0(s,a)}}return n}}function SA(e,t){if(e==null)return null;if(typeof e=="string")return pu(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let a=e[s];MK(t,s,a)?n.push(a):n.push(SA(a,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r],a=pu(r);(r==="name"||r==="className")&&typeof s=="string"?n[a]=s:n[a]=SA(s,r)}return n}}var CM="4.3.0",ml=class extends zt{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){let y=this.getClassName().toLowerCase();this.name=jN(y)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Dc(this.inputs).length!==this.inputs.length)throw new he(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(y=>y.name)}`);Dc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(y=>y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let y of this.outputs){let b=y.sourceLayer,x=y.nodeIndex,w=y.tensorIndex;this.outputLayers.push(b),this.outputLayersNodeIndices.push(x),this.outputLayersTensorIndices.push(w)}for(let y of this.inputs){let b=y.sourceLayer,x=y.nodeIndex,w=y.tensorIndex;vl(x===0,"input layer has >1 nodes"),vl(w===0,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(x),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){let b=this.inputLayers[y];if(!(b instanceof hb))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(let y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(y=>y.shape),this.internalOutputShapes=this.outputs.map(y=>y.shape);let t={},n={},r={},s={},a={},i=[],o=(y,b,x,w,v,k)=>{(w==null||v==null||k==null)&&(w=y.sourceLayer,v=y.nodeIndex,k=y.tensorIndex);let I=w.inboundNodes[v];if(x.indexOf(I)!==-1)throw new zo(`The tensor ${y.name} at layer "${w.name}" is part of a cycle.`);if(b.indexOf(I)!==-1)return;this.containerNodes.add(ml.nodeKey(w,v)),w.id in a||(a[w.id]=Object.keys(a).length),x.indexOf(I)===-1&&x.push(I);let S=I.inboundLayers.length;for(let $=0;$<S;$++){let N=I.inputTensors[$],T=I.inboundLayers[$],C=I.nodeIndices[$],E=I.tensorIndices[$];o(N,b,x,T,C,E)}for(b.push(I);x.indexOf(I)>=0;)x.splice(x.indexOf(I),1);i.push(I)},l=[],u=[];for(let y of this.outputs)o(y,l,u);let c=i.slice().reverse();for(let y of c){n[y.id]=y,y.id in t||(t[y.id]=0);let b=t[y.id],x=r[y.outboundLayer.id]==null?0:r[y.outboundLayer.id];b=Math.max(b,x),r[y.outboundLayer.id]=b,s[y.outboundLayer.id]=y.outboundLayer,t[y.id]=b;for(let w=0;w<y.inboundLayers.length;w++){let v=y.inboundLayers[w],k=y.nodeIndices[w],I=v.inboundNodes[k],S=t[I.id]==null?0:t[I.id];t[I.id]=Math.max(b+1,S),n[I.id]=I}}let d={};for(let y in t){let b=t[y];b in d||(d[b]=[]),d[b].push(n[y])}let h={};for(let y in r){let b=r[y];b in h||(h[b]=[]),h[b].push(s[y])}let p=Object.keys(h).map(y=>parseInt(y,10)).sort(sk);this.layers=[];for(let y of p){let b=h[y];b.sort((x,w)=>{let v=a[x.id],k=a[w.id];return v<k?-1:v>k?1:0});for(let x of b)x instanceof ml&&this.internalContainerRefs.push(x),this.layers.push(x)}this.layersByDepth=h,p=Object.keys(d).map(y=>parseInt(y,10)).sort(sk);let f=this.inputs.slice(),m=[];for(let y of p)for(let b of d[y]){let x=b.outboundLayer;if(x!=null){for(let w of b.inputTensors)if(f.indexOf(w)===-1)throw new zo(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${x.name}". The following previous layers were accessed without issue: ${m}`);for(let w of b.outputTensors)f.push(w);m.push(x.name)}}this.nodesByDepth=d;let g=this.layers.map(y=>y.name);for(let y of g){let b=g.filter(x=>x===y).length;if(b!==1)throw new zo(`The name "${y}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new t2({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(y=>null),outputMasks:this.outputs.map(y=>null),inputShapes:this.inputs.map(y=>y.shape),outputShapes:this.outputs.map(y=>y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(n=>n.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new he("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.layers)t.push(...n.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},r=0;for(let a of this.layers)for(let i of a.weights){if(n[i.originalName]!=null)throw new he(`Duplicate weight name: ${i.originalName}`);n[i.originalName]=i,r++}let s=[];for(let a in e){let i=a;if(n[a]==null){let o=a.split("/");i=o.slice(0,-2).concat([o[o.length-1]]).join("/")}if(n[i]!=null)s.push([n[i],e[a]]);else if(t)throw new he(`Provided weight data has no target variable: ${a}`);delete n[i]}if(t){let a=[];for(let i in n)a.push(i);if(a.length>0)throw new he(`${a.length} of ${r} weights are not set: ${a}`)}mM(s)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${CM}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=SA(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return ue(()=>{e=Bn(e);let n=new yh;for(let r=0;r<this.inputs.length;++r)n.add(this.inputs[r],e[r]);return gx(this.outputs,n,t)})}computeMask(e,t){return ue(()=>{e=Bn(e);let n;return t==null?n=Xh(null,e.length):n=Bn(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=sS(e);if(t.length!==this.inputLayers.length)throw new he(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let i=0;i<t.length;i++){let o=this.inputLayers[i],l=t[i],u=o.name+"_0_0";n[u]=l}let r=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(sk);if(r.length>1)for(let i of r){let o=this.nodesByDepth[i];for(let l of o){let u=l.outboundLayer;if(this.inputLayers.map(f=>f.id).indexOf(u.id)!==-1)continue;let c=[];for(let f=0;f<l.inboundLayers.length;f++){let m=l.inboundLayers[f],g=l.nodeIndices[f],y=l.tensorIndices[f],b=`${m.name}_${g}_${y}`,x=n[b];c.push(x)}let d=u.computeOutputShape(ba(c)),h=sS(d),p=u.inboundNodes.indexOf(l);for(let f=0;f<h.length;f++){let m=`${u.name}_${p}_${f}`;n[m]=h[f]}}}let s=[],a=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=this.outputLayersTensorIndices[i],c=`${o.name}_${l}_${u}`;a.push(c)}for(let i=0;i<a.length;i++){let o=a[i];vl(o in n),s.push(n[o])}return ba(s)}runInternalGraph(e,t){t==null&&(t=Xh(null,e.length));let n={};for(let o=0;o<this.inputs.length;++o){let l=this.inputs[o],u=e[o],c=t[o];n[l.id]=[u,c]}let r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(sk);for(let o of r){let l=this.nodesByDepth[o];for(let u of l){let c=u.outboundLayer,d=u.inputTensors,h=u.outputTensors,p=new Array;for(let f of d)f.id in n&&p.push(n[f.id]);if(p.length===d.length){let f={},m,g,y,b;if(u.callArgs!=null&&(f=u.callArgs),p.length===1){let[x,w]=p[0];f.mask==null&&(f.mask=w),y=Bn(c.call(x,f)),b=Bn(c.computeMask(x,w)),m=[x],g=[w]}else m=p.map(x=>x[0]),g=p.map(x=>x[1]),f.mask==null&&(f.mask=g),y=Bn(c.call(m,f)),b=Bn(c.computeMask(m,g));if(c.activityRegularizer)throw new Rt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let x=0;x<h.length;++x){let w=h[x],v=y[x],k=b[x];n[w.id]=[v,k]}}}}let s=[],a=[],i=[];for(let o of this.outputs){vl(o.id in n,`Could not compute output ${o.name} : ${o.id}`);let[l,u]=n[o.id];i.push(l.shape),s.push(l),a.push(u)}return[s,a,i]}buildNodeConversionMap(e){let t={},n;for(let r of this.layers){n=r instanceof ml?1:0;for(let s=0;s<r.inboundNodes.length;s++){let a=ml.nodeKey(r,s);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new he(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new he("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===e)return n;throw new he(`No such layer: ${e}`)}calculateLosses(){return ue(()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let r=ml.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let a of this.layers){let i=a.getClassName(),o=a.getConfig(),l=[];for(let c=0;c<a.inboundNodes.length;c++){let d=a.inboundNodes[c],h=ml.nodeKey(a,c),p={};if(this.containerNodes.has(h)){if(d.callArgs)try{JSON.stringify(d.callArgs),p=d.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(d.inboundLayers.length>0){let f=[];for(let m=0;m<d.inboundLayers.length;m++){let g=d.inboundLayers[m],y=d.nodeIndices[m],b=d.tensorIndices[m],x=ml.nodeKey(g,y),w=t[x];w==null&&(w=0),f.push([g.name,w,b,p])}l.push(f)}}}let u={};u.name=a.name,u.className=i,u.config=o,u.inboundNodes=l,n.push(u)}e.layers=n;let r=[];for(let a=0;a<this.inputLayers.length;a++){let i=this.inputLayers[a],o=this.inputLayersNodeIndices[a],l=ml.nodeKey(i,o);if(!this.containerNodes.has(l))continue;let u=t[l];u==null&&(u=0);let c=this.inputLayersTensorIndices[a];r.push([i.name,u,c])}e.inputLayers=r;let s=[];for(let a=0;a<this.outputLayers.length;a++){let i=this.outputLayers[a],o=this.outputLayersNodeIndices[a],l=ml.nodeKey(i,o);if(!this.containerNodes.has(l))continue;let u=t[l];u==null&&(u=0);let c=this.outputLayersTensorIndices[a];s.push([i.name,u,c])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){let s={},a={};function i(m,g){m.name in a?a[m.name].push(g):a[m.name]=[g]}function o(m,g){let y=[],b;for(let x of g){let w=x[0],v=x[1],k=x[2];if(b=x[3]==null?{}:x[3],!(w in s)){i(m,g);return}let I=s[w];if(I.inboundNodes.length<=v){i(m,g);return}let S=I.inboundNodes[v];y.push(S.outputTensors[k])}y.length>0&&m.apply(ba(y),b)}function l(m){let g=m.name,y=Ho(m,t.customObjects!=null?t.customObjects:{});y.setFastWeightInitDuringBuild(r),s[g]=y,m.inboundNodes.forEach(b=>{if(!(b instanceof Array))throw new he(`Corrupted configuration, expected array for nodeData: ${b}`);i(y,b)})}let u=t.name,c=t.layers;for(let m of c)l(m);for(;!Eve(a);)for(let m of c){let g=s[m.name];if(g.name in a){let y=a[g.name];delete a[g.name];for(let b of y)o(g,b)}}let d=[],h=[],p=t.inputLayers;for(let m of p){let g=m[0],y=m[1],b=m[2];vl(g in s);let x=s[g].inboundNodes[y].outputTensors;d.push(x[b])}let f=t.outputLayers;for(let m of f){let g=m[0],y=m[1],b=m[2];vl(g in s);let x=s[g].inboundNodes[y].outputTensors;h.push(x[b])}return new e({inputs:d,outputs:h,name:u})}get stateful(){if(this._stateful)throw new he("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){ue(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function nIe(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let s=[];return t.forEach(a=>{a in e?s.push(e[a]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function LK(e,t){return nIe(e,t,"classWeight")}async function PK(e,t,n,r){if(t!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){let s=ue(()=>{if(e.shape.length===1)return Fl(e);if(e.shape.length===2){if(e.shape[1]>1)return Uh(e,1);if(e.shape[1]===1)return oe(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await s.data());St(s);let i=[];return a.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),gn(i,"float32")}else return null}function rIe(e,t){return ae(e,t)}var sIe=32;function zK(e,t){let n,r,s=t;n=s.xs,r=s.ys,_.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let a=OV("input",e.inputNames,n),i=OV("output",e.outputNames,r),o=a[0].shape[0];_.assert(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),_.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<a.length;l++)_.assert(a[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)_.assert(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:a,ys:i}}function OV(e,t,n){if(n instanceof Tt)return[n];if(Array.isArray(n))return _.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let s of t){if(n[s]==null)throw new he(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function aIe(e){if(e.length===3)throw new Rt("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function iIe(e,t,n){let r=n.batchesPerEpoch!=null;if(_.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),_.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),_.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),_.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),_.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let s=n.validationData!=null,a,i;if(s)if(MV(n.validationData))_.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=aIe(n.validationData);a=g.xs,i=g.ys}let o=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),u;s?u=l.slice().concat(l.map(g=>"val_"+g)):u=l.slice();let c=_K(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:h,history:p}=EK(c,d,n.epochs,null,null,oIe(t,n),null,s,u);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let g={};await h.onEpochBegin(f);let y=0,b=0;for(r||(m=await t.iterator());!r||y<n.batchesPerEpoch;){let x=await m.next();if(r&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){let{xs:w,ys:v}=zK(e,x.value),k={};k.batch=b,k.size=w[0].shape[0],await h.onBatchBegin(b,k);let I=[];if(n.classWeight!=null){let N=LK(n.classWeight,e.outputNames);for(let T=0;T<N.length;++T)I.push(await PK(v[T],null,N[T]))}let S=w.concat(v).concat(I),$=o(S);St(S);for(let N=0;N<l.length;++N){let T=l[N],C=$[N];k[T]=C,Or(C)}await h.onBatchEnd(b,k),CK(k),b++,y++}if(r?y>=n.batchesPerEpoch:x.done){if(s){let w;MV(n.validationData)?w=Bn(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):w=Bn(e.evaluate(a,i,{batchSize:n.validationBatchSize==null?sIe:n.validationBatchSize,verbose:0}));for(let v=0;v<e.metricsNames.length;++v)g[`val_${e.metricsNames[v]}`]=w[v]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,g),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function oIe(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function MV(e){return typeof e.iterator=="function"}function lIe(e){return typeof e.next=="function"}async function uIe(e,t,n){n=n||{};let r=n.batches!=null,s=e.testFunction,a=[];if(n.verbose>0)throw new Rt("Verbose mode is not implemented yet.");_.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=lIe(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let u=await i.next();if(a=ue(()=>{if(u.value){let{xs:c,ys:d}=zK(e,u.value),h=c.concat(d),p=ue(()=>s(h));if(St(h),l===0)for(let m=0;m<p.length;++m)a.push(mt(0));let f=h[0].shape[0];for(let m=0;m<p.length;++m){let g=p[m],y=a[m];a[m]=ue(()=>Ie(a[m],ae(f,g))),l>0&&St(y)}St(p),o+=f,++l}return a}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){let c=a[u];a[u]=tt(a[u],o),St(c)}return ba(a)}function d_(e){_.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function ex(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>Nh(r,t,n-t)):Nh(e,t,n-t)}function CA(e,t){return ue(()=>e==null?null:Array.isArray(e)?e.map(n=>CA(n,t)):yK(e,t.dtype==="int32"?t:Me(t,"int32")))}function h_(e,t){let n=[],r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function BK(e){let t=[];e instanceof Tt&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(Bw(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Eo(e,t){if(e==null)return;let n=[];if(t instanceof Tt)n.push(t.id);else if(Array.isArray(t))t.forEach(s=>n.push(s.id));else if(t!=null)for(let s in t){let a=t[s];n.push(a.id)}let r=[];if(e instanceof Tt)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(e!=null)for(let s in e){let a=e[s];n.indexOf(a.id)===-1&&r.push(a)}r.forEach(s=>{s.isDisposed||s.dispose()})}function cIe(e){return e instanceof Tt}function NA(e){return Array.isArray(e)}function LV(e){return!cIe(e)&&!NA(e)}function PV(e,t,n,r=!0,s=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(NA(e)&&e.length>0)i=!0;else if(LV(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new he(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let a;if(LV(e)){e=e,a=[];for(let i of t){if(e[i]==null)throw new he(`No data provided for "${i}". Need data for each key in: ${t}`);a.push(e[i])}}else if(NA(e)){if(e=e,e.length!==t.length)throw new he(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new he(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=BK(a),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=a[i];if(o.shape.length!==n[i].length)throw new he(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let u=o.shape[l],c=n[i][l];if(c!=null&&c>=0&&u!==c)throw new he(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function dIe(e,t,n){let r=Dc(e.map(a=>a.shape[0]));r.sort();let s=Dc(t.map(a=>a.shape[0]));if(s.sort(),r.length>1)throw new he(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>1)throw new he(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(r.length>0&&s.length>0&&!_.arraysEqual(r,s))throw new he(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function hIe(e,t,n){let r=[Lf,r2,v0];for(let s=0;s<e.length;++s){let a=e[s],i=t[s],o=n[s];if(i!=null){if(i===v0&&a.shape[a.shape.length-1]===1)throw new he(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){let l=a.shape.slice(1),u=o.slice(1);for(let c=0;c<l.length;++c){let d=l[c],h=u[c];if(h!=null&&d!==h)throw new he(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function zV(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new he(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new he(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=a[i];if(o.shape.length!==n[i].length)throw new he(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let u=o.shape[l],c=n[i][l];if(c!=null&&c!==u)throw new he(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function pIe(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let s of t){let a=n.hasOwnProperty(s)?n[s]:[];Array.isArray(a)||(a=[a]),r.push(a)}return r}}var fIe="layers-model",Nu=class extends ml{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new he("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Zke(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Yke(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Hu))throw new he("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new he(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(c_(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new he(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>c_(a))}else{let a=c_(e.loss);this.outputs.forEach(i=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let i=this.internalOutputShapes[a],o=this.outputNames[a];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[a])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ch("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([i,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let r=pIe(e.metrics,this.outputNames),s=(a,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[a]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,a])};Ch("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=r[a];(o=>{let l="",u,c,d;for(let h of o){if(typeof h=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(h)!==-1){let f=this.internalOutputShapes[a];f[f.length-1]===1||this.lossFunctions[a]===r2?["accuracy","acc"].indexOf(h)!==-1?c=kM:["crossentropy","ce"].indexOf(h)!==-1&&(c=DK):this.lossFunctions[a]===uS?["accuracy","acc"].indexOf(h)!==-1?c=FK:["crossentropy","ce"].indexOf(h)!==-1&&(c=OK):["accuracy","acc"].indexOf(h)!==-1?c=IM:["crossentropy","ce"].indexOf(h)!==-1&&(c=SM);let m;["accuracy","acc"].indexOf(h)!==-1?m="acc":["crossentropy","ce"].indexOf(h)!==-1&&(m="ce"),d=c,u=l+m}else d=Xke(h),u=l+ok(h);let p;Ch(u,()=>{p=d}),s(a,u,p)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;d_(r);let s=!0,a=this.standardizeUserDataXY(e,t,s,r);try{let i=a[0].concat(a[1]);this.makeTestFunction();let o=this.testFunction,l=this.testLoop(o,i,r,n.verbose,n.steps);return ba(l)}finally{Eo(a[0],e),Eo(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),uIe(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(n!=null){if(s=null,t!=null)throw new he(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new he(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new he("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new yh;if(e instanceof Tt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new he(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)a.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(l==null)throw new he(`No value is provided for the model's input ${o.name}`);a.add(o,l)}let i=gx(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Xh(null,e.length),n=e.length;for(let r of this.layers){let s=Array.isArray(r.output)?r.output:[r.output],a=s.map(i=>i.name);for(let i=0;i<e.length;++i){let o=a.indexOf(e[i]);if(o!==-1&&(t[i]=s[o],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw t.forEach((s,a)=>{s==null&&r.push(e[a])}),new he(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return ue(()=>{let r=this.checkNumSamples(e);if(n)throw new Rt("Verbose predictLoop() is not implemented yet.");let s=h_(r,t),a=this.outputs.map(i=>[]);for(let i=0;i<s.length;++i)ue(()=>{let o=s[i][0],l=s[i][1],u=ex(e,o,l),c=[];if(Array.isArray(u))for(let h=0;h<u.length;++h)c.push({key:this.inputs[h],value:u[h]});else c.push({key:this.inputs[0],value:u});let d=new yh(c);return gx(this.outputs,d)}).forEach((o,l)=>a[l].push(o));return ba(a.map(i=>In(i,0)))})}predict(e,t={}){let n=BK(e);zV(n,this.inputNames,this.feedInputShapes,!1);try{let r=t.batchSize==null?32:t.batchSize;return d_(r),this.predictLoop(n,r)}finally{Eo(n,e)}}predictOnBatch(e){zV(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new zo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let a=0;a<this.feedOutputShapes.length;++a){let i=this.feedOutputShapes[a];this.feedLossFns[a]===uS?s.push(i.slice(0,i.length-1).concat([1])):s.push(i)}if(e=PV(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=PV(t,this.feedOutputNames,s,!1,"target"),dIe(e,t),hIe(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new he(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){let[i,o]=this.standardizeUserDataXY(e,t,s,a);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){let u=LK(r,this.outputNames);l=[];for(let c=0;c<u.length;++c)l.push(await PK(o[c],null,u[c]))}return[i,o,l]}testLoop(e,t,n,r=0,s){return ue(()=>{let a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new Rt("Verbose mode is not implemented yet.");if(s!=null)throw new Rt("steps mode in testLoop() is not implemented yet");{let o=h_(a,n),l=gn(el(0,a));for(let u=0;u<o.length;++u){let c=o[u][0],d=o[u][1],h=Nh(l,c,d-c),p=CA(t,h),f=e(p);if(u===0)for(let m=0;m<f.length;++m)i.push(mt(0));for(let m=0;m<f.length;++m){let g=f[m];i[m]=Ie(i[m],ae(d-c,g))}}for(let u=0;u<i.length;++u)i[u]=tt(i[u],a)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],s=r;if(SV(e,r)>1){let a=SV(e.slice(0,n),r);s+=`_${a}`}t.push(s)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],i=()=>{let u=[];for(let p=0;p<this.inputs.length;++p)u.push({key:this.inputs[p],value:n[p]});let c=new yh(u),d=gx(this.outputs,c,{training:!0}),h;for(let p=0;p<this.lossFunctions.length;++p){let f=this.lossFunctions[p],m=f(r[p],d[p]);s[p]!=null&&(m=rIe(m,s[p]));let g=rr(m);t.push(g),p===0?h=m:h=Ie(h,m)}for(let p=0;p<this.metricsTensors.length;++p){let f;if(this.outputs.length>1&&p<this.outputs.length)f=t[p];else{let m=this.metricsTensors[p][0],g=this.metricsTensors[p][1];f=rr(m(r[g],d[g]))}Or(f),a.push(f)}return h=rr(h),this.calculateLosses().forEach(p=>{h=Ie(h,p)}),h},o=this.collectedTrainableWeights.map(u=>u.read()),l=!0;return[this.optimizer_.minimize(i,l,o)].concat(a)}}makeTestFunction(){this.testFunction=e=>ue(()=>{let t=[],n,r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let l=0;l<this.inputs.length;++l)a.push({key:this.inputs[l],value:r[l]});let i=new yh(a),o=gx(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let u=this.lossFunctions[l],c=rr(u(s[l],o[l]));l===0?n=c:n=Ie(n,c),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let u=this.metricsTensors[l][0],c=this.metricsTensors[l][1],d=rr(u(s[c],o[c]));t.push(d)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,s,a,i,o,l,u,c,d;try{let h=n.batchSize==null?32:n.batchSize;d_(h);let p=!1,f=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,p,h);r=f[0],s=f[1],d=f[2];let m=!1,g;if(n.validationData!=null&&n.validationData.length>0){if(m=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Rt("validationData including sample weights is not supported yet."):new he(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let I=!0,S=await this.standardizeUserData(o,l,null,null,I,h);u=S[0],c=S[1],g=u.concat(c)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){m=!0;let I=Math.floor(r[0].shape[0]*(1-n.validationSplit)),S=r[0].shape[0];u=ex(r,I,S),a=r,r=ex(r,0,I),c=ex(s,I,S),i=s,s=ex(s,0,I),g=u.concat(c)}else n.validationSteps!=null&&(m=!0);let y=r.concat(s).concat(d);this.checkTrainableWeightsConsistency();let b=this.makeTrainFunction(),x=this.getDedupedMetricsNames(),w,v;m?(this.makeTestFunction(),w=this.testFunction,v=x.slice().concat(x.map(I=>"val_"+I))):(w=null,g=[],v=x.slice());let k=_K(n.callbacks,n.yieldEvery);return await this.fitLoop(b,y,x,h,n.epochs,n.verbose,k,w,g,n.shuffle,v,n.initialEpoch,null,null)}finally{this.isTraining=!1,Eo(r,e),Eo(s,t),Eo(a,e),Eo(i,t),Eo(u,o),Eo(c,l),d!=null&&St(d)}}async fitLoop(e,t,n,r,s,a,i,o,l,u,c,d,h,p){r==null&&(r=32),s==null&&(s=1),u==null&&(u=!0),d==null&&(d=0);let f=!1;if(o!=null&&l!=null&&(f=!0),p!=null&&(f=!0,h==null))throw new he("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m=this.checkNumSamples(t,r,h,"steps_per_epoch"),g;m!=null&&(g=el(0,m)),a==null&&(a=1);let{callbackList:y,history:b}=EK(i,a,s,d,m,h,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<s;++x){await y.onEpochBegin(x);let w={};if(h!=null)throw new Rt("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new Rt("batch shuffling is not implemneted yet");u&&_.shuffle(g);let v=gn(g),k=h_(m,r);for(let I=0;I<k.length;++I){let S={};if(await y.onBatchBegin(I,S),ue(()=>{let $=k[I][0],N=k[I][1],T=Nh(v,$,N-$);S.batch=I,S.size=N-$;let C=CA(t,T),E=e(C);for(let M=0;M<n.length;++M){let F=n[M],z=E[M];S[F]=z,Or(z)}if(I===k.length-1&&f){let M=this.testLoop(o,l,r);for(let F=0;F<n.length;++F){let z=n[F],H=M[F];Or(H),w["val_"+z]=H}}}),await y.onBatchEnd(I,S),CK(S),this.stopTraining_)break}v.dispose()}if(await y.onEpochEnd(x,w),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return iIe(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(let o of a){let l=await o.data();i.push(l[0])}return St(a),Eo(n[0],e),Eo(n[1],t),ba(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<r.length;++a)n&&!r[a].trainable||t.push({name:r[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=nS().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-nS().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=pu(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>pu(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]=="string")e[r]=pu(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[pu(ok(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>pu(ok(e)));{let e={};for(let t in this.metrics)e[t]=pu(ok(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=k0(e.optimizer_config),n=Ho(t),r;if(typeof e.loss=="string")r=oh(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>oh(a));else if(e.loss!=null){r={};for(let a in e.loss)r[a]=oh(e.loss[a])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(a=>oh(a));else if(e.metrics!=null){s={};for(let a in e.metrics)s[a]=oh(e.metrics[a])}this.compile({loss:r,metrics:s,optimizer:n})}async save(e,t){if(typeof e=="string"){let i=ws.getSaveHandlers(e);if(i.length===0)throw new he(`Cannot find any save handlers for URL '${e}'`);if(i.length>1)throw new he(`Found more than one (${i.length}) save handlers for URL '${e}'`);e=i[0]}if(e.save==null)throw new he("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await ws.encodeWeights(this.getNamedWeights(t)),r=!1,s=null,a={modelTopology:this.toJSON(s,r),format:fIe,generatedBy:`TensorFlow.js tfjs-layers v${CM}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let i="optimizer",{data:o,specs:l}=await ws.encodeWeights(await this.optimizer.getWeights(),i);n.specs.push(...l),n.data=ws.concatenateArrayBuffers([n.data,o])}return this.userDefinedMetadata!=null&&(FV(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){FV(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};Nu.className="Model";_e.registerClass(Nu);var WK=class extends Nu{};WK.className="Functional";_e.registerClass(WK);async function mIe(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=k0(n),s=Ho(r,t);if(e.weightsManifest!=null){let a=await ws.loadWeights(e.weightsManifest,e.pathPrefix,s.weights.map(o=>o.originalName)),i={};for(let o of s.weights)i[o.originalName]=a[o.originalName];s.loadWeights(i),St(a)}return s}async function gIe(e,t){if(t==null&&(t={}),typeof e=="string"){let n=ws.getLoadHandlers(e,t);if(n.length===0)n.push(ws.browserHTTPRequest(e,t));else if(n.length>1)throw new he(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return yIe(e,void 0,t)}async function yIe(e,t,n){if(n==null&&(n={}),e.load==null)throw new he("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),s=r.modelTopology;s.model_config!=null&&(s=s.model_config);let a=n.strict==null?!0:n.strict,i=r.weightData!=null&&r.weightSpecs!=null&&a,o=Ho(k0(s),t,i),l=r.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),r.userDefinedMetadata!=null&&o.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new he("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:u,optimizerWeights:c}=bIe(r.weightData,r.weightSpecs);o.loadWeights(u,a),o.optimizer!=null&&c.length>0&&await o.optimizer.setWeights(c),St(u),St(c.map(d=>d.tensor))}return o}function bIe(e,t){let n=ws.decodeWeights(e,t),r={},s=[];return t.forEach(a=>{a.group==="optimizer"?s.push({name:a.name,tensor:n[a.name]}):r[a.name]=n[a.name]}),{modelWeights:r,optimizerWeights:s}}var Sg=class extends Nu{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:jN("sequential_"),e.layers!=null)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new he(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t=e instanceof Sg||e instanceof Nu,n;if(t){if(n=e,n.outputs.length!==1)throw new he("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new he("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new he("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let r=vK({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(e.inboundNodes.length!==1)throw new he(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new he("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=wK(this.outputs[0])}this.inboundNodes=[],new t2({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Xh(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(dn(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Nu({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new zo("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new zo("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new zo("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new zo("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let s,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new he("Legacy serialization format not supported yet.");s=t}else _.assert(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,a=t;let i=new e(a);if(!(i instanceof Sg))throw new Rt(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let o of s){let l=Ho(o,void 0,r);r&&l.setFastWeightInitDuringBuild(!0),i.add(l)}return i}set stopTraining(e){if(this.model==null)throw new he("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new he("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};Sg.className="Sequential";_e.registerClass(Sg);function xIe(e){return new Nu(e)}function wIe(e){return new Sg(e)}function VK(e){return vK(e)}function vIe(e,t){qi.registerCallbackConstructor(e,t)}var Da=class extends _e.Serializable{getConfig(){return{}}},UK=class extends Da{apply(e,t=1){return Hve(e,t)}};UK.className="elu";_e.registerClass(UK);var GK=class extends Da{apply(e){return _N(e)}};GK.className="selu";_e.registerClass(GK);var HK=class extends Da{apply(e){return yn(e)}};HK.className="relu";_e.registerClass(HK);var jK=class extends Da{apply(e){return ue(()=>jc(6,yn(e)))}};jK.className="relu6";_e.registerClass(jK);var qK=class extends Da{apply(e){return e}};qK.className="linear";_e.registerClass(qK);var KK=class extends Da{apply(e){return ho(e)}};KK.className="sigmoid";_e.registerClass(KK);var XK=class extends Da{apply(e){return qve(e)}};XK.className="hardSigmoid";_e.registerClass(XK);var YK=class extends Da{apply(e){return Ff(e)}};YK.className="softplus";_e.registerClass(YK);var ZK=class extends Da{apply(e){return jve(e)}};ZK.className="softsign";_e.registerClass(ZK);var JK=class extends Da{apply(t){return Hh(t)}};JK.className="tanh";_e.registerClass(JK);var NM=class extends Da{apply(e,t=-1){return kd(e,t)}};NM.className="softmax";_e.registerClass(NM);var QK=class extends Da{apply(e,t=-1){return vN(e,t)}};QK.className="logSoftmax";_e.registerClass(QK);var eX=class extends Da{apply(e,t=1){return ue(()=>ae(ho(ae(e,t)),e))}};eX.className="swish";_e.registerClass(eX);var tX=class extends Da{apply(e){return ue(()=>ae(e,Hh(Ff(e))))}};tX.className="mish";_e.registerClass(tX);function Xc(e){return e.getClassName()}function p_(e,t={}){return zw(e,_e.SerializationMap.getMap().classNameMap,t,"activation")}function Yc(e){if(e==null){let t={};return t.className="linear",t.config={},p_(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},p_(t)}else return e instanceof Da?e:p_(e)}function $M(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var nX=class extends _e.Serializable{},Gw=class extends nX{constructor(e){super(),$M(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ue(()=>{let t=sr([1]);return this.hasL1&&(t=Ie(t,st(ae(this.l1,Ir(e))))),this.hasL2&&(t=Ie(t,st(ae(this.l2,Ww(e))))),oe(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Gw.className="L1L2";_e.registerClass(Gw);function kIe(e){return $M(e),new Gw({l1:e!=null?e.l1:null,l2:0})}function IIe(e){return $M(e),new Gw({l2:e!=null?e.l2:null,l1:0})}var BV={l1l2:"L1L2"};function _n(e){return aM(e)}function WV(e,t={}){return zw(e,_e.SerializationMap.getMap().classNameMap,t,"regularizer")}function Jn(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in BV?BV[e]:e,config:{}};return WV(t)}else return e instanceof nX?e:WV(e)}var TM=class extends zt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=kt(e);let n=yn(e);return this.maxValue!=null&&(n=Ms(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};TM.className="ReLU";_e.registerClass(TM);var _M=class extends zt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=kt(e);return _w(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};_M.className="LeakyReLU";_e.registerClass(_M);var EM=class extends zt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Yn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Jn(e.alphaRegularizer),this.alphaConstraint=Vr(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new he(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=dn(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Cr({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=kt(e),Fw(e,this.alpha.read())}getConfig(){let e={alphaInitializer:ar(this.alphaInitializer),alphaRegularizer:_n(this.alphaRegularizer),alphaConstraint:Wr(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};EM.className="PReLU";_e.registerClass(EM);var AM=class extends zt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Rt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=kt(e);return sb(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};AM.className="ELU";_e.registerClass(AM);var RM=class extends zt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=kt(e);return ae(n,Me(la(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};RM.className="ThresholdedReLU";_e.registerClass(RM);var DM=class extends zt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new NM().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){let n=kt(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};DM.className="Softmax";_e.registerClass(DM);function Hm(e,t,n){if(typeof e=="number")return Xh(e,t);if(e.length!==t)throw new he(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let s=e[r];if(!Wve(s))throw new he(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function jo(e,t,n,r,s=1){if(e==null)return e;let a=t+(t-1)*(s-1),i;return n==="same"?i=e:i=e-a+1,Math.floor((i+r-1)/r)}function kl(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+Kc([n-t,0]);else if(r==="same")e=e*t;else throw new he(`Unsupport padding mode: ${r}.`);return e}function FM(e,t){return ue(()=>(xr(t),t==="channelsFirst"?Ft(e,[0,2,3,1]):e))}function rX(e,t){return ue(()=>(xr(t),t==="channelsFirst"?Ft(e,[0,2,3,4,1]):e))}function SIe(e,t,n,r=1,s="valid",a,i=1){return ue(()=>{if(a==null&&(a=tl()),xr(a),e.shape.length!==3)throw new he(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new he(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new he(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(a==="channelsFirst"&&(e=Ft(e,[0,2,1])),s==="causal")throw new Rt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=mN(e,t,r,s==="same"?"same":"valid","NWC",i);return n!=null&&(o=ul(o,n)),o})}function VV(e,t,n,r=[1,1],s="valid",a,i,o=null){return ue(()=>{if(a==null&&(a=tl()),xr(a),e.rank!==3&&e.rank!==4)throw new he(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new he(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=FM(e,a);if(s==="causal")throw new Rt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=wg.conv2d({x:l,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),a==="channelsFirst"&&(l=Ft(l,[0,3,1,2])),l})}function CIe(e,t,n,r=[1,1,1],s="valid",a,i){return ue(()=>{if(a==null&&(a=tl()),xr(a),e.rank!==4&&e.rank!==5)throw new he(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new he(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=rX(e,a);if(s==="causal")throw new Rt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=lO(o,t,r,s==="same"?"same":"valid","NDHWC",i),n!=null&&(o=ul(o,n)),a==="channelsFirst"&&(o=Ft(o,[0,4,1,2,3])),o})}var OM=class extends zt{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",OM.verifyArgs(t),this.rank=e,ts(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Rt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Hm(t.kernelSize,e,"kernelSize"),this.strides=Hm(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Li(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,xr(this.dataFormat),this.activation=Yc(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=Yn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Vr(t.biasConstraint),this.biasRegularizer=Jn(t.biasRegularizer),this.activityRegularizer=Jn(t.activityRegularizer),this.dilationRate=Hm(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new he(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new he(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new he(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(vl("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!iM(e.kernelSize,"number",1,3))throw new he(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Xc(this.activation),useBias:this.useBias,biasInitializer:ar(this.biasInitializer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),biasConstraint:Wr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Hw=class extends OM{constructor(e,t){super(e,t),this.kernel=null,Hw.verifyArgs(t),this.filters=t.filters,ts(this.filters,"filters"),this.kernelInitializer=Yn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Vr(t.kernelConstraint),this.kernelRegularizer=Jn(t.kernelRegularizer)}build(e){e=dn(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new he(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return ue(()=>{e=kt(e);let n,r=this.bias==null?null:this.bias.read(),s=dK(this.activation.getClassName());if(s!=null&&this.rank===2)n=VV(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=SIe(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=VV(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=CIe(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Rt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(e){e=dn(e);let t=[],n=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){let a=jo(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);t.push(a)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:ar(this.kernelInitializer),kernelRegularizer:_n(this.kernelRegularizer),kernelConstraint:Wr(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new he(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},jw=class extends Hw{constructor(e){super(2,e),jw.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!iM(e.kernelSize,"number",1,2))throw new he(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};jw.className="Conv2D";_e.registerClass(jw);var qw=class extends Hw{constructor(e){super(3,e),qw.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new he(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};qw.className="Conv3D";_e.registerClass(qw);var MM=class extends jw{constructor(e){if(super(e),this.inputSpec=[new Cr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new he(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=dn(e),e.length!==4)throw new he("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new he("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Cr({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return ue(()=>{let n=kt(e);if(n.shape.length!==4)throw new he(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],a,i;this.dataFormat==="channelsFirst"?(a=2,i=3):(a=1,i=2);let o=r[a],l=r[i],u=this.kernelSize[0],c=this.kernelSize[1],d=this.strides[0],h=this.strides[1],p=kl(o,d,u,this.padding),f=kl(l,h,c,this.padding),m=[s,p,f,this.filters];this.dataFormat!=="channelsLast"&&(n=Ft(n,[0,2,3,1]));let g=gN(n,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=Ft(g,[0,3,1,2])),this.bias!=null&&(g=ul(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=dn(e);let t=e.slice(),n,r,s;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3):(n=3,r=1,s=2);let a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=kl(t[r],o,a,this.padding),t[s]=kl(t[s],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};MM.className="Conv2DTranspose";_e.registerClass(MM);var LM=class extends qw{constructor(e){if(super(e),this.inputSpec=[new Cr({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new he(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=dn(e),e.length!==5)throw new he("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new he("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Cr({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return ue(()=>{let n=kt(e);if(n.shape.length!==5)throw new he(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],a,i,o;this.dataFormat==="channelsFirst"?(o=2,a=3,i=4):(o=1,a=2,i=3);let l=r[o],u=r[a],c=r[i],d=this.kernelSize[0],h=this.kernelSize[1],p=this.kernelSize[2],f=this.strides[0],m=this.strides[1],g=this.strides[2],y=kl(l,f,d,this.padding),b=kl(u,m,h,this.padding),x=kl(c,g,p,this.padding),w=[s,y,b,x,this.filters];this.dataFormat!=="channelsLast"&&(n=Ft(n,[0,2,3,4,1]));let v=uO(n,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=Ft(v,[0,4,1,2,3])),this.bias!==null&&(v=ul(v,this.bias.read(),this.dataFormat)),this.activation!==null&&(v=this.activation.apply(v)),v})}computeOutputShape(e){e=dn(e);let t=e.slice(),n,r,s,a;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=kl(t[r],u,i,this.padding),t[s]=kl(t[s],c,o,this.padding),t[a]=kl(t[a],d,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};LM.className="Conv3DTranspose";_e.registerClass(LM);var sX=class extends Hw{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new he("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new he("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new he(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Yn(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Jn(t.depthwiseRegularizer),this.depthwiseConstraint=Vr(t.depthwiseConstraint),this.pointwiseInitializer=Yn(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Jn(t.pointwiseRegularizer),this.pointwiseConstraint=Vr(t.pointwiseConstraint)}build(e){if(e=dn(e),e.length<this.rank+2)throw new he(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new he(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Cr({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return ue(()=>{e=kt(e);let n;if(this.rank===1)throw new Rt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Ft(e,[0,2,3,1])),n=ub(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=ul(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Ft(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=ar(this.depthwiseInitializer),e.pointwiseInitializer=ar(this.pointwiseInitializer),e.depthwiseRegularizer=_n(this.depthwiseRegularizer),e.pointwiseRegularizer=_n(this.pointwiseRegularizer),e.depthwiseConstraint=Wr(this.depthwiseConstraint),e.pointwiseConstraint=Wr(this.pointwiseConstraint),e}};sX.className="SeparableConv";var PM=class extends sX{constructor(e){super(2,e)}};PM.className="SeparableConv2D";_e.registerClass(PM);var s2=class extends Hw{constructor(e){super(1,e),s2.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!iM(e.kernelSize,"number",1,1))throw new he(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};s2.className="Conv1D";_e.registerClass(s2);var zM=class extends zt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ue(()=>{if(e=kt(e),this.dataFormat==="channelsLast"){let n=ik(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return ik(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=ik(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return ik(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};zM.className="Cropping2D";_e.registerClass(zM);var BM=class extends zt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,xr(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,Pve(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return ue(()=>{let n=kt(e),r=n.shape;if(this.dataFormat==="channelsFirst"){n=Ft(n,[0,2,3,1]);let s=this.size[0]*r[2],a=this.size[1]*r[3],i=this.interpolation==="nearest"?Po.resizeNearestNeighbor(n,[s,a]):Po.resizeBilinear(n,[s,a]);return Ft(i,[0,3,1,2])}else{let s=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?Po.resizeNearestNeighbor(n,[s,a]):Po.resizeBilinear(n,[s,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};BM.className="UpSampling2D";_e.registerClass(BM);function NIe(e,t,n=[1,1],r="valid",s,a){return ue(()=>{s==null&&(s=tl()),xr(s);let i=FM(e,s);if(e.rank!==4)throw new he(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new he(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Df(i,t,n,r==="same"?"same":"valid","NHWC",a),s==="channelsFirst"&&(i=Ft(i,[0,3,1,2])),i})}var WM=class extends OM{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Yn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Vr(e.depthwiseConstraint),this.depthwiseRegularizer=Jn(e.depthwiseRegularizer)}build(e){if(e=dn(e),e.length<4)throw new he(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new he(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ue(()=>{e=kt(e);let n=NIe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=ul(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=dn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=jo(t,this.kernelSize[0],this.padding,this.strides[0]),a=jo(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=ar(this.depthwiseInitializer),e.depthwiseRegularizer=_n(this.depthwiseRegularizer),e.depthwiseConstraint=Wr(this.depthwiseRegularizer),e}};WM.className="DepthwiseConv2D";_e.registerClass(WM);function aX(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new he("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(a){return a==null||Array.isArray(a)?a:[a]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function iX(e,t,n,r=!1,s,a,i=!1,o=!1){return ue(()=>{let l=t.shape.length;if(l<3)throw new he(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(el(2,l));if(t=Ft(t,u),a!=null)throw new Rt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=Me(Me(s,"bool"),"float32"),s.rank===l-1&&(s=ms(s,-1)),s=Ft(s,u)),r&&(t=Ti(t,0),s!=null&&(s=Ti(s,0)));let c=[],d,h=n,p=t.shape[0],f=fr(t),m;s!=null&&(m=fr(s));for(let y=0;y<p;++y){let b=f[y],x=ue(()=>e(b,h));if(s==null)d=x[0],h=x[1];else{let w=ue(()=>{let v=m[y],k=qe(ei(v),v),I=Ie(ae(x[0],v),ae(h[0],k)),S=h.map(($,N)=>Ie(ae(x[1][N],v),ae($,k)));return{output:I,newStates:S}});d=w.output,h=w.newStates}o&&c.push(d)}let g;return o&&(g=zr(c,1)),[d,g,h]})}var Zl=class extends zt{constructor(e){super(e);let t;if(e.cell==null)throw new he("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new o2({cells:e.cell}):t=e.cell,t.stateSize==null)throw new he("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Cr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return el(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){vA(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n=t[0],r;if(this.returnSequences?r=[e[0],e[1],n]:r=[e[0],n],this.returnState){let s=[];for(let a of t)s.push([e[0],a]);return[r].concat(s)}else return r}computeMask(e,t){return ue(()=>{Array.isArray(t)&&(t=t[0]);let n=this.returnSequences?t:null;if(this.returnState){let r=this.states.map(s=>null);return[n].concat(r)}else return n})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Rt("Constants support is not implemented in RNN yet.");vA(e)&&(e=e[0]),e=e;let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Cr({shape:[t,null,...n]});let r=[e[0]].concat(e.slice(2));this.cell.build(r);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!_.arraysEqual(this.stateSpec.map(a=>a.shape[a.shape.length-1]),s))throw new he(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(a=>new Cr({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){ue(()=>{if(!this.stateful)throw new hu("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new he("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>sr([n,r])):this.states_=[sr([n,this.cell.stateSize])];else if(e==null)St(this.states_),this.keptStates!=null&&(St(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>sr([n,r])):this.states_[0]=sr([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new he(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):St(this.states_);for(let r=0;r<this.states_.length;++r){let s=e[r],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,i=[n,a];if(!_.arraysEqual(s.shape,i))throw new he(`State ${r} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${s.shape}`);this.states_[r]=s}}this.states_=this.states_.map(r=>Or(r.clone()))})}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let s=aX(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(n!=null){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(let o of n)this.stateSpec.push(new Cr({shape:o.shape}));i=i.concat(this.stateSpec)}if(r!=null&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof Bo){let o=[e].concat(a),l=this.inputSpec.concat(i),u=this.inputSpec;this.inputSpec=l;let c=super.apply(o,t);return this.inputSpec=u,c}else return super.apply(e,t)}call(e,t){return ue(()=>{let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;e=kt(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new he(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:r},o=iX((h,p)=>{let f=this.cell.call([h].concat(p),i);return[f[0],f.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);let d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d})}getInitialState(e){return ue(()=>{let t=sr(e.shape);return t=st(t,[1,2]),t=Bw(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?xA(t,[1,n]):t):this.cell.stateSize>1?[xA(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===Zl.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){let r=t.cell,s=Ho(r,n);return new e(Object.assign(t,{cell:s}))}};Zl.className="RNN";_e.registerClass(Zl);var Kw=class extends zt{},a2=class extends Kw{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ts(this.units,"units"),this.activation=Yc(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Yn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Yn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Yn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Jn(e.kernelRegularizer),this.recurrentRegularizer=Jn(e.recurrentRegularizer),this.biasRegularizer=Jn(e.biasRegularizer),this.kernelConstraint=Vr(e.kernelConstraint),this.recurrentConstraint=Vr(e.recurrentConstraint),this.biasConstraint=Vr(e.biasConstraint),this.dropout=kg([1,Kc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=kg([1,Kc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=dn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ue(()=>{if(e=e,e.length!==2)throw new he(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Zc({ones:()=>ei(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Zc({ones:()=>ei(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let s,a=this.dropoutMask,i=this.recurrentDropoutMask;a!=null?s=Ml(ae(e,a),this.kernel.read()):s=Ml(e,this.kernel.read()),this.bias!=null&&(s=ul(s,this.bias.read())),i!=null&&(n=ae(n,i));let o=Ie(s,Ml(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Xc(this.activation),useBias:this.useBias,kernelInitializer:ar(this.kernelInitializer),recurrentInitializer:ar(this.recurrentInitializer),biasInitializer:ar(this.biasInitializer),kernelRegularizer:_n(this.kernelRegularizer),recurrentRegularizer:_n(this.recurrentRegularizer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),kernelConstraint:Wr(this.kernelConstraint),recurrentConstraint:Wr(this.recurrentConstraint),biasConstraint:Wr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};a2.className="SimpleRNNCell";_e.registerClass(a2);var VM=class extends Zl{constructor(e){e.cell=new a2(e),super(e)}call(e,t){return ue(()=>{this.cell.dropoutMask!=null&&(St(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(St(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return new e(t)}};VM.className="SimpleRNN";_e.registerClass(VM);var i2=class extends Kw{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new he("GRUCell does not support reset_after parameter set to true.");this.units=e.units,ts(this.units,"units"),this.activation=Yc(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Yc(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Yn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Yn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Yn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Jn(e.kernelRegularizer),this.recurrentRegularizer=Jn(e.recurrentRegularizer),this.biasRegularizer=Jn(e.biasRegularizer),this.kernelConstraint=Vr(e.kernelConstraint),this.recurrentConstraint=Vr(e.recurrentConstraint),this.biasConstraint=Vr(e.biasConstraint),this.dropout=kg([1,Kc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=kg([1,Kc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=dn(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ue(()=>{if(e=e,e.length!==2)throw new he(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Zc({ones:()=>ei(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Zc({ones:()=>ei(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,a=this.recurrentDropoutMask,i,o,l;0<this.dropout&&this.dropout<1&&(e=ae(e,s[0]));let u=Ml(e,this.kernel.read());this.useBias&&(u=ul(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ae(r,a[0]));let c=this.recurrentKernel.read(),[d,h]=Sa(c,[2*this.units,this.units],c.rank-1),p=Ml(r,d),[f,m,g]=Sa(u,3,u.rank-1),[y,b]=Sa(p,2,p.rank-1);i=this.recurrentActivation.apply(Ie(f,y)),o=this.recurrentActivation.apply(Ie(m,b));let x=Ml(ae(o,r),h);l=this.activation.apply(Ie(g,x));let w=Ie(ae(i,r),ae(Ie(1,Mn(i)),l));return[w,w]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Xc(this.activation),recurrentActivation:Xc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ar(this.kernelInitializer),recurrentInitializer:ar(this.recurrentInitializer),biasInitializer:ar(this.biasInitializer),kernelRegularizer:_n(this.kernelRegularizer),recurrentRegularizer:_n(this.recurrentRegularizer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),kernelConstraint:Wr(this.kernelConstraint),recurrentConstraint:Wr(this.recurrentConstraint),biasConstraint:Wr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};i2.className="GRUCell";_e.registerClass(i2);var UM=class extends Zl{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new i2(t),super(t)}call(t,n){return ue(()=>{this.cell.dropoutMask!=null&&(St(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(St(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}};UM.className="GRU";_e.registerClass(UM);var Xw=class extends Kw{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ts(this.units,"units"),this.activation=Yc(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Yc(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Yn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Yn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Yn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Jn(e.kernelRegularizer),this.recurrentRegularizer=Jn(e.recurrentRegularizer),this.biasRegularizer=Jn(e.biasRegularizer),this.kernelConstraint=Vr(e.kernelConstraint),this.recurrentConstraint=Vr(e.recurrentConstraint),this.biasConstraint=Vr(e.biasConstraint),this.dropout=kg([1,Kc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=kg([1,Kc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=dn(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,a=this.units;r=new(t=class extends Io{apply(i,o){let l=s.apply([a]),u=new KN().apply([a]),c=s.apply([a*2]);return NV(NV(l,u),c)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ue(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new he(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Zc({ones:()=>ei(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Zc({ones:()=>ei(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,i=this.recurrentDropoutMask,o,l,u,c;0<this.dropout&&this.dropout<1&&(e=ae(e,a[0]));let d=Ml(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ae(r,i[0])),d=Ie(d,Ml(r,this.recurrentKernel.read())),this.useBias&&(d=ul(d,this.bias.read()));let[h,p,f,m]=Sa(d,4,d.rank-1);o=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(p),u=Ie(ae(l,s),ae(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);let g=ae(c,this.activation.apply(u));return[g,g,u]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Xc(this.activation),recurrentActivation:Xc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ar(this.kernelInitializer),recurrentInitializer:ar(this.recurrentInitializer),biasInitializer:ar(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:_n(this.kernelRegularizer),recurrentRegularizer:_n(this.recurrentRegularizer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),kernelConstraint:Wr(this.kernelConstraint),recurrentConstraint:Wr(this.recurrentConstraint),biasConstraint:Wr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};Xw.className="LSTMCell";_e.registerClass(Xw);var GM=class extends Zl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Xw(e),super(e)}call(e,t){return ue(()=>{this.cell.dropoutMask!=null&&(St(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(St(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};GM.className="LSTM";_e.registerClass(GM);var o2=class extends Kw{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ue(()=>{e=e;let n=e.slice(1),r=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(n.splice(0,i.stateSize.length)):r.push(n.splice(0,1));r.reverse();let s=[],a;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],i===0?a=[e[0]].concat(n):a=[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(let i of s.slice().reverse())n.push(...i);return[a[0]].concat(n)})}build(e){vA(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{Ch(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let r=[];for(let s of t.cells)r.push(Ho(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return kA(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,s=e.splice(r);for(let a=0;a<n.weights.length;++a)t.push([n.weights[a],s[a]])}mM(t)}};o2.className="StackedRNNCells";_e.registerClass(o2);function Zc(e){let{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>a!=null?a(t(),n):bK(t(),n),o=()=>Vw(i,t,r);return!s||s<=1?Or(o().clone()):Array(s).fill(void 0).map(o).map(l=>Or(l.clone()))}var $Ie=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n},oX=class extends Zl{constructor(e){if(e.unroll)throw new Rt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Rt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Cr({ndim:5})]}call(e,t){return ue(()=>{if(this.cell.dropoutMask!=null&&(St(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(St(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new he("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ue(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)],a=sr(s);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){ue(()=>{if(!this.stateful)throw new hu("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(n[0]==null)throw new he("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>sr(s)):this.states_=[sr(s)];else if(e==null)St(this.states_),this.keptStates!=null&&(St(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>sr(s)):this.states_[0]=sr(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new he(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):St(this.states_);for(let a=0;a<this.states_.length;++a){let i=e[a],o=s;if(!_.arraysEqual(i.shape,o))throw new he(`State ${a} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[a]=i}}this.states_=this.states_.map(a=>Or(a.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o=t==="channelsFirst",l=e[o?3:2],u=e[o?4:3],c=jo(l,r[0],s,a[0],i[0]),d=jo(u,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}};oX.className="ConvRNN2D";var l2=class extends Xw{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,ts(this.filters,"filters"),this.kernelSize=Hm(n,2,"kernelSize"),this.kernelSize.forEach(o=>ts(o,"kernelSize")),this.strides=Hm(r||1,2,"strides"),this.strides.forEach(o=>ts(o,"strides")),this.padding=s||"valid",Li(this.padding),this.dataFormat=a||"channelsLast",xr(this.dataFormat),this.dilationRate=Hm(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>ts(o,"dilationRate"))}build(e){var t;e=dn(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new he(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],s=4,a=this.kernelSize.concat([r,this.filters*s]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,u=this.filters;o=new(t=class extends Io{apply(c,d){let h=l.apply([u]),p=Ha([u]),f=l.apply([u*2]);return oM([h,p,f])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ue(()=>{if(e.length!==3)throw new he(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],s=e[1],a=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Zc({ones:()=>ei(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(O,L,V)=>!L||!L[V]?O:ae(L[V],O),u=l(r,o,0),c=l(r,o,1),d=l(r,o,2),h=l(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Zc({ones:()=>ei(s),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let p=this.recurrentDropoutMask,f=l(s,p,0),m=l(s,p,1),g=l(s,p,2),y=l(s,p,3),b=3,[x,w,v,k]=Sa(this.kernel.read(),i,b),[I,S,$,N]=this.useBias?Sa(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,x,I,this.padding),c=this.inputConv(c,w,S,this.padding),d=this.inputConv(d,v,$,this.padding),h=this.inputConv(h,k,N,this.padding);let[T,C,E,M]=Sa(this.recurrentKernel.read(),i,b);f=this.recurrentConv(f,T),m=this.recurrentConv(m,C),g=this.recurrentConv(g,E),y=this.recurrentConv(y,M);let F=this.recurrentActivation.apply(Ie(u,f)),z=this.recurrentActivation.apply(Ie(c,m)),H=Ie(ae(z,a),ae(F,this.activation.apply(Ie(d,g)))),P=ae(this.recurrentActivation.apply(Ie(h,y)),this.activation.apply(H));return[P,P,H]})}getConfig(){let e=super.getConfig(),t=$Ie(e,["units"]),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),n)}inputConv(e,t,n,r){let s=ea(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?ul(s,n,this.dataFormat):s}recurrentConv(e,t){return ea(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};l2.className="ConvLSTM2DCell";_e.registerClass(l2);var HM=class extends oX{constructor(e){let t=new l2(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};HM.className="ConvLSTM2D";_e.registerClass(HM);var u2=class extends zt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=kt(e);if(0<this.rate&&this.rate<1){let r=t.training==null?!1:t.training,s=this.getNoiseShape(n);return Vw(()=>bK(n,this.rate,s,this.seed),()=>n,r)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};u2.className="Dropout";_e.registerClass(u2);var jM=class extends u2{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};jM.className="SpatialDropout1D";_e.registerClass(jM);var qM=class extends zt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,ts(this.units,"units"),this.activation=Yc(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Yn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Yn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Vr(e.kernelConstraint),this.biasConstraint=Vr(e.biasConstraint),this.kernelRegularizer=Jn(e.kernelRegularizer),this.biasRegularizer=Jn(e.biasRegularizer),this.activityRegularizer=Jn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=dn(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=dn(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=kt(e),r=dK(this.activation.getClassName()),s;return r!=null?s=Ml(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=Ml(n,this.kernel.read()),this.bias!=null&&(s=ul(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let e={units:this.units,activation:Xc(this.activation),useBias:this.useBias,kernelInitializer:ar(this.kernelInitializer),biasInitializer:ar(this.biasInitializer),kernelRegularizer:_n(this.kernelRegularizer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),kernelConstraint:Wr(this.kernelConstraint),biasConstraint:Wr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};qM.className="Dense";_e.registerClass(qM);var KM=class extends zt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=dn(e);for(let t of e.slice(1))if(t==null)throw new he(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Fc(e,1)]}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=kt(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let s=2;s<n.rank;++s)r.push(s);r.push(1),n=Ft(n,r)}return Gve(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};KM.className="Flatten";_e.registerClass(KM);var XM=class extends zt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Yc(e.activation)}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=kt(e);return this.activation.apply(n)})}getConfig(){let e={activation:Xc(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};XM.className="Activation";_e.registerClass(XM);var YM=class extends zt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ue(()=>(e=kt(e),Vve(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};YM.className="RepeatVector";_e.registerClass(YM);var ZM=class extends zt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),s=1,a=null;for(let o=0;o<r.length;++o){let l=r[o];if(this.isUnknown(l))if(a===null)a=o;else throw new he("Can only specifiy one unknown dimension.");else s*=l}let i=Fc(e);if(a!==null){if(s===0||i%s!==0)throw new he(n);r[a]=i/s}else if(i!==s)throw new he(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=kt(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return oe(n,s)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};ZM.className="Reshape";_e.registerClass(ZM);var JM=class extends zt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=el(1,e.dims.length+1);if(!_.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Cr({ndim:this.dims.length+1})]}computeOutputShape(e){e=dn(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return Ft(kt(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};JM.className="Permute";_e.registerClass(JM);var QM=class extends zt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=kt(e),r=-1;return y0(qh(n,this.maskValue),r)}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=kt(e),r=-1,s=!0,a=y0(qh(n,this.maskValue),r,s);return ae(n,Me(a,n.dtype))})}};QM.className="Masking";_e.registerClass(QM);var e3=class extends zt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Bn(e.inputLength))}this.inputDim=e.inputDim,ts(this.inputDim,"inputDim"),this.outputDim=e.outputDim,ts(this.outputDim,"outputDim"),this.embeddingsInitializer=Yn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Jn(e.embeddingsRegularizer),this.activityRegularizer=Jn(e.activityRegularizer),this.embeddingsConstraint=Vr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ue(()=>this.maskZero?(e=kt(e),qh(e,Ht(e))):null)}computeOutputShape(e){if(e=dn(e),this.inputLength==null)return[...e,this.outputDim];let t=Bn(this.inputLength);if(t.length!==e.length-1)throw new he(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let s=t[r],a=e[r+1];if(s!=null&&a!=null&&s!==a)throw new he(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=kt(e);n.dtype!=="int32"&&(n=Mu(n,"int32"));let r=yK(this.embeddings.read(),oe(n,[n.size]));return oe(r,dn(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ar(this.embeddingsInitializer),embeddingsRegularizer:_n(this.embeddingsRegularizer),activityRegularizer:_n(this.activityRegularizer),embeddingsConstraint:Wr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};e3.className="Embedding";_e.registerClass(e3);var Pf=class extends zt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Rt}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let s=e[e.length-t.length+r],a=t[r];if(s==null||a==null||s<0||a<0)n.push(null);else if(s===1)n.push(a);else if(a===1)n.push(s);else{if(s!==a)throw new he("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[dn(e)]),e=e,e.length<2)throw new he(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=Dc(t),t.length>1)throw new he(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){let a=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let r=e.map(s=>s.length);e.indexOf(null)===-1&&Dc(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ue(()=>{if(e=e,this.reshapeRequired){let n=[],r=e.map(s=>s.rank);if(r.indexOf(null)===-1){let s=Kc(r);for(let a of e){let i=a.rank;for(let o=0;o<s-i;++o)a=Bw(a,1);n.push(a)}return this.mergeFunction(n)}else{let s=!1;for(let o of e){let l=o.rank;if(l==null){let u=o.shape,c=u[0],d=u.slice(1).concat([c]),h=oe(o,[c].concat(Fc(u.slice(1))));h=Ft(h,[1,0]),h=oe(h,d),n.push(h),s=!0}else if(l>1){let u=el(1,l).concat([0]);n.push(Ft(o,u)),s=!0}else n.push(o)}let a=this.mergeFunction(n),i=a.rank;if(s){if(i==null){let o=a.shape,l=o.length,u=o[l-1],c=[u].concat(o.slice(0,o.length-1));a=oe(Ft(oe(a,[-1,u]),[1,0]),c)}else if(i>1){let o=[i-1].concat(el(0,i-1));a=Ft(a,o)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(let r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=Dc(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return ue(()=>{if(t==null)return null;if(!Array.isArray(t))throw new he("`mask` should be an Array");if(!Array.isArray(e))throw new he("`inputs` should be an Array");if(t.length!==e.length)throw new he(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:ms(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=yo(n,t[r]);return n})}},t3=class extends Pf{constructor(e){super(e)}mergeFunction(e){return ue(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ie(t,e[n]);return t})}};t3.className="Add";_e.registerClass(t3);var n3=class extends Pf{constructor(e){super(e)}mergeFunction(e){return ue(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ae(t,e[n]);return t})}};n3.className="Multiply";_e.registerClass(n3);var r3=class extends Pf{constructor(e){super(e)}mergeFunction(e){return ue(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ie(t,e[n]);return ae(1/e.length,t)})}};r3.className="Average";_e.registerClass(r3);var s3=class extends Pf{constructor(e){super(e)}mergeFunction(e){return ue(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Xl(t,e[n]);return t})}};s3.className="Maximum";_e.registerClass(s3);var a3=class extends Pf{constructor(e){super(e)}mergeFunction(e){return ue(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=jc(t,e[n]);return t})}};a3.className="Minimum";_e.registerClass(a3);var i3=class extends Pf{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new he("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let r of e)if(r!=null){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let s=e[r].slice();s.splice(this.axis,1);let a=!1;for(let i of n)if(_.arraysEqual(i,s)){a=!0;break}a||n.push(s)}if(n.length>1)throw new he("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ue(()=>oM(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new he("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let s of t.slice(1)){if(n[r]==null||s[r]==null){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new he("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new he("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new he(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ue(()=>{let n=!0;if(t.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;let r=[];for(let a=0;a<e.length;++a)t[a]==null?r.push(Me(ei(e[a]),"bool")):t[a].rank<e[a].rank?r.push(ms(t[a],-1)):r.push(t[a]);let s=In(r,this.axis);return fN(s,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};i3.className="Concatenate";_e.registerClass(i3);function tx(e,t){for(;e<0;)e+=t;return e}function TIe(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Rt("batchDot is not implemented for tensors of 4D or higher rank yet");if(_.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),_.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new Rt("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,s=t.shape.length;n==null&&(n=[r-1,s-2]);let a=n;return ue(()=>{let i;if(r>s){i=r-s;let l=[];for(let u=0;u<i;++u)l.push(1);t=oe(t,t.shape.concat(l))}else if(s>r){i=s-r;let l=[];for(let u=0;u<i;++u)l.push(1);e=oe(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)a[0]===a[1]?o=st(ae(e,t),a[0]):o=st(ae(Ft(e,[1,0]),t),a[1]);else{let l=a[0]!==e.shape.length-1,u=a[1]===t.shape.length-1;o=At(e,t,l,u)}if(i>0){let l;r>s?l=r+s-3:l=r-1;let u=[];for(let c=l;c<l+i;++c)u.push(c);o=Id(o,u)}return o.shape.length===1&&(o=ms(o,1)),o})}var o3=class extends Pf{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){_.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Rt("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new he(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new he(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((s,a)=>tx(s,e[a].shape.length)):r=[tx(this.axes,t.shape.length),tx(this.axes,n.shape.length)],this.normalize&&(t=lS(t,r[0]),n=lS(n,r[1])),TIe(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[tx(this.axes,e.length),tx(this.axes,t.length)],n}computeOutputShape(e){_.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Rt("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let s=t.concat(n);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};o3.className="Dot";_e.registerClass(o3);var l3=class extends zt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=kt(e);return Vw(()=>Ie(qN(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};l3.className="GaussianNoise";_e.registerClass(l3);var u3=class extends zt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=kt(e);return this.rate>0&&this.rate<1?Vw(()=>{let r=Math.sqrt(this.rate/(1-this.rate));return ae(n,qN(n.shape,1,r))},()=>n,t.training||!1):n})}};u3.className="GaussianDropout";_e.registerClass(u3);var c3=class extends zt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||kt(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ue(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Vw(()=>{let r=kt(e),s=1.6732632423543772,a=1.0507009873554805,i=-s*a,o=Uu(lb(n),this.rate);o=Mu(o,"float32");let l=((1-this.rate)*(1+this.rate*i**2))**-.5,u=-l*i*this.rate,c=Ie(ae(r,o),ae(Ie(o,-1),i));return Ie(ae(c,l),u)},()=>kt(e),t.training||!1)}return e})}};c3.className="AlphaDropout";_e.registerClass(c3);function I0(e,t,n,r,s,a=.001){let i;if(e.rank===2)i=JF(e,t,n,r,s,a);else if(e.rank===3)i=QF(e,t,n,r,s,a);else if(e.rank===4)i=eO(e,t,n,r,s,a);else throw new Rt(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function _Ie(e,t,n,r,s=.001){return ue(()=>{let a=Rw(e,r),i=a.mean,o=a.variance;return[I0(e,i,o,n,t,s),i,o]})}function EIe(e,t,n,r,s=.001){return ue(()=>{let a=Rw(e,r),i=a.mean,o=a.variance,l=[];for(let p of el(0,e.rank))r.indexOf(p)!==-1?l.push(1):l.push(e.shape[p]);let u=oe(i,l),c=oe(o,l),d=t==null?null:oe(t,l),h=n==null?null:oe(n,l);return[I0(e,u,c,h,d,s),i,o]})}function AIe(e,t,n,r,s=.001){return _.arraysEqual(r.slice().sort(),el(0,e.rank-1))?_Ie(e,t,n,r,s):EIe(e,t,n,r,s)}var d3=class extends zt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Yn(e.betaInitializer||"zeros"),this.gammaInitializer=Yn(e.gammaInitializer||"ones"),this.movingMeanInitializer=Yn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Yn(e.movingVarianceInitializer||"ones"),this.betaConstraint=Vr(e.betaConstraint),this.gammaConstraint=Vr(e.gammaConstraint),this.betaRegularizer=Jn(e.betaRegularizer),this.gammaRegularizer=Jn(e.gammaRegularizer)}build(e){e=dn(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new he(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Cr({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ue(()=>{let n=t.training==null?!1:t.training,r=kt(e),s=r.shape,a=s.length,i=el(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);let l=Xh(1,a);l[o]=s[o];let u=i.slice();u.sort();let c=!_.arraysEqual(u,el(0,a).slice(0,a-1)),d=()=>{if(c){let g=oe(this.movingMean.read(),l),y=oe(this.movingVariance.read(),l),b=this.center?oe(this.beta.read(),l):null,x=this.scale?oe(this.gamma.read(),l):null;return I0(r,g,y,b,x,this.epsilon)}else return I0(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[h,p,f]=AIe(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(g,y,b)=>{ue(()=>{let x=1-b,w=g.read(),v=ae(qe(w,y),x);g.write(qe(w,v))})};return m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum),h})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ar(this.betaInitializer),gammaInitializer:ar(this.gammaInitializer),movingMeanInitializer:ar(this.movingMeanInitializer),movingVarianceInitializer:ar(this.movingVarianceInitializer),betaRegularizer:_n(this.betaRegularizer),gammaRegularizer:_n(this.gammaRegularizer),betaConstraint:Wr(this.betaConstraint),gammaConstraint:Wr(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};d3.className="BatchNormalization";_e.registerClass(d3);var h3=class extends zt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Yn(e.betaInitializer||"zeros"),this.gammaInitializer=Yn(e.gammaInitializer||"ones"),this.betaRegularizer=Jn(e.betaRegularizer),this.gammaRegularizer=Jn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=dn(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(let s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Dc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>e[s]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=kt(e),r=n.shape,s=r.length;return ue(()=>{let{mean:a,variance:i}=Rw(n,this.axis,!0),o=Xh(1,s);for(let p of this.axis)o[p]=r[p];let l=p=>p!=null&&p.shape.length!==s?oe(p,o):p,u=this.scale?l(this.gamma.read()):null,c=this.center?l(this.beta.read()):null,d=[],h=[];for(let p=0;p<s;++p)this.axis.indexOf(p)!==-1?(d.push(r[p]),h.push(1)):(d.push(1),h.push(r[p]));return a=Ga(a,d),i=Ga(i,d),u!=null&&(u=Ga(u,h)),c!=null&&(c=Ga(c,h)),I0(n,a,i,c,u,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ar(this.betaInitializer),gammaInitializer:ar(this.gammaInitializer),betaRegularizer:_n(this.betaRegularizer),gammaRegularizer:_n(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};h3.className="LayerNormalization";_e.registerClass(h3);function RIe(e,t,n){return ue(()=>{if(e.rank!==4)throw new he(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new he("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=tl()),n!=="channelsLast"&&n!=="channelsFirst")throw new he(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],ll(e,r)})}var p3=class extends zt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?tl():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new he(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new he(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new he(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Cr({ndim:4})]}computeOutputShape(e){e=dn(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return ue(()=>RIe(kt(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};p3.className="ZeroPadding2D";_e.registerClass(p3);function c2(e,t,n,r,s,a){return ue(()=>{xr(s),pK(a),Li(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=tl()),a==null&&(a="max"),e=FM(e,s);let i,o=r==="same"?"same":"valid";return a==="max"?i=Yr(e,t,n,o):i=Vu(e,t,n,o),s==="channelsFirst"&&(i=Ft(i,[0,3,1,2])),i})}function lX(e,t,n,r,s,a){return ue(()=>{xr(s),pK(a),Li(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=tl()),a==null&&(a="max"),e=rX(e,s);let i,o=r==="same"?"same":"valid";return a==="max"?i=CO(e,t,n,o):i=ZF(e,t,n,o),s==="channelsFirst"&&(i=Ft(i,[0,4,1,2,3])),i})}var uX=class extends zt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new he(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(ts(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new he(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);ts(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Li(this.padding),this.inputSpec=[new Cr({ndim:3})]}computeOutputShape(e){e=dn(e);let t=jo(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ue(()=>{this.invokeCallHook(e,t),e=Bw(kt(e),2);let n=this.poolingFunction(kt(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Id(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},f3=class extends uX{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return xr(s),Li(r),c2(e,t,n,r,s,"max")}};f3.className="MaxPooling1D";_e.registerClass(f3);var m3=class extends uX{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return xr(s),Li(r),c2(e,t,n,r,s,"avg")}};m3.className="AveragePooling1D";_e.registerClass(m3);var cX=class extends zt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new he(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];ts(this.poolSize,"poolSize"),ts(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,xr(this.dataFormat),Li(this.padding),this.inputSpec=[new Cr({ndim:4})]}computeOutputShape(e){e=dn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=jo(t,this.poolSize[0],this.padding,this.strides[0]),n=jo(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return ue(()=>(this.invokeCallHook(e,t),this.poolingFunction(kt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},g3=class extends cX{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return xr(s),Li(r),c2(e,t,n,r,s,"max")}};g3.className="MaxPooling2D";_e.registerClass(g3);var y3=class extends cX{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return xr(s),Li(r),c2(e,t,n,r,s,"avg")}};y3.className="AveragePooling2D";_e.registerClass(y3);var dX=class extends zt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new he(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];ts(this.poolSize,"poolSize"),ts(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,xr(this.dataFormat),Li(this.padding),this.inputSpec=[new Cr({ndim:5})]}computeOutputShape(e){e=dn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=jo(t,this.poolSize[0],this.padding,this.strides[0]),n=jo(n,this.poolSize[1],this.padding,this.strides[1]),r=jo(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return ue(()=>(this.invokeCallHook(e,t),this.poolingFunction(kt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},b3=class extends dX{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return xr(s),Li(r),lX(e,t,n,r,s,"max")}};b3.className="MaxPooling3D";_e.registerClass(b3);var x3=class extends dX{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return xr(s),Li(r),lX(e,t,n,r,s,"avg")}};x3.className="AveragePooling3D";_e.registerClass(x3);var hX=class extends zt{constructor(e){super(e),this.inputSpec=[new Cr({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Rt}},w3=class extends hX{constructor(e){super(e||{})}call(e,t){return ue(()=>{let n=kt(e);return rr(n,1)})}};w3.className="GlobalAveragePooling1D";_e.registerClass(w3);var v3=class extends hX{constructor(e){super(e||{})}call(e,t){return ue(()=>{let n=kt(e);return Ci(n,1)})}};v3.className="GlobalMaxPooling1D";_e.registerClass(v3);var pX=class extends zt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,xr(this.dataFormat),this.inputSpec=[new Cr({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Rt}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},k3=class extends pX{call(e,t){return ue(()=>{let n=kt(e);return this.dataFormat==="channelsLast"?rr(n,[1,2]):rr(n,[2,3])})}};k3.className="GlobalAveragePooling2D";_e.registerClass(k3);var I3=class extends pX{call(e,t){return ue(()=>{let n=kt(e);return this.dataFormat==="channelsLast"?Ci(n,[1,2]):Ci(n,[2,3])})}};I3.className="GlobalMaxPooling2D";_e.registerClass(I3);var fX=class extends zt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,s=Ho(r,n);delete t.layer;let a={layer:s};return Object.assign(a,t),new e(a)}},S3=class extends fX{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=dn(t),t.length<3)throw new he(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=dn(t);let n=[t[0]].concat(t.slice(2)),r=this.layer.computeOutputShape(n),s=t[1];return[r[0],s].concat(r.slice(1))}call(t,n){return ue(()=>(t=kt(t),iX((r,s)=>[kt(this.layer.call(r,n)),[]],t,[],!1,null,null,!1,!0)[1]))}};S3.className="TimeDistributed";_e.registerClass(S3);function DIe(e){Mf(Lve,"BidirectionalMergeMode",e)}var FIe="concat",C3=class extends fX{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Ho(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Ho(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?FIe:e.mergeMode,DIe(this.mergeMode),e.weights)throw new Rt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,s;return this.returnState&&(s=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):ba(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let s=aX(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let a=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new he("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);let u=n.map(c=>new Cr({shape:c.shape}));this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),i.push(...u)}if(r!=null)throw new Rt("Support for constants in Bidirectional layers is not implemented yet.");let o=a[0]instanceof Bo;for(let l of a)if(l instanceof Bo!==o)throw new he("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let l=[e].concat(a),u=this.inputSpec.concat(i),c=this.inputSpec;this.inputSpec=u;let d=super.apply(l,t);return this.inputSpec=c,d}else return super.apply(e,t)}call(e,t){return ue(()=>{let n=t.initialState,r,s;if(n==null)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=Ti(s,1));let i;return this.mergeMode==="concat"?i=oM([r,s]):this.mergeMode==="sum"?i=Ie(r,s):this.mergeMode==="ave"?i=ae(.5,Ie(r,s)):this.mergeMode==="mul"?i=ae(r,s):this.mergeMode==null&&(i=[r,s]),this.returnState?this.mergeMode==null?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Ch(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Ch(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let r=this.forwardLayer.states.map(s=>null);return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Ho(t.layer);if(delete t.layer,t.numConstants!=null)throw new Rt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};C3.className="Bidirectional";_e.registerClass(C3);var N3=class extends zt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ue(()=>(e=kt(e),e.dtype!=="float32"&&(e=Mu(e,"float32")),Ie(ae(e,this.scale),this.offset)))}};N3.className="Rescaling";_e.registerClass(N3);var{resizeBilinear:OIe,cropAndResize:MIe}=Po,$3=class extends zt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,o){return ue(()=>{let l,u=!1,c=t/a,d=n/i,h=(r+t)/a,p=(s+n)/i,f=[c,d,h,p],m=[];e.rank===3?(u=!0,l=zr([e])):l=e;for(let x=0;x<l.shape[0];x++)m.push(f);let g=Js(m,[m.length,4]),y=Kh(0,m.length,1,"int32"),b=MIe(l,g,y,[r,s],"nearest");return Mu(u?kt(fr(b)):b,o)})}upsize(e,t,n,r){return ue(()=>{let s=OIe(e,[t,n]);return Mu(s,r)})}call(e,t){return ue(()=>{let n=kt(e),r=n.dtype,s=n.shape,a=s[s.length-3],i=s[s.length-2],o=0;a!==this.height&&(o=Math.floor((a-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,a,i,r):this.upsize(e,this.height,this.width,r)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=dn(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};$3.className="CenterCrop";_e.registerClass($3);function LIe(e,t,n,r){let s=kt(e);if(s.dtype!=="int32"&&(s=Mu(s,"int32")),t==="int")return s;let a=s.shape;if(s.rank===0&&(s=ms(s,-1)),t==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=ms(s,-1)),s.rank>2)throw new he(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);let i=["multiHot","oneHot"].includes(t),o=s,l;if(typeof r<"u"&&t==="count"?l=rS(o,r,n,i):l=rS(o,[],n,i),t!=="tfIdf")return l;if(r)return ae(l,r);throw new he("When outputMode is 'tfIdf', weights must be provided.")}var T3=class extends zt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=dn(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return ue(()=>{e=kt(e),e.dtype!=="int32"&&(e=Mu(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new he(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=kt(t.countWeights)}let r=Ci(e),s=fg(e),a=la(this.numTokens,r).bufferSync().get(0),i=Uu(s,0).bufferSync().get(0);if(!(a&&i))throw new he(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return LIe(e,this.outputMode,this.numTokens,n)})}};T3.className="CategoryEncoding";_e.registerClass(T3);var PIe=["bilinear","nearest"],UV=new Set(PIe),_3=class extends zt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(UV.has(e.interpolation))this.interpolation=e.interpolation;else throw new he(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=dn(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ue(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return Po.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Po.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...UV]} are supported`)})}};_3.className="Resizing";_e.registerClass(_3);function zIe(e){return new hb(e)}function BIe(e){return new AM(e)}function WIe(e){return new TM(e)}function VIe(e){return new _M(e)}function UIe(e){return new EM(e)}function GIe(e){return new DM(e)}function HIe(e){return new RM(e)}function jIe(e){return new s2(e)}function qIe(e){return new jw(e)}function KIe(e){return new MM(e)}function XIe(e){return new qw(e)}function YIe(e){return new LM(e)}function ZIe(e){return new PM(e)}function JIe(e){return new zM(e)}function QIe(e){return new BM(e)}function eSe(e){return new WM(e)}function tSe(e){return new XM(e)}function nSe(e){return new qM(e)}function rSe(e){return new u2(e)}function sSe(e){return new jM(e)}function aSe(e){return new KM(e)}function iSe(e){return new YM(e)}function oSe(e){return new ZM(e)}function lSe(e){return new JM(e)}function uSe(e){return new e3(e)}function cSe(e){return new t3(e)}function dSe(e){return new r3(e)}function hSe(e){return new i3(e)}function pSe(e){return new s3(e)}function fSe(e){return new a3(e)}function mSe(e){return new n3(e)}function gSe(e){return new o3(e)}function ySe(e){return new d3(e)}function bSe(e){return new h3(e)}function xSe(e){return new p3(e)}function E3(e){return new m3(e)}function wSe(e){return E3(e)}function vSe(e){return E3(e)}function A3(e){return new y3(e)}function kSe(e){return A3(e)}function ISe(e){return A3(e)}function R3(e){return new x3(e)}function SSe(e){return R3(e)}function CSe(e){return R3(e)}function NSe(e){return new w3(e)}function $Se(e){return new k3(e)}function mX(e){return new v3(e)}function gX(e){return new I3(e)}function yX(e){return new f3(e)}function bX(e){return new g3(e)}function TSe(e){return new b3(e)}function _Se(e){return new UM(e)}function ESe(e){return new i2(e)}function ASe(e){return new GM(e)}function RSe(e){return new Xw(e)}function DSe(e){return new VM(e)}function FSe(e){return new a2(e)}function OSe(e){return new HM(e)}function MSe(e){return new l2(e)}function LSe(e){return new Zl(e)}function PSe(e){return new o2(e)}function zSe(e){return new C3(e)}function BSe(e){return new S3(e)}var WSe=mX,VSe=gX,USe=yX,GSe=bX;function HSe(e){return new l3(e)}function jSe(e){return new u3(e)}function qSe(e){return new c3(e)}function KSe(e){return new QM(e)}function XSe(e){return new N3(e)}function YSe(e){return new $3(e)}function ZSe(e){return new _3(e)}function JSe(e){return new T3(e)}var xX={};Ct(xX,{MAPE:()=>uCe,MSE:()=>hCe,binaryAccuracy:()=>QSe,binaryCrossentropy:()=>eCe,categoricalAccuracy:()=>nCe,categoricalCrossentropy:()=>rCe,cosineProximity:()=>iCe,mape:()=>cCe,meanAbsoluteError:()=>oCe,meanAbsolutePercentageError:()=>lCe,meanSquaredError:()=>dCe,mse:()=>pCe,precision:()=>sCe,recall:()=>aCe,sparseCategoricalAccuracy:()=>tCe});function QSe(e,t){return kM(e,t)}function eCe(e,t){return DK(e,t)}function tCe(e,t){return FK(e,t)}function nCe(e,t){return IM(e,t)}function rCe(e,t){return SM(e,t)}function sCe(e,t){return RK(e,t)}function aCe(e,t){return Wke(e,t)}function iCe(e,t){return vM(e,t)}function oCe(e,t){return n2(e,t)}function lCe(e,t){return pb(e,t)}function uCe(e,t){return pb(e,t)}function cCe(e,t){return pb(e,t)}function dCe(e,t){return Lf(e,t)}function hCe(e,t){return Lf(e,t)}function pCe(e,t){return Lf(e,t)}var wX={};Ct(wX,{modelFromJSON:()=>mIe});var vX={};Ct(vX,{l1:()=>mCe,l1l2:()=>fCe,l2:()=>gCe});function fCe(e){return new Gw(e)}function mCe(e){return kIe(e)}function gCe(e){return IIe(e)}var kX=class extends Ig{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Nu))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function lk(e,t){return e<t}function GV(e,t){return e>t}var IX=class extends kX{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Rt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=lk:this.mode==="max"?this.monitorFunc=GV:this.monitor.indexOf("acc")!==-1?this.monitorFunc=GV:this.monitorFunc=lk,this.monitorFunc===lk&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===lk?1/0:-1/0}async onEpochEnd(e,t){await sc(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function yCe(e){return new IX(e)}var bCe={earlyStopping:yCe},xCe=me();xCe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Hi;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(Hi||(Hi={}));var HV;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(HV||(HV={}));var D3={};function wCe(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};D3[e]=n}function SX(e){return D3[e]}function vCe(e){delete D3[e]}function A(e,t,n,r,s){let a=t.inputParams[e];if(a&&a.inputIndexStart!==void 0){let o=a.inputIndexStart,l=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?o+1:a.inputIndexEnd,u=o<0?t.inputNames.length+o:o;if(a.type==="tensor")return gs(t.inputNames[u],n,r,s);if(a.type==="tensors"){let h=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((p,f)=>{var m;return((m=h[f])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(p=>gs(p,n,r,s))}let c=gs(t.inputNames[u],n,r,s),d=c.dataSync();return a.type==="number"?d[0]:_.toNestedArray(c.shape,d)}let i=t.attrParams[e];return i&&i.value}function gs(e,t,n,r){let[s,a]=Pa(e,n);if(r!=null){let o=r.getHashTableHandleByName(s);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[pS(s,o)]);return i!==void 0?t[pS(s,i)][a]:void 0}function jV(e,t,n){return t[pS(e,n.currentContextId)]}function fu(e,t){let[n,r,s]=Pa(e,t);return[pS(n,t&&t.currentContextId),r,s]}function pS(e,t){return t?`${e}-${t}`:e}function Pa(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let a=t.parseNodeNameCache.get(e);if(a!=null)return a}let r=e.split(":"),s;if(r.length===1)s=[e,0,void 0];else{let a=r[0],i=r.length===3?r[1]:void 0,o=Number(r[r.length-1]);s=[a,o,i]}return n&&t.parseNodeNameCache.set(e,s),s}function lI(e,t,n){let r=A("pad",e,t,n);if(r==="explicit"){r=A("explicitPaddings",e,t,n);let s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function mu(e){return e.kept?e:Fl(e)}var CX={};Ct(CX,{json:()=>kCe});var kCe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],NX={};Ct(NX,{json:()=>ICe});var ICe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],$X={};Ct($X,{json:()=>SCe});var SCe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],TX={};Ct(TX,{json:()=>CCe});var CCe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],_X={};Ct(_X,{json:()=>NCe});var NCe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],EX={};Ct(EX,{json:()=>$Ce});var $Ce=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],AX={};Ct(AX,{json:()=>TCe});var TCe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],RX={};Ct(RX,{json:()=>_Ce});var _Ce=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],DX={};Ct(DX,{json:()=>ECe});var ECe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],FX={};Ct(FX,{json:()=>ACe});var ACe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],OX={};Ct(OX,{json:()=>RCe});var RCe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],MX={};Ct(MX,{json:()=>DCe});var DCe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],LX={};Ct(LX,{json:()=>FCe});var FCe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],PX={};Ct(PX,{json:()=>OCe});var OCe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],zX={};Ct(zX,{json:()=>MCe});var MCe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],BX={};Ct(BX,{json:()=>LCe});var LCe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],WX={};Ct(WX,{json:()=>PCe});var PCe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],VX={};Ct(VX,{json:()=>zCe});var zCe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],UX={};Ct(UX,{json:()=>BCe});var BCe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],qV=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[CX,NX,$X,TX,_X,EX,AX,RX,DX,FX,OX,MX,LX,PX,zX,BX,WX,VX,UX],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){let n=e.node,r=[],s=[],a=[],i=n.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(f[m.name]):m.op==="Const"?s.push(f[m.name]):(m.input==null||m.input.length===0)&&a.push(f[m.name]),f),{}),o=[],l=[],u={},c={};t!=null&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach(f=>{let m=i[f];m.inputNames.forEach((g,y)=>{let[b,,x]=fu(g),w=i[b];if(w.outputs!=null){let v=w.outputs.indexOf(x);if(v!==-1){let k=`${b}:${v}`;m.inputNames[y]=k}}m.inputs.push(w),w.children.push(m)})}),Object.keys(c).length===0?d.forEach(f=>{let m=i[f];m.children.length===0&&l.push(m)}):Object.keys(c).forEach(f=>{let[m]=fu(f),g=i[m];g!=null&&(g.signatureKey=c[f],l.push(g))}),Object.keys(u).length>0?Object.keys(u).forEach(f=>{let[m]=fu(f),g=i[m];g&&(g.signatureKey=u[f],o.push(g))}):o=r;let h={};e.library!=null&&e.library.function!=null&&(h=e.library.function.reduce((f,m)=>(f[m.signature.name]=this.mapFunction(m),f),{}));let p={nodes:i,inputs:o,outputs:l,weights:s,placeholders:r,signature:t,functions:h};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=SX(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,s)=>(r[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,s)=>{let a=s.type,i;switch(s.type){case"string":i=$A(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=$A(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":i=FA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=FA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":i=_A(e.attr,s.tfName,s.defaultValue||0),i===void 0&&s.tfDeprecatedName&&(i=_A(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":i=DA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=DA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":i=TA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=TA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":i=MA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=MA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":i=RA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=RA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":i=OA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=OA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":i=EA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=EA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":i=AA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=AA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":i=KV(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=KV(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return r[s.name]={value:i,type:a},r},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],s={};t!=null&&(s=t.reduce((u,c)=>(u[c.name]=this.mapNode(c),c.op==="Const"&&r.push(u[c.name]),u),{}));let a=[],i=[];e.signature.inputArg.forEach(u=>{let[c]=fu(u.name),d={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:F3(u.type),type:"dtype"}},children:[]};d.signatureKey=u.name,a.push(d),s[c]=d}),Object.keys(s).forEach(u=>{let c=s[u];c.inputNames.forEach((d,h)=>{let[p,,f]=fu(d),m=s[p];if(m.outputs!=null){let g=m.outputs.indexOf(f);if(g!==-1){let y=`${p}:${g}`;c.inputNames[h]=y}}c.inputs.push(m),m.children.push(c)})});let o=e.ret;e.signature.outputArg.forEach(u=>{let[c,d]=fu(o[u.name]),h=s[c];h!=null&&(h.defaultOutput=d,i.push(h))});let l=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function WCe(e){let t=me().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function GX(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):WCe(e);return t?n:n.toLowerCase()}function $A(e,t,n,r=!1){let s=e[t];return s!=null?GX(s.s,r):n}function TA(e,t,n){let r=e[t];return r?r.b:n}function _A(e,t,n){let r=e[t]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function F3(e){switch(typeof e=="string"&&(e=Hi[e]),e){case Hi.DT_FLOAT:case Hi.DT_HALF:return"float32";case Hi.DT_INT32:case Hi.DT_INT64:case Hi.DT_INT8:case Hi.DT_UINT8:return"int32";case Hi.DT_BOOL:return"bool";case Hi.DT_DOUBLE:return"float32";case Hi.DT_STRING:return"string";default:return null}}function KV(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function EA(e,t,n){let r=e[t];return r&&r.type?F3(r.type):n}function AA(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(s=>F3(s)):n}function HX(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function RA(e,t,n){let r=e[t];return r&&r.shape?HX(r.shape):n}function DA(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function FA(e,t,n,r=!1){let s=e[t];return s&&s.list&&s.list.s?s.list.s.map(a=>GX(a,r)):n}function OA(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>HX(s)):n}function MA(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var VCe=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,s)=>(r[s]=this.getAttr(s),r),{}))}getInput(e){return gs(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return gs(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return _A(this.node.rawAttrs,e,t);if(n.s!=null)return $A(this.node.rawAttrs,e,t);if(n.b!=null)return TA(this.node.rawAttrs,e,t);if(n.shape!=null)return RA(this.node.rawAttrs,e,t);if(n.type!=null)return EA(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return DA(this.node.rawAttrs,e,t);if(n.list.s!=null)return FA(this.node.rawAttrs,e,t);if(n.list.shape!=null)return OA(this.node.rawAttrs,e,t);if(n.list.b!=null)return MA(this.node.rawAttrs,e,t);if(n.list.type!=null)return AA(this.node.rawAttrs,e,t)}return t}},os={};Ct(os,{OP_SCOPE_SUFFIX:()=>LF,abs:()=>Ir,acos:()=>VF,acosh:()=>UF,add:()=>Ie,addN:()=>Cq,all:()=>fN,any:()=>y0,argMax:()=>Uh,argMin:()=>GF,asin:()=>HF,asinh:()=>jF,atan:()=>qF,atan2:()=>KF,atanh:()=>XF,avgPool:()=>Vu,avgPool3d:()=>ZF,basicLSTMCell:()=>_q,batchNorm:()=>Rf,batchNorm2d:()=>JF,batchNorm3d:()=>QF,batchNorm4d:()=>eO,batchToSpaceND:()=>Nw,bincount:()=>tO,booleanMaskAsync:()=>y8,broadcastArgs:()=>Eq,broadcastTo:()=>Sh,buffer:()=>Ot,cast:()=>Me,ceil:()=>nO,clipByValue:()=>Ms,clone:()=>Fl,complex:()=>Fu,concat:()=>In,concat1d:()=>rO,concat2d:()=>sO,concat3d:()=>aO,concat4d:()=>iO,conv1d:()=>mN,conv2d:()=>ea,conv2dTranspose:()=>gN,conv3d:()=>lO,conv3dTranspose:()=>uO,cos:()=>$w,cosh:()=>yN,cosineWindow:()=>BN,cumprod:()=>w0,cumsum:()=>bN,denseBincount:()=>rS,depthToSpace:()=>cO,depthwiseConv2d:()=>Df,diag:()=>Rq,dilation2d:()=>dO,div:()=>tt,divNoNan:()=>hO,dot:()=>pO,dropout:()=>UO,einsum:()=>Fq,elu:()=>sb,enclosingPowerOfTwo:()=>GO,equal:()=>Ja,erf:()=>fO,euclideanNorm:()=>yO,exp:()=>ta,expandDims:()=>ms,expm1:()=>bO,eye:()=>xN,fft:()=>Mw,fill:()=>Ya,floor:()=>ib,floorDiv:()=>pN,fused:()=>wg,gather:()=>ob,gatherND:()=>v8,greater:()=>la,greaterEqual:()=>Uu,ifft:()=>xg,imag:()=>Tw,image:()=>Po,inTopKAsync:()=>k8,irfft:()=>DN,isFinite:()=>xO,isInf:()=>wO,isNaN:()=>vO,leakyRelu:()=>_w,less:()=>mg,lessEqual:()=>vd,linalg:()=>qO,linspace:()=>zq,localResponseNormalization:()=>kO,log:()=>Qa,log1p:()=>Ew,logSigmoid:()=>IO,logSoftmax:()=>vN,logSumExp:()=>kN,logicalAnd:()=>yo,logicalNot:()=>Aw,logicalOr:()=>IN,logicalXor:()=>SO,losses:()=>F8,lowerBound:()=>Wq,matMul:()=>At,max:()=>Ci,maxPool:()=>Yr,maxPool3d:()=>CO,maxPoolWithArgmax:()=>Vq,maximum:()=>Xl,mean:()=>rr,meshgrid:()=>Uq,min:()=>fg,minimum:()=>jc,mirrorPad:()=>NO,mod:()=>$O,moments:()=>Rw,movingAverage:()=>b8,mul:()=>ae,multiRNNCell:()=>Gq,multinomial:()=>Hq,neg:()=>Mn,norm:()=>ab,notEqual:()=>qh,oneHot:()=>gg,ones:()=>Ha,onesLike:()=>ei,op:()=>re,outerProduct:()=>jq,pad:()=>ll,pad1d:()=>qq,pad2d:()=>Kq,pad3d:()=>Xq,pad4d:()=>Yq,pool:()=>TO,pow:()=>Ou,prelu:()=>Fw,print:()=>WF,prod:()=>_O,raggedGather:()=>Zq,raggedRange:()=>Jq,raggedTensorToTensor:()=>Qq,rand:()=>e8,randomGamma:()=>s8,randomNormal:()=>CN,randomStandardNormal:()=>a8,randomUniform:()=>lb,range:()=>Kh,real:()=>yg,reciprocal:()=>FO,relu:()=>yn,relu6:()=>NN,reshape:()=>oe,reverse:()=>Ti,reverse1d:()=>i8,reverse2d:()=>o8,reverse3d:()=>l8,reverse4d:()=>u8,rfft:()=>Lw,round:()=>$N,rsqrt:()=>TN,scalar:()=>mt,scatterND:()=>x8,searchSorted:()=>SN,selu:()=>_N,separableConv2d:()=>ub,setdiff1dAsync:()=>c8,sigmoid:()=>ho,sign:()=>OO,signal:()=>D8,sin:()=>EN,sinh:()=>AN,slice:()=>Vt,slice1d:()=>Ow,slice2d:()=>RN,slice3d:()=>cb,slice4d:()=>bg,softmax:()=>kd,softplus:()=>Ff,spaceToBatchND:()=>Dw,sparse:()=>O8,sparseToDense:()=>w8,spectral:()=>R8,split:()=>Sa,sqrt:()=>ks,square:()=>vn,squaredDifference:()=>FN,squeeze:()=>Id,stack:()=>zr,step:()=>Of,stridedSlice:()=>MO,string:()=>M8,sub:()=>qe,sum:()=>st,tan:()=>LO,tanh:()=>Hh,tensor:()=>Js,tensor1d:()=>gn,tensor2d:()=>Ol,tensor3d:()=>ON,tensor4d:()=>qc,tensor5d:()=>d8,tensor6d:()=>h8,tensorScatterUpdate:()=>f8,tile:()=>Ga,topk:()=>zO,transpose:()=>Ft,truncatedNormal:()=>PN,unique:()=>BO,unsortedSegmentSum:()=>zN,unstack:()=>fr,upperBound:()=>m8,variable:()=>WO,where:()=>ss,whereAsync:()=>VO,zeros:()=>sr,zerosLike:()=>Ht});var UCe=(e,t,n,r=os)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(A("a",e,t,n),A("b",e,t,n))];case"AddN":return[r.addN(A("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(A("a",e,t,n),A("b",e,t,n))];case"Mul":return[r.mul(A("a",e,t,n),A("b",e,t,n))];case"RealDiv":case"Div":return[r.div(A("a",e,t,n),A("b",e,t,n))];case"DivNoNan":return[r.divNoNan(A("a",e,t,n),A("b",e,t,n))];case"FloorDiv":return[r.floorDiv(A("a",e,t,n),A("b",e,t,n))];case"Sub":return[r.sub(A("a",e,t,n),A("b",e,t,n))];case"Minimum":return[r.minimum(A("a",e,t,n),A("b",e,t,n))];case"Maximum":return[r.maximum(A("a",e,t,n),A("b",e,t,n))];case"Pow":return[r.pow(A("a",e,t,n),A("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(A("a",e,t,n),A("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},GCe=(e,t,n,r=os)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(A("x",e,t,n))];case"Acos":return[r.acos(A("x",e,t,n))];case"Acosh":return[r.acosh(A("x",e,t,n))];case"Asin":return[r.asin(A("x",e,t,n))];case"Asinh":return[r.asinh(A("x",e,t,n))];case"Atan":return[r.atan(A("x",e,t,n))];case"Atan2":return[r.atan2(A("x",e,t,n),A("y",e,t,n))];case"Atanh":return[r.atanh(A("x",e,t,n))];case"Ceil":return[r.ceil(A("x",e,t,n))];case"Complex":return[r.complex(A("real",e,t,n),A("imag",e,t,n))];case"Cos":return[r.cos(A("x",e,t,n))];case"Cosh":return[r.cosh(A("x",e,t,n))];case"Elu":return[r.elu(A("x",e,t,n))];case"Erf":return[r.erf(A("x",e,t,n))];case"Exp":return[r.exp(A("x",e,t,n))];case"Expm1":return[r.expm1(A("x",e,t,n))];case"Floor":return[r.floor(A("x",e,t,n))];case"Log":return[r.log(A("x",e,t,n))];case"Log1p":return[r.log1p(A("x",e,t,n))];case"Imag":return[r.imag(A("x",e,t,n))];case"Neg":return[r.neg(A("x",e,t,n))];case"Reciprocal":return[r.reciprocal(A("x",e,t,n))];case"Real":return[r.real(A("x",e,t,n))];case"Relu":return[r.relu(A("x",e,t,n))];case"Round":return[r.round(A("x",e,t,n))];case"Selu":return[r.selu(A("x",e,t,n))];case"Sigmoid":return[r.sigmoid(A("x",e,t,n))];case"Sin":return[r.sin(A("x",e,t,n))];case"Sign":return[r.sign(A("x",e,t,n))];case"Sinh":return[r.sinh(A("x",e,t,n))];case"Softplus":return[r.softplus(A("x",e,t,n))];case"Sqrt":return[r.sqrt(A("x",e,t,n))];case"Square":return[r.square(A("x",e,t,n))];case"Tanh":return[r.tanh(A("x",e,t,n))];case"Tan":return[r.tan(A("x",e,t,n))];case"ClipByValue":return[r.clipByValue(A("x",e,t,n),A("clipValueMin",e,t,n),A("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(A("x",e,t,n))];case"Rsqrt":return[r.rsqrt(gs(e.inputNames[0],t,n))];case"Prod":return[r.prod(A("x",e,t,n),A("axes",e,t,n))];case"LeakyRelu":return[r.leakyRelu(A("x",e,t,n),A("alpha",e,t,n))];case"Prelu":return[r.prelu(A("x",e,t,n),A("alpha",e,t,n))];case"IsNan":return[r.isNaN(gs(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(gs(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(gs(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Yi(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){_.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let s=e[r],a=t[r];_.assert(s<0||a<0||s===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function XV(e){return!(typeof e=="number"||e.some(t=>t<0))}function nx(e,t,n){let r=LA(e,n),s=!XV(r);if(s&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(a=>{r=LA(a.shape,r)}),!XV(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function LA(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}var HCe=class{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=mt(0),Or(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Yi(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Or(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Js([],[0].concat(this.elementShape));let n=this.readMany(e);return Yi(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),zr(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Js([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return Yi(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),In(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,fr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,a=[];ue(()=>{t=oe(t,[1,n,s]);for(let o=0;o<e.length;++o){let l=[0,o===0?0:r[o-1],0],u=[1,e[o],s];a[o]=oe(Vt(t,l,u),this.elementShape)}return a});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,a)}},Cg=class{get id(){return this.idTensor.id}constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e!=null&&e.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Yi(t,s.shape,"TensorList shape mismatch: "),Or(s)}),this.idTensor=mt(0),this.maxNumElements=r,Or(this.idTensor)}copy(){return new Cg([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Yi(e,this.elementShape,"TensorList shape mismatch: ");let r=nx(this.elementShape,this.tensors,e);return ue(()=>{let s=this.tensors.map(a=>oe(a,r));return zr(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=nx(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,Yi(r.shape,e,"TensorList shape mismatch: "),oe(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Yi(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Or(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new Cg([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Yi(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=nx(this.elementShape,this.tensors,t);return oe(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Yi(this.elementShape,t.shape,"TensorList shape mismatch: "),Or(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Yi(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=nx(this.elementShape,this.tensors,n);return e.length===0?Js([],[0].concat(r)):ue(()=>{let s=e.map(a=>oe(this.tensors[a],r));return zr(s,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Yi(this.elementShape,t,"TensorList shape mismatch: ");let n=nx(this.elementShape,this.tensors,t);return this.size()===0?Js([],[0].concat(n)):ue(()=>{let r=this.tensors.map(s=>oe(s,n));return In(r,0)})}};function jCe(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let s=e.shape.slice(1);Yi(s,t,"TensorList shape mismatch: ");let a=fr(e);return new Cg(a,t,r)}function qCe(e,t,n,r){return new Cg([],e,t,r)}function KCe(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let s=Math.max(...t);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);let a=new Cg([],n,e.dtype,r),i=fr(e,0);return t.forEach((o,l)=>{a.setItem(o,i[l])}),a}function XCe(e,t,n){let r=0,s=t.map(c=>(r+=c,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let a=e.shape.slice(1),i=LA(a,n),o=r===0?0:e.size/r,l=ue(()=>{let c=[];e=oe(e,[1,r,o]);for(let d=0;d<t.length;++d){let h=[0,d===0?0:s[d-1],0],p=[1,t[d],o];c[d]=oe(Vt(e,h,p),i)}return e.dispose(),c}),u=new Cg([],n,e.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}var YCe=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=A("thenBranch",e,t,n),s=A("elseBranch",e,t,n),a=A("cond",e,t,n),i=A("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=A("body",e,t,n),s=A("cond",e,t,n),a=A("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map(c=>c.id),l=await i[0].data();i.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let u=a;for(;l[0];){let c=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let d=u.map(p=>p.id);c.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()});let h=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await h[0].data(),h.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()})}return u}case"LoopCond":{let r=A("pred",e,t,n);return[mu(r)]}case"Switch":{let r=A("pred",e,t,n),s=A("data",e,t,n);return s.kept||(s=mu(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{let r=e.inputNames.find(s=>gs(s,t,n)!==void 0);if(r){let s=gs(r,t,n);return[mu(s)]}return}case"Enter":{let r=A("frameName",e,t,n),s=A("tensor",e,t,n);return n.enterFrame(r),[mu(s)]}case"Exit":{let r=A("tensor",e,t,n);return n.exitFrame(),[mu(r)]}case"NextIteration":{let r=A("tensor",e,t,n);return n.nextIteration(),[mu(r)]}case"TensorArrayV3":{let r=A("size",e,t,n),s=A("dtype",e,t,n),a=A("elementShape",e,t,n),i=A("dynamicSize",e,t,n),o=A("clearAfterRead",e,t,n),l=A("identicalElementShapes",e,t,n),u=A("name",e,t,n),c=new HCe(u,s,r,a,l,i,o);return n.addTensorArray(c),[c.idTensor,mt(1)]}case"TensorArrayWriteV3":{let r=A("tensorArrayId",e,t,n),s=A("index",e,t,n),a=A("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{let r=A("tensorArrayId",e,t,n),s=A("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{let r=A("tensorArrayId",e,t,n),s=A("indices",e,t,n),a=A("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{let r=A("tensorArrayId",e,t,n),s=A("indices",e,t,n),a=A("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{let r=A("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=A("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{let r=A("tensorArrayId",e,t,n),s=A("tensor",e,t,n),a=A("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{let r=A("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return[mt(s.size(),"int32")]}case"TensorArrayCloseV3":{let r=A("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{let r=A("tensorListId",e,t,n),s=A("index",e,t,n),a=A("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{let r=A("tensorListId",e,t,n),s=A("index",e,t,n),a=A("elementShape",e,t,n),i=A("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=A("indices",e,t,n),s=A("tensor",e,t,n),a=A("elementShape",e,t,n),i=A("numElements",e,t,n),o=KCe(s,r,a,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=A("elementShape",e,t,n),s=A("elementDType",e,t,n),a;e.op==="TensorListReserve"?a="numElements":a="maxNumElements";let i=A(a,e,t,n),o=e.op==="TensorListReserve"?-1:i,l=qCe(r,s,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=A("tensorListId",e,t,n),s=A("indices",e,t,n),a=A("elementShape",e,t,n),i=A("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{let r=A("tensorListId",e,t,n),s=A("elementShape",e,t,n),a=A("elementDType",e,t,n),i=A("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{let r=A("tensor",e,t,n),s=A("elementShape",e,t,n),a=A("elementDType",e,t,n),i=jCe(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=A("tensorListId",e,t,n),s=n.getTensorList(r.id),a=A("dtype",e,t,n),i=A("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{let r=A("tensorListId",e,t,n),s=A("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{let r=A("tensorListId",e,t,n),s=A("elementShape",e,t,n),a=A("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{let r=A("tensor",e,t,n),s=A("elementShape",e,t,n),a=A("lengths",e,t,n),i=XCe(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=A("tensorListId",e,t,n),s=n.getTensorList(r.id);return[mt(s.size(),"int32")]}case"TensorListResize":{let r=A("tensorListId",e,t,n),s=A("size",e,t,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function YV(e,t,n){let[r,s]=A("fusedOps",e,t,n),a=r==="biasadd",i=!a,o=s==="prelu",l=r==="fusedbatchnorm",u=A("numArgs",e,t,n);if(a){if(o&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=A("strides",e,t,n),d=lI(e,t,n),h=A("dataFormat",e,t,n).toUpperCase(),p=A("dilations",e,t,n),[f,m]=A("args",e,t,n);i&&(m=f,f=void 0);let g=A("leakyreluAlpha",e,t,n);return{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:g}}var ZCe=(e,t,n,r=os)=>{switch(e.op){case"Conv1D":{let s=A("stride",e,t,n),a=A("pad",e,t,n),i=A("dataFormat",e,t,n).toUpperCase(),o=A("dilation",e,t,n);return[r.conv1d(A("x",e,t,n),A("filter",e,t,n),s,a,i,o)]}case"Conv2D":{let s=A("strides",e,t,n),a=lI(e,t,n),i=A("dataFormat",e,t,n).toUpperCase(),o=A("dilations",e,t,n);return[r.conv2d(A("x",e,t,n),A("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=YV(e,t,n);return[r.fused.conv2d({x:A("x",e,t,n),filter:A("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{let{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=YV(e,t,n);return[r.fused.depthwiseConv2d({x:A("x",e,t,n),filter:A("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let s=A("outputShape",e,t,n),a=A("strides",e,t,n),i=lI(e,t,n);return[r.conv2dTranspose(A("x",e,t,n),A("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let s=A("strides",e,t,n),a=lI(e,t,n),i=A("dilations",e,t,n),o=A("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(A("input",e,t,n),A("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{let s=A("strides",e,t,n),a=A("pad",e,t,n),i=A("dataFormat",e,t,n).toUpperCase(),o=A("dilations",e,t,n);return[r.conv3d(A("x",e,t,n),A("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{let s=A("strides",e,t,n),a=A("pad",e,t,n),i=A("kernelSize",e,t,n);return[r.avgPool(A("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{let s=A("strides",e,t,n),a=A("pad",e,t,n),i=A("kernelSize",e,t,n);return[r.maxPool(A("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{let s=A("strides",e,t,n),a=A("pad",e,t,n),i=A("kernelSize",e,t,n),o=A("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(A("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[l,u]}case"AvgPool3D":{let s=A("strides",e,t,n),a=A("pad",e,t,n),i=A("kernelSize",e,t,n);return[r.avgPool3d(A("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{let s=A("strides",e,t,n),a=A("pad",e,t,n),i=A("kernelSize",e,t,n);return[r.maxPool3d(A("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{let s=A("strides",e,t,n),a=A("pad",e,t,n),i=A("dilations",e,t,n),o=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(A("x",e,t,n),A("filter",e,t,n),[o,l],a,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},JCe=(e,t,n,r=os)=>{switch(e.op){case"Fill":{let s=A("shape",e,t,n),a=A("dtype",e,t,n),i=A("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{let s=A("start",e,t,n),a=A("stop",e,t,n),i=A("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{let s=A("logits",e,t,n),a=A("numSamples",e,t,n),i=A("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{let s=A("indices",e,t,n),a=A("depth",e,t,n),i=A("onValue",e,t,n),o=A("offValue",e,t,n),l=A("dtype",e,t,n);return[r.oneHot(s,a,i,o,l)]}case"Ones":return[r.ones(A("shape",e,t,n),A("dtype",e,t,n))];case"OnesLike":return[r.onesLike(A("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(A("shape",e,t,n),A("dtype",e,t,n),A("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(A("shape",e,t,n),A("minval",e,t,n),A("maxval",e,t,n),A("dtype",e,t,n))];case"Range":{let s=A("start",e,t,n),a=A("stop",e,t,n),i=A("step",e,t,n);return[r.range(s,a,i,A("dtype",e,t,n))]}case"TruncatedNormal":{let s=A("shape",e,t,n),a=A("mean",e,t,n),i=A("stdDev",e,t,n),o=A("seed",e,t,n);return[r.truncatedNormal(s,a,i,A("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(A("shape",e,t,n),A("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(A("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function f_(e,t,n){let r=A("boxes",e,t,n),s=A("scores",e,t,n),a=A("maxOutputSize",e,t,n),i=A("iouThreshold",e,t,n),o=A("scoreThreshold",e,t,n),l=A("softNmsSigma",e,t,n);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var QCe=async(e,t,n,r,s=os)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=f_(e,t,n),d=await s.image.nonMaxSuppressionWithScoreAsync(a,i,o,l,u,c);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=f_(e,t,n),c=A("padToMaxOutputSize",e,t,n),d=await s.image.nonMaxSuppressionPaddedAsync(a,i,o,l,u,c);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=f_(e,t,n);return[await s.image.nonMaxSuppressionAsync(a,i,o,l,u)]}case"Where":{let a=s.cast(A("condition",e,t,n),"bool"),i=[await s.whereAsync(a)];return a.dispose(),i}case"ListDiff":return s.setdiff1dAsync(A("x",e,t,n),A("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},eNe=(e,t,n,r=os)=>{switch(e.op){case"LowerBound":{let s=A("sortedSequence",e,t,n),a=A("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{let s=A("x",e,t,n),a=A("k",e,t,n),i=A("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{let s=A("sortedSequence",e,t,n),a=A("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{let s=A("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{let s=A("x",e,t,n),a=A("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},tNe=(e,t,n,r=os)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let s=A("default",e,t,n);return[gs(e.name,t,n)||s];case"Placeholder":return[gs(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=A("x",e,t,n);return[mu(c)]}case"IdentityN":return A("x",e,t,n).map(c=>mu(c));case"Snapshot":let a=A("x",e,t,n);return[mu(a)];case"Shape":return[r.tensor1d(A("x",e,t,n).shape,"int32")];case"ShapeN":return A("x",e,t,n).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(A("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(A("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=A("x",e,t,n),o=A("data",e,t,n),l=A("message",e,t,n),u=A("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},nNe=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=mt(0),this.tensorMap=new Map,Or(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return mt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),ue(()=>{let r=fr(t),s=n.length,a=r.length;_.assert(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let i=0;i<s;i++){let o=n[i],l=r[i];Or(l),this.tensorMap.set(o,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return ue(()=>{let r=[];for(let s=0;s<n.length;s++){let a=n[s],i=this.findWithDefault(a,t);r.push(i)}return zr(r)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},rNe=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let s=r.getHashTableHandleByName(e.name);if(s!=null)return[s];{let a=A("keyDType",e,t,n),i=A("valueDType",e,t,n),o=new nNe(a,i);return r.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let s=A("tableHandle",e,t,n,r),a=A("keys",e,t,n),i=A("values",e,t,n);return[await r.getHashTableById(s.id).import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{let s=A("tableHandle",e,t,n,r),a=A("keys",e,t,n),i=A("defaultValue",e,t,n);return[await r.getHashTableById(s.id).find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let s=A("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},sNe=(e,t,n,r=os)=>{switch(e.op){case"ResizeBilinear":{let s=A("images",e,t,n),a=A("size",e,t,n),i=A("alignCorners",e,t,n),o=A("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{let s=A("images",e,t,n),a=A("size",e,t,n),i=A("alignCorners",e,t,n),o=A("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{let s=A("image",e,t,n),a=A("boxes",e,t,n),i=A("boxInd",e,t,n),o=A("cropSize",e,t,n),l=A("method",e,t,n),u=A("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,l,u)]}case"ImageProjectiveTransformV3":{let s=A("images",e,t,n),a=A("transforms",e,t,n),i=A("outputShape",e,t,n),o=A("fillValue",e,t,n),l=A("interpolation",e,t,n),u=A("fillMode",e,t,n);return[r.image.transform(s,a,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},aNe=(e,t,n,r=os)=>{switch(e.op){case"Equal":return[r.equal(A("a",e,t,n),A("b",e,t,n))];case"NotEqual":return[r.notEqual(A("a",e,t,n),A("b",e,t,n))];case"Greater":return[r.greater(A("a",e,t,n),A("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(A("a",e,t,n),A("b",e,t,n))];case"Less":return[r.less(A("a",e,t,n),A("b",e,t,n))];case"LessEqual":return[r.lessEqual(A("a",e,t,n),A("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(A("a",e,t,n),A("b",e,t,n))];case"LogicalNot":return[r.logicalNot(A("a",e,t,n))];case"LogicalOr":return[r.logicalOr(A("a",e,t,n),A("b",e,t,n))];case"Select":case"SelectV2":return[r.where(A("condition",e,t,n),A("a",e,t,n),A("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},iNe=(e,t,n,r=os)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(A("a",e,t,n),A("b",e,t,n),A("transposeA",e,t,n),A("transposeB",e,t,n))];case"Einsum":return[r.einsum(A("equation",e,t,n),...A("tensors",e,t,n))];case"Transpose":return[r.transpose(A("x",e,t,n),A("perm",e,t,n))];case"_FusedMatMul":let[s,a]=A("fusedOps",e,t,n),i=s==="biasadd",o=a==="prelu",l=A("numArgs",e,t,n),u=A("leakyreluAlpha",e,t,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,d]=A("args",e,t,n);return[r.fused.matMul({a:A("a",e,t,n),b:A("b",e,t,n),transposeA:A("transposeA",e,t,n),transposeB:A("transposeB",e,t,n),bias:c,activation:a,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(A("a",e,t,n),A("numLower",e,t,n),A("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},oNe=(e,t,n,r=os)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(A("x",e,t,n),A("axis",e,t,n),A("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(A("x",e,t,n),A("mean",e,t,n),A("variance",e,t,n),A("offset",e,t,n),A("scale",e,t,n),A("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(A("x",e,t,n),A("mean",e,t,n),A("variance",e,t,n),A("offset",e,t,n),A("scale",e,t,n),A("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(A("x",e,t,n),A("radius",e,t,n),A("bias",e,t,n),A("alpha",e,t,n),A("beta",e,t,n))];case"Softmax":return[r.softmax(A("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(A("x",e,t,n))];case"SparseToDense":return[r.sparseToDense(A("sparseIndices",e,t,n),A("outputShape",e,t,n),A("sparseValues",e,t,n),A("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},lNe=(e,t,n,r=os)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(A("paramsNestedSplits",e,t,n),A("paramsDenseValues",e,t,n),A("indices",e,t,n),A("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{let{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(A("starts",e,t,n),A("limits",e,t,n),A("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(A("shape",e,t,n),A("values",e,t,n),A("defaultValue",e,t,n),A("rowPartitionTensors",e,t,n),A("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},uNe=(e,t,n,r=os)=>{switch(e.op){case"Max":{let o=A("axis",e,t,n),l=A("keepDims",e,t,n);return[r.max(A("x",e,t,n),o,l)]}case"Mean":{let o=A("axis",e,t,n),l=A("keepDims",e,t,n);return[r.mean(A("x",e,t,n),o,l)]}case"Min":{let o=A("axis",e,t,n),l=A("keepDims",e,t,n);return[r.min(A("x",e,t,n),o,l)]}case"Sum":{let o=A("axis",e,t,n),l=A("keepDims",e,t,n);return[r.sum(A("x",e,t,n),o,l)]}case"All":{let o=A("axis",e,t,n),l=A("keepDims",e,t,n);return[r.all(A("x",e,t,n),o,l)]}case"Any":{let o=A("axis",e,t,n),l=A("keepDims",e,t,n);return[r.any(A("x",e,t,n),o,l)]}case"ArgMax":{let o=A("axis",e,t,n);return[r.argMax(A("x",e,t,n),o)]}case"ArgMin":{let o=A("axis",e,t,n);return[r.argMin(A("x",e,t,n),o)]}case"Prod":{let o=A("axis",e,t,n),l=A("keepDims",e,t,n);return[r.prod(A("x",e,t,n),o,l)]}case"Cumprod":{let o=A("axis",e,t,n),l=A("exclusive",e,t,n),u=A("reverse",e,t,n);return[r.cumprod(A("x",e,t,n),o,l,u)]}case"Cumsum":{let o=A("axis",e,t,n),l=A("exclusive",e,t,n),u=A("reverse",e,t,n);return[r.cumsum(A("x",e,t,n),o,l,u)]}case"Bincount":let s=A("x",e,t,n),a=A("weights",e,t,n),i=A("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{let o=A("x",e,t,n),l=A("weights",e,t,n),u=A("size",e,t,n),c=A("binaryOutput",e,t,n);return[r.denseBincount(o,l,u,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},cNe=(e,t,n,r=os)=>{switch(e.op){case"ConcatV2":case"Concat":{let s=A("n",e,t,n),a=A("axis",e,t,n),i=A("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{let s=A("x",e,t,n),a=A("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{let s=A("axis",e,t,n),a=A("batchDims",e,t,n),i=A("x",e,t,n),o=A("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{let s=A("dims",e,t,n),a=[];for(let o=0;o<s.length;o++)s[o]&&a.push(o);let i=A("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{let s=A("axis",e,t,n),a=A("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{let s=A("begin",e,t,n),a=A("size",e,t,n);return[r.slice(A("x",e,t,n),s,a)]}case"StridedSlice":{let s=A("begin",e,t,n),a=A("end",e,t,n),i=A("strides",e,t,n),o=A("beginMask",e,t,n),l=A("endMask",e,t,n),u=A("ellipsisMask",e,t,n),c=A("newAxisMask",e,t,n),d=A("shrinkAxisMask",e,t,n),h=A("x",e,t,n);return[r.stridedSlice(h,s,a,i,o,l,u,c,d)]}case"Pack":return ue(()=>{let s=A("axis",e,t,n),a=A("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,l=a.map(u=>{let c=_.arraysEqual(u.shape,i);if(!c&&!_.arraysEqual(r.squeeze(u).shape,o))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,i)});return[r.stack(l,s)]});case"Unpack":{let s=A("axis",e,t,n),a=A("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{let s=A("reps",e,t,n);return[r.tile(A("x",e,t,n),s)]}case"Split":case"SplitV":{let s=A("axis",e,t,n),a=A("numOrSizeSplits",e,t,n),i=A("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{let s=A("indices",e,t,n),a=A("values",e,t,n),i=A("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{let s=A("x",e,t,n),a=A("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{let s=A("sparseIndices",e,t,n),a=A("outputShape",e,t,n),i=A("sparseValues",e,t,n),o=A("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let s=A("indices",e,t,n),a=A("values",e,t,n),i=A("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},dNe=(e,t,n,r=os)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(A("indices",e,t,n),A("values",e,t,n),A("denseShape",e,t,n),A("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{let{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(A("inputIndices",e,t,n),A("inputShape",e,t,n),A("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(A("data",e,t,n),A("indices",e,t,n),A("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(A("data",e,t,n),A("indices",e,t,n),A("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},hNe=(e,t,n,r=os)=>{switch(e.op){case"FFT":return[r.fft(A("x",e,t,n))];case"IFFT":return[r.ifft(A("x",e,t,n))];case"RFFT":return[r.rfft(A("x",e,t,n))];case"IRFFT":return[r.irfft(A("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},pNe=(e,t,n,r=os)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(A("input",e,t,n),A("pattern",e,t,n),A("rewrite",e,t,n),A("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(A("data",e,t,n),A("dataSplits",e,t,n),A("separator",e,t,n),A("nGramWidths",e,t,n),A("leftPad",e,t,n),A("rightPad",e,t,n),A("padWidth",e,t,n),A("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{let{indices:s,values:a,shape:i}=r.string.stringSplit(A("input",e,t,n),A("delimiter",e,t,n),A("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(A("input",e,t,n),A("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},fNe=(e,t,n,r=os)=>{switch(e.op){case"Cast":return[r.cast(A("x",e,t,n),A("dtype",e,t,n))];case"ExpandDims":{let s=A("axis",e,t,n);return[r.expandDims(A("x",e,t,n),s)]}case"Squeeze":{let s=A("axis",e,t,n);return[r.squeeze(A("x",e,t,n),s)]}case"Reshape":return[r.reshape(A("x",e,t,n),A("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(A("x",e,t,n),A("padding",e,t,n),A("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(A("x",e,t,n),A("padding",e,t,n),A("constantValue",e,t,n))];case"SpaceToBatchND":{let s=A("blockShape",e,t,n),a=A("paddings",e,t,n);return[r.spaceToBatchND(A("x",e,t,n),s,a)]}case"BatchToSpaceND":{let s=A("blockShape",e,t,n),a=A("crops",e,t,n);return[r.batchToSpaceND(A("x",e,t,n),s,a)]}case"DepthToSpace":{let s=A("blockSize",e,t,n),a=A("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(A("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(A("x",e,t,n),A("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(A("s0",e,t,n),A("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function ZV(e,t,n,r,s=ue){let a=((i,o,l)=>{switch(i.category){case"arithmetic":return s(()=>UCe(i,o,l));case"basic_math":return s(()=>GCe(i,o,l));case"control":return YCe(i,o,l);case"convolution":return s(()=>ZCe(i,o,l));case"creation":return s(()=>JCe(i,o,l));case"dynamic":return QCe(i,o,l);case"evaluation":return s(()=>eNe(i,o,l));case"image":return s(()=>sNe(i,o,l));case"graph":return s(()=>tNe(i,o,l));case"logical":return s(()=>aNe(i,o,l));case"matrices":return s(()=>iNe(i,o,l));case"normalization":return s(()=>oNe(i,o,l));case"ragged":return s(()=>lNe(i,o,l));case"reduction":return s(()=>uNe(i,o,l));case"slice_join":return s(()=>cNe(i,o,l));case"sparse":return s(()=>dNe(i,o,l));case"spectral":return s(()=>hNe(i,o,l));case"string":return s(()=>pNe(i,o,l));case"transformation":return s(()=>fNe(i,o,l));case"hash_table":return rNe(i,o,l,r);case"custom":let u=SX(i.op);if(u&&u.customExecutor)return u.customExecutor(new VCe(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return _.isPromise(a)?a.then(i=>[].concat(i)):[].concat(a)}var JV=class{constructor(e={},t={},n={},r={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function QV(e,t,n,r){let s=new Set,a=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map(h=>Pa(h)[0]));r=r||[];let c=new Set(r.map(h=>Pa(h.name)[0])),d=[...t];for(;d.length>0;){let h=d.pop();if((Fm(h)||kNe(h)||INe(h))&&i==null&&(i=h,o=i.children.map(p=>p.name).filter(p=>s.has(p))),s.add(h.name),n[h.name]==null&&!u.has(h.name)&&!c.has(h.name)){if(h.inputs.length===0){a.push(h.name);continue}h.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),d.push(p))})}}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}function mNe(e,t){let{usedNodes:n,inputs:r}=t,s=Object.keys(r).map(g=>Pa(g)[0]).map(g=>e.nodes[g]),a=e.initNodes||[],i=g=>n.has(typeof g=="string"?g:g.name);function o(g){return[...new Map(g.map(y=>[y.name,y])).values()]}let l=o([...s,...e.weights,...a]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map(g=>[g.name,g])),d={};for(let g of u){d[g.name]=d[g.name]||0;for(let y of g.children)i(y)||(d[y.name]=Number.POSITIVE_INFINITY),d[y.name]=(d[y.name]||0)+1}let h=Object.entries(d).filter(([,g])=>g===0).map(([g])=>g),p=[...h];for(;h.length>0;){let g=h.pop(),y=c.get(g);for(let b of y.children.filter(i))--d[b.name]===0&&(p.push(b.name),h.push(b.name))}let f=p.map(g=>c.get(g)),m=gNe(f,l);return yNe(m,l),m}function gNe(e,t){let n=new Map(e.map(a=>[a.name,a])),r=t.map(a=>a.name),s=new Set(r);for(;r.length>0;){let a=r.pop(),i=n.get(a);for(let o of i.children)!n.has(o.name)||s.has(o.name)||(s.add(o.name),r.push(o.name))}return e.filter(a=>s.has(a.name))}var uk=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function yNe(e,t){let n=new Map(e.map((o,l)=>[o.name,l])),r=new Set(t.map(o=>o.name)),s=o=>r.has(typeof o=="string"?o:o.name),a=new Set(e.map(o=>o.name)),i=o=>a.has(typeof o=="string"?o:o.name);for(let o of e){for(let l of o.children.filter(i)){if(!n.has(l.name))throw new uk(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new uk(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!s(o))for(let l of o.inputs){if(!n.has(l.name))throw new uk(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new uk(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function bNe(e){let t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,r=e.map((o,l)=>Fm(o)?n:l),s=o=>{let l=r[t.get(o.name)];return l??-1},a=e.map((o,l)=>o.children.map(s).reduce((u,c)=>Math.max(u,c),r[l])),i=new Map;for(let o=0;o<e.length;++o){let l=a[o];if(l===n)continue;let u=e[o],c=e[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u.name)}return i}var xNe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),wNe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),vNe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Fm(e){return xNe.has(e.op)}function kNe(e){return wNe.has(e.op)}function INe(e){return vNe.has(e.op)}var PA=class{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(n=>e[n].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new PA(e.functions[n],this)})}getCompilationKey(e,t){let n=e.map(s=>s.name).sort(),r=t.map(s=>s.name).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){let n=QV(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){let l=t.map(c=>c.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${u}]. Missing the following inputs: [${r}]`)}let i=mNe(this.graph,n),o=bNe(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(e==null)return null;let t=e.clone();return Or(t),t}cloneTensorList(e){return e?e.map(t=>this.cloneAndKeepTensor(t)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,n])=>[t,this.cloneTensorList(n)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map(d=>this.graph.nodes[Pa(d)[0]]),s=t.map(d=>Pa(d)[0]),a=new Set(s),i=s.map(d=>this.graph.nodes[d]);i.length===0&&(i=this._outputs);let o=this.getCompilationKey(r,i),l=this.compiledMap.get(o);l==null&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=me().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let u={},c={};return ue(()=>{let d=new JV(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),h=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(g=>{let[y,b]=Pa(g,d),x=[];x[b]=e[g],h[y]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(x))});let p=this.getFrozenTensorIds(h),{orderedNodes:f,nodeLiveUntilMap:m}=l;for(let g of f){if(h[g.name])continue;let y=ZV(g,h,d,this._resourceManager);if(_.isPromise(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);h[g.name]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[g.name]=this.cloneTensorList(y)),this.checkTensorForDisposalWithNodeLiveUntilInfo(g,h,d,p,a,m.get(g.name))}return this.parent==null&&d.dispose(p),t.map(g=>gs(g,h,d))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,i){if(!(Fm(t)||a.has(e))){for(let o of n[e])o!=null&&(i[o.id]=(i[o.id]||0)+t.children.length);for(let o of t.inputs){if(Fm(o))continue;let l=jV(o.name,n,r);if(l!=null)for(let u of l){if(!u||u.kept||s.has(u.id))continue;let c=i[u.id];c===1?(u.dispose(),delete i[u.id]):c!=null&&i[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,s,a){if(!(Fm(e)||s.has(e.name))&&a!=null)for(let i of a){let o=jV(i,t,n);for(let l of o)!l||l.kept||r.has(l.id)||l.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},s={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=me().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let a=new JV(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let i=await this.executeWithControlFlow(e,a,t,n),o=t.map(d=>gs(d,i,a)),l=o.map(d=>d.id),u=Object.keys(e).map(d=>e[d].id),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach(d=>{d.forEach(h=>{h&&!h.isDisposed&&!c.has(h.id)&&h.dispose()})}),this.parent==null&&a.dispose(c),o}async executeFunctionAsync(e,t,n){let r=e.reduce((s,a,i)=>(s[this.inputs[i].name]=a,s),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let s=Object.keys(e),a=s.map(x=>this.graph.nodes[Pa(x)[0]]),i=n.map(x=>Pa(x)[0]),o=new Set(i),l=i.map(x=>this.graph.nodes[x]);l.length===0&&(l=this._outputs);let{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:h}=QV(e,l,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map(x=>({node:x,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(x=>{let[w,v]=Pa(x),k=[];k[v]=e[x],f[w]=k});let m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){let x=this.processStack(a,p,t,f,y,g,o,m,u);await Promise.all(x)}d==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=l.filter(x=>!Fm(x)&&!gs(x.name,f,t)).map(x=>x.name);if(b.length>0){let x="";throw d!=null&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${x}`)}return f}processStack(e,t,n,r,s,a,i,o,l){let u=[];for(;t.length>0;){let c=t.pop();n.currentContext=c.contexts;let d="";if(c.node.op==="Enter"&&A("isConstant",c.node,r,n)&&([d]=fu(c.node.name,n)),r[c.node.name]==null){let h=ZV(c.node,r,n,this._resourceManager);d||([d]=fu(c.node.name,n));let p=n.currentContext;_.isPromise(h)?u.push(h.then(f=>(r[d]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(f)),n.currentContext=p,this.checkTensorForDisposal(d,c.node,r,n,a,i,o),this.processChildNodes(c.node,t,n,r,s,l),f))):(r[d]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(h)),this.checkTensorForDisposal(d,c.node,r,n,a,i,o),this.processChildNodes(c.node,t,n,r,s,l))}else this.processChildNodes(c.node,t,n,r,s,l)}return u}processChildNodes(e,t,n,r,s,a){e.children.forEach(i=>{let[o]=fu(i.name,n);s[o]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!gs(l,r,n))&&(s[o]=!0,t.push({contexts:n.currentContext,node:i})):i.inputNames.every(l=>!!gs(l,r,n))&&(s[o]=!0,t.push({contexts:n.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[r]=Pa(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){let a=s.attrParams.shape.value,i=a.length===n.shape.length&&n.shape.every((o,l)=>a[l]===-1||a[l]===o);_.assert(i,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&_.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){var t,n;let r={};for(let s in e){let a=(n=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||n===void 0?void 0:n[s];a!=null?r[a.name]=e[s]:r[s]=e[s]}return r}checkInputs(e){let t=Object.keys(e).filter(n=>{let[r]=Pa(n);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var n,r;let s=(r=(n=this._signature)===null||n===void 0?void 0:n.outputs)===null||r===void 0?void 0:r[t];return s!=null?s.name:t},{})}checkOutputs(e){e.forEach(t=>{let[n]=Pa(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}},SNe=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},CNe="?tfjs-format=file",NNe="model.json",O3=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=ws){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new SNe}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return _.isPromise(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(n=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new PA(qV.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=qV.Instance.transformGraph(e.modelInitializer);this.initializer=new PA(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Tt?[e]:e,n={};return t.forEach((r,s)=>n[this.structuredOutputKeys[s]]=r),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Tt)&&!Array.isArray(e)){let s=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(s!=null)for(let a in s){let i=s[a];i.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((s,a)=>{var i,o,l;let u=(l=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[a])===null||l===void 0?void 0:l.resourceId;return u!=null?s[a]=this.resourceIdToCapturedInput[u]:s[a]=e[r++],s},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let s=n[r],a=t[s];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&St(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function $Ne(e,t={},n=ws){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=_Ne(e));let r=new O3(e,t,n);return await r.load(),r}function TNe(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[r,s]=e;if(!r)throw new Error("modelJSON must be the first element of the array");if(!s||!(s instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let a=ws.getWeightSpecs(r.weightsManifest),i=ws.getModelArtifactsForJSONSync(r,a,s);t=ws.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=ws.fromMemorySync(e);else throw new Error("Unknown model format");let n=new O3(t);return n.load(),n}function _Ne(e){return e.endsWith("/")||(e=e+"/"),`${e}${NNe}${CNe}`}var ENe="4.3.0",jX={};Ct(jX,{CSVDataset:()=>t7,Dataset:()=>fb,FileDataSource:()=>l7,TextLineDataset:()=>e7,URLDataSource:()=>u7,array:()=>QNe,csv:()=>c2e,func:()=>d2e,generator:()=>h2e,microphone:()=>f2e,version_data:()=>m2e,webcam:()=>p2e,zip:()=>e2e});var ANe=fd(HC()),RNe=fd(HC());function DNe(e,t){return fS(e,t)}function fS(e,t,n=new Map,r=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(Ng(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let i in e){let o=e[i],l=fS(o,t,n,r);a[i]=l}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,s.value),s.value}function FNe(e,t=KX){return qX(e,t)}function qX(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(Ng(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let o=e.map(u=>u[i]),l=qX(o,t,n);a[i]=l}return n.delete(r),a}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function KX(e){return e===null?null:Ng(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function XX(e,t){let n=new Map;fS(e,t,n);for(let r of Array.from(n.keys())){let s=n.get(r);if(_.isPromise(s)){let a=await s;n.set(r,a)}}return fS(e,t,n)}function Ng(e){let t=!1;if(me().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=z6();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Tt)&&!(e instanceof Promise)&&!t)}function ONe(e){return e==null||MNe(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Tt||_.isTypedArray(e)}function MNe(e){return e===null||typeof e!="object"&&typeof e!="function"}function LNe(e){return DNe(e,PNe)}function PNe(e){return e instanceof Tt?{value:e.clone(),recurse:!1}:Ng(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var YX=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},M3=class extends YX{constructor(){super(M3.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=this.capacity*2,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};M3.INITIAL_CAPACITY=32;function ZX(e){return new WNe(e)}function L3(e){return new VNe(e)}function zNe(e,t){return new JX(e,t)}function BNe(e,t=yc.FAIL){return new ZNe(e,t)}var is=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new XNe(this,e)}filter(e){return new qNe(this,e)}map(e){return new KNe(this,e)}mapAsync(e){return new eU(this,e)}serialMapAsync(e){return new eU(this,e).serial()}flatmap(e){return new YNe(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new jNe(this,e,t)}columnMajorBatch(e,t=!0,n=KX){return this.rowMajorBatch(e,t).map(r=>FNe(r,n))}concatenate(e,t){return new JX(ZX([this,e]),t)}take(e){return e<0||e==null?this:new HNe(this,e)}skip(e){return e<0||e==null?this:new GNe(this,e)}prefetch(e){return new QX(this,e)}shuffle(e,t){return new JNe(this,e,t)}serial(){return new UNe(this)}},WNe=class extends is{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:LNe(e),done:!1}}},VNe=class extends is{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},UNe=class extends is{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},GNe=class extends is{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;St(e.value)}return this.upstream.next()}},HNe=class extends is{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},jNe=class extends is{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},qNe=class extends is{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;St(e.value)}}},KNe=class extends is{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Go.getTensorsInContainer(e.value),n=this.transform(e.value),r=Go.getTensorsInContainer(n);for(let s of t)Go.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},XNe=class extends is{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},eU=class extends is{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Go.getTensorsInContainer(e.value),n=await this.transform(e.value),r=Go.getTensorsInContainer(n);for(let s of t)Go.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},P3=class extends is{constructor(){super(),this.outputQueue=new M3,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},YNe=class extends P3{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Go.getTensorsInContainer(e.value),n=this.transform(e.value),r=Go.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of t)Go.isTensorInList(s,r)||s.dispose();return!0}},JX=class extends is{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},yc;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(yc||(yc={}));var ZNe=class extends is{constructor(e,t=yc.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(a){return a instanceof is?{value:a.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let s=await XX(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case yc.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case yc.SHORTEST:return{value:null,done:!0};case yc.LONGEST:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},QX=class extends is{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new YX(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},JNe=class extends QX{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=RNe.alea(n||_.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},fb=class{constructor(){this.size=null}batch(e,t=!0){let n=this;_.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),La(async()=>(await n.iterator()).columnMajorBatch(e,t,t2e),r)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,La(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,La(async()=>(await t.iterator()).filter(r=>ue(()=>e(r))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return La(async()=>(await t.iterator()).map(n=>ue(()=>e(n))),this.size)}mapAsync(e){let t=this;return La(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return La(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,La(async()=>{let r=L3(async()=>({value:await t.iterator(),done:!1}));return zNe(r.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,La(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,s=ANe.alea(t||_.now().toString());return La(async()=>{let a=s.int32();return n&&(a+=s.int32()),(await r.iterator()).shuffle(e,a.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,La(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};fb.MAX_BUFFER_SIZE=1e4;function La(e,t=null){return new class extends fb{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function QNe(e){return La(async()=>ZX(e),e.length)}function e2e(e){if(!Ng(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return La(async()=>{let n=await XX(e,r=>{if(r instanceof fb)return{value:r.iterator(),recurse:!1};if(Ng(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return BNe(n,yc.SHORTEST)},t)}function t2e(e){if(e===null)return null;let t=e[0];return ONe(t)?{value:n2e(e),recurse:!1}:{value:null,recurse:!0}}function n2e(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Tt?zr(e):Js(e)}var e7=class extends fb{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},ck='"',rx=Symbol("out"),tU=Symbol("field"),dk=Symbol("quote"),m_=Symbol("quoteafterquote"),nU=Symbol("quoteinquote"),t7=class extends fb{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&_.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((r,s)=>(r[s]=r[s]+1||1,r),{}),n=Object.keys(t).filter(r=>t[r]>1);if(_.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new e7(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(_.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let s=0;s<this.fullColumnNames.length;s++){let a=this.fullColumnNames[s],i=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[s],l=null;if(o==="")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);l=void 0}else{let u=Number(o);if(isNaN(u))i&&i.dtype==="bool"?l=this.getBoolean(o):l=o;else if(!i||!i.dtype)l=u;else switch(i.dtype){case"float32":l=u;break;case"int32":l=Math.floor(u);break;case"bool":l=this.getBoolean(o);break;default:l=u}}i&&i.isLabel?r[a]=l:n[a]=l}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],r=0,s=e.length,a=rx;for(let i=0;i<s;i++)switch(a){case rx:switch(e.charAt(i)){case ck:r=i+1,a=dk;break;case this.delimiter:if(r=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),a=rx;break;default:a=tU,r=i;break}break;case tU:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),a=rx,r=i+1;break}break;case dk:switch(e.charAt(i)){case ck:a=m_;break}break;case m_:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),a=rx,r=i+1;break;case ck:a=dk;break;default:a=nU;break}break;case nU:switch(e.charAt(i)){case ck:a=dk;break}break}if(a===m_?n.push(e.substring(r,s-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},n7=class extends is{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!me().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let t=new n7(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise(r=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((r,s)=>n.set(r,s*t)),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(_.sizeFromShape(t));return n.set(e,n.length-e.length),Js(n,t)}},r7=class extends is{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=gn([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-n)/2,a=(1-r)/2,i=s+n,o=r+a;this.cropBox=Ol([a,s,o,i],[1,4])}else this.cropBox=Ol([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!me().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new r7(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&_.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Pw.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return ue(()=>{let t=ms(Me(e,"float32"),0),n;n=Po.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=n.shape;return oe(n,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},s7=class{},a7=class extends is{split(e){return new r2e(this,e)}},r2e=class extends a7{constructor(e,t){super(),this.upstream=e,this.impl=new s2e(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},s2e=class extends P3{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},a2e=class extends is{decodeUTF8(){return new i2e(this)}},i2e=class extends a7{constructor(e){super(),this.upstream=e,this.impl=new o2e(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},o2e=class extends P3{constructor(e){if(super(),this.upstream=e,me().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=z6();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return me().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},i7=class extends a2e{constructor(e,t={}){super(),this.file=e,this.options=t,_.assert(e instanceof Uint8Array||(me().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=a=>{let i=r.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},r.onabort=a=>t(new Error("Aborted")),r.onerror=a=>t(new Error(a.type));let s=this.file.slice(this.offset,n);r.readAsArrayBuffer(s)}this.offset=n}),done:!1}}};async function l2e(e,t={},n){let r,s;typeof e=="string"?r=e:(r=e.url,s=u2e(e));let a=await(n||_.fetch)(r,s);if(a.ok){let i=new Uint8Array(await a.arrayBuffer());return new i7(i,t)}else throw new Error(a.statusText)}var u2e=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function o7(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var l7=class extends s7{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(o7(this.input)&&me().get("IS_NODE")){let e=EF();this.input=e.readFileSync(this.input.slice(7))}return new i7(this.input,this.options)}},u7=class extends s7{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return o7(this.url)?new l7(this.url,this.fileOptions).iterator():l2e(this.url,this.fileOptions)}};function c2e(e,t={}){return new t7(new u7(e),t)}function d2e(e){let t=L3(e);return La(async()=>t)}function h2e(e){return La(async()=>{let t=await e();return L3(()=>t.next())})}async function p2e(e,t){return r7.create(e,t)}async function f2e(e){return n7.create(e)}var m2e="4.3.0";function lt(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&_.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var g2e=Yl.whereImpl,d2=class extends ew{nextDataId(){return d2.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new jC(this,Xi())}write(e,t,n){this.firstUse&&(this.firstUse=!1,me().get("IS_NODE")&&W.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&_.isString(n[0])){let s=n.map(a=>_.encodeString(a));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){let r=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return W.mergeRealAndImagArrays(r,s)}return _.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let n=t.map(r=>_.decodeString(r));return Ot(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ot(e.shape,e.dtype,t)}makeOutput(e,t,n){return Xi().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=_.now();return e(),{kernelMs:_.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){lt([e],"where");let t=this.readSync(e.dataId);return g2e(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};d2.nextDataId=0;var z3={};Ct(z3,{addImpl:()=>h7,bincountImpl:()=>W3,bincountReduceImpl:()=>p7,castImpl:()=>d7,ceilImpl:()=>f7,concatImpl:()=>V3,equalImpl:()=>m7,expImpl:()=>y7,expm1Impl:()=>x7,floorDivImpl:()=>v7,floorImpl:()=>w7,gatherNdImpl:()=>k7,gatherV2Impl:()=>I7,greaterEqualImpl:()=>C7,greaterImpl:()=>S7,lessEqualImpl:()=>$7,lessImpl:()=>N7,linSpaceImpl:()=>T7,logImpl:()=>_7,maxImpl:()=>E7,maximumImpl:()=>A7,minimumImpl:()=>R7,multiplyImpl:()=>U3,negImpl:()=>D7,notEqualImpl:()=>F7,prodImpl:()=>O7,raggedGatherImpl:()=>M7,raggedRangeImpl:()=>L7,raggedTensorToTensorImpl:()=>P7,rangeImpl:()=>H3,rsqrtImpl:()=>z7,scatterImpl:()=>bh,sigmoidImpl:()=>h$e,simpleAbsImpl:()=>c7,sliceImpl:()=>gS,sparseFillEmptyRowsImpl:()=>W7,sparseReshapeImpl:()=>V7,sparseSegmentReductionImpl:()=>j3,sqrtImpl:()=>m$e,squaredDifferenceImpl:()=>U7,staticRegexReplaceImpl:()=>G7,stridedSliceImpl:()=>H7,stringNGramsImpl:()=>q3,stringSplitImpl:()=>K3,stringToHashBucketFastImpl:()=>X3,subImpl:()=>j7,tileImpl:()=>q7,topKImpl:()=>X7,transposeImpl:()=>G3,uniqueImpl:()=>Z3});function c7(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var y2e=e=>{let{x:t}=e.inputs,n=e.backend;lt(t,"abs");let r=new Float32Array(_.sizeFromShape(t.shape)),s=n.data.get(t.dataId).values;return r=c7(s),n.makeOutput(r,t.shape,t.dtype)},b2e={kernelName:Qg,backendName:"cpu",kernelFunc:y2e};function Er(e){return(t,n,r,s,a)=>{let i=W.assertAndGetBroadcastShape(t,n),o=i.length,l=_.computeStrides(i),u=_.sizeFromShape(i),c=_.getTypedArrayFromDType(a,u),d=t.length,h=n.length,p=_.computeStrides(t),f=_.computeStrides(n),m=W.getBroadcastDims(t,i),g=W.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=e(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){let b=_.indexToLoc(y,o,l),x=b.slice(-d);m.forEach(I=>x[I]=0);let w=_.locToIndex(x,d,p),v=b.slice(-h);g.forEach(I=>v[I]=0);let k=_.locToIndex(v,h,f);c[y]=e(r[w],s[k])}return[c,i]}}function Wa(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}var x2e={kernelName:YC,backendName:"cpu",kernelFunc:Wa};function mS(e,t,n="float32"){if(n==="complex64"){let s=mS(e,t,"float32"),a=mS(e,t,"float32");return Wa({inputs:{real:s,imag:a},backend:e})}let r=_.makeZerosTypedArray(_.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function Hl(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var w2e={kernelName:Gp,backendName:"cpu",kernelFunc:Hl};function Yh(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}var v2e={kernelName:uN,backendName:"cpu",kernelFunc:Yh};function d7(e,t,n,r){if(r==="int32"){let s=Int32Array.from(e);return[t,"int32",s]}if(r==="bool"){let s=_.toTypedArray([0],n),[a,i]=Er((o,l)=>o!==l?1:0)(t,[],e,s,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Jc(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return Hl({inputs:{x:s},backend:n});let c=mS(n,s.shape,s.dtype),d=Jc({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),h=Wa({inputs:{real:d,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),h}if(s.dtype==="complex64"){let c=Yh({inputs:{input:s},backend:n}),d=Jc({inputs:{x:c},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(c),d}if(!_.hasEncodingLoss(s.dtype,a)){let c=Hl({inputs:{x:s},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:a}}let i=n.data.get(s.dataId).values,[o,l,u]=d7(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}var k2e={kernelName:Np,backendName:"cpu",kernelFunc:Jc};function ls(e,t,n,r){return n==null?({inputs:s,backend:a})=>{let{a:i,b:o}=s,l=a;lt([i,o],e);let u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d=i.dtype==="string"?W.fromUint8ToStringArray(u):u,h=i.dtype==="string"?W.fromUint8ToStringArray(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:({inputs:s,backend:a})=>{let{a:i,b:o}=s,l=a;if(i.dtype==="complex64"||o.dtype==="complex64"){let u=Jc({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),d=c.complexTensorInfos.real,h=c.complexTensorInfos.imag,p=l.data.get(d.dataId).values,f=l.data.get(h.dataId).values,m=Jc({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,x=l.data.get(y.dataId).values,w=l.data.get(b.dataId).values,[v,k,I]=n(i.shape,o.shape,p,f,x,w),S=l.makeTensorInfo(I,"float32",v),$=l.makeTensorInfo(I,"float32",k),N=Wa({inputs:{real:S,imag:$},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(S),l.disposeIntermediateTensorInfo($),N}else{let u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d=r||i.dtype,[h,p]=t(i.shape,o.shape,u,c,d);return l.makeTensorInfo(p,d,h)}}}function B3(e){return(t,n,r,s,a,i)=>{let o=W.assertAndGetBroadcastShape(t,n),l=_.sizeFromShape(o),u=o.length,c=_.computeStrides(o),d=_.getTypedArrayFromDType("float32",l),h=_.getTypedArrayFromDType("float32",l),p=W.getBroadcastDims(t,o),f=W.getBroadcastDims(n,o),m=W.mergeRealAndImagArrays(r,s),g=W.mergeRealAndImagArrays(a,i),y=t.length,b=_.computeStrides(t),x=n.length,w=_.computeStrides(n);if(p.length+f.length===0)for(let v=0;v<d.length;v++){let k=v%m.length,I=v%g.length,S=e(m[k*2],m[k*2+1],g[I*2],g[I*2+1]);d[v]=S.real,h[v]=S.imag}else for(let v=0;v<d.length;v++){let k=_.indexToLoc(v,u,c),I=k.slice(-y);p.forEach(C=>I[C]=0);let S=_.locToIndex(I,y,b),$=k.slice(-x);f.forEach(C=>$[C]=0);let N=_.locToIndex($,x,w),T=e(m[S*2],m[S*2+1],g[N*2],g[N*2+1]);d[v]=T.real,h[v]=T.imag}return[d,h,o]}}var h7=Er((e,t)=>e+t),I2e=B3((e,t,n,r)=>({real:e+n,imag:t+r})),$g=ls(gd,h7,I2e),S2e={kernelName:gd,backendName:"cpu",kernelFunc:$g};function W3(e,t,n,r,s){let a=_.sizeFromShape(r),i=_.makeZerosTypedArray(s,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(a>0?i[l]+=t[o]:i[l]+=1)}return i}function p7(e,t,n,r=!1){let s=e.shape[0],a=e.shape[1],i=Ot([s,n],t.dtype);for(let o=0;o<s;o++)for(let l=0;l<a;l++){let u=e.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(r?i.set(1,o,u):t.size>0?i.set(i.get(o,u)+t.get(o,l),o,u):i.set(i.get(o,u)+1,o,u))}return i}function Jl(e){return(t,n,r)=>{let s=_.getArrayFromDType(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}function bn(e,t,n){let r=Jl(t);return Sd(e,r,n)}function Sd(e,t,n){return({inputs:r,attrs:s,backend:a})=>{let{x:i}=r;lt(i,e);let o=a,l=o.data.get(i.dataId).values,u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=W.fromUint8ToStringArray(l)}else u=l;let c=n||i.dtype,d=t(u,c,s);return o.makeTensorInfo(i.shape,c,d)}}var f7=Jl(e=>Math.ceil(e)),C2e=Sd($p,f7),N2e={kernelName:$p,backendName:"cpu",kernelFunc:C2e};function V3(e,t,n,r){let s=_.getArrayFromDType(n,_.sizeFromShape(t));if(r&&n!=="string"){let a=0;e.forEach(i=>{let o=_.sizeFromShape(i.shape);s.set(i.vals,a),a+=o})}else{let a=0;e.forEach(i=>{let o=n==="string"?W.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let u=0;u<i.shape[0];++u){let c=u*t[1]+a;for(let d=0;d<i.shape[1];++d)s[c+d]=o[l++]}a+=i.shape[1]})}return s}var m7=Er((e,t)=>e===t?1:0),g7=ls(my,m7,null,"bool"),$2e={kernelName:my,backendName:"cpu",kernelFunc:g7},y7=Jl(e=>Math.exp(e)),b7=Sd(Pp,y7,"float32"),T2e={kernelName:Pp,backendName:"cpu",kernelFunc:b7},x7=Jl(e=>Math.expm1(e)),_2e=Sd(zp,x7),E2e={kernelName:zp,backendName:"cpu",kernelFunc:_2e},w7=Jl(e=>Math.floor(e)),A2e=Sd(Bp,w7),R2e={kernelName:Bp,backendName:"cpu",kernelFunc:A2e},v7=Er((e,t)=>Math.floor(e/t)),D2e=ls(Wp,v7,null,"int32"),F2e={kernelName:Wp,backendName:"cpu",kernelFunc:D2e};function k7(e,t,n,r,s,a,i,o,l){let u=Ot([r,a],n);for(let c=0;c<r;c++){let d=[],h=0;for(let p=0;p<s;p++){let f=e[c*s+p];h+=f*i[p],d.push(f)}if(h<0||h>=l/a)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let p=0;p<a;p++)u.values[c*a+p]=t.get(...t.indexToLoc(h*a+p))}return u}function I7(e,t,n){let r=Ot(n,e.dtype);for(let s=0;s<r.size;++s){let a=r.indexToLoc(s).slice(),i=a[0],o=a[2],l=t.locToIndex([i,o]);a[2]=t.values[l];let u=e.locToIndex(a);0<=u&&u<e.values.length&&(r.values[s]=e.values[u])}return r}var S7=Er((e,t)=>e>t?1:0),O2e=ls(wy,S7,null,"bool"),M2e={kernelName:wy,backendName:"cpu",kernelFunc:O2e},C7=Er((e,t)=>e>=t?1:0),L2e=ls(Up,C7,null,"bool"),P2e={kernelName:Up,backendName:"cpu",kernelFunc:L2e},N7=Er((e,t)=>e<t?1:0),z2e=ls(vy,N7,null,"bool"),B2e={kernelName:vy,backendName:"cpu",kernelFunc:z2e},$7=Er((e,t)=>e<=t?1:0),W2e=ls(ky,$7,null,"bool"),V2e={kernelName:ky,backendName:"cpu",kernelFunc:W2e};function T7(e,t,n){let r=(t-e)/(n-1),s=_.makeZerosTypedArray(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}var _7=Jl(e=>Math.log(e)),U2e=Sd(Xp,_7),G2e={kernelName:Xp,backendName:"cpu",kernelFunc:U2e};function E7(e,t,n,r){let s=_.getTypedArrayFromDType(r,_.sizeFromShape(n));for(let a=0;a<s.length;++a){let i=a*t,o=e[i];for(let l=0;l<t;++l){let u=e[i+l];(Number.isNaN(u)||u>o)&&(o=u)}s[a]=o}return s}var A7=Er((e,t)=>Math.max(e,t)),H2e=ls(Qp,A7),j2e={kernelName:Qp,backendName:"cpu",kernelFunc:H2e},R7=Er((e,t)=>Math.min(e,t)),q2e=ls(rf,R7),K2e={kernelName:rf,backendName:"cpu",kernelFunc:q2e},U3=Er((e,t)=>e*t),X2e=B3((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),h2=ls(af,U3,X2e),Y2e={kernelName:af,backendName:"cpu",kernelFunc:h2};function D7(e,t,n){let r=_.createScalarValue(-1,n);return U3([],t,r,e,n)}function Z2e(e){let{inputs:t,backend:n}=e,{x:r}=t;lt(r,"neg");let s=n.data.get(r.dataId).values,[a,i]=D7(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}var J2e={kernelName:Ay,backendName:"cpu",kernelFunc:Z2e},F7=Er((e,t)=>e!==t?1:0),Q2e=ls(Ry,F7,null,"bool"),e$e={kernelName:Ry,backendName:"cpu",kernelFunc:Q2e};function G3(e,t,n,r,s){let a=t.length,i=_.sizeFromShape(t),o=_.computeStrides(t),l=_.computeStrides(s),u=_.getTypedArrayFromDType(n,_.sizeFromShape(s));for(let c=0;c<i;++c){let d=_.indexToLoc(c,a,o),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[r[f]];let p=_.locToIndex(h,a,l);u[p]=e[c]}return u}function Ta(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;lt(s,"transpose");let i=s.shape.length,o=new Array(i);for(let c=0;c<o.length;c++)o[c]=s.shape[a[c]];let l=r.data.get(s.dataId).values,u=G3(l,s.shape,s.dtype,a,o);return{dataId:r.write(u,o,s.dtype),shape:o,dtype:s.dtype}}var t$e={kernelName:Cu,backendName:"cpu",kernelFunc:Ta};function O7(e,t,n,r){let[s,a]=W.computeOutAndReduceShapes(e,r),i=$i(t,"int32"),o=_.makeZerosTypedArray(_.sizeFromShape(s),i),l=_.sizeFromShape(a);for(let u=0;u<o.length;++u){let c=u*l,d=1;for(let h=0;h<l;++h)d*=n[c+h];o[u]=d}return{outVals:o,outShape:s,outDtype:i}}function n$e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;lt(s,"prod");let o=s.shape.length,l=_.parseAxisParam(a,s.shape),u=W.getAxesPermutation(l,o),c=l,d=s,h=[];u!=null&&(d=Ta({inputs:{x:s},backend:n,attrs:{perm:u}}),h.push(d),c=W.getInnerMostAxes(c.length,o));let p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=O7(d.shape,d.dtype,p,c),y=m;return i&&(y=W.expandShapeToKeepDim(m,l)),h.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(y,g,f)}var r$e={kernelName:df,backendName:"cpu",kernelFunc:n$e};function s$e(e,t,n){e.forEach((r,s)=>{if(r<0||r>=n){let a=_.indexToLoc(s,t.length,_.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${r} is not in [0, ${n})`)}})}function a$e(e,t){for(let n=0;n<e.length;++n){let r=e[n],s=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let a=1;a<r.length;++a)if(r[a-1]>r[a])throw new Error("Ragged splits must be sorted in ascending order")}}function i$e(e,t,n,r){let s=[],a=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);a$e(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let c=t[u+1];for(let d=1;d<l+1;++d)o[u].push(d*c)}for(let u=0;u<e.length;++u){let c=e[u],d=e[u]+1;for(let h=0;h<n.length;++h){let p=n[h],f=h+t.length-1;if(f>=0){let m=o[f],g=m[m.length-1]-p[c];for(let y=c;y<d;++y)o[f].push(p[y+1]+g)}c=p[c],d=p[d]}d!==c&&(s.push([c,d]),a+=d-c)}return{outSplits:o,valueSlices:s,numValues:a}}function o$e(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,s=_.getArrayFromDType("int32",r);t.push(s),e[n].forEach((a,i)=>s[i]=a)}return t}function rU(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function l$e(e,t,n,r,s,a){let i=rU(t,2)[1],o=rU(a,2)[1],l=0;for(let u of n)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)s[l*o+d]=e[c*i+d];++l}}function u$e(e,t,n,r,s){let a=t.slice();a[0]=s;let i=_.getArrayFromDType(n,_.sizeFromShape(a)),o=e.length,l=o===0?0:o/t[0];return l$e(e,t,r,l,i,a),[i,a]}function M7(e,t,n,r,s,a,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(s$e(a,i,l),r.length===0)throw new Error("params.rank must be nonzero");let u=r[0],{outSplits:c,valueSlices:d,numValues:h}=i$e(a,i,e,u),p=o$e(c),f=u$e(n,r,s,d,h);return[p,f[0],f[1]]}var sU=2147483647;function L7(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,l=s.length===0,u=i.length===0,c=[];o||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");let d=c.length===0?1:c[0],h=_.getArrayFromDType("int32",d+1);h[0]=0;for(let g=0;g<d;++g){let y=o?e[0]:e[g],b=l?r[0]:r[g],x=u?a[0]:a[g];if(x===0)throw new Error("Requires delta != 0");let w;if(x>0&&b<y||x<0&&b>y)w=0;else if(w=Math.ceil(Math.abs((b-y)/x)),w>sU)throw new Error(`Requires ((limit - start) / delta) <= ${sU}`);h[g+1]=h[g]+w}let p=h[d],f=_.getArrayFromDType(n,p),m=0;for(let g=0;g<d;++g){let y=h[g+1]-h[g],b=o?e[0]:e[g],x=u?a[0]:a[g];for(let w=0;w<y;++w)f[m++]=b,b+=x}return[h,f]}var Vi=W.RowPartitionType,zA=class{constructor(e,t,n,r,s,a,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=W.getRowPartitionTypesHelper(u),this.raggedRank=W.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Vi.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Vi.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Vi.VALUE_ROWIDS:return zA.getMaxWidthValueRowID(t);case Vi.ROW_SPLITS:return zA.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Vi[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(t===0||t===1)return 0;let n=0;for(let r=0;r<t-1;++r){let s=e[r+1]-e[r];s>n&&(n=s)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(t===0)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){let i=e[a];i!==r&&(r=i,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return iU(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;W.validateDefaultValueShape(n,t);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=W.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);s[0]<0&&(s[0]=e);for(let a=1;a<=this.raggedRank;++a)s[a]<0&&(s[a]=this.getMaxWidth(a));return s}calculateFirstParentOutputIndex(e,t,n){let r=Math.min(e,n),s=[],a=0;for(let i=0;i<r;++i,a+=t)s.push(a);for(let i=r;i<e;++i)s.push(-1);return _.assert(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,n,r){let s=e.length,a=[];for(let i=0;i<s-1;++i){let o=e[i+1]-e[i],l=Math.min(r,o),u=t[i];u===-1&&(l=0);for(let c=0;c<l;++c)a.push(u),u+=n;for(let c=0;c<o-l;++c)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){let s=e.length,a=[];if(s===0)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];a.push(l);for(let u=1;u<s;++u){let c=e[u];if(c===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=c,c>=t.length)throw new Error(`Got nextValueRowId=${c} which is not less than ${t.length}`);l=t[c]}a.push(l)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){let s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case Vi.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case Vi.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${Vi[a]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case Vi.FIRST_DIM_SIZE:return e[0];case Vi.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Vi.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Vi[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let a=n.length-2;a>=0;--a)n[a]=n[a+1]*t[a+1];let r=iU(t,!1),s=_.getArrayFromDType(this.valuesDType,_.sizeFromShape(r));if(n[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let i=1;i<=this.raggedRank;++i)a=this.calculateOutputIndex(i-1,a,n[i],t[i]);this.setOutput(this.raggedRank,a,s,r)}return[r,s]}setOutput(e,t,n,r){if(n.length===0)return;let s=this.values,a=n,i=r.slice();i=i.slice(e+1);let o=_.sizeFromShape(i),l=t.length,u=this.defaultValue;if(u.length!==o&&u.length!==1){let p=this.defaultValueShape;ue(()=>{let f=oe(u,p);u=Sh(f,i).dataSync()})}let c=0,d=0,h=0;for(let p=0;p<=l;++p){let f=p<l?t[p]:-1;if(f===h){++h;continue}if(d<h){let m=s.subarray(c*o),g=a.subarray(d*o),y=(h-d)*o;aU(g,m,y)}if(p>=l){let m=n.length;f=Math.floor(m/o)}if(f>h)if(this.defaultValue.length===1)a.subarray(h*o,f*o).fill(this.defaultValue[0]),h=f;else for(;f>h;){let m=a.slice(h*o);aU(m,u,o),++h}f<0?(c=p+1,d=h):(c=p,d=h,h=d+1)}}};function aU(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function iU(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function P7(e,t,n,r,s,a,i,o,l,u){return new zA(e,t,n,r,s,a,i,o,l,u).compute()}function H3(e,t,n,r){let s=e===t,a=e<t&&n<0,i=t<e&&n>1;if(s||a||i)return _.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=_.makeZerosTypedArray(o,r);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var z7=Jl(e=>1/Math.sqrt(e)),c$e=Sd(xf,z7),d$e={kernelName:xf,backendName:"cpu",kernelFunc:c$e};function bh(e,t,n,r,s,a,i,o,l,u){let c=[r/s,s],d=e.values,h=t.values;if(r===0)return Ot(n,t.dtype);let p=l instanceof Nr?l:Ot(c,t.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<a;f++){let m=[],g=0;for(let y=0;y<i;y++){let b=d[f*i+y];m.push(b),g+=b*o[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let y=0;y<s;y++)u?p.values[g*s+y]+=h[f*s+y]:p.values[g*s+y]=t.rank===0?h[0]:h[f*s+y]}return p}var h$e=Jl(e=>1/(1+Math.exp(-e))),B7=bn(If,e=>1/(1+Math.exp(-e))),p$e={kernelName:If,backendName:"cpu",kernelFunc:B7};function gS(e,t,n,r,s){let a=Br.isSliceContinous(r,t,n),i=_.sizeFromShape(n),o=_.computeStrides(r);if(a){let d=Br.computeFlatOffset(t,o);return s==="string"?e.slice(d,d+i):e.subarray(d,d+i)}let l=s==="string"?W.fromUint8ToStringArray(e):e,u=Ot(r,s,l),c=Ot(n,s);for(let d=0;d<c.size;++d){let h=c.indexToLoc(d),p=h.map((f,m)=>f+t[m]);c.set(u.get(...p),...h)}return s==="string"?W.fromStringArrayToUint8(c.values):c.values}function Zh(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;lt(s,"slice");let[o,l]=Br.parseSliceParams(s,a,i);Br.assertParamsValid(s,o,l);let u=n.data.get(s.dataId).values,c=gS(u,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,c)}var f$e={kernelName:Hy,backendName:"cpu",kernelFunc:Zh};function W7(e,t,n,r,s,a,i){let o=t[0],l=a[0],u=new Array(l),c=new Array(o),d=t[1];if(l===0){if(o!==0)throw new Error(W.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let g=_.getArrayFromDType(n,0),y=_.getArrayFromDType(s,0);return[g,[0,d],y,u,c]}let h=!0,p=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let y=e[g*d];if(y<0)throw new Error(W.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=l)throw new Error(W.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,l));++f[y],h=h&&y>=p,p=y}let m=!0;for(let g=0;g<l;++g){let y=f[g]===0;u[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){let g=e,y=r;for(let b=0;b<o;++b)c[b]=b;return[g,[o,d],y,u,c]}else{let g=f[l-1],y=_.getArrayFromDType(n,g*d),b=_.getArrayFromDType(s,g),x=new Array(l).fill(0);for(let w=0;w<o;++w){let v=e[w*d],k=x[v],I=(v===0?0:f[v-1])+k;x[v]++;for(let S=0;S<d;++S)y[I*d+S]=e[w*d+S];b[I]=r[w],c[w]=I}for(let w=0;w<l;++w)if(x[w]===0){let v=w===0?0:f[w-1];y[v*d+0]=w;for(let k=1;k<d;++k)y[v*d+k]=0;b[v]=i}return[y,[g,d],b,u,c]}}function V7(e,t,n,r,s){let a=_.sizeFromShape(r),i=t[0],o=s.length,l=[],u=1,c=-1;for(let m=0;m<o;++m){let g=s[m];if(g===-1){if(c!==-1)throw new Error(W.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,m));c=m,l.push(1)}else{if(g<0)throw new Error(W.getSparseReshapeNegativeOutputDimErrorMessage(m,g));u*=g,l.push(g)}}if(c!==-1){if(u<=0)throw new Error(W.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(a/u);if(u*m!==a)throw new Error(W.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=m}if(_.sizeFromShape(l)!==a)throw new Error(W.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let d=r.length,h=[];if(d>0){h[d-1]=1;for(let m=d-2;m>=0;--m)h[m]=h[m+1]*r[m+1]}let p=[];if(o>0){p[o-1]=1;for(let m=o-2;m>=0;--m)p[m]=p[m+1]*l[m+1]}let f=_.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let g=0;for(let y=0;y<d;++y)g+=e[m*d+y]*h[y];for(let y=0;y<o;++y)f[m*o+y]=Math.trunc(g/p[y]),g%=p[y]}return[f,[i,o],l]}function j3(e,t,n,r,s,a=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error(W.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=c;let h=d.reduce((b,x)=>b*x,1),p=_.getArrayFromDType(n,h);if(o===0)return c>0&&p.fill(i),[p,d];if(c<=0)throw new Error(W.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=s[f];for(;;){let b=0;if(m<o){if(b=s[m],y===b){++m;continue}if(y>=b)throw new Error(W.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=c)throw new Error(W.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,c));y>g&&p.fill(i,g*u,y*u);for(let x=f;x<m;++x){let w=r[x];if(w<0||w>=l[0])throw new Error(W.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x,r[x],l[0]));for(let v=0;v<u;v++)p[y*u+v]+=e[w*u+v]}if(a)for(let x=0;x<u;x++)p[y*u+x]/=m-f;if(f=m,++m,g=y+1,y=b,m>o)break}return g<c&&p.fill(i,g*u,c*u),[p,d]}var m$e=Jl(e=>Math.sqrt(e)),g$e=bn(Cf,e=>Math.sqrt(e)),y$e={kernelName:Cf,backendName:"cpu",kernelFunc:g$e},U7=Er((e,t)=>{let n=e-t;return n*n}),b$e=ls(Tf,U7),x$e={kernelName:Tf,backendName:"cpu",kernelFunc:b$e},G7=Jl((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)}),w$e=Sd(fw,G7),v$e={kernelName:fw,backendName:"cpu",kernelFunc:w$e};function H7(e,t,n,r){let s=Ot(e,t.dtype);for(let a=0;a<s.size;a++){let i=s.indexToLoc(a),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+r[l];s.set(t.get(...o),...i)}return s}var k$e=class{constructor(e,t,n,r,s,a){this.separator=_.encodeString(e),this.nGramWidths=t,this.leftPad=_.encodeString(n),this.rightPad=_.encodeString(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){let o=this.getPadWidth(a),l=Math.max(0,o-i),u=Math.max(0,o-(s-(i+1))),c=a-(l+u),d=t+(l>0?0:i-o),h=0;h+=l*this.leftPad.length;for(let y=0;y<c;++y)h+=e[d+y].length;h+=u*this.rightPad.length;let p=l+u+c-1;h+=p*this.separator.length,n[r+i]=new Uint8Array(h);let f=n[r+i],m=0,g=y=>y.forEach(b=>f[m++]=b);for(let y=0;y<l;++y)g(this.leftPad),g(this.separator);for(let y=0;y<c-1;++y)g(e[d+y]),g(this.separator);if(c>0){g(e[d+c-1]);for(let y=0;y<u;++y)g(this.separator),g(this.rightPad)}else{for(let y=0;y<u-1;++y)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<r;++l){let u=t[l]>=o;if(u=u&&t[l]<=n,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let s=r-1,a=_.getArrayFromDType("int32",r);if(n===0||r===0){let o=new Array(n);for(let l=0;l<=s;++l)a[l]=0;return[o,a]}a[0]=0;for(let o=1;o<=s;++o){let l=t[o]-t[o-1],u=0;this.nGramWidths.forEach(c=>{u+=this.getNumNGrams(l,c)}),this.preserveShort&&l>0&&u===0&&(u=1),a[o]=a[o-1]+u}let i=new Array(a[s]);for(let o=0;o<s;++o){let l=t[o],u=a[o];if(this.nGramWidths.forEach(c=>{let d=t[o+1]-t[o],h=this.getNumNGrams(d,c);this.createNGrams(e,l,i,u,h,c),u+=h}),this.preserveShort&&u===a[o]){let c=t[o+1]-t[o];if(c===0)continue;let d=c+2*this.padWidth,h=1;this.createNGrams(e,l,i,u,h,d)}}return[i,a]}};function q3(e,t,n,r,s,a,i,o){return new k$e(n,r,s,a,i,o).compute(e,t)}function I$e(e,t,n,r){if(!e.length)return;if(t.length===0){for(let a=0;a<e.length;++a)r.push(e.subarray(a,a+1));return}if(t.length===1){let a=t[0],i=e.indexOf(a);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(a)}(!n||e.length!==0)&&r.push(e);return}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||t.indexOf(e[a])!==-1){let i=e.subarray(s,a);(!n||i.length!==0)&&r.push(i),s=a+1}}function K3(e,t,n){let r=e.length,s=[],a=0,i=0,o=new Array(r);for(let h=0;h<r;++h){let p=s.length;I$e(e[h],t,n,s);let f=s.length-p;o[h]=f,a+=f,i=Math.max(i,f)}let l=_.getArrayFromDType("int32",a*2),u=new Array(a),c=[r,i],d=0;for(let h=0;h<r;++h)for(let p=0;p<o[h];++p)l[d*2]=h,l[d*2+1]=p,u[d]=s[d],++d;return[l,u,c]}function X3(e,t){let n=_.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=_.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var j7=Er((e,t)=>e-t),S$e=B3((e,t,n,r)=>({real:e-n,imag:t-r})),Y3=ls(_f,j7,S$e),C$e={kernelName:_f,backendName:"cpu",kernelFunc:Y3};function q7(e,t){let n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];let r=Ot(n,e.dtype);for(let s=0;s<r.values.length;++s){let a=r.indexToLoc(s),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=a[l]%e.shape[l];let o=e.locToIndex(i);r.values[s]=e.values[o]}return r}var yx=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function K7(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let o=r-n+1,l=t-n+1,u=Math.log(o),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(o-c)/o)*Math.sign(l-o/2),h=Math.max(n,Math.floor(t-l*c/o+d)),p=Math.min(r,Math.floor(t+(o-l)*c/o+d));K7(e,t,h,p)}let s=e[t],a=n,i=r;for(_.swap(e,n,t),yx(e[r],s)>0&&_.swap(e,n,r);a<i;){for(_.swap(e,a,i),a++,i--;yx(e[a],s)<0;)a=a+1;for(;yx(e[i],s)>0;)i=i-1}yx(e[n],s)===0?_.swap(e,n,i):(i=i+1,_.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function X7(e,t,n,r,s){let a=t[t.length-1],[i,o]=[e.length/a,a],l=_.getTypedArrayFromDType(n,i*r),u=_.getTypedArrayFromDType("int32",i*r);for(let d=0;d<i;d++){let h=d*o,p=e.subarray(h,h+o),f=new Array(p.length);p.forEach((b,x)=>f[x]={value:b,index:x}),r<f.length&&(K7(f,r),f=f.slice(0,r)),s&&f.sort(yx);let m=d*r,g=l.subarray(m,m+r),y=u.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=f[b].value,y[b]=f[b].index}let c=t.slice();return c[c.length-1]=r,[Ot(c,n,l),Ot(c,"int32",u)]}function Z3(e,t,n,r){let s=_.parseAxisParam(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];let i=new Map,o=new Int32Array(n[s]),l=new Nr(a,r,e),u=[],c=a[0]===1&&a[2]===1;for(let f=0;f<n[s];f++){let m;if(c)m=e[f].toString();else{let y=[];for(let b=0;b<a[0];b++)for(let x=0;x<a[2];x++)y.push(l.get(b,f,x));m=y.join(",")}let g=i.get(m);if(g!=null)o[f]=g;else{let y=i.size;i.set(m,y),o[f]=y,u.push(f)}}let d=a.slice();d[1]=i.size;let h=new Nr(d,r);u.forEach((f,m)=>{for(let g=0;g<a[0];g++)for(let y=0;y<a[2];y++)h.set(l.get(g,f,y),g,m,y)});let p=n.slice();return p[s]=d[1],{outputValues:h.values,outputShape:p,indices:o}}var N$e="4.3.0";hN("cpu",()=>new d2,1);var Y7=bn(Lp,e=>e>=0?e:Math.exp(e)-1),$$e={kernelName:Lp,backendName:"cpu",kernelFunc:Y7};function Z7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;lt([s],"leakyRelu");let i=_.sizeFromShape(s.shape),o=n.data.get(s.dataId).values,l=_.getTypedArrayFromDType("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?a*o[u]:o[u];return n.makeTensorInfo(s.shape,"float32",l)}var T$e={kernelName:Kp,backendName:"cpu",kernelFunc:Z7},_$e=Er((e,t)=>e<0?t*e:e);function J7(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t;lt([r,s],"prelu");let a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=_$e(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}var E$e={kernelName:cf,backendName:"cpu",kernelFunc:J7},Q7=bn(pf,e=>Math.max(0,e)),A$e={kernelName:pf,backendName:"cpu",kernelFunc:Q7},e9=bn(gf,e=>Math.min(Math.max(0,e),6)),R$e={kernelName:gf,backendName:"cpu",kernelFunc:e9};function yS(e,t,n,r,s){if(n==="linear")return Hl({inputs:{x:t},backend:e});if(n==="relu")return Q7({inputs:{x:t},backend:e});if(n==="elu")return Y7({inputs:{x:t},backend:e});if(n==="relu6")return e9({inputs:{x:t},backend:e});if(n==="prelu")return J7({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return Z7({inputs:{x:t},backend:e,attrs:{alpha:s}});if(n==="sigmoid")return B7({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Ln(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=_.sizeFromShape(s.shape),o=_.inferFromImplicitShape(a,i),l=_.sizeFromShape(o);_.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);let u=n.data.get(s.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,d=u.complexTensorInfos.imag;c.shape=o,d.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}var D$e={kernelName:Py,backendName:"cpu",kernelFunc:Ln};function t9(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;lt([s,a],"matMul");let l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=o?a.shape[u-1]:a.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=_.sizeFromShape(f),y=_.sizeFromShape(m),b=rb.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);_.assert(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,c,h]:[g,h,c],w=o?[y,p,d]:[y,d,p],v=Ln({inputs:{x:s},backend:n,attrs:{shape:x}}),k=Ln({inputs:{x:a},backend:n,attrs:{shape:w}}),I=i?v.shape[1]:v.shape[2],S=i?v.shape[2]:v.shape[1],$=o?k.shape[1]:k.shape[2],N=Math.max(g,y),T=n.data.get(v.dataId).values,C=n.data.get(k.dataId).values,E=_.computeStrides(v.shape),M=_.computeStrides(k.shape),[F,z,H]=i?[E[0],1,E[1]]:[E[0],E[1],1],[P,O,L]=o?[1,M[1],M[0]]:[M[1],1,M[0]],V=S*$,q=Ot([N,S,$],v.dtype),B=q.values,X=n.blockSize;for(let ee=0;ee<N;ee++){let Z=ee%g,fe=ee%y;for(let Q=0;Q<S;Q+=X){let be=Math.min(Q+X,S);for(let we=0;we<$;we+=X){let Ne=Math.min(we+X,$);for(let $e=0;$e<I;$e+=X){let je=Math.min($e+X,I);for(let He=Q;He<be;He++)for(let Re=we;Re<Ne;Re++){let Fe=0;for(let Pe=$e;Pe<je;Pe++){let Je=T[Z*F+He*z+Pe*H],pn=C[Pe*P+Re*O+fe*L];Fe+=Je*pn}B[ee*V+(He*$+Re)]+=Fe}}}}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(k),n.makeTensorInfo(b,q.dtype,q.values)}var F$e={kernelName:Cp,backendName:"cpu",kernelFunc:t9};function O$e(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r,h,p,f,m=[];h=t9({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=$g({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=yS(n,h,c,o,d),m.push(h),h=f);for(let g of m)n.disposeIntermediateTensorInfo(g);return h}var M$e={kernelName:Lh,backendName:"cpu",kernelFunc:O$e},L$e=bn(gp,e=>Math.acos(e)),P$e={kernelName:gp,backendName:"cpu",kernelFunc:L$e},z$e=bn(yp,e=>Math.acosh(e)),B$e={kernelName:yp,backendName:"cpu",kernelFunc:z$e};function W$e(e){let{inputs:t,backend:n}=e,r=t;lt(t,"addN");let s=r.map(o=>n.data.get(o.dataId).values),a=Ot(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){let l=s[o];for(let u=0;u<i.length;u++)i[u]+=l[u]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}var V$e={kernelName:bp,backendName:"cpu",kernelFunc:W$e};function U$e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;lt(s,"all");let o=_.parseAxisParam(a,s.shape),l=o,u=W.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=Ta({inputs:{x:s},backend:n,attrs:{perm:u}}),l=W.getInnerMostAxes(l.length,s.shape.length)),W.assertAxesAreInnerMostDims("all",l,c.shape.length);let[d,h]=W.computeOutAndReduceShapes(c.shape,l),p=_.sizeFromShape(h),f=_.makeZerosTypedArray(_.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let b=y*p,x=m[b];for(let w=0;w<p;++w){let v=m[b+w];x=x&&v}f[y]=x}u!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let y=W.expandShapeToKeepDim(d,o),b=Ln({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var G$e={kernelName:ey,backendName:"cpu",kernelFunc:U$e};function H$e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;lt(s,"any");let o=_.parseAxisParam(a,s.shape),l=o,u=W.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=Ta({inputs:{x:s},backend:n,attrs:{perm:u}}),l=W.getInnerMostAxes(l.length,s.shape.length)),W.assertAxesAreInnerMostDims("any",l,c.shape.length);let[d,h]=W.computeOutAndReduceShapes(c.shape,l),p=_.sizeFromShape(h),f=_.makeZerosTypedArray(_.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let b=y*p,x=m[b];for(let w=0;w<p;++w){let v=m[b+w];x=x||v}f[y]=x}u!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let y=W.expandShapeToKeepDim(d,o),b=Ln({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var j$e={kernelName:ty,backendName:"cpu",kernelFunc:H$e};function q$e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;lt(s,"argMax");let i=_.parseAxisParam(a,s.shape),o=W.getAxesPermutation(i,s.shape.length),l=s,u=[];o!=null&&(l=Ta({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=W.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],W.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[c,d]=W.computeOutAndReduceShapes(l.shape,i),h=_.sizeFromShape(c),p=_.makeZerosTypedArray(h,"int32"),f=_.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let y=g*f,b=m[y],x=0;for(let w=0;w<f;++w){let v=m[y+w];v>b&&(b=v,x=w)}p[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",p)}var K$e={kernelName:ny,backendName:"cpu",kernelFunc:q$e};function X$e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;lt(s,"argMin");let i=_.parseAxisParam(a,s.shape),o=W.getAxesPermutation(i,s.shape.length),l=s,u=[];o!=null&&(l=Ta({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=W.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],W.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[c,d]=W.computeOutAndReduceShapes(l.shape,i),h=_.sizeFromShape(c),p=_.makeZerosTypedArray(h,"int32"),f=_.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let y=g*f,b=m[y],x=0;for(let w=0;w<f;++w){let v=m[y+w];v<b&&(b=v,x=w)}p[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",p)}var Y$e={kernelName:ry,backendName:"cpu",kernelFunc:X$e},Z$e=bn(xp,e=>Math.asin(e)),J$e={kernelName:xp,backendName:"cpu",kernelFunc:Z$e},Q$e=bn(wp,e=>Math.asinh(e)),eTe={kernelName:wp,backendName:"cpu",kernelFunc:Q$e},tTe=bn(vp,e=>Math.atan(e)),nTe={kernelName:vp,backendName:"cpu",kernelFunc:tTe},rTe=Er((e,t)=>Math.atan2(e,t)),sTe=ls(Ip,rTe),aTe={kernelName:Ip,backendName:"cpu",kernelFunc:sTe},iTe=bn(kp,e=>Math.atanh(e)),oTe={kernelName:kp,backendName:"cpu",kernelFunc:iTe};function J3(e,t,n,r,s,a){let i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,f=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Ot(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let w=0;w<s.batchSize;++w){let v=w*y,k=w*r[0];for(let I=0;I<s.inChannels;++I)for(let S=0;S<s.outHeight;++S){let $=S*i-h,N=Math.max(0,$),T=Math.min(s.inHeight,c+$),C=v+S*b;for(let E=0;E<s.outWidth;++E){let M=E*o-p,F=Math.max(0,M),z=Math.min(s.inWidth,d+M),H=f,P=0,O=0;for(let V=N;V<T;V+=l){let q=k+V*r[1];for(let B=F;B<z;B+=u){let X=q+B*r[2],ee=e[X+I];a==="max"&&ee>H?H=ee:a==="avg"&&(P+=ee,O++)}if(isNaN(H))break}let L=C+E*x+I;g[L]=a==="avg"?P/O:H}}}return m}function n9(e,t,n,r,s=!1,a=!1){let i=Ot(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Ot(t,n,e);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){let x=b*o-p,w=x;for(;w<0;)w+=u;let v=Math.min(r.inHeight,d+x);for(let k=0;k<r.outWidth;++k){let I=k*l-f,S=I;for(;S<0;)S+=c;let $=Math.min(r.inWidth,h+I),N=Number.NEGATIVE_INFINITY,T=-1;for(let C=w;C<v;C+=u){let E=C-x;for(let M=S;M<$;M+=c){let F=M-I,z=m.get(g,C,M,y);z>N&&(N=z,s?T=a?((g*r.inHeight+C)*r.inWidth+M)*r.inChannels+y:(C*r.inWidth+M)*r.inChannels+y:T=E*h+F)}}i.set(T,g,b,k,y)}}return i}function r9(e,t,n,r,s,a){let i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Ot(s.outShape,n),w=x.values,v=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],I=s.outShape[3]*s.outShape[4],S=s.outShape[4];for(let $=0;$<s.batchSize;++$){let N=$*v,T=$*r[0];for(let C=0;C<s.inChannels;++C)for(let E=0;E<s.outDepth;++E){let M=E*i-m,F=M;for(;F<0;)F+=u;let z=Math.min(s.inDepth,h+M),H=N+E*k;for(let P=0;P<s.outHeight;++P){let O=P*o-g,L=O;for(;L<0;)L+=c;let V=Math.min(s.inHeight,p+O),q=H+P*I;for(let B=0;B<s.outWidth;++B){let X=B*l-y,ee=X;for(;ee<0;)ee+=d;let Z=Math.min(s.inWidth,f+X),fe=q+B*S,Q=b,be=0,we=0;for(let $e=F;$e<z;$e+=u){let je=T+$e*r[1];for(let He=L;He<V;He+=c){let Re=je+He*r[2];for(let Fe=ee;Fe<Z;Fe+=d){let Pe=Re+Fe*r[3],Je=e[Pe+C];if(a==="max"&&Je>Q?Q=Je:a==="avg"&&(be+=Je,we++),isNaN(Q))break}if(isNaN(Q))break}if(isNaN(Q))break}let Ne=fe+C;w[Ne]=a==="avg"?be/Math.max(we,1):Q}}}}return x}function lTe(e,t){let n=Ot(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-h,x=b;for(;x<0;)x+=i;let w=Math.min(t.inDepth,u+b);for(let v=0;v<t.outHeight;++v){let k=v*s-p,I=k;for(;I<0;)I+=o;let S=Math.min(t.inHeight,c+k);for(let $=0;$<t.outWidth;++$){let N=$*a-f,T=N;for(;T<0;)T+=l;let C=Math.min(t.inWidth,d+N),E=Number.NEGATIVE_INFINITY,M=-1;for(let F=x;F<w;F+=i){let z=F-b;for(let H=I;H<S;H+=o){let P=H-k;for(let O=T;O<C;O+=l){let L=O-N,V=e.get(m,F,H,O,g);V>=E&&(E=V,M=z*c*d+P*c+L)}}}n.set(M,m,y,v,$,g)}}}return n}function uTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;lt(s,"avgPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;_.assert(W.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=W.computePool2DInfo(s.shape,a,i,u,o,l),d;if(c.filterWidth===1&&c.filterHeight===1&&_.arraysEqual(c.inShape,c.outShape))d=Hl({inputs:{x:s},backend:n});else{let h=n.data.get(s.dataId).values,p=_.computeStrides(s.shape),f=J3(h,s.shape,s.dtype,p,c,"avg");d=n.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}var cTe={kernelName:Sp,backendName:"cpu",kernelFunc:uTe};function dTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;lt(s,"avgPool3d");let c=W.computePool3DInfo(s.shape,a,i,1,o,l,u),d=n.data.get(s.dataId).values,h=r9(d,s.shape,s.dtype,_.computeStrides(s.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}var hTe={kernelName:sy,backendName:"cpu",kernelFunc:dTe};function pTe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;lt([s,a],"avgPool3DGrad");let c=W.computePool3DInfo(a.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,x=c.dilationWidth,w=c.effectiveFilterDepth,v=c.effectiveFilterHeight,k=c.effectiveFilterWidth,I=w-1-c.padInfo.front,S=k-1-c.padInfo.left,$=v-1-c.padInfo.top,N=Ot(a.shape,"float32"),T=1/(f*m*g),C=n.bufferSync(s);for(let E=0;E<c.batchSize;++E)for(let M=0;M<c.inChannels;++M)for(let F=0;F<c.inDepth;++F)for(let z=0;z<c.inHeight;++z)for(let H=0;H<c.inWidth;++H){let P=F-I,O=z-$,L=H-S,V=0;for(let q=0;q<w;q+=y){let B=(P+q)/d;if(!(B<0||B>=c.outDepth||Math.floor(B)!==B))for(let X=0;X<v;X+=b){let ee=(O+X)/h;if(!(ee<0||ee>=c.outHeight||Math.floor(ee)!==ee))for(let Z=0;Z<k;Z+=x){let fe=(L+Z)/p;if(fe<0||fe>=c.outWidth||Math.floor(fe)!==fe)continue;let Q=C.get(E,B,ee,fe,M);V+=Q}}}N.set(V*T,E,F,z,H,M)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var fTe={kernelName:nw,backendName:"cpu",kernelFunc:pTe};function mTe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;lt([s,a],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=W.computePool2DInfo(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,x=b-1-c.padInfo.left,w=y-1-c.padInfo.top,v=Ot(i.shape,"float32"),k=1/(p*f),I=n.data.get(s.dataId).values,S=Ot(s.shape,"float32",I);for(let $=0;$<c.batchSize;++$)for(let N=0;N<c.inChannels;++N)for(let T=0;T<c.inHeight;++T)for(let C=0;C<c.inWidth;++C){let E=T-w,M=C-x,F=0;for(let z=0;z<y;z+=m){let H=(E+z)/d;if(!(H<0||H>=c.outHeight||Math.floor(H)!==H))for(let P=0;P<b;P+=g){let O=(M+P)/h;if(O<0||O>=c.outWidth||Math.floor(O)!==O)continue;let L=S.get($,H,O,N);F+=L}}v.set(F*k,$,T,C,N)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var gTe={kernelName:XC,backendName:"cpu",kernelFunc:mTe};function yTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;_.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),lt([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);let c=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,x=d.length,w=0,v=0,k=0,I=0;for(let S=0;S<c.length;++S)m[S]=f[w++]+(c[S]-d[v++])*p[k++]/Math.sqrt(h[I++]+u),w>=g&&(w=0),v>=x&&(v=0),k>=y&&(k=0),I>=b&&(I=0);return n.makeTensorInfo(s.shape,s.dtype,m)}var bTe={kernelName:Vp,backendName:"cpu",kernelFunc:yTe};function xTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;lt([s],"batchToSpaceND");let o=a.reduce((y,b)=>y*b),l=W.getReshaped(s.shape,a,o),u=W.getPermuted(l.length,a.length),c=W.getReshapedPermuted(s.shape,a,o),d=W.getSliceBeginCoords(i,a.length),h=W.getSliceSize(c,i,a.length),p=Ln({inputs:{x:s},backend:n,attrs:{shape:l}}),f=Ta({inputs:{x:p},backend:n,attrs:{perm:u}}),m=Ln({inputs:{x:f},backend:n,attrs:{shape:c}}),g=Zh({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var wTe={kernelName:ay,backendName:"cpu",kernelFunc:xTe};function vTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=W3(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}var kTe={kernelName:iy,backendName:"cpu",kernelFunc:vTe};function ITe(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=W.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var STe={kernelName:rw,backendName:"cpu",kernelFunc:ITe},CTe=bn(yd,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),NTe={kernelName:yd,backendName:"cpu",kernelFunc:CTe},$Te=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(_.sizeFromShape(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let c=o[u],d=l[u];r[u]=Math.hypot(c,d)}return n.makeOutput(r,t.shape,"float32")},TTe={kernelName:sw,backendName:"cpu",kernelFunc:$Te};function Tg(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}var _Te={kernelName:rN,backendName:"cpu",kernelFunc:Tg};function _g(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=_.parseAxisParam(s,t[0].shape)[0],i=t.map(m=>m.shape);W.assertParamsConsistent(i,a);let o=W.computeOutShape(t.map(m=>m.shape),a);if(_.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(m=>_.sizeFromShape(m.shape)>0);if(l.length===1)return Hl({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){let m=l.map(w=>Yh({inputs:{input:w},backend:n})),g=l.map(w=>Tg({inputs:{input:w},backend:n})),y=_g({inputs:m,backend:n,attrs:{axis:a}}),b=_g({inputs:g,backend:n,attrs:{axis:a}}),x=Wa({inputs:{real:y,imag:b},backend:n});return m.forEach(w=>n.disposeIntermediateTensorInfo(w)),g.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),x}let u=l.map(m=>{let g=[-1,_.sizeFromShape(m.shape.slice(a))];return Ln({inputs:{x:m},backend:n,attrs:{shape:g}})}),c=u.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=W.computeOutShape(u.map(m=>m.shape),1);let d=u[0].shape[0]===1,h=V3(c,o,t[0].dtype,d),p=W.computeOutShape(l.map(m=>m.shape),a),f=n.makeTensorInfo(p,t[0].dtype,h);return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var ETe={kernelName:oy,backendName:"cpu",kernelFunc:_g};function s9(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;lt([s,a],"conv2d");let d=W.convertConv2DDataFormat(l),h=W.computeConv2DInfo(s.shape,a.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,x=h.dataFormat==="channelsLast",w=new Nr(h.outShape,s.dtype),v=_.computeStrides(s.shape),k=_.computeStrides(a.shape),I=v[0],S=x?v[1]:v[2],$=x?v[2]:1,N=x?1:v[1],T=w.strides[0],C=x?w.strides[1]:w.strides[2],E=x?w.strides[2]:1,M=x?1:w.strides[1],F=n.data.get(s.dataId).values,z=n.data.get(a.dataId).values,H=w.values;for(let P=0;P<h.batchSize;++P){let O=P*I,L=P*T;for(let V=0;V<h.outHeight;++V){let q=L+V*C,B=V*h.strideHeight-b;for(let X=0;X<p;++X){let ee=B+X*m;if(ee<0||ee>=h.inHeight)continue;let Z=X*k[0],fe=O+ee*S;for(let Q=0;Q<h.outWidth;++Q){let be=q+Q*E,we=Q*h.strideWidth-y;for(let Ne=0;Ne<f;++Ne){let $e=we+Ne*g;if($e<0||$e>=h.inWidth)continue;let je=Z+Ne*k[1],He=fe+$e*$,Re=je;for(let Fe=0;Fe<h.inChannels;++Fe){let Pe=F[He+Fe*N];for(let Je=0;Je<h.outChannels;++Je)H[be+Je*M]+=Pe*z[Re+Je];Re+=h.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,H)}var ATe={kernelName:Tp,backendName:"cpu",kernelFunc:s9};function RTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;lt([s,a],"conv2dBackpropFilter");let d=W.convertConv2DDataFormat(l),h=W.computeConv2DInfo(s.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y=h.dataFormat==="channelsLast",b=new Nr(h.filterShape,"float32"),x=h.padInfo.left,w=h.padInfo.top,v=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,I=new Nr(s.shape,s.dtype,v),S=new Nr(a.shape,a.dtype,k);for(let $=0;$<m;++$){let N=Math.max(0,Math.ceil((w-$)/p)),T=Math.min(h.outHeight,(h.inHeight+w-$)/p);for(let C=0;C<g;++C){let E=Math.max(0,Math.ceil((x-C)/f)),M=Math.min(h.outWidth,(h.inWidth+x-C)/f);for(let F=0;F<h.inChannels;++F)for(let z=0;z<h.outChannels;++z){let H=0;for(let P=0;P<h.batchSize;++P)for(let O=N;O<T;++O){let L=$+O*p-w;for(let V=E;V<M;++V){let q=C+V*f-x;y?H+=I.get(P,L,q,F)*S.get(P,O,V,z):H+=I.get(P,F,L,q)*S.get(P,z,O,V)}}b.set(H,$,C,F,z)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var DTe={kernelName:ZC,backendName:"cpu",kernelFunc:RTe};function FTe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;lt([s,a],"conv2dBackpropInput");let d=_.computeStrides(a.shape),h=_.computeStrides(s.shape),p=W.convertConv2DDataFormat(u),f=W.computeConv2DInfo(i,a.shape,o,1,l,c,!1,p),m=new Nr(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[x,w,v]=d,{batchSize:k,filterHeight:I,filterWidth:S,inChannels:$,inHeight:N,inWidth:T,outChannels:C,outHeight:E,outWidth:M,strideHeight:F,strideWidth:z}=f;p=f.dataFormat;let H=I-1-f.padInfo.top,P=S-1-f.padInfo.left,O=p==="channelsLast",L=m.strides[0],V=O?m.strides[1]:m.strides[2],q=O?m.strides[2]:1,B=O?1:m.strides[1],X=h[0],ee=O?h[1]:h[2],Z=O?h[2]:1,fe=O?1:h[1];for(let Q=0;Q<k;++Q)for(let be=0;be<$;++be)for(let we=0;we<N;++we){let Ne=we-H,$e=Math.max(0,Math.ceil(Ne/F)),je=Math.min(E,(I+Ne)/F);for(let He=0;He<T;++He){let Re=He-P,Fe=Math.max(0,Math.ceil(Re/z)),Pe=Math.min(M,(S+Re)/z),Je=0;for(let ct=$e;ct<je;++ct){let an=ct*F-Ne;for(let Lt=Fe;Lt<Pe;++Lt){let Gt=Lt*z-Re,Qe=X*Q+ee*ct+Z*Lt,It=x*(I-1-an)+w*(S-1-Gt)+v*be;for(let mn=0;mn<C;++mn){let en=y[Qe+fe*mn],on=b[It+mn];Je+=en*on}}}let pn=L*Q+V*we+q*He+B*be;g[pn]=Je}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var OTe={kernelName:_p,backendName:"cpu",kernelFunc:FTe};function MTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;lt([s,a],"conv3d");let u=W.computeConv3DInfo(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,x=g.top,w=new Nr(u.outShape,s.dtype),v=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,I=w.values,S=_.computeStrides(s.shape),$=_.computeStrides(a.shape);for(let N=0;N<u.batchSize;++N){let T=N*S[0],C=N*w.strides[0];for(let E=0;E<u.outDepth;++E){let M=C+E*w.strides[1],F=E*u.strideDepth-y;for(let z=0;z<c;++z){let H=F+z*p;if(H<0||H>=u.inDepth)continue;let P=z*$[0],O=T+H*S[1];for(let L=0;L<u.outHeight;++L){let V=M+L*w.strides[2],q=L*u.strideHeight-x;for(let B=0;B<d;++B){let X=q+B*f;if(X<0||X>=u.inHeight)continue;let ee=P+B*$[1],Z=O+X*S[2];for(let fe=0;fe<u.outWidth;++fe){let Q=V+fe*u.outChannels,be=fe*u.strideWidth-b;for(let we=0;we<h;++we){let Ne=be+we*m;if(Ne<0||Ne>=u.inWidth)continue;let $e=ee+we*$[2],je=Z+Ne*u.inChannels,He=$e;for(let Re=0;Re<u.inChannels;++Re){let Fe=v[je+Re];for(let Pe=0;Pe<u.outChannels;++Pe)I[Q+Pe]+=Fe*k[He+Pe];He+=u.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var LTe={kernelName:Ep,backendName:"cpu",kernelFunc:MTe};function PTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;lt([s,a],"conv3dBackpropFilterV2");let u=_.computeStrides(s.shape),c=_.computeStrides(a.shape),d=W.computeConv3DInfo(s.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new Nr(d.filterShape,"float32"),x=b.values,[w,v,k,I]=b.strides,S=n.data.get(a.dataId).values,[$,N,T,C]=c,E=n.data.get(s.dataId).values,[M,F,z,H]=u,P=d.padInfo.front,O=d.padInfo.left,L=d.padInfo.top;for(let V=0;V<m;++V){let q=Math.max(0,Math.ceil((P-V)/h)),B=Math.min(d.outDepth,(d.inDepth+P-V)/h),X=V*w;for(let ee=0;ee<g;++ee){let Z=Math.max(0,Math.ceil((L-ee)/p)),fe=Math.min(d.outHeight,(d.inHeight+L-ee)/p),Q=ee*v+X;for(let be=0;be<y;++be){let we=Math.max(0,Math.ceil((O-be)/f)),Ne=Math.min(d.outWidth,(d.inWidth+O-be)/f),$e=be*k+Q;for(let je=0;je<d.inChannels;++je){let He=je*I+$e;for(let Re=0;Re<d.outChannels;++Re){let Fe=0;for(let Pe=0;Pe<d.batchSize;++Pe){let Je=Pe*M,pn=Pe*$;for(let ct=q;ct<B;++ct){let an=(V+ct*h-P)*F+Je,Lt=ct*N+pn;for(let Gt=Z;Gt<fe;++Gt){let Qe=(ee+Gt*p-L)*z+an,It=Gt*T+Lt;for(let mn=we;mn<Ne;++mn){let en=(be+mn*f-O)*H+Qe,on=mn*C+It;Fe+=E[en+je]*S[on+Re]}}}}x[He+Re]=Fe}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var zTe={kernelName:ly,backendName:"cpu",kernelFunc:PTe};function BTe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;lt([s],"conv3dBackpropInputV2");let u=_.computeStrides(s.shape),c=_.computeStrides(a.shape),d=W.computeConv3DInfo(l,a.shape,o,1,i),h=new Nr(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(s.dataId).values,[x,w,v,k]=u,I=n.data.get(a.dataId).values,[S,$,N,T]=c,{batchSize:C,filterDepth:E,filterHeight:M,filterWidth:F,inChannels:z,inDepth:H,inHeight:P,inWidth:O,outChannels:L,outDepth:V,outHeight:q,outWidth:B,strideDepth:X,strideHeight:ee,strideWidth:Z}=d,fe=E-1-d.padInfo.front,Q=M-1-d.padInfo.top,be=F-1-d.padInfo.left;for(let we=0;we<C;++we)for(let Ne=0;Ne<z;++Ne)for(let $e=0;$e<H;++$e){let je=$e-fe,He=Math.max(0,Math.ceil(je/X)),Re=Math.min(V,(E+je)/X);for(let Fe=0;Fe<P;++Fe){let Pe=Fe-Q,Je=Math.max(0,Math.ceil(Pe/ee)),pn=Math.min(q,(M+Pe)/ee);for(let ct=0;ct<O;++ct){let an=ct-be,Lt=Math.max(0,Math.ceil(an/Z)),Gt=Math.min(B,(F+an)/Z),Qe=0;for(let It=He;It<Re;++It){let mn=It*X-je;for(let en=Je;en<pn;++en){let on=en*ee-Pe;for(let Ws=Lt;Ws<Gt;++Ws){let Bi=Ws*Z-an,ha=x*we+w*It+v*en+k*Ws,tu=S*(E-1-mn)+$*(M-1-on)+N*(F-1-Bi)+T*Ne;for(let Es=0;Es<L;++Es){let To=b[ha+Es],De=I[tu+Es];Qe+=To*De}}}}p[f*we+m*$e+g*Fe+y*ct+Ne]=Qe}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}var WTe={kernelName:uy,backendName:"cpu",kernelFunc:BTe},VTe=bn(Ap,e=>Math.cos(e)),UTe={kernelName:Ap,backendName:"cpu",kernelFunc:VTe},GTe=bn(Rp,e=>Math.cosh(e)),HTe={kernelName:Rp,backendName:"cpu",kernelFunc:GTe};function jTe(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=s.shape,f=a.shape[0],[m,g]=o,y=Ot([f,m,g,p],"float32"),b=n.data.get(a.dataId).values,x=n.data.get(i.dataId).values,w=n.data.get(s.dataId).values,v=_.computeStrides(s.shape),k=_.computeStrides(y.shape);for(let I=0;I<f;I++){let S=I*4,$=b[S],N=b[S+1],T=b[S+2],C=b[S+3],E=x[I];if(E>=c)continue;let M=m>1?(T-$)*(d-1)/(m-1):0,F=g>1?(C-N)*(h-1)/(g-1):0;for(let z=0;z<m;z++){let H=m>1?$*(d-1)+z*M:.5*($+T)*(d-1);if(H<0||H>d-1){for(let P=0;P<g;P++)for(let O=0;O<p;O++){let L=O+P*k[2]+z*k[1]+I*k[0];y.values[L]=u}continue}if(l==="bilinear"){let P=Math.floor(H),O=Math.ceil(H),L=H-P;for(let V=0;V<g;V++){let q=g>1?N*(h-1)+V*F:.5*(N+C)*(h-1);if(q<0||q>h-1){for(let Z=0;Z<p;Z++){let fe=Z+V*k[2]+z*k[1]+I*k[0];y.values[fe]=u}continue}let B=Math.floor(q),X=Math.ceil(q),ee=q-B;for(let Z=0;Z<p;Z++){let fe=Z+B*v[2]+P*v[1]+E*v[0],Q=w[fe];fe=Z+X*v[2]+P*v[1]+E*v[0];let be=w[fe];fe=Z+B*v[2]+O*v[1]+E*v[0];let we=w[fe];fe=Z+X*v[2]+O*v[1]+E*v[0];let Ne=w[fe],$e=Q+(be-Q)*ee,je=we+(Ne-we)*ee;fe=Z+V*k[2]+z*k[1]+I*k[0],y.values[fe]=$e+(je-$e)*L}}}else for(let P=0;P<g;++P){let O=g>1?N*(h-1)+P*F:.5*(N+C)*(h-1);if(O<0||O>h-1){for(let q=0;q<p;q++){let B=q+P*k[2]+z*k[1]+I*k[0];y.values[B]=u}continue}let L=Math.round(O),V=Math.round(H);for(let q=0;q<p;q++){let B=q+L*v[2]+V*v[1]+E*v[0],X=q+P*k[2]+z*k[1]+I*k[0];y.values[X]=w[B]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var qTe={kernelName:dy,backendName:"cpu",kernelFunc:jTe};function KTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;lt(s,"cumprod");let l=W.getAxesPermutation([a],s.shape.length),u=s;l!=null&&(u=Ta({inputs:{x:s},backend:n,attrs:{perm:l}}));let c=W.getInnerMostAxes(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=$i(u.dtype,"int32"),h=_.makeOnesTypedArray(_.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){let x=m(y,b);if(b===0)h[x]=i?1:p[x];else{let w=m(y,b-1);h[x]=i?p[w]*h[w]:p[x]*h[w]}}let g=n.makeTensorInfo(u.shape,d,h);if(l!=null){let y=W.getUndoAxesPermutation(l),b=Ta({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),b}return g}var XTe={kernelName:cy,backendName:"cpu",kernelFunc:KTe};function YTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;lt(s,"cumsum");let l=W.getAxesPermutation([a],s.shape.length),u=s;l!=null&&(u=Ta({inputs:{x:s},backend:n,attrs:{perm:l}}));let c=W.getInnerMostAxes(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=$i(u.dtype,"int32"),h=_.makeZerosTypedArray(_.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){let x=m(y,b);if(b===0)h[x]=i?0:p[x];else{let w=m(y,b-1);h[x]=i?p[w]+h[w]:p[x]+h[w]}}let g=n.makeTensorInfo(u.shape,d,h);if(l!=null){let y=W.getUndoAxesPermutation(l),b=Ta({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),b}return g}var ZTe={kernelName:Dp,backendName:"cpu",kernelFunc:YTe};function JTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){let l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=W3(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){let l=n.bufferSync(s),u=n.bufferSync(a),c=p7(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var QTe={kernelName:aw,backendName:"cpu",kernelFunc:JTe};function e_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;_.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*a,h=u*a,p=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*d*h*p),g=0;for(let y=0;y<o;++y)for(let b=0;b<d;++b){let x=Math.floor(b/a),w=b%a;for(let v=0;v<h;++v){let k=Math.floor(v/a),I=v%a,S=(w*a+I)*p;for(let $=0;$<p;++$){let N=$+S+c*(k+u*(x+l*y));m[g++]=f[N]}}}return n.makeTensorInfo([o,d,h,p],s.dtype,m)}var t_e={kernelName:hy,backendName:"cpu",kernelFunc:e_e};function a9(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;lt([s,a],"depthwiseConv2DNative");let c=_.computeStrides(s.shape),d=_.computeStrides(a.shape),h=l;h==null&&(h=[1,1]),_.assert(W.eitherStridesOrDilationsAreOne(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);let p=W.computeConv2DInfo(s.shape,a.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,x=b.left,w=b.top,v=p.outChannels/p.inChannels,k=new Nr(p.outShape,s.dtype),I=n.data.get(s.dataId).values,S=n.data.get(a.dataId).values,$=k.values;for(let N=0;N<p.batchSize;++N){let T=N*c[0],C=N*k.strides[0];for(let E=0;E<p.outHeight;++E){let M=C+E*k.strides[1],F=E*p.strideHeight-w;for(let z=0;z<f;++z){let H=F+z*g;if(H<0||H>=p.inHeight)continue;let P=z*d[0],O=T+H*c[1];for(let L=0;L<p.outWidth;++L){let V=M+L*k.strides[2],q=L*p.strideWidth-x;for(let B=0;B<m;++B){let X=q+B*y;if(X<0||X>=p.inWidth)continue;let ee=P+B*d[1],Z=O+X*p.inChannels,fe=V,Q=ee;for(let be=0;be<p.inChannels;++be){let we=I[Z+be];for(let Ne=0;Ne<v;++Ne)$[fe+Ne]+=we*S[Q+Ne];fe+=v,Q+=v}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var n_e={kernelName:Fp,backendName:"cpu",kernelFunc:a9};function r_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;lt([s,a],"depthwiseConv2dNativeBackpropFilter");let d=W.computeConv2DInfo(s.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new Nr(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,x=d.outChannels/d.inChannels,w=n.data.get(s.dataId).values,v=new Nr(s.shape,s.dtype,w),k=n.data.get(a.dataId).values,I=new Nr(a.shape,a.dtype,k);for(let S=0;S<f;++S){let $=Math.max(0,Math.ceil((b-S)/h)),N=Math.min(d.outHeight,(d.inHeight+b-S)/h);for(let T=0;T<m;++T){let C=Math.max(0,Math.ceil((y-T)/p)),E=Math.min(d.outWidth,(d.inWidth+y-T)/p);for(let M=0;M<d.outChannels;++M){let F=Math.trunc(M/x),z=M%x,H=0;for(let P=0;P<d.batchSize;++P)for(let O=$;O<N;++O){let L=S+O*h-b;for(let V=C;V<E;++V){let q=T+V*p-y;H+=v.get(P,L,q,F)*I.get(P,O,V,M)}}g.set(H,S,T,F,z)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var s_e={kernelName:JC,backendName:"cpu",kernelFunc:r_e};function a_e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;lt([s,a],"depthwiseConv2DNativeBackpropInput");let d=_.computeStrides(s.shape),h=_.computeStrides(a.shape),p=W.computeConv2DInfo(c,a.shape,i,o,l,u,!0),f=new Nr(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(s.dataId).values,[w,v,k]=d,I=n.data.get(a.dataId).values,[S,$,N]=h,{batchSize:T,filterHeight:C,filterWidth:E,inChannels:M,inHeight:F,inWidth:z,outChannels:H,outHeight:P,outWidth:O,strideHeight:L,strideWidth:V}=p,q=C-1-p.padInfo.top,B=E-1-p.padInfo.left,X=H/M;for(let ee=0;ee<T;++ee)for(let Z=0;Z<M;++Z)for(let fe=0;fe<F;++fe){let Q=fe-q,be=Math.max(0,Math.ceil(Q/L)),we=Math.min(P,(C+Q)/L);for(let Ne=0;Ne<z;++Ne){let $e=Ne-B,je=Math.max(0,Math.ceil($e/V)),He=Math.min(O,(E+$e)/V),Re=0;for(let Fe=be;Fe<we;++Fe){let Pe=Fe*L-Q;for(let Je=je;Je<He;++Je){let pn=Je*V-$e,ct=w*ee+v*Fe+k*Je,an=S*(C-1-Pe)+$*(E-1-pn)+N*Z;for(let Lt=0;Lt<X;++Lt){let Gt=Z*X+Lt,Qe=x[ct+Gt],It=I[an+Lt];Re+=Qe*It}}}m[g*ee+y*fe+b*Ne+Z]=Re}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var i_e={kernelName:QC,backendName:"cpu",kernelFunc:a_e};function o_e(e){let{inputs:t,backend:n}=e,{x:r}=t,s=_.sizeFromShape(r.shape),a=n.data.get(r.dataId).values,i=Ot([s,s],r.dtype),o=i.values;for(let u=0;u<a.length;u++)o[u*s+u]=a[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var l_e={kernelName:iw,backendName:"cpu",kernelFunc:o_e},u_e={kernelName:Op,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:w,strideWidth:v,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:$,outShape:N}=W.computeDilation2DInfo(r.shape,s.shape,a,i,"NHWC",o),T=_.sizeFromShape(N),C=N.length,E=_.getArrayFromDType(r.dtype,T);for(let M=0;M<p;++M)for(let F=0;F<y;++F){let z=F*w-x.top;for(let H=0;H<b;++H){let P=H*v-x.left;for(let O=0;O<g;++O){let L=Number.MIN_SAFE_INTEGER;for(let q=0;q<k;++q){let B=z+q*S;if(B>=0&&B<f)for(let X=0;X<I;++X){let ee=P+X*$;if(ee>=0&&ee<m){let Z=_.locToIndex([M,B,ee,O],c,_.computeStrides(r.shape)),fe=_.locToIndex([q,X,O],h,_.computeStrides(s.shape)),Q=u[Z]+d[fe];Q>L&&(L=Q)}}}let V=_.locToIndex([M,F,H,O],C,_.computeStrides(N));E[V]=L}}}return{dataId:l.write(_.toTypedArray(E,r.dtype),N,r.dtype),shape:N,dtype:r.dtype}}},c_e={kernelName:hg,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=_.toNestedArray(r.shape,u.data.get(r.dataId).values),d=_.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:$}=W.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",l);_.assert(a.rank===$.length,()=>`Error in ${hg}, dy must have the same rank as output ${$.length}, but got ${a.rank}`);let N=_.toNestedArray($,u.data.get(a.dataId).values),T=_.makeZerosNestedTypedArray(s.shape,s.dtype);for(let C=0;C<h;++C)for(let E=0;E<g;++E){let M=E*x-b.top;for(let F=0;F<y;++F){let z=F*w-b.left;for(let H=0;H<m;++H){let P=Number.MIN_SAFE_INTEGER,O=0,L=0;for(let V=0;V<v;++V){let q=M+V*I;if(q>=0&&q<p)for(let B=0;B<k;++B){let X=z+B*S;if(X>=0&&X<f){let ee=c[C][q][X][H]+d[V][B][H];ee>P&&(P=ee,O=V,L=B)}}}T[O][L][H]+=N[C][E][F][H]}}}return{dataId:u.write(_.toTypedArray(T,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},d_e={kernelName:dg,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=_.toNestedArray(r.shape,u.data.get(r.dataId).values),d=_.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:$}=W.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",l);_.assert(a.rank===$.length,()=>`Error in ${dg}, dy must have the same rank as output ${$.length}, but got ${a.rank}`);let N=_.toNestedArray($,u.data.get(a.dataId).values),T=_.makeZerosNestedTypedArray(r.shape,r.dtype);for(let C=0;C<h;++C)for(let E=0;E<g;++E){let M=E*x-b.top;for(let F=0;F<y;++F){let z=F*w-b.left;for(let H=0;H<m;++H){let P=Number.MIN_SAFE_INTEGER,O=M<0?0:M,L=z<0?0:z;for(let V=0;V<v;++V){let q=M+V*I;if(q>=0&&q<p)for(let B=0;B<k;++B){let X=z+B*S;if(X>=0&&X<f){let ee=c[C][q][X][H]+d[V][B][H];ee>P&&(P=ee,O=q,L=X)}}}T[C][O][L][H]+=N[C][E][F][H]}}}return{dataId:u.write(_.toTypedArray(T,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Yw(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;lt(s,"sum");let o;s.dtype==="bool"?o=Jc({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):o=Hl({inputs:{x:s},backend:n});let l=o.shape.length,u=_.parseAxisParam(a,o.shape),c=W.getAxesPermutation(u,l),d=u,h=o;c!=null&&(h=Ta({inputs:{x:o},backend:n,attrs:{perm:c}}),d=W.getInnerMostAxes(d.length,l)),W.assertAxesAreInnerMostDims("sum",d,h.shape.length);let[p,f]=W.computeOutAndReduceShapes(h.shape,d),m=W.upcastType(h.dtype,"int32"),g=mS(n,p,m),y=_.sizeFromShape(f),b=n.data.get(g.dataId).values,x=n.data.get(h.dataId).values;for(let w=0;w<b.length;++w){let v=w*y,k=0;for(let I=0;I<y;++I)k+=x[v+I];b[w]=k}if(i){let w=W.expandShapeToKeepDim(g.shape,u),v=g;g=Ln({inputs:{x:g},backend:n,attrs:{shape:w}}),n.disposeIntermediateTensorInfo(v)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(h),g}var h_e={kernelName:Nf,backendName:"cpu",kernelFunc:Yw};function p_e(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=W.decodeEinsumEquation(s,a.length);W.checkEinsumDimSizes(i.length,l,a);let{path:u,steps:c}=W.getEinsumComputePath(o,l),d=c.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let g of c[m]){let{permutationIndices:y,expandDims:b}=W.getEinsumPermutation(p,l[g]),x;W.isIdentityPermutation(y)?x=a[g]:(x=Ta({inputs:{x:a[g]},backend:n,attrs:{perm:y}}),f.push(x));let w=x.shape.slice();for(let v=0;v<b.length;++v)w.splice(b[v],0,1);_.arraysEqual(x.shape,w)||(x=Ln({inputs:{x},backend:n,attrs:{shape:w}}),f.push(x)),h===null?h=x:(h=h2({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=Yw({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}var f_e={kernelName:eN,backendName:"cpu",kernelFunc:p_e};function m_e(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t;lt([r,s],"eluGrad");let a=new Float32Array(_.sizeFromShape(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let u=i[l];u>=0?a[l]=o[l]:a[l]=o[l]*(u+1)}return n.makeTensorInfo(s.shape,"float32",a)}var g_e={kernelName:py,backendName:"cpu",kernelFunc:m_e},y_e=W.ERF_P,b_e=W.ERF_A1,x_e=W.ERF_A2,w_e=W.ERF_A3,v_e=W.ERF_A4,k_e=W.ERF_A5,I_e=bn(fy,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+y_e*n);return t*(1-((((k_e*r+v_e)*r+w_e)*r+x_e)*r+b_e)*r*Math.exp(-n*n))}),S_e={kernelName:fy,backendName:"cpu",kernelFunc:I_e};function bS(e){let{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(_.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),Ln({inputs:{x:s},backend:n,attrs:{shape:o}})}var C_e={kernelName:gy,backendName:"cpu",kernelFunc:bS},N_e=Er((e,t)=>e/t),Q3=ls(Mp,N_e),BA={kernelName:Mp,backendName:"cpu",kernelFunc:Q3};function i9(e,t,n){let r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=_.sizeFromShape(u),d=_.getTypedArrayFromDType("float32",c),h=_.getTypedArrayFromDType("float32",c);for(let g=0;g<s;g++){let y=Zh({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),b=Zh({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,a]}}),x=Wa({inputs:{real:y,imag:b},backend:n}),{real:w,imag:v}=$_e(x,t,n),k=W.mergeRealAndImagArrays(w,v);for(let I=0;I<a;I++){let S=W.getComplexWithIndex(k,I);d[g*a+I]=S.real,h[g*a+I]=S.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x)}let p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=Wa({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function $_e(e,t,n){let r=_.sizeFromShape(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(T_e(r)){let o=WA(a,i,r,t,n),l=[e.shape[0],e.shape[1]];if(t){let u=n.makeTensorInfo(l,"float32",o.real),c=n.makeTensorInfo(l,"float32",o.imag),d=n.makeTensorInfo([],"float32",_.createScalarValue(r,"float32")),h=Hl({inputs:{x:d},backend:n}),p=BA.kernelFunc({inputs:{a:u,b:d},backend:n}),f=BA.kernelFunc({inputs:{a:c,b:h},backend:n}),m=n.data.get(p.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return o}else{let o=W.mergeRealAndImagArrays(a,i),l=__e(o,r,t);return W.splitRealAndImagArrays(l)}}function T_e(e){return(e&e-1)===0}function WA(e,t,n,r,s){if(n===1)return{real:e,imag:t};let a=W.mergeRealAndImagArrays(e,t),i=n/2,o=W.complexWithEvenIndex(a),l=o.real,u=o.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),p=Wa({inputs:{real:d,imag:h},backend:s}),f=W.complexWithOddIndex(a),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),x=s.makeTensorInfo(y,"float32",g),w=Wa({inputs:{real:b,imag:x},backend:s}),v=WA(l,u,i,r,s),k=v.real,I=v.imag,S=[k.length],$=s.makeTensorInfo(S,"float32",k),N=s.makeTensorInfo(S,"float32",I),T=Wa({inputs:{real:$,imag:N},backend:s}),C=WA(m,g,i,r,s),E=C.real,M=C.imag,F=[E.length],z=s.makeTensorInfo(F,"float32",E),H=s.makeTensorInfo(F,"float32",M),P=Wa({inputs:{real:z,imag:H},backend:s}),O=W.exponents(n,r),L=[O.real.length],V=s.makeTensorInfo(L,"float32",O.real),q=s.makeTensorInfo(L,"float32",O.imag),B=Wa({inputs:{real:V,imag:q},backend:s}),X=h2({inputs:{a:B,b:P},backend:s}),ee=$g({inputs:{a:T,b:X},backend:s}),Z=Y3({inputs:{a:T,b:X},backend:s}),fe=Yh({inputs:{input:ee},backend:s}),Q=Yh({inputs:{input:Z},backend:s}),be=Tg({inputs:{input:ee},backend:s}),we=Tg({inputs:{input:Z},backend:s}),Ne=_g({inputs:[fe,Q],backend:s,attrs:{axis:0}}),$e=_g({inputs:[be,we],backend:s,attrs:{axis:0}}),je=s.data.get(Ne.dataId).values,He=s.data.get($e.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(X),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(Z),s.disposeIntermediateTensorInfo(fe),s.disposeIntermediateTensorInfo(be),s.disposeIntermediateTensorInfo(Q),s.disposeIntermediateTensorInfo(we),s.disposeIntermediateTensorInfo(Ne),s.disposeIntermediateTensorInfo($e),{real:je,imag:He}}function __e(e,t,n){let r=new Float32Array(t*2);for(let s=0;s<t;s++){let a=0,i=0;for(let o=0;o<t;o++){let l=W.exponent(s*o,t,n),u=W.getComplexWithIndex(e,o);a+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}n&&(a/=t,i/=t),W.assignToTypedArray(r,a,i,s)}return r}function E_e(e){let{inputs:t,backend:n}=e,{input:r}=t,s=_.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=Ln({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=i9(o,!1,n),u=Ln({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var A_e={kernelName:tN,backendName:"cpu",kernelFunc:E_e};function eL(e){let{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||_.inferDtype(s),o=_.getArrayFromDType(i,_.sizeFromShape(r));return D_e(o,s),t.makeTensorInfo(r,i,o)}var R_e={kernelName:ow,backendName:"cpu",kernelFunc:eL};function D_e(e,t,n){e.fill(t)}var F_e={kernelName:yy,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,s=n,a=_.getTypedArrayFromDType(r.dtype,_.sizeFromShape(r.shape)),[i,o,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let d=0;d<i;d++){let h=d*l*o*u;for(let p=0;p<o;p++){let f=p*(l*u);for(let m=0;m<l;m++){let g=m*u;for(let y=0;y<u;y++){let b=Math.round(l-m-1),x=h+f+g+y,w=c[x];if(b>=0&&b<l){let v=b*u,k=h+f+v+y;w=c[k]}a[x]=w}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function O_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=s9({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){let g=m;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let y=Ln({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=$g({inputs:{a:m,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else m=$g({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(p){let g=m;if(c==="NCHW"&&p==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let y=Ln({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=yS(n,m,p,y,f),n.disposeIntermediateTensorInfo(y)}else m=yS(n,m,p,o,f);n.disposeIntermediateTensorInfo(g)}return m}var M_e={kernelName:Ph,backendName:"cpu",kernelFunc:O_e};function L_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=a9({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){let g=m;m=$g({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(p){let g=m;m=yS(n,m,p,o,f),n.disposeIntermediateTensorInfo(g)}return m}var P_e={kernelName:zh,backendName:"cpu",kernelFunc:L_e};function z_e(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=_.sizeFromShape(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,d]=W.prepareAndValidate(r,s);if(u===0)return n.makeTensorInfo(l,r.dtype,[]);let h=n.data.get(s.dataId).values,p=n.bufferSync(r),f=k7(h,p,r.dtype,u,o,c,d,r.shape,a);return n.makeTensorInfo(l,r.dtype,f.values)}var B_e={kernelName:xy,backendName:"cpu",kernelFunc:z_e};function W_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;lt([s,a],"gatherV2");let l=_.parseAxisParam(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let w=0;w<u.length;++w){let v=u[w];_.assert(v<=c-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${c-1}]`)}let d=o;o==null&&(d=0);let h=_.sizeFromShape(a.shape),p=W.segment_util.collectGatherOpShapeInfo(s,a,l,d),f=Ln({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Ln({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=n.bufferSync(f),x=I7(b,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,x.dtype,x.values)}var V_e={kernelName:by,backendName:"cpu",kernelFunc:W_e};function U_e(e){let{inputs:t,backend:n}=e,{input:r}=t,s=_.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=Ln({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=i9(o,!0,n),u=Ln({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var G_e={kernelName:nN,backendName:"cpu",kernelFunc:U_e},H_e=bn(Hp,e=>Number.isFinite(e)?1:0,"bool"),j_e={kernelName:Hp,backendName:"cpu",kernelFunc:H_e},q_e=bn(jp,e=>Math.abs(e)===1/0?1:0,"bool"),K_e={kernelName:jp,backendName:"cpu",kernelFunc:q_e},X_e=bn(qp,e=>Number.isNaN(e)?1:0,"bool"),Y_e={kernelName:qp,backendName:"cpu",kernelFunc:X_e};function Z_e(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=T7(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}var J_e={kernelName:Iy,backendName:"cpu",kernelFunc:Z_e},Q_e=bn(Yp,e=>Math.log1p(e)),eEe={kernelName:Yp,backendName:"cpu",kernelFunc:Q_e},tEe=Er((e,t)=>e&&t),nEe=ls(Sy,tEe,null,"bool"),rEe={kernelName:Sy,backendName:"cpu",kernelFunc:nEe},sEe=bn(Cy,e=>e?0:1,"bool"),aEe={kernelName:Cy,backendName:"cpu",kernelFunc:sEe},iEe=Er((e,t)=>e||t),oEe=ls(Ny,iEe,null,"bool"),lEe={kernelName:Ny,backendName:"cpu",kernelFunc:oEe};function uEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;lt(s,"LRN");let u=s.shape[3],c=u-1,d=n.data.get(s.dataId).values,h=_.sizeFromShape(s.shape),p=new Float32Array(h);function f(m){let g=m%u,y=m-g+Math.max(0,g-a),b=m-g+Math.min(g+a,c),x=0;for(;y<=b;y++){let w=d[y];x+=w*w}return x}for(let m=0;m<h;m++){let g=f(m),y=d[m]*Math.pow(i+o*g,-l);p[m]=y}return n.makeTensorInfo(s.shape,s.dtype,p)}var cEe={kernelName:Zp,backendName:"cpu",kernelFunc:uEe};function dEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;lt(i,"LRNGrad");let d=_.sizeFromShape(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){let x=b%h,w=b-x+Math.max(0,x-o),v=b-x+Math.min(h,x+o+1),k=0;for(let I=w;I<v;I++)k+=Math.pow(f[I],2);k=u*k+l;for(let I=w;I<v;I++){let S=-2*u*c*f[I]*m[b]/k;b===I&&(S+=Math.pow(k,-c)),S*=p[b],g[I]+=S}}return n.makeTensorInfo(i.shape,s.dtype,g)}var hEe={kernelName:$y,backendName:"cpu",kernelFunc:dEe};function o9(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n,l=s.shape,u=l.length,c=_.parseAxisParam(a,l),d=c,h=W.getAxesPermutation(d,u),p=o.data.get(s.dataId).values;if(h!=null){let w=new Array(u);for(let v=0;v<w.length;v++)w[v]=l[h[v]];p=G3(p,l,s.dtype,h,w),d=W.getInnerMostAxes(d.length,u),l=w}lt(s,"max"),W.assertAxesAreInnerMostDims("max",d,u);let[f,m]=W.computeOutAndReduceShapes(l,d),g=_.sizeFromShape(m),y=E7(p,g,f,s.dtype),b=o.write(y,f,s.dtype),x=f;return i&&(x=W.expandShapeToKeepDim(f,c)),{dataId:b,shape:x,dtype:s.dtype}}var pEe={kernelName:Jp,backendName:"cpu",kernelFunc:o9};function fEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;lt(s,"maxPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;_.assert(W.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=W.computePool2DInfo(s.shape,a,i,u,o,l),d;if(c.filterWidth===1&&c.filterHeight===1&&_.arraysEqual(c.inShape,c.outShape))d=Hl({inputs:{x:s},backend:n});else{let h=n.data.get(s.dataId).values,p=_.computeStrides(s.shape),f=J3(h,s.shape,s.dtype,p,c,"max");d=n.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}var mEe={kernelName:ef,backendName:"cpu",kernelFunc:fEe};function gEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;lt(s,"maxPool3d");let c=W.computePool3DInfo(s.shape,a,i,1,o,l,u),d=n.data.get(s.dataId).values,h=r9(d,s.shape,s.dtype,_.computeStrides(s.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}var yEe={kernelName:Ty,backendName:"cpu",kernelFunc:gEe};function bEe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;lt([s,a],"maxPool3DGrad");let c=W.computePool3DInfo(a.shape,i,o,1,l,u),d=n.bufferSync(a),h=lTe(d,c),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,v=c.effectiveFilterWidth,k=x-1-c.padInfo.front,I=v-1-c.padInfo.left,S=w-1-c.padInfo.top,$=Ot(a.shape,"float32"),N=n.bufferSync(s);for(let T=0;T<c.batchSize;++T)for(let C=0;C<c.inChannels;++C)for(let E=0;E<c.inDepth;++E)for(let M=0;M<c.inHeight;++M)for(let F=0;F<c.inWidth;++F){let z=E-k,H=M-S,P=F-I,O=0;for(let L=0;L<x;L+=g){let V=(z+L)/p;if(!(V<0||V>=c.outDepth||Math.floor(V)!==V))for(let q=0;q<w;q+=y){let B=(H+q)/f;if(!(B<0||B>=c.outHeight||Math.floor(B)!==B))for(let X=0;X<v;X+=b){let ee=(P+X)/m;if(ee<0||ee>=c.outWidth||Math.floor(ee)!==ee)continue;let Z=x*w*v-1-h.get(T,V,B,ee,C),fe=L*w*v+q*v+X,Q=Z===fe?1:0;if(Q===0)continue;let be=N.get(T,V,B,ee,C);O+=be*Q}}}$.set(O,T,E,M,F,C)}return n.makeTensorInfo($.shape,$.dtype,$.values)}var xEe={kernelName:lw,backendName:"cpu",kernelFunc:bEe};function wEe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;lt([a,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=W.computePool2DInfo(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=Ot(h.outShape,o.dtype,n9(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,x=h.effectiveFilterHeight,w=h.effectiveFilterWidth,v=w-1-h.padInfo.left,k=x-1-h.padInfo.top,I=Ot(o.shape,"float32"),S=n.data.get(s.dataId).values,$=Ot(s.shape,"float32",S);for(let N=0;N<h.batchSize;++N)for(let T=0;T<h.inChannels;++T)for(let C=0;C<h.inHeight;++C)for(let E=0;E<h.inWidth;++E){let M=C-k,F=E-v,z=0;for(let H=0;H<x;H+=y){let P=(M+H)/m;if(!(P<0||P>=h.outHeight||Math.floor(P)!==P))for(let O=0;O<w;O+=b){let L=(F+O)/g;if(L<0||L>=h.outWidth||Math.floor(L)!==L)continue;let V=x*w-1-f.get(N,P,L,T),q=H*w+O,B=V===q?1:0;if(B===0)continue;let X=$.get(N,P,L,T);z+=X*B}}I.set(z,N,C,E,T)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var vEe={kernelName:sN,backendName:"cpu",kernelFunc:wEe};function kEe(e,t,n,r,s){let a=_.computeStrides(t),i=J3(e,t,n,a,s,"max"),o=n9(e,t,n,s,!0,r);return[i.values,o.values]}var IEe={kernelName:aN,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;lt(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,c=W.computePool2DInfo(r.shape,s,a,[1,1],i),[d,h]=kEe(u,r.shape,r.dtype,o,c),p=l.write(d,c.outShape,r.dtype),f=l.write(h,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};function SEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=_.parseAxisParam(a,s.shape),l=W.computeOutAndReduceShapes(s.shape,o)[1],u=_.sizeFromShape(l),c=[],d=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(d);let h=Jc({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});c.push(h);let p=Q3({inputs:{a:h,b:d},backend:n});c.push(p);let f=Yw({inputs:{x:p},backend:n,attrs:{axis:a,keepDims:i}});return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var CEe={kernelName:tf,backendName:"cpu",kernelFunc:SEe};function NEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;lt(s,"min");let o=_.parseAxisParam(a,s.shape),l=o,u=W.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=Ta({inputs:{x:s},backend:n,attrs:{perm:u}}),l=W.getInnerMostAxes(l.length,s.shape.length)),W.assertAxesAreInnerMostDims("min",l,c.shape.length);let[d,h]=W.computeOutAndReduceShapes(c.shape,l),p=_.sizeFromShape(h),f=_.makeZerosTypedArray(_.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let b=y*p,x=m[b];for(let w=0;w<p;++w){let v=m[b+w];(Number.isNaN(v)||v<x)&&(x=v)}f[y]=x}u!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let y=W.expandShapeToKeepDim(d,o),b=Ln({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var $Ee={kernelName:nf,backendName:"cpu",kernelFunc:NEe};function TEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;lt(s,"mirrorPad");let o=a.map((b,x)=>b[0]+s.shape[x]+b[1]),l=a.map(b=>b[0]),u=a.map((b,x)=>b[0]+s.shape[x]),c=i==="reflect"?0:1,d=n.data.get(s.dataId).values,h=s.shape.length,p=_.computeStrides(s.shape),f=_.sizeFromShape(o),m=o.length,g=_.computeStrides(o),y=_.getTypedArrayFromDType(s.dtype,f);for(let b=0;b<f;b++){let x=_.indexToLoc(b,m,g);for(let v=0;v<m;v++)x[v]<l[v]?x[v]=l[v]*2-x[v]-c:x[v]>=u[v]&&(x[v]=(u[v]-1)*2-x[v]+c);x=x.map((v,k)=>v-l[k]);let w=_.locToIndex(x,h,p);y[b]=d[w]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}var _Ee={kernelName:sf,backendName:"cpu",kernelFunc:TEe},EEe=Er((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),AEe=ls(_y,EEe),REe={kernelName:_y,backendName:"cpu",kernelFunc:AEe},DEe=fd(HC());function l9(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length,o=a;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=_.parseAxisParam([o],s.shape),u=o9({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=W.expandShapeToKeepDim(u.shape,l),d=Ln({inputs:{x:u},backend:n,attrs:{shape:c}}),h=Y3({inputs:{a:s,b:d},backend:n}),p=b7({inputs:{x:h},backend:n}),f=Yw({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=Ln({inputs:{x:f},backend:n,attrs:{shape:c}}),g=Q3({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var FEe={kernelName:$f,backendName:"cpu",kernelFunc:l9};function OEe(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;lt(s,"multinomial");let l=o?s:l9({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,a],p=_.makeZerosTypedArray(_.sizeFromShape(h),"int32");for(let f=0;f<u;++f){let m=f*c,g=new Float32Array(c-1);g[0]=d[m];for(let x=1;x<g.length;++x)g[x]=g[x-1]+d[m+x];let y=DEe.alea(i.toString()),b=f*a;for(let x=0;x<a;++x){let w=y();p[b+x]=g.length;for(let v=0;v<g.length;v++)if(w<g[v]){p[b+x]=v;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}var MEe={kernelName:Ey,backendName:"cpu",kernelFunc:OEe},LEe=Yl.nonMaxSuppressionV3Impl;function PEe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;lt(s,"NonMaxSuppression");let u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d}=LEe(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var zEe={kernelName:Dy,backendName:"cpu",kernelFunc:PEe},BEe=Yl.nonMaxSuppressionV4Impl;function WEe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;lt(s,"NonMaxSuppressionPadded");let c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:h,validOutputs:p}=BEe(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}var VEe={kernelName:Fy,backendName:"cpu",kernelFunc:WEe},UEe=Yl.nonMaxSuppressionV5Impl;function GEe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;lt(s,"NonMaxSuppressionWithScore");let c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=UEe(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var HEe={kernelName:Oy,backendName:"cpu",kernelFunc:GEe};function jEe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r;lt(s,"oneHot");let u=_.sizeFromShape(s.shape),c=new Float32Array(u*i);c.fill(l);let d=n.data.get(s.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}var qEe={kernelName:of,backendName:"cpu",kernelFunc:jEe};function xS(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let s=Yh({inputs:{input:r},backend:n}),a=xS({inputs:{x:s},backend:n}),i=Tg({inputs:{input:r},backend:n}),o=xS({inputs:{x:i},backend:n}),l=Wa({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return eL({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var KEe={kernelName:tb,backendName:"cpu",kernelFunc:xS};function u9(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let s=Yh({inputs:{input:r},backend:n}),a=u9({inputs:{x:s},backend:n}),i=Tg({inputs:{input:r},backend:n}),o=xS({inputs:{x:i},backend:n}),l=Wa({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return eL({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var XEe={kernelName:My,backendName:"cpu",kernelFunc:u9};function c9(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return bS({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,i=t[0].dtype;t.forEach(c=>{_.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),_.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(c=>{let d=bS({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=_g({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var YEe={kernelName:Ly,backendName:"cpu",kernelFunc:c9};function ZEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;lt(s,"pad");let o=a.map((y,b)=>y[0]+s.shape[b]+y[1]),l=a.map(y=>y[0]),u=n.data.get(s.dataId).values,c=_.sizeFromShape(s.shape),d=s.shape.length,h=_.computeStrides(s.shape),p=_.sizeFromShape(o),f=o.length,m=_.computeStrides(o),g=_.getTypedArrayFromDType(s.dtype,p);i!==0&&g.fill(i);for(let y=0;y<c;y++){let b=_.indexToLoc(y,d,h).map((w,v)=>w+l[v]),x=_.locToIndex(b,f,m);g[x]=u[y]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}var d9={kernelName:lf,backendName:"cpu",kernelFunc:ZEe},JEe=Er((e,t)=>Math.pow(e,t)),QEe=ls(uf,JEe),eAe={kernelName:uf,backendName:"cpu",kernelFunc:QEe};function tAe(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,o=s.map(g=>n.data.get(g.dataId).values),l=s.map(g=>g.shape),u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,[d,h,p]=M7(o,l,u,a.shape,a.dtype,c,i.shape),f=d.map(g=>n.makeTensorInfo([g.length],"int32",g)),m=n.makeTensorInfo(p,a.dtype,h);return f.concat([m])}var nAe={kernelName:iN,backendName:"cpu",kernelFunc:tAe};function rAe(e){let{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=L7(i,r.shape,r.dtype,o,s.shape,l,a.shape),d=n.makeTensorInfo([u.length],"int32",u),h=n.makeTensorInfo([c.length],r.dtype,c);return[d,h]}var sAe={kernelName:oN,backendName:"cpu",kernelFunc:rAe};function aAe(e){let{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=o.map(g=>n.data.get(g.dataId).values),p=o.map(g=>g.shape),[f,m]=P7(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}var iAe={kernelName:lN,backendName:"cpu",kernelFunc:aAe};function oAe(e){let{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=H3(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}var lAe={kernelName:uw,backendName:"cpu",kernelFunc:oAe},uAe=bn(hf,e=>1/e),cAe={kernelName:hf,backendName:"cpu",kernelFunc:uAe};function dAe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;lt(s,"resizeBilinear");let l=_.computeStrides(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(_.sizeFromShape([d,u,c,f])),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],x=0,w=y[0]/b[0],v=y[1]/b[1];for(let k=0;k<d;k++)for(let I=0;I<u;I++){let S;i?S=w*(I+.5)-.5:S=w*I;let $=Math.max(0,Math.floor(S)),N=S-$,T=Math.min(h-1,Math.ceil(S)),C=k*l[0]+$*l[1],E=k*l[0]+T*l[1];for(let M=0;M<c;M++){let F;i?F=v*(M+.5)-.5:F=v*M;let z=Math.max(0,Math.floor(F)),H=F-z,P=Math.min(p-1,Math.ceil(F)),O=C+z*l[2],L=E+z*l[2],V=C+P*l[2],q=E+P*l[2];for(let B=0;B<f;B++){let X=m[O+B],ee=m[L+B],Z=m[V+B],fe=m[q+B],Q=X+(Z-X)*H,be=ee+(fe-ee)*H,we=Q+(be-Q)*N;g[x++]=we}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}var hAe={kernelName:mf,backendName:"cpu",kernelFunc:dAe};function pAe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;lt([a,s],"resizeBilinearGrad");let o=_.computeStrides(s.shape),[l,u,c,d]=s.shape,[,h,p]=a.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(a.dataId).values,w=0;for(let v=0;v<l;v++){let k=v*o[0];for(let I=0;I<h;I++){let S=I*y,$=Math.floor(S),N=Math.min(Math.ceil(S),u-1),T=k+$*o[1],C=k+N*o[1],E=S-$,M=1-E;for(let F=0;F<p;F++){let z=F*b,H=Math.floor(z),P=Math.min(Math.ceil(z),c-1),O=z-H,L=1-O,V=T+H*o[2],q=T+P*o[2],B=C+H*o[2],X=C+P*o[2],ee=M*L,Z=M*O,fe=E*L,Q=E*O;for(let be=0;be<d;be++){let we=x[w++];f[V+be]+=we*ee,f[q+be]+=we*Z,f[B+be]+=we*fe,f[X+be]+=we*Q}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}var fAe={kernelName:By,backendName:"cpu",kernelFunc:pAe};function mAe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;lt(s,"resizeNearestNeighbor");let l=_.computeStrides(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(d*u*c*f),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],x=y[0]/b[0],w=y[1]/b[1],v=0;for(let k=0;k<d;k++){let I=k*l[0];for(let S=0;S<u;S++){let $=i?x*(S+.5):x*S,N=Math.min(h-1,a?Math.round($):Math.floor($));i&&(N=Math.max(0,N));let T=I+N*l[1];for(let C=0;C<c;C++){let E=i?w*(C+.5):w*C,M=Math.min(p-1,a?Math.round(E):Math.floor(E));i&&(M=Math.max(0,M));let F=T+M*l[2];for(let z=0;z<f;z++){let H=m[F+z];g[v++]=H}}}}return n.makeTensorInfo([d,u,c,f],s.dtype,g)}var gAe={kernelName:ff,backendName:"cpu",kernelFunc:mAe};function yAe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;lt([a,s],"resizeNearestNeighborGrad");let o=_.computeStrides(s.shape),l=_.computeStrides(a.shape),[u,c,d,h]=s.shape,[,p,f]=a.shape,m=new Float32Array(u*c*d*h),g=n.data.get(a.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=y[0]/b[0],w=y[1]/b[1],v=1/x,k=1/w,I=Math.ceil(v)*2+2,S=Math.ceil(k)*2+2;for(let $=0;$<u;$++){let N=$*o[0];for(let T=0;T<c;T++){let C=N+T*o[1],E=Math.floor(T*v),M=Math.floor(E-I/2);for(let F=0;F<d;F++){let z=C+F*o[2],H=Math.floor(F*k),P=Math.floor(H-S/2);for(let O=0;O<h;O++){let L=0;for(let V=0;V<I;V++){let q=V+M;if(q<0||q>=p)continue;let B=N+q*l[1],X=q*x,ee=Math.min(c-1,i?Math.round(X):Math.floor(X));if(T===ee)for(let Z=0;Z<S;Z++){let fe=Z+P;if(fe<0||fe>=f)continue;let Q=B+fe*l[2],be=fe*w,we=Math.min(d-1,i?Math.round(be):Math.floor(be));F===we&&(L+=g[Q+O])}}m[z+O]=L}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}var bAe={kernelName:zy,backendName:"cpu",kernelFunc:yAe};function xAe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;lt(s,"reverse");let i=s.shape.length,o=_.parseAxisParam(a,s.shape);if(i===0)return Hl({inputs:{x:s},backend:n});let l=new Nr(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){let d=l.indexToLoc(c),h=d.slice();o.forEach(p=>h[p]=s.shape[p]-1-h[p]),l.set(u.get(...h),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var wAe={kernelName:yf,backendName:"cpu",kernelFunc:xAe},vAe={kernelName:nb,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=_.getTypedArrayFromDType(r.dtype,_.sizeFromShape(r.shape)),[u,c,d,h]=r.shape,[p,f]=W.getImageCenter(i,c,d),m=255,g=Math.sin(s),y=Math.cos(s),b=o.data.get(r.dataId).values;for(let x=0;x<u;x++){let w=x*d*c*h;for(let v=0;v<c;v++){let k=v*(d*h);for(let I=0;I<d;I++){let S=I*h;for(let $=0;$<h;$++){let N=[u,v,I,$],T=N[2],C=N[1],E=(T-p)*y-(C-f)*g,M=(T-p)*g+(C-f)*y;E=Math.round(E+p),M=Math.round(M+f);let F=a;if(typeof a!="number"&&($===3?F=m:F=a[$]),E>=0&&E<d&&M>=0&&M<c){let H=M*(d*h),P=E*h,O=w+H+P+$;F=b[O]}let z=w+k+S+$;l[z]=F}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},kAe=bn(bf,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),IAe={kernelName:bf,backendName:"cpu",kernelFunc:kAe};function SAe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=W.calculateShapes(a,s,i),h=!0,p=n.bufferSync(s),f=n.bufferSync(a),m=bh(p,f,i,d,u,l,o,c,0,h);return n.makeTensorInfo(i,m.dtype,m.values)}var CAe={kernelName:Wy,backendName:"cpu",kernelFunc:SAe};function NAe(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function $Ae(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}function TAe(e,t,n,r,s,a){let i=_.getArrayFromDType("int32",n*s);for(let o=0;o<n;++o){let l=e.slice(o*r,(o+1)*r),u=o*s;for(let c=0;c<s;++c)i[u+c]=a==="left"?NAe(l,t[c+u]):$Ae(l,t[c+u])}return i}function _Ae(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=TAe(o,l,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",u)}var EAe={kernelName:Uy,backendName:"cpu",kernelFunc:_Ae};function AAe(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;lt([r,s,a],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=$i(s.dtype,a.dtype),d=_.makeZerosTypedArray(_.sizeFromShape(s.shape),c),h=0,p=i===0||i>1||s.shape.length===1?1:_.sizeFromShape(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<p;m++)o[f]===1?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(s.shape,c,d)}var RAe={kernelName:Gy,backendName:"cpu",kernelFunc:AAe},DAe=W.SELU_SCALEALPHA,FAe=W.SELU_SCALE,OAe=bn(wf,e=>e>=0?FAe*e:DAe*(Math.exp(e)-1)),MAe={kernelName:wf,backendName:"cpu",kernelFunc:OAe},LAe=bn(kf,e=>e<0?-1:e>0?1:0),PAe={kernelName:kf,backendName:"cpu",kernelFunc:LAe},zAe=bn(vf,e=>Math.sin(e)),BAe={kernelName:vf,backendName:"cpu",kernelFunc:zAe},WAe=bn(jy,e=>Math.sinh(e)),VAe={kernelName:jy,backendName:"cpu",kernelFunc:WAe},UAe=11920928955078125e-23,oU=Math.log(UAe)+2,GAe=bn(Sf,e=>{let t=e>-oU,n=e<oU,r=Math.exp(e),s;return n?s=r:t?s=e:s=Math.log(1+r),s}),HAe={kernelName:Sf,backendName:"cpu",kernelFunc:GAe};function jAe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;lt([s],"spaceToBatchND");let o=_.sizeFromShape(a),l=[[0,0]];l.push(...i);for(let g=1+a.length;g<s.shape.length;++g)l.push([0,0]);let u=d9.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=W.getReshaped(u.shape,a,o,!1),d=W.getPermuted(c.length,a.length,!1),h=W.getReshapedPermuted(u.shape,a,o,!1),p=Ln({inputs:{x:u},backend:n,attrs:{shape:c}}),f=Ta({inputs:{x:p},backend:n,attrs:{perm:d}}),m=Ln({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}var qAe={kernelName:qy,backendName:"cpu",kernelFunc:jAe};function KAe(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=W7(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var XAe={kernelName:cw,backendName:"cpu",kernelFunc:KAe};function YAe(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,d]=V7(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var ZAe={kernelName:Xy,backendName:"cpu",kernelFunc:YAe};function JAe(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=j3(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var QAe={kernelName:dw,backendName:"cpu",kernelFunc:JAe};function eRe(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=j3(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}var tRe={kernelName:hw,backendName:"cpu",kernelFunc:eRe};function nRe(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=W.calculateShapes(a,s,o),p=!1,f=n.bufferSync(s),m;switch(a.dtype){case"bool":{let g=n.bufferSync(a),y=!!n.data.get(i.dataId).values[0];m=bh(f,g,o,h,c,u,l,d,y,p);break}case"float32":{let g=n.bufferSync(a),y=n.data.get(i.dataId).values[0];m=bh(f,g,o,h,c,u,l,d,y,p);break}case"int32":{let g=n.bufferSync(a),y=n.data.get(i.dataId).values[0];m=bh(f,g,o,h,c,u,l,d,y,p);break}case"string":{let g=n.bufferSync(a),y=_.decodeString(n.data.get(i.dataId).values[0]);m=bh(f,g,o,h,c,u,l,d,y,p);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}var rRe={kernelName:Yy,backendName:"cpu",kernelFunc:nRe};function sRe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=_.parseAxisParam(i,s.shape)[0],l=W.prepareSplitSize(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{let h=[...c];h[o]=d;let p=Zh({inputs:{x:s},backend:n,attrs:{begin:u,size:h}});return u[o]+=d,p})}var aRe={kernelName:Ky,backendName:"cpu",kernelFunc:sRe},iRe={kernelName:pw,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;lt(n,"square");let s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let i=0;i<s.length;++i){let o=s[i];a[i]=o*o}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},oRe=bn(xd,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),lRe={kernelName:xd,backendName:"cpu",kernelFunc:oRe};function uRe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;lt(s,"stridedSlice");let{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=Br.sliceInfo(s.shape,a,i,o,l,u,c,d,h),v;if(m)v=Ln({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){_.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let k=Br.computeOutShape(b,x,w),I=Zh({inputs:{x:s},backend:n,attrs:{begin:b,size:k}});v=Ln({inputs:{x:I},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(I)}else{let k=n.bufferSync(s),I=H7(p,k,w,b);v=n.makeTensorInfo(f,I.dtype,I.values)}return v}var cRe={kernelName:Zy,backendName:"cpu",kernelFunc:uRe};function dRe(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=q3(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var hRe={kernelName:mw,backendName:"cpu",kernelFunc:dRe};function pRe(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=K3(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var fRe={kernelName:gw,backendName:"cpu",kernelFunc:pRe};function mRe(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(a.dataId).values,o=X3(i,s);return n.makeTensorInfo(a.shape,"int32",o)}var gRe={kernelName:yw,backendName:"cpu",kernelFunc:mRe},yRe=bn(Ef,e=>Math.tan(e)),bRe={kernelName:Ef,backendName:"cpu",kernelFunc:yRe},xRe=bn(Af,e=>Math.tanh(e)),wRe={kernelName:Af,backendName:"cpu",kernelFunc:xRe};function vRe(e){let{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=W.calculateShapes(a,s,r.shape),d=!1,h=n.bufferSync(s),p=n.bufferSync(a),f=n.bufferSync(r),m=bh(h,p,r.shape,c,l,o,i,u,f,d);return n.makeTensorInfo(r.shape,m.dtype,m.values)}var kRe={kernelName:Vy,backendName:"cpu",kernelFunc:vRe};function IRe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;lt(s,"tile");let i=q7(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var SRe={kernelName:bd,backendName:"cpu",kernelFunc:IRe};function CRe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;lt(s,"topk");let o=n.data.get(s.dataId).values,[l,u]=X7(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var NRe={kernelName:Jy,backendName:"cpu",kernelFunc:CRe};function $Re(e){let{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=s.shape,[f,m]=u??[d,h],g=[c,f,m,p],y=_.computeStrides(s.shape),b=y[0],x=y[1],w=y[2],v=_.computeStrides(g),k=v[0],I=v[1],S=v[2],$=_.getTypedArrayFromDType(s.dtype,_.sizeFromShape(g));$.fill(l);let N=r.data.get(s.dataId).values,T=r.data.get(a.dataId).values;for(let C=0;C<c;++C){let E=a.shape[0]===1?T:T.subarray(C*8,C*8+8);for(let M=0;M<f;++M)for(let F=0;F<m;++F)for(let z=0;z<p;++z){let H,P=E[6]*F+E[7]*M+1;if(P===0)continue;let O=(E[0]*F+E[1]*M+E[2])/P,L=(E[3]*F+E[4]*M+E[5])/P,V=lU(O,h,o),q=lU(L,d,o);switch(i){case"nearest":H=DRe(N,d,h,b,x,w,C,q,V,z,l);break;case"bilinear":H=FRe(N,d,h,b,x,w,C,q,V,z,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let B=C*k+M*I+F*S+z;$[B]=H}return r.makeTensorInfo(g,s.dtype,$)}return{dataId:r.write($,g,s.dtype),shape:s.shape,dtype:s.dtype}}var TRe={kernelName:Qy,backendName:"cpu",kernelFunc:$Re};function lU(e,t,n){switch(n){case"reflect":return _Re(e,t);case"wrap":return ERe(e,t);case"nearest":return RRe(e,t);case"constant":default:return ARe(e)}}function _Re(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return _.clamp(0,n,t-1)}function ERe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return _.clamp(0,n,t-1)}function ARe(e,t){return e}function RRe(e,t){return _.clamp(0,e,t-1)}function bx(e,t,n,r,s,a,i,o,l,u,c){let d=i*r+o*s+l*a+u;return 0<=o&&o<t&&0<=l&&l<n?e[d]:c}function DRe(e,t,n,r,s,a,i,o,l,u,c){let d=Math.round(o),h=Math.round(l);return bx(e,t,n,r,s,a,i,d,h,u,c)}function FRe(e,t,n,r,s,a,i,o,l,u,c){let d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1,m=(f-l)*bx(e,t,n,r,s,a,i,d,h,u,c)+(l-h)*bx(e,t,n,r,s,a,i,d,f,u,c),g=(f-l)*bx(e,t,n,r,s,a,i,p,h,u,c)+(l-h)*bx(e,t,n,r,s,a,i,p,f,u,c);return(p-o)*m+(o-d)*g}function ORe(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;lt(a,"unique");let i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=Z3(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var MRe={kernelName:bw,backendName:"cpu",kernelFunc:ORe};function LRe(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let i=s.shape.length,o=s.shape[a],l=new Array(i-1),u=0;for(let p=0;p<i;p++)p!==a&&(l[u++]=s.shape[p]);let c=new Array(i).fill(0),d=s.shape.slice();d[a]=1;let h=new Array(o);for(let p=0;p<h.length;p++){c[a]=p;let f=Zh({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});h[p]=Ln({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return h}var PRe={kernelName:eb,backendName:"cpu",kernelFunc:LRe};function zRe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;lt(s,"unsortedSegmentSum");let o=s.shape.length,l=a.shape.length,u=[],c=[],d=o-l,h=a;for(let f=0;f<d;++f){let m=bS({inputs:{input:h},backend:n,attrs:{dim:f+1}});h=m,c.push(m)}for(let f=0;f<i;++f){let m=_.createScalarValue(f,"int32"),g=n.makeTensorInfo([],"int32",m),y=g7({inputs:{a:g,b:h},backend:n}),b=Jc({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),x=h2({inputs:{a:b,b:s},backend:n}),w=Yw({inputs:{x},backend:n,attrs:{axis:0,keepDims:!1}});u.push(w),c.push(g),c.push(y),c.push(b),c.push(x),c.push(w)}let p=c9({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}var BRe={kernelName:xw,backendName:"cpu",kernelFunc:zRe},WRe=[M$e,b2e,P$e,B$e,S2e,V$e,G$e,j$e,K$e,Y$e,J$e,eTe,nTe,aTe,oTe,cTe,hTe,fTe,gTe,F$e,bTe,wTe,kTe,STe,k2e,N2e,NTe,x2e,TTe,ETe,ATe,DTe,OTe,LTe,zTe,WTe,UTe,HTe,qTe,XTe,ZTe,QTe,t_e,n_e,s_e,i_e,l_e,u_e,c_e,d_e,f_e,$$e,g_e,$2e,S_e,T2e,C_e,E2e,A_e,R_e,F_e,R2e,F2e,M_e,P_e,B_e,V_e,M2e,P2e,w2e,G_e,_Te,j_e,K_e,Y_e,T$e,B2e,V2e,J_e,G2e,eEe,rEe,aEe,lEe,cEe,hEe,pEe,j2e,mEe,yEe,xEe,vEe,IEe,CEe,$Ee,K2e,_Ee,REe,MEe,Y2e,J2e,zEe,VEe,HEe,e$e,qEe,XEe,YEe,d9,eAe,E$e,r$e,nAe,sAe,iAe,lAe,v2e,BA,cAe,A$e,R$e,D$e,hAe,fAe,gAe,bAe,wAe,vAe,IAe,d$e,CAe,EAe,RAe,MAe,p$e,PAe,BAe,VAe,f$e,FEe,HAe,qAe,XAe,ZAe,QAe,tRe,rRe,aRe,y$e,iRe,x$e,v$e,lRe,cRe,hRe,fRe,gRe,C$e,h_e,bRe,wRe,kRe,SRe,NRe,TRe,t$e,MRe,PRe,BRe,KEe];for(let e of WRe)ww(e);var h9={};Ct(h9,{assertNotComplex:()=>gb,bindCanvasToFramebuffer:()=>JRe,bindColorTextureToFramebuffer:()=>cI,bindTextureToProgramUniformSampler:()=>T9,bindTextureUnit:()=>C9,bindVertexBufferToProgramAttribute:()=>VA,callAndCheck:()=>Ve,canBeRepresented:()=>f9,createFragmentShader:()=>y9,createFramebuffer:()=>S9,createProgram:()=>b9,createStaticIndexBuffer:()=>v9,createStaticVertexBuffer:()=>w9,createTexture:()=>k9,createVertexShader:()=>g9,getBatchDim:()=>Jh,getExtensionOrThrow:()=>xx,getFramebufferErrorMessage:()=>_9,getMaxTexturesInShader:()=>D9,getNumChannels:()=>YRe,getProgramUniformLocation:()=>$9,getProgramUniformLocationOrThrow:()=>N9,getRowsCols:()=>Qh,getShapeAs3D:()=>vx,getTextureShapeFromLogicalShape:()=>A9,getWebGLDisjointQueryTimerVersion:()=>F9,getWebGLErrorMessage:()=>m9,getWebGLMaxTextureSize:()=>R9,hasExtension:()=>wi,isCapableOfRenderingToFloatTexture:()=>O9,isDownloadFloatTextureEnabled:()=>M9,isReshapeFree:()=>C0,isWebGLFenceEnabled:()=>L9,isWebGLVersionEnabled:()=>GA,linkProgram:()=>x9,logShaderSourceAndInfoLog:()=>nL,resetMaxTextureSize:()=>QRe,resetMaxTexturesInShader:()=>eDe,unbindColorTextureFromFramebuffer:()=>UA,unbindTextureUnit:()=>ZRe,validateFramebuffer:()=>wx,validateProgram:()=>uI,validateTextureSize:()=>I9});var lh={},hk={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function p9(e,t){lh[e]=t}function nl(e,t){if(!(e in lh)||t!=null){let r=URe(e,t);if(r!==null)lh[e]=r;else return console.log("Could not get context for WebGL version",e),null}let n=lh[e];return n==null||n.isContextLost()?(delete lh[e],nl(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),lh[e])}function VRe(e){if(!me().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function URe(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??VRe(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete lh[e]},!1),me().getBool("SOFTWARE_WEBGL_ENABLED")&&(hk.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",hk)||n.getContext("experimental-webgl",hk):n.getContext("webgl2",hk)}var S0;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(S0||(S0={}));var xi;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(xi||(xi={}));var ys;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(ys||(ys={}));function Zw(e,t){return[t,e]}function GRe(e,t){return e*t}function pk(e){let t=_.sizeFromShape(e),n=Math.ceil(t/4);return _.sizeToSquarishShape(n)}function mb(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function HRe(e,t){let[n,r]=mb(e,t);return n*r*4}function tL(e,t){let n=e,r,s,a,i,o,l,u,c,d,h;return me().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=t!=null?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function Ve(e,t){let n=t();return me().getBool("DEBUG")&&jRe(e),n}function jRe(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+m9(e,t))}var qRe=596e-10,KRe=65504;function f9(e){return!!(me().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||qRe<Math.abs(e)&&Math.abs(e)<KRe)}function m9(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function xx(e,t){return ju(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function g9(e,t){let n=ju(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ve(e,()=>e.shaderSource(n,t)),Ve(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function y9(e,t){let n=ju(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ve(e,()=>e.shaderSource(n,t)),Ve(e,()=>e.compileShader(n)),me().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw nL(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var XRe=/ERROR: [0-9]+:([0-9]+):/g;function nL(e,t){let n=XRe.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],s=e.split(`
`),a=s.length.toString().length+2,i=s.map((d,h)=>_.rightPad((h+1).toString(),a)+d),o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);let l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${_.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function b9(e){return ju(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function x9(e,t){if(Ve(e,()=>e.linkProgram(t)),!me().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function uI(e,t){if(Ve(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function w9(e,t){let n=ju(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Ve(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),Ve(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function v9(e,t){let n=ju(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Ve(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),Ve(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function YRe(){return me().getNumber("WEBGL_VERSION")===2?1:4}function k9(e){return ju(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function I9(e,t){let n=me().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function S9(e){return ju(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function VA(e,t,n,r,s,a,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(Ve(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),Ve(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i)),Ve(e,()=>e.enableVertexAttribArray(o)),!0)}function C9(e,t,n){E9(e,n),Ve(e,()=>e.activeTexture(e.TEXTURE0+n)),Ve(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function ZRe(e,t){E9(e,t),Ve(e,()=>e.activeTexture(e.TEXTURE0+t)),Ve(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function N9(e,t,n){return ju(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function $9(e,t,n){return e.getUniformLocation(t,n)}function T9(e,t,n,r){Ve(e,()=>C9(e,t,r)),Ve(e,()=>e.uniform1i(n,r))}function JRe(e){Ve(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ve(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),Ve(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function cI(e,t,n){Ve(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),Ve(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function UA(e,t){Ve(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),Ve(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function wx(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+_9(e,t))}function _9(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function ju(e,t,n){let r=Ve(e,()=>t());if(r==null)throw new Error(n);return r}function E9(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Jh(e,t=2){return _.sizeFromShape(e.slice(0,e.length-t))}function Qh(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function vx(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Jh(e),...Qh(e)]),t}function A9(e,t=!1){let n=me().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=me().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&me().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,l)=>l>=e.length-2?_.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=_.squeezeShape(e).newShape);let s=_.sizeFromShape(e),a=null;e.length<=1&&s<=n?a=[1,s]:e.length===2&&e[0]<=n&&e[1]<=n?a=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);let i=a!=null&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(a==null||i)if(t){let o=Jh(e),l=2,u=2;e.length&&([l,u]=Qh(e)),s=o*(l/2)*(u/2),a=_.sizeToSquarishShape(s).map(c=>c*2)}else a=_.sizeToSquarishShape(s);return a}function fk(e){return e%2===0}function C0(e,t){if(e=e.slice(-2),t=t.slice(-2),_.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||fk(n)&&fk(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&fk(e[0])&&fk(t[0])}var dI,hI;function R9(e){if(dI==null){let t=nl(e);dI=t.getParameter(t.MAX_TEXTURE_SIZE)}return dI}function QRe(){dI=null}function eDe(){hI=null}function D9(e){if(hI==null){let t=nl(e);hI=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,hI)}function F9(e){if(e===0)return 0;let t,n=nl(e);return wi(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:wi(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function wi(e,t){return e.getExtension(t)!=null}function GA(e){try{if(nl(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function O9(e){if(e===0)return!1;let t=nl(e);if(e===1){if(!wi(t,"OES_texture_float"))return!1}else if(!wi(t,"EXT_color_buffer_float"))return!1;return HA(t)}function M9(e){if(e===0)return!1;let t=nl(e);if(e===1){if(!wi(t,"OES_texture_float")||!wi(t,"WEBGL_color_buffer_float"))return!1}else{if(wi(t,"EXT_color_buffer_float"))return HA(t);let n="EXT_color_buffer_half_float";if(wi(t,n)){let r=t.getExtension(n);return tDe(t,r)}return!1}return HA(t)}function HA(e){let t=tL(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let r=1,s=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,s,0,t.textureFormatFloat,t.textureTypeFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),i}function tDe(e,t){let n=tL(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let s=1,a=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,a,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}function L9(e){return e!==2?!1:nl(e).fenceSync!=null}function gb(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&_.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var dt=me();dt.registerFlag("HAS_WEBGL",()=>dt.getNumber("WEBGL_VERSION")>0);dt.registerFlag("WEBGL_VERSION",()=>GA(2)?2:GA(1)?1:0);dt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);dt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>dt.get("WEBGL_VERSION")===2);dt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);dt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);dt.registerFlag("WEBGL_PACK",()=>dt.getBool("HAS_WEBGL"));dt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_CLIP",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_REDUCE",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_LAZILY_UNPACK",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_CONV_IM2COL",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>R9(dt.getNumber("WEBGL_VERSION")));dt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>D9(dt.getNumber("WEBGL_VERSION")));dt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=dt.getNumber("WEBGL_VERSION");return e===0?0:F9(e)});dt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>dt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Iw.isMobile());dt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>O9(dt.getNumber("WEBGL_VERSION")));dt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>dt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:dt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));dt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>M9(dt.getNumber("WEBGL_VERSION")));dt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>L9(dt.getNumber("WEBGL_VERSION")));dt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>dt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);dt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});dt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Iw.isMobile()?1:-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});dt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);dt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);dt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);dt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);dt.registerFlag("WEBGL_EXP_CONV",()=>!1);dt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>dt.getBool("IS_TEST"));dt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);dt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);dt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);dt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function ua(){let e,t,n,r,s,a,i,o,l,u;return me().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=me().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function zf(e,t,n="index"){let r=_.computeStrides(t);return r.map((s,a)=>{let i=`int ${e[a]} = ${n} / ${s}`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${s}`:`index -= ${e[a]} * ${s}`;return`${i}; ${o};`}).join("")}function p2(e,t,n="index"){let r=_.computeStrides(t);return r.map((s,a)=>{let i=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${i}; ${o};`}).join("")}function nDe(e,t){let n=e.length,r=e.map(a=>`${t}[${a}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function rDe(e,t,n="index"){let r=e.map((a,i)=>i),s=nDe(r,t);return s.map((a,i)=>{let o=`int ${e[i]} = ${n} / ${s[i]}`,l=i===s.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${s[i]}`:`index -= ${e[i]} * ${s[i]}`;return`${o}; ${l};`}).join("")}function rL(e){let t=_.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function sL(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var P9=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:z9}=W;function sDe(e,t,n){let r=[];if(e.forEach(h=>{let p=_.sizeFromShape(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?r.push(`uniform float ${h.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${h.name};`),r.push(`uniform int offset${h.name};`)),n.enableShapeUniforms){let{uniformShape:f}=aL(n.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(f.length){case 1:r.push(`uniform int ${h.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${h.name}Shape;`);break}r.push(`uniform ivec2 ${h.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(h=>{r.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});let s=r.join(`
`),a=e.map(h=>aDe(h,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=ua(),l=lDe(o),u,c,d=dDe(o);return t.isPacked?(u=iDe(t.logicalShape,i,n.enableShapeUniforms),c=cDe(o)):(u=oDe(t.logicalShape,i,n.enableShapeUniforms),c=uDe(o)),n.packedInputs&&(d+=mDe),[d,l,c,s,u,a,n.userCode].join(`
`)}function yb(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return $De(e,t);case 1:return _De(e,t);case 2:return ADe(e,t);case 3:return DDe(e,t);case 4:return ODe(e,t);case 5:return MDe(e);case 6:return LDe(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function B9(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return NDe(e);case 1:return TDe(e,t);case 2:return EDe(e,t);case 3:return RDe(e,t);default:return FDe(e,t)}}function aDe(e,t,n=!1,r){let s="";n?s+=B9(e,r):s+=yb(e,r);let a=e.shapeInfo.logicalShape,i=t.logicalShape;return a.length<=i.length&&(n?s+=PDe(e,t):s+=zDe(e,t)),s}function iDe(e,t,n){switch(e.length){case 0:return W9();case 1:return gDe(e,t,n);case 2:return SDe(e,t,n);case 3:return bDe(e,t,n);default:return wDe(e,t,n)}}function oDe(e,t,n){switch(e.length){case 0:return W9();case 1:return yDe(e,t,n);case 2:return CDe(e,t,n);case 3:return xDe(e,t,n);case 4:return vDe(e,t,n);case 5:return kDe(e,t);case 6:return IDe(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function lDe(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function uDe(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function cDe(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function dDe(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${hDe}
    ${pDe}
    ${fDe}
  `}var hDe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,pDe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,fDe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,mDe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function W9(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function gDe(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function yDe(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function bDe(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function xDe(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${p2(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=zf(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function wDe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2),i=a,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+o,l=`b${u}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${e.length}(${l});
    }
  `}function vDe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${p2(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=zf(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function kDe(e,t){let n=zf(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function IDe(e,t){let n=zf(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function SDe(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(_.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let s=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function CDe(e,t,n){return _.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Bf(e){return`offset${e}`}function NDe(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=ua();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function $De(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[s,a]=e.shapeInfo.texShape;if(s===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=Bf(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function TDe(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=ua();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function _De(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${bb(e)}
      }
    `;let s=e.shapeInfo.texShape,a=s[0],i=s[1];if(i===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=Bf(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function EDe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],l=ua();if(a!=null&&_.arraysEqual(n,a))return t?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function ADe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(a!=null&&_.arraysEqual(n,a)){if(t)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let h=a[0],p=a[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:o}=_.squeezeShape(n),l=i;if(l.length<n.length){let h=xb(e,l),p=["row","col"];return`
      ${yb(h,t)}
      float ${s}(int row, int col) {
        return ${s}(${wb(p,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${bb(e)}
      }
    `;let u=a[0],c=a[1],d=Bf(r);return c===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function RDe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){let h=n.slice(1),p=[1,2],f=xb(e,h),m=["b","row","col"];return`
        ${B9(f,t)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${wb(m,p)});
        }
      `}let o=ua();if(t)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;let l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${d}, ${c}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function DDe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=_.squeezeShape(n),u=o;if(u.length<n.length){let m=xb(e,u),g=["row","col","depth"];return`
        ${yb(m,t)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${wb(g,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${i}, 1)));
        ${bb(e)}
      }
    `;let c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===a&&p==null)return t?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(h===i&&p==null)return t?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;let f=Bf(r);return t?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${h}, index);
        return sampleTexture(${r}, uv);
      }
  `}function FDe(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=ua();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;let a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(a[i-1]/2),h=d*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=a[i-m-1],f=`b${m} * ${h} + `+f;return`
    vec4 ${r}(${p}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${s.texture2D}(${n}, uv);
    }
  `}function ODe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=_.squeezeShape(n);if(l.length<n.length){let b=xb(e,l),x=["row","col","depth","depth2"];return`
      ${yb(b,t)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${wb(x,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${a}, 1)));
        ${bb(e)}
      }
    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(p===a&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;let y=Bf(r);return t?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function MDe(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=_.squeezeShape(t);if(l.length<t.length){let m=xb(e,l),g=["row","col","depth","depth2","depth3"];return`
      ${yb(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${wb(g,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${a}, ${s})) +
          depth3;
        ${bb(e)}
      }
    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;let f=Bf(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${a} +
          depth2 * ${s} + depth3 + ${f};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function LDe(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=_.squeezeShape(t);if(s.length<t.length){let g=xb(e,s),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${yb(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${wb(y,a)});
      }
    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${bb(e)}
      }
    `;let d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=Bf(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function bb(e){let t=e.name,n=_.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function PDe(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=z9(e.shapeInfo.logicalShape,t.logicalShape),l=Cn(i),u=i-a,c,d=["x","y","z","w","u","v"];a===0?c="":i<2&&o.length>=1?c="coords = 0;":c=o.map(g=>`coords.${d[g+u]} = 0;`).join(`
`);let h="";i<2&&a>0?h="coords":h=e.shapeInfo.logicalShape.map((g,y)=>`coords.${d[y+u]}`).join(", ");let p="return outputValue;",f=_.sizeFromShape(e.shapeInfo.logicalShape)===1,m=_.sizeFromShape(t.logicalShape)===1;if(a===1&&!f&&!m)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(f&&!m)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(o.length){let g=a-2,y=a-1;o.indexOf(g)>-1&&o.indexOf(y)>-1?p="return vec4(outputValue.x);":o.indexOf(g)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(y)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${h});
      ${p}
    }
  `}function zDe(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&_.arraysEqual(i,a))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let u=Cn(l),c=z9(e.shapeInfo.logicalShape,t.logicalShape),d=l-o,h,p=["x","y","z","w","u","v"];o===0?h="":l<2&&c.length>=1?h="coords = 0;":h=c.map(m=>`coords.${p[m+d]} = 0;`).join(`
`);let f="";return l<2&&o>0?f="coords":f=e.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+d]}`).join(", "),`
    float ${s}() {
      ${u} coords = getOutputCoords();
      ${h}
      return get${r}(${f});
    }
  `}function Cn(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function aL(e,t,n){let{newShape:r,keptDims:s}=_.squeezeShape(t),a=t.length,i=e&&a===3&&t[0]===1,o=i?t.slice(1):r,l=!e&&a>1&&!_.arraysEqual(t,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:s}}function xb(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function wb(e,t){return t.map(n=>e[n]).join(", ")}function BDe(e,t,n,r){let s=n.map((c,d)=>{let h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),a=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=sDe(s,i,t),l=y9(e.gl,o),u=e.createProgram(l);return me().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},V9(e,t,u))}function V9(e,t,n){let r=[],s=[],a,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),me().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));let c=!1;for(let d of t.variableNames){let h={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(h.shape=e.getUniformLocation(n,`${d}Shape`,c),h.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),r.push(h)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(let d of t.customUniforms)s.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function uU(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let s=n.logicalShape,a=t[r],i=a.shape;if(!_.arraysEqual(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&a.isUniform)return;let o=n.texShape,l=a.isUniform?null:a.texData.texShape;if(!_.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function WDe(e,t,n,r,s){t.program.enableShapeUniforms||(uU(t.inShapeInfos,n),uU([t.outShapeInfo],[r]));let a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),me().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let u=n[l],{uniform:c,offset:d,shape:h,texShape:p}=t.variablesLocations[l];if(h){let{uniformShape:f}=aL(t.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:e.gl.uniform1iv(h,new Int32Array(f));break;case 2:e.gl.uniform2iv(h,new Int32Array(f));break;case 3:e.gl.uniform3iv(h,new Int32Array(f));break;case 4:e.gl.uniform4iv(h,new Int32Array(f));break}}if(p&&e.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(_.sizeFromShape(u.shape)<2)e.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),e.gl.uniform1fv(c,f)}continue}u.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,c,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){let l=_.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let l=0;l<t.program.customUniforms.length;++l){let u=t.program.customUniforms[l],c=t.customUniformLocations[l],d=s[l];if(u.type==="float")e.gl.uniform1fv(c,d);else if(u.type==="vec2")e.gl.uniform2fv(c,d);else if(u.type==="vec3")e.gl.uniform3fv(c,d);else if(u.type==="vec4")e.gl.uniform4fv(c,d);else if(u.type==="int")e.gl.uniform1iv(c,d);else if(u.type==="ivec2")e.gl.uniform2iv(c,d);else if(u.type==="ivec3")e.gl.uniform3iv(c,d);else if(u.type==="ivec4")e.gl.uniform4iv(c,d);else throw Error(`uniform type ${u.type} is not supported yet.`)}e.executeProgram()}function VDe(e,t,n){let r="";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=aL(e.packedInputs,i.shape,l),h="",p="",f="";if(c.length===1&&e.packedInputs){let v=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${v[0]>1}_${v[1]>1}`}else if(c.length===2&&!e.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){let v=_.computeStrides(c);f=`${v[0]===l[1]}_${v[v.length-1]===l[1]}`}let m=i.shape.length,g=c.length===2&&_.arraysEqual(i.shape,l),y=_.sizeFromShape(i.shape)===1,b=W.getBroadcastDims(i.shape,n.shape),x=!e.packedInputs&&m===n.shape.length&&_.arraysEqual(l,n.texData.texShape),w=e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${x}_${u?d:""}_${c.length}_${y}_${b}_${g}_${h}_${p}_${f}_${w}_${o}`}else{let l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${o}`}});let s=e.userCode,a=e.constructor.name;return a+="_"+r+"_"+s+`${me().getNumber("WEBGL_VERSION")}`,a}function zs(e){return me().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var UDe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=S0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=ua();this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?p2(["r","c","d"],e):zf(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},GDe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=S0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=ua();this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?p2(["r","c","d"],e):zf(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},HDe=class{constructor(e){this.variableNames=["A"],this.outTexUsage=xi.DOWNLOAD;let t=ua();this.outputShape=e,this.userCode=`
      ${P9}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},jDe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=xi.DOWNLOAD;let t=ua();this.outputShape=e,this.userCode=`
      ${P9}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},qDe={R:0,G:1,B:2,A:3},cU=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=ua();this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let i=0;i<n.length;i++){let o=n[i];a+=`
          if(offset == ${i}) {
            result = values[${qDe[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?sL():rL(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}},KDe=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=ua();this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){let o=a*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?sL():rL(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${s};
        }
    `}},U9={};Ct(U9,{bindVertexProgramAttributeStreams:()=>J9,createBufferFromOutputTexture:()=>tY,createFloat16MatrixTexture:()=>K9,createFloat16PackedMatrixTexture:()=>Z9,createFloat32MatrixTexture:()=>q9,createIndexBuffer:()=>j9,createPackedMatrixTexture:()=>Y9,createUnsignedBytesMatrixTexture:()=>X9,createVertexBuffer:()=>H9,createVertexShader:()=>G9,downloadByteEncodedFloatMatrixFromOutputTexture:()=>rY,downloadFloat32MatrixFromBuffer:()=>nY,downloadMatrixFromPackedOutputTexture:()=>aY,downloadPackedMatrixFromBuffer:()=>sY,getInternalFormatForFloat16MatrixTexture:()=>oL,getInternalFormatForFloat16PackedMatrixTexture:()=>cL,getInternalFormatForFloat32MatrixTexture:()=>iL,getInternalFormatForPackedMatrixTexture:()=>uL,getInternalFormatForUnsignedBytesMatrixTexture:()=>lL,uploadDenseMatrixToTexture:()=>Q9,uploadPixelDataToTexture:()=>eY});function G9(e){let t=ua(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return g9(e,n)}function H9(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return w9(e,t)}function j9(e){let t=new Uint16Array([0,1,2,2,1,3]);return v9(e,t)}function Jw(e,t,n,r,s,a){I9(t,n);let i=k9(e),o=e.TEXTURE_2D;return Ve(e,()=>e.bindTexture(o,i)),Ve(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),Ve(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),Ve(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),Ve(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),me().getNumber("WEBGL_VERSION")===1?Ve(e,()=>e.texImage2D(o,0,r,t,n,0,s,a,null)):Ve(e,()=>e.texStorage2D(o,1,r,t,n)),Ve(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function iL(e){return e.internalFormatFloat}function q9(e,t,n,r){let[s,a]=Zw(t,n);return Jw(e,s,a,iL(r),r.textureFormatFloat,e.FLOAT)}function oL(e){return e.internalFormatHalfFloat}function K9(e,t,n,r){let[s,a]=Zw(t,n);return Jw(e,s,a,oL(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function lL(e){return e.downloadTextureFormat}function X9(e,t,n,r){let[s,a]=Zw(t,n);return Jw(e,s,a,lL(r),e.RGBA,e.UNSIGNED_BYTE)}function uL(e){return e.internalFormatPackedFloat}function Y9(e,t,n,r){let[s,a]=mb(t,n);return Jw(e,s,a,uL(r),e.RGBA,e.FLOAT)}function cL(e){return e.internalFormatPackedHalfFloat}function Z9(e,t,n,r){let[s,a]=mb(t,n);return Jw(e,s,a,cL(r),e.RGBA,r.textureTypeHalfFloat)}function J9(e,t,n){return Ve(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),VA(e,t,"clipSpacePos",n,3,20,0)&&VA(e,t,"uv",n,2,20,12)}function Q9(e,t,n,r,s,a){Ve(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),me().getNumber("WEBGL_VERSION")===2?Ve(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):Ve(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),Ve(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function eY(e,t,n){Ve(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?me().getNumber("WEBGL_VERSION")===2?Ve(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):Ve(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):me().getNumber("WEBGL_VERSION")===2?Ve(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):Ve(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),Ve(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function tY(e,t,n,r){let s=e.createBuffer();Ve(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));let a=4*4*t*n;return Ve(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),Ve(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),Ve(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function nY(e,t,n){let r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function rY(e,t,n,r){let[s,a]=Zw(t,n),i=4,o=new Uint8Array(GRe(t*n,i));return Ve(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function sY(e,t,n,r,s,a,i,o){let l=e,u=new Float32Array(HRe(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function aY(e,t,n){let r=new Float32Array(t*n*4);return Ve(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var pI=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=me().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,p9(t,e)):this.gl=nl(t),e=this.gl,me().getNumber("WEBGL_VERSION")===2){let s=e;this.createVertexArray=()=>Ve(s,()=>s.createVertexArray()),this.bindVertexArray=a=>Ve(s,()=>s.bindVertexArray(a)),this.deleteVertexArray=a=>Ve(s,()=>s.deleteVertexArray(a)),this.getVertexArray=()=>Ve(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(e!=null){let s=e.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ve(e,()=>s.createVertexArrayOES()),this.bindVertexArray=a=>Ve(e,()=>s.bindVertexArrayOES(a)),this.deleteVertexArray=a=>Ve(e,()=>s.deleteVertexArrayOES(a)),this.getVertexArray=()=>Ve(e,()=>e.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),me().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=xx(this.gl,s),wi(this.gl,a))this.textureHalfFloatExtension=xx(this.gl,a);else if(me().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),wi(this.gl,r))this.colorBufferHalfFloatExtension=xx(this.gl,r);else if(me().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",wi(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(wi(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=H9(this.gl),this.indexBuffer=j9(this.gl),this.framebuffer=S9(this.gl),this.textureConfig=tL(this.gl,this.textureHalfFloatExtension)}get debug(){return me().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;Ve(e,()=>e.finish()),Ve(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ve(e,()=>e.deleteFramebuffer(this.framebuffer)),Ve(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Ve(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Ve(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),q9(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),K9(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),X9(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),eY(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),Q9(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Z9(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Y9(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(UA(this.gl,this.framebuffer),this.outputTexture=null),Ve(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>rY(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return sY(this.gl,e,t,n,r,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return nY(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=tY(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(me().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let a=r.clientWaitSync(s,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=s}else me().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,me().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>aY(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=G9(t));let n=b9(t);Ve(t,()=>t.attachShader(n,this.vertexShader)),Ve(t,()=>t.attachShader(n,e)),x9(t,n);let r;return r=Object.assign(n,{vao:this.createVertexArray()}),this.bindVertexArray(r.vao),Ve(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(J9(t,r,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&uI(t,r),this.setProgram(r),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Ve(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&uI(this.gl,this.program)),Ve(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?N9(this.gl,e,t):$9(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Ve(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),T9(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,s]=mb(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&uI(this.gl,this.program),wx(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ve(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ve(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=xx(this.gl,me().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(me().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(me().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await _.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,me().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,me().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=XDe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in me().platform&&(n=me().platform.setTimeoutCustom.bind(me().platform)),_.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),cI(this.gl,e,this.framebuffer),this.debug&&wx(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(cI(this.gl,this.outputTexture,this.framebuffer),this.debug&&wx(this.gl)):UA(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;cI(r,e,this.framebuffer),this.debug&&wx(r),this.outputTexture=e,Ve(r,()=>r.viewport(0,0,t,n)),Ve(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),Ve(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function XDe(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:YDe,bincountImpl:iY,bincountReduceImpl:ZDe,castImpl:JDe,ceilImpl:QDe,concatImpl:eFe,equalImpl:tFe,expImpl:nFe,expm1Impl:rFe,floorImpl:sFe,gatherNdImpl:aFe,gatherV2Impl:iFe,greaterImpl:oFe,greaterEqualImpl:lFe,lessImpl:uFe,lessEqualImpl:cFe,linSpaceImpl:dFe,logImpl:hFe,maxImpl:pFe,maximumImpl:fFe,minimumImpl:mFe,multiplyImpl:gFe,negImpl:yFe,notEqualImpl:bFe,prodImpl:xFe,raggedGatherImpl:wFe,raggedRangeImpl:vFe,raggedTensorToTensorImpl:kFe,rangeImpl:IFe,rsqrtImpl:SFe,scatterImpl:CFe,sigmoidImpl:NFe,simpleAbsImpl:oY,sliceImpl:$Fe,sparseFillEmptyRowsImpl:TFe,sparseReshapeImpl:_Fe,sparseSegmentReductionImpl:lY,sqrtImpl:EFe,staticRegexReplaceImpl:AFe,stridedSliceImpl:RFe,stringNGramsImpl:DFe,stringSplitImpl:FFe,stringToHashBucketFastImpl:OFe,subImpl:MFe,tileImpl:LFe,topKImpl:PFe,transposeImpl:dL,uniqueImpl:zFe}=z3;function uY(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Ys(e,t){return t===1?[e]:uY(e,t)}function BFe(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var WFe=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=zs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=Ys("rc",this.rank),n=Cn(this.rank),r=this.getOutOfBoundsCondition(t),s=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)s=`${e[e.length-1-a]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},cY=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length);let n="";for(let r=0;r<4;r++){let s="thisRC = rc;";r%2===1&&(s+="thisRC.z += 1;"),r>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${VFe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?sL():rL(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function VFe(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?rDe(["r","c","d"],"inputShape"):zf(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var UFe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=hU(t,n),s=pU(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let a=dU(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let o=this.freeTextures[s].pop();return this.usedTextures[s].push(o),o}let i;return r===ys.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===ys.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===ys.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===ys.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===ys.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let s=hU(n,r),a=pU(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);let i=dU(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=me().get("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[a],u=l&&l.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function GFe(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function dU(e,t,n,r,s){let a=HFe(t,r),i;if(s){let[l,u]=mb(e[0],e[1]);i=l*u}else{let[l,u]=Zw(e[0],e[1]);i=l*u}let o=GFe(n,a);return i*o}function HFe(e,t){switch(e){case ys.PACKED_2X2_FLOAT32:return uL(t);case ys.PACKED_2X2_FLOAT16:return cL(t);case ys.UNPACKED_FLOAT32:return iL(t);case ys.UNPACKED_FLOAT16:return oL(t);case ys.PACKED_4X1_UNSIGNED_BYTE:return lL(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function jFe(e){return me().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?ys.PACKED_2X2_FLOAT32:ys.UNPACKED_FLOAT32:e?ys.PACKED_2X2_FLOAT16:ys.UNPACKED_FLOAT16}function hU(e,t){if(e===xi.UPLOAD)return ys.PACKED_2X2_FLOAT32;if(e===xi.RENDER||e==null)return jFe(t);if(e===xi.DOWNLOAD||e===xi.PIXELS)return ys.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function pU(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var _l=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},So="if (isnan(x)) return x;",qFe="return x;",fU="return abs(x);",KFe="return (x >= 0.0) ? x : (exp(x) - 1.0);",XFe=So+`
  return (x < 0.0) ? 0.0 : x;
`,YFe=So+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,lc="return x;",ZFe="return 1.0 / (1.0 + exp(-1.0 * x));",JFe="return x;",QFe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,eOe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tOe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,nOe="return 1.0 / (1.0 + exp(-1.0 * x));",bc=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},rOe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length);let t=e.length,n=Ys("rc",t),r=Cn(t),s=BFe(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},sOe=Yl.whereImpl,aOe=1e-7,iOe=1e-4,g_={};function oOe(e){return e in g_||(g_[e]={}),g_[e]}var lOe=me().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),uOe=600;function cOe(){return me().global.screen==null?1024:me().global.screen.height*me().global.screen.width*window.devicePixelRatio*uOe/1024/1024}var f2=class extends ew{nextDataId(){return f2.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!me().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof pI)t=e;else{let n=nl(me().getNumber("WEBGL_VERSION"),e);t=new pI(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let n=nl(me().getNumber("WEBGL_VERSION"));t=new pI(n),this.binaryCache=oOe(me().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new UFe(this.gpgpu),this.numMBBeforeWarning=cOe(),this.texData=new jC(this,Xi())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,s,a){let i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,s]},o.texShape=[r,s];let l=vx(t),u=new cU(l,!1,a),c=this.runWebGLProgram(u,[i],n,[[r,s]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((me().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||me().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:xi.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,r,s){if(me().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:xi.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:o}=t;if(a!=null){let d;o?d=new bc(i,lc):d=new _l(i,lc);let h=this.runWebGLProgram(d,[{dataId:e,shape:i,dtype:r}],r),p=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),p}if(n!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return n;let l=this.activeTimers!=null,u;l&&(u=_.now());let c;if(r==="complex64"){let d=this.readSync(s.real.dataId),h=this.readSync(s.imag.dataId);c=W.mergeRealAndImagArrays(d,h)}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=_.now()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){let p=this.pendingRead.get(e);return new Promise(f=>p.push(f))}let t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:i,isPacked:o}=t;if(s!=null){let p;o?p=new bc(r,lc):p=new _l(r,lc);let f=this.runWebGLProgram(p,[{dataId:e,shape:r,dtype:a}],a),m=this.read(f.dataId);return this.disposeIntermediateTensorInfo(f),m}if(n!=null)return this.convertAndCacheOnCPU(e);if(me().getBool("DEBUG")&&!me().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&me().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,u;if(a!=="complex64"&&me().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);let p=this.texData.get(u.dataId);l=this.gpgpu.createBufferFromTexture(p.texture.texture,...pk(r))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let c;if(a==="complex64"){let p=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),f=p[0],m=p[1];c=W.mergeRealAndImagArrays(f,m)}else if(l==null)c=this.getValuesFromTexture(e);else{let p=_.sizeFromShape(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(l,p)}if(u!=null&&this.disposeIntermediateTensorInfo(u),l!=null){let p=this.gpgpu.gl;Ve(p,()=>p.deleteBuffer(l))}let d=this.convertAndCacheOnCPU(e,c),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(p=>p(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Xi().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){let n=this.texData.get(e),{values:r,shape:s,slice:a,dtype:i,isPacked:o,texture:l}=n;if(i==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let h;o?h=new bc(s,lc):h=new _l(s,lc);let p=this.runWebGLProgram(h,[{dataId:e,shape:s,dtype:i}],i),f=this.readToGPU(p,t);return this.disposeIntermediateTensorInfo(p),f}if(l==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(e,t.customTexShape),c=Xi().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let n=t.map(r=>_.decodeString(r));return Ot(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ot(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let n=e[t];if(!f9(n))throw me().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=_.sizeFromShape(t);if(me().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let d=this.decode(e),h=this.texData.get(d.dataId),p=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...pk(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(d),p}let a=me().getBool("WEBGL_PACK")&&r===!0,i=a?vx(t):t,o=a?new jDe(i):new HDe(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return me().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;this.programTimersStack==null?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=_.flatten(this.activeTimers.map(o=>o.query)).filter(o=>o!=null),a=_.flatten(this.activeTimers.map(o=>o.name)).filter(o=>o!=null);this.activeTimers=t,r&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(me().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let o=await Promise.all(s);i.kernelMs=_.sum(o),i.getExtraProfileInfo=()=>o.map((l,u)=>({name:a[u],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return me().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:_.now(),endMs:null}}endTimer(e){return me().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=_.now(),e)}async getQueryTime(e){if(me().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=lOe){return me().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&_.sizeFromShape(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){W.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return sOe(e.shape,t)}packedUnaryOp(e,t,n){let r=new bc(e.shape,t),s=this.compileAndRun(r,[e],n);return Xi().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let r=oY(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(me().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,fU,e.dtype);let t=new _l(e.shape,fU),n=this.compileAndRun(t,[e]);return Xi().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&_.isString(n[0])){let s=n.map(a=>_.encodeString(a));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return Xi().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new rOe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new WFe(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[Jh(e.shape),...Qh(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[Jh(t),...Qh(t)],a=new cY(s,n),i=!0,o=[n],l=this.runWebGLProgram(a,[r],e.dtype,o,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:r,shape:s,dtype:a}=n;if(t!=null){let d=_.sizeFromShape(s),h=t[0]*t[1]*4;_.assert(d<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let i=vx(s),o;r?o=new GDe(i):o=new UDe(i);let l=!0,u=[t??pk(i)],c=this.runWebGLProgram(o,[{shape:i,dtype:a,dataId:e}],a,u,l,t);return{dtype:a,shape:s,dataId:c.dataId}}runWebGLProgram(e,t,n,r,s=!1,a){let i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===S0.DENSE){let g=a??pk(e.outputShape);o.texShape=g.map(y=>y*2)}if(e.outTexUsage!=null&&(o.usage=e.outTexUsage),_.sizeFromShape(i.shape)===0)return o.values=_.getTypedArrayFromDType(i.dtype,0),i;let l=[],u=t.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let y=this.texData.get(g.dataId);if(y.texture==null){if(!e.packedInputs&&_.sizeFromShape(g.shape)<=me().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:y.values};e.packedInputs&&(y.isPacked=!0,y.shape=g.shape)}if(this.uploadToGPU(g.dataId),!!y.isPacked!=!!e.packedInputs)g=y.isPacked?this.unpackTensor(g):this.packTensor(g),l.push(g),y=this.texData.get(g.dataId);else if(y.isPacked&&!C0(y.shape,g.shape)){let b=g,x=g.shape;g.shape=y.shape,g=this.packedReshape(g,x),l.push(g),y=this.texData.get(g.dataId),b.shape=x}return{shape:g.shape,texData:y,isUniform:!1}});this.uploadToGPU(i.dataId);let c={shape:i.shape,texData:o,isUniform:!1},d=VDe(e,u,c),h=this.getAndSaveBinary(d,()=>BDe(this.gpgpu,e,u,c)),p=this.activeTimers!=null,f;p&&(f=this.startTimer()),me().get("ENGINE_COMPILE_ONLY")||WDe(this.gpgpu,h,u,c,r),l.forEach(g=>this.disposeIntermediateTensorInfo(g)),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));let m=me().get("WEBGL_FLUSH_THRESHOLD");if(m>0){let g=_.now();g-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!me().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&s===!1){let g=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),g}return i}compileAndRun(e,t,n,r,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(me().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ue(()=>{if(!me().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=me().getBool("DEBUG");me().set("DEBUG",!1);let t=this.abs(mt(1e-8)).dataSync()[0];if(me().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?aOe:iOe}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:o}=t;if(a!=null)return;let l=this.activeTimers!=null,u;l&&(u=_.now());let c=t.texShape;if(c==null&&(c=A9(n,o),t.texShape=c),s!=null){let d=vx(n),h,p=c[1],f=c[0],m=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(o||!m)&&([p,f]=mb(c[0],c[1])),o?h=new KDe(d,m):h=new cU(d,m);let g=m?[f,p]:c,y=this.makeTensorInfo(g,r),b=this.texData.get(y.dataId);m?b.usage=xi.PIXELS:b.usage=xi.UPLOAD,b.texShape=g,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),p,f,s);let x=[[f,p]],w=!0,v=this.runWebGLProgram(h,[y],r,x,w),k=this.texData.get(v.dataId);t.texShape=k.texShape,t.isPacked=k.isPacked,t.usage=k.usage,me().get("ENGINE_COMPILE_ONLY")?this.disposeData(v.dataId):(t.texture=k.texture,t.values=null,this.texData.delete(v.dataId)),this.disposeIntermediateTensorInfo(y),l&&(this.uploadWaitMs+=_.now()-u)}else{let d=this.acquireTexture(c,i,r,o);t.texture=d}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return t!=null&&(n.values=dOe(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*_.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(s){throw s}});e.push(n)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await rM(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(nL(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){let{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}=V9(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";let{texture:r,height:s,width:a,channels:i}=e,o=Xi().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=o.writeTexture(r,t,n,s,a,i);return Xi().makeTensorFromDataId(l,t,n,o)}};f2.nextDataId=0;function dOe(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}var hOe="4.3.0";function dY(){me().set("WEBGL_FORCE_F16_TEXTURES",!0)}Iw.isBrowser()&&hN("webgl",()=>new f2,2);var pOe={forceHalfFloat:dY},hL=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,Eg=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=W.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=zs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},Wf=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,Qw=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=W.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length;this.enableShapeUniforms=zs(s);let a="";if(r)if(s===0||_.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Cn(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=Ys("coords",s);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function ti(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var fOe={kernelName:Gp,backendName:"webgl",kernelFunc:ti};function Cd(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=ti({inputs:{x:r},backend:n}),l=ti({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}var mOe={kernelName:YC,backendName:"webgl",kernelFunc:Cd},hY="return (a < 0.) ? b * a : a;",pY=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function gOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",_.createScalarValue(a,"float32")),o=me().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qw(pY,s.shape,i.shape):new Eg(hY,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var yOe={kernelName:Kp,backendName:"webgl",kernelFunc:gOe},fY="return (a < 0.) ? b * a : a;",mY=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function bOe(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=me().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qw(mY,r.shape,s.shape):new Eg(fY,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}var xOe={kernelName:cf,backendName:"webgl",kernelFunc:bOe},vb="if (isnan(x)) return x;";function Jt({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{let{x:i}=s,o=a,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let d=o.texData.get(i.dataId),h=n(d.values,l);return o.makeTensorInfo(i.shape,l,h)}let u=me().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return u?c=new bc(i.shape,t):c=new _l(i.shape,e),o.runWebGLProgram(c,[i],l)}}function Cs({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{let{a:l,b:u}=i,c=o;if(r&&l.dtype==="complex64"){let f=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(x=>{let[w,v]=x,k={dataId:w.dataId,dtype:w.dtype,shape:l.shape},I={dataId:v.dataId,dtype:v.dtype,shape:u.shape},S=new Eg(e,l.shape,u.shape);return c.runWebGLProgram(S,[k,I],$i(w.dtype,v.dtype))}),b=Cd({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}let d=a||$i(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&s!=null){let f=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,g=l.dtype==="string"?W.fromUint8ToStringArray(f):f,y=l.dtype==="string"?W.fromUint8ToStringArray(m):m,[b,x]=s(l.shape,u.shape,g,y,d),w=c.makeTensorInfo(x,d),v=c.texData.get(w.dataId);return v.values=b,w}let h=me().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,p;return h?p=new Qw(t,l.shape,u.shape,n):p=new Eg(e,l.shape,u.shape),c.runWebGLProgram(p,[l,u],d)}}function N0(e,t=!1){if(e==="linear")return t?JFe:qFe;if(e==="relu")return t?eOe:XFe;if(e==="elu")return t?QFe:KFe;if(e==="relu6")return t?tOe:YFe;if(e==="prelu")return t?mY:fY;if(e==="leakyrelu")return t?pY:hY;if(e==="sigmoid")return t?nOe:ZFe;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var gY=class{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=zs(this.outputShape.length);let u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(o?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:m=`vec4 activation(vec4 x) {
          ${i}
        }`,g="result = activation(result);");let y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${b};
        int batchB = ${x};
        for (int i = 0; i < ${c}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${f[0]});
          result += (${p[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${g}

        setOutput(result);
      }
    `}},mU={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},gU=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=W.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},yU="return a * b;";function pL(e){let{inputs:t,backend:n}=e,{a:r,b:s}=t,a=W.upcastType(r.dtype,s.dtype);if(r.dtype==="complex64"){let o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),u=new gU(mU.REAL,r.shape,s.shape),c=new gU(mU.IMAG,r.shape,s.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=n.runWebGLProgram(u,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=Cd({inputs:{real:h,imag:p},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([r,s])){let o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[u,c]=gFe(r.shape,s.shape,o.values,l.values,a),d=n.makeTensorInfo(c,a),h=n.texData.get(d.dataId);return h.values=u,d}let i;return me().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Qw(yU,r.shape,s.shape):i=new Eg(yU,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}var wOe={kernelName:af,backendName:"webgl",kernelFunc:pL};function vOe(e,t,n){let r=[Jh(e.shape),...Qh(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[Jh(t),...Qh(t)],i=new cY(a,r),o=!0,l=[r],u=n.runWebGLProgram(i,[s],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function Be(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=_.sizeFromShape(s.shape),l=_.inferFromImplicitShape(a,o),u=_.sizeFromShape(l);_.assert(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(s.dataId);return c.isPacked&&!C0(s.shape,l)&&!(c.texture!==null&&C0(c.shape,l))?vOe(s,l,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}var kOe={kernelName:Py,backendName:"webgl",kernelFunc:Be},bU=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i=Math.floor(n/4)*4,o=n%4,l="sumValue += dot(values, ones);";if(t!=null){let c=1/t;l=`sumValue += dot(values * ${_.isInt(c)?c.toPrecision(2):c}, ones);`}let u="";s%n>0&&(u=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},IOe=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let u=Math.floor(n/4)*4,c=n%4,d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";t==="all"?(i="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):t==="any"&&(i="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${c===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${c===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function SOe(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=W.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function Vf(e,t,n,r){let s=SOe(e.shape),a=e;for(let i=0;i<s.length;i++){let{inSize:o,windowSize:l,outSize:u}=s[i],c,d;n==="mean"?c=i===0?new bU({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new bU({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):c=new IOe({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=a,a=r.runWebGLProgram(c,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}var COe=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;let r=Cn(this.rank),s=NOe(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function NOe(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}var $Oe=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=Cn(this.rank),s=uY("rc",this.rank),a=new Array(this.rank);for(let u=0;u<t.length;u++)a[t[u]]=s[u];let i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function m2(e,t,n){let r=me().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $Oe(e.shape,t):new COe(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function TOe(e,t,n,r){let s=t,a=e.shape.length,i=_.parseAxisParam(s,e.shape),o=i,l=W.getAxesPermutation(o,a),u=l!=null,c=e;u&&(c=m2(e,l,r),o=W.getInnerMostAxes(o.length,a)),W.assertAxesAreInnerMostDims("sum",o,a);let[d,h]=W.computeOutAndReduceShapes(c.shape,o),p=d;n&&(p=W.expandShapeToKeepDim(d,i));let f=_.sizeFromShape(h),m=_.sizeFromShape(e.shape)/f,g=Be({inputs:{x:c},attrs:{shape:[m,f]},backend:r}),y=dN(e.dtype),b=Vf(g,y,"sum",r),x=Be({inputs:{x:b},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(b),u&&r.disposeIntermediateTensorInfo(c),x}function g2(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return TOe(s,a,i,n)}var _Oe={kernelName:Nf,backendName:"webgl",kernelFunc:g2};function na(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=s.shape[a[c]];let u;if(i.shouldExecuteOnCPU([s])){let c=i.texData.get(s.dataId).values,d=dL(c,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype);let h=i.texData.get(u.dataId);h.values=d}else u=m2(s,a,i);return u}var EOe={kernelName:Cu,backendName:"webgl",kernelFunc:na},yY=1e3;function wS({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u=e.shape.length,c=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],h=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=_.sizeFromShape(m),b=_.sizeFromShape(g),x=rb.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);_.assert(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let w=n?[y,d,p]:[y,p,d],v=r?[b,f,h]:[b,h,f],k=Be({inputs:{x:e},backend:s,attrs:{shape:w}}),I=Be({inputs:{x:t},backend:s,attrs:{shape:v}}),S=[k,I],$=Math.max(y,b),N=n?k.shape[1]:k.shape[2],T=a!=null,C=i!=null,E=l==="leakyrelu",M=l!=null?N0(l,!0):null,F=T||C||E||M!=null,z;if((p===1||f===1)&&N>yY&&F===!1){let P=k,O=I;n&&(P=na({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),S.push(P)),r&&(O=na({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),S.push(O));let L=f!==1,V=f===1,q=P;L&&(q=Be({inputs:{x:P},backend:s,attrs:{shape:[$,N,1]}}),S.push(q));let B=f===1?2:1,X=O;V&&(X=Be({inputs:{x:O},backend:s,attrs:{shape:[$,1,N]}}),S.push(X));let ee=pL({inputs:{a:q,b:X},backend:s});z=g2({inputs:{x:ee},backend:s,attrs:{axis:B,keepDims:!0}}),S.push(ee)}else{let P=$i(e.dtype,t.dtype),O=new gY(w,v,[$,p,f],n,r,T,M,C,E),L=[k,I];if(a!=null&&L.push(a),C&&L.push(i),E){let V=s.makeTensorInfo([],"float32",_.createScalarValue(o,"float32"));L.push(V),S.push(V)}z=s.runWebGLProgram(O,L,P)}let H=Be({inputs:{x:z},backend:s,attrs:{shape:x}});S.push(z);for(let P of S)s.disposeIntermediateTensorInfo(P);return H}function AOe(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return wS({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}var ROe={kernelName:Lh,backendName:"webgl",kernelFunc:AOe},xU="return abs(x);";function DOe(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let a=n.texData.get(r.dataId),i=oY(a.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return me().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new bc(r.shape,xU):s=new _l(r.shape,xU),n.runWebGLProgram(s,[r],r.dtype)}var FOe={kernelName:Qg,backendName:"webgl",kernelFunc:DOe},OOe=So+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,MOe=Jt({opSnippet:OOe}),LOe={kernelName:gp,backendName:"webgl",kernelFunc:MOe},POe=So+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,zOe=Jt({opSnippet:POe}),BOe={kernelName:yp,backendName:"webgl",kernelFunc:zOe},wU="return a + b;",WOe=Cs({opSnippet:wU,packedOpSnippet:wU,supportsComplex:!0,cpuKernelImpl:YDe}),VOe={kernelName:gd,backendName:"webgl",kernelFunc:WOe},UOe=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},GOe=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function fI(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return ti({inputs:{x:r[0]},backend:n});if(r.length>me().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(r.length/2),l=fI({inputs:r.slice(0,o),backend:n}),u=fI({inputs:r.slice(o),backend:n});return fI({inputs:[l,u],backend:n})}let s=r.map(o=>o.dtype).reduce((o,l)=>$i(o,l)),a=r.map(o=>o.shape),i=me().getBool("WEBGL_PACK")?new GOe(r[0].shape,a):new UOe(r[0].shape,a);return n.runWebGLProgram(i,r,s)}var HOe={kernelName:bp,backendName:"webgl",kernelFunc:fI};function jOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=_.parseAxisParam(a,s.shape),u=l,c=W.getAxesPermutation(u,o),d=s;c!=null&&(d=na({inputs:{x:s},backend:n,attrs:{perm:c}}),u=W.getInnerMostAxes(u.length,o)),W.assertAxesAreInnerMostDims("all",u,o);let[h,p]=W.computeOutAndReduceShapes(d.shape,u),f=_.sizeFromShape(p),m=Be({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=Vf(m,m.dtype,"all",n),y;if(i){let b=W.expandShapeToKeepDim(h,l);y=Be({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=Be({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}var qOe={kernelName:ey,backendName:"webgl",kernelFunc:jOe};function KOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=_.parseAxisParam(a,s.shape),u=l,c=W.getAxesPermutation(u,o),d=s;c!=null&&(d=na({inputs:{x:s},backend:n,attrs:{perm:c}}),u=W.getInnerMostAxes(u.length,o)),W.assertAxesAreInnerMostDims("any",u,o);let[h,p]=W.computeOutAndReduceShapes(d.shape,u),f=_.sizeFromShape(p),m=Be({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=Vf(m,m.dtype,"any",n),y;if(i){let b=W.expandShapeToKeepDim(h,l);y=Be({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=Be({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}var XOe={kernelName:ty,backendName:"webgl",kernelFunc:KOe},YOe=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];let i=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},ZOe=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,_.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,l=Cn(o),u=Ys("coords",o),c,d;if(a===1){d=o+1;let I=Cn(d);c=`
        ${I} sourceLocR = ${I}(${u.join()}, 0);
        ++${u[o-1]};
        ${I} sourceLocG = ${I}(${u.join()}, 0);
        ++${u[o-2]};
        ${I} sourceLocA = ${I}(${u.join()}, 0);
        --${u[o-1]};
        ${I} sourceLocB = ${I}(${u.join()}, 0);
        --${u[o-2]};`}else d=o,c=`
        ${l} sourceLocR = coords;
        ++${u[o-1]};
        ${l} sourceLocG = coords;
        ++${u[o-2]};
        ${l} sourceLocA = coords;
        --${u[o-1]};
        ${l} sourceLocB = coords;
        --${u[o-2]};`;let h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map(I=>"int "+I),m=Ys("sourceLocR",d-1).concat("inIdx.r"),g=Ys("sourceLocG",d-1).concat("inIdx.g"),y=Ys("sourceLocB",d-1).concat("inIdx.b"),b=Ys("sourceLocA",d-1).concat("inIdx.a"),x=n==="max"?"greaterThan":"lessThan",w=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()})));`,v=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`
      float getBestIndicesAChannel(${f.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${f.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${v};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${w}
          vec4 candidate = ${v};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function bY(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];r!=null&&(s=r.shape[0],a=r.shape[1]);let i=W.computeOptimalWindowSize(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new YOe(o,n,r==null),u=[t];r!=null&&u.push(r);let c=e.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;let d=bY(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function xY(e,t,n,r=null){let s=r!=null?r.shape:t.shape,a=s[s.length-1],i=W.computeOptimalWindowSize(a),o=new ZOe(s,i,n,r==null),l=r==null?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let c=xY(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}return u}function wY(e,t,n,r){let s=[n];if(W.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!me().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let a=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,l=t;o&&(l=e.unpackTensor(t),a.push(l));let[u,c]=W.computeOutAndReduceShapes(l.shape,s),d=_.sizeFromShape(c),h=Be({inputs:{x:l},backend:e,attrs:{shape:[-1,d]}});a.push(h);let p=bY(e,h,r);a.push(p);let f=Be({inputs:{x:p},backend:e,attrs:{shape:u}});return a.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return xY(e,t,r)}function JOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,i=_.parseAxisParam(a,s.shape),o=W.getAxesPermutation(i,s.shape.length),l=s,u=[];o!=null&&(l=na({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=W.getInnerMostAxes(i.length,l.shape.length)),W.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let c=wY(n,l,i[0],"max");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}var QOe={kernelName:ny,backendName:"webgl",kernelFunc:JOe};function eMe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,i=_.parseAxisParam(a,s.shape),o=W.getAxesPermutation(i,s.shape.length),l=s,u=[];o!=null&&(l=na({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=W.getInnerMostAxes(i.length,l.shape.length)),W.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let c=wY(n,l,i[0],"min");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}var tMe={kernelName:ry,backendName:"webgl",kernelFunc:eMe},nMe=So+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,rMe=Jt({opSnippet:nMe}),sMe={kernelName:xp,backendName:"webgl",kernelFunc:rMe},aMe=So+"return log(x + sqrt(x * x + 1.0));",iMe=Jt({opSnippet:aMe}),oMe={kernelName:wp,backendName:"webgl",kernelFunc:iMe},lMe=So+`
  return atan(x);
`,uMe=Jt({opSnippet:lMe}),cMe={kernelName:vp,backendName:"webgl",kernelFunc:uMe},dMe=hL+`
  return atan(a, b);
`,hMe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Wf+`
  return result;
`,pMe=Cs({opSnippet:dMe,packedOpSnippet:hMe}),fMe={kernelName:Ip,backendName:"webgl",kernelFunc:pMe},mMe=So+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,gMe=Jt({opSnippet:mMe}),yMe={kernelName:kp,backendName:"webgl",kernelFunc:gMe},$0=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;let f=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let I=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${h}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?s?m:g:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let b="max",x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(x="avgValue / max(count, 1.0)");let w=Math.floor(a/4)*4,v=a%4,k=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${h}, ${p});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${w}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${w};
          if (${v===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${v===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${v===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${x});
      }
    `}},fL=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b=t==="avg",x="0.0";if(b||(x="-1.0 / 1e-20"),n){let $=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${m}, ${g}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${$} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(v="avgValue / max(count, 1.0)");let k=Math.floor(a/4)*4,I=a%4,S=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${S}
            }

            int xC = xCCorner + ${k};
            if (${I===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${S}
            } else if (${I===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${S}
            } else if (${I===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${S}
            }
          }
        }
        setOutput(${v});
      }
    `}};function bMe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;gb(s,"avgPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;_.assert(W.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=W.computePool2DInfo(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&_.arraysEqual(c.inShape,c.outShape))return ti({inputs:{x:s},backend:n});let d=new $0(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}var xMe={kernelName:Sp,backendName:"webgl",kernelFunc:bMe};function wMe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],d=W.computePool3DInfo(s.shape,a,i,c,o,l,u),h=new fL(d,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}var vMe={kernelName:sy,backendName:"webgl",kernelFunc:wMe},kMe=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${c});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},IMe=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${m});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function SMe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],h=W.computePool3DInfo(i.shape,o,l,d,u,c),p=new IMe(h);return n.runWebGLProgram(p,[s],i.dtype)}var CMe={kernelName:nw,backendName:"webgl",kernelFunc:SMe};function NMe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;gb([s,a],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=W.computePool2DInfo(i.shape,o,l,1,u),d=new kMe(c);return n.runWebGLProgram(d,[s],i.dtype)}var $Me={kernelName:XC,backendName:"webgl",kernelFunc:NMe};function TMe(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return wS({a:s,b:a,transposeA:i,transposeB:o,backend:n})}var _Me={kernelName:Cp,backendName:"webgl",kernelFunc:TMe},EMe=class{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],W.assertAndGetBroadcastShape(e,t),W.assertAndGetBroadcastShape(e,n);let i="0.0";r!=null&&(W.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";s!=null&&(W.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},AMe=class{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],W.assertAndGetBroadcastShape(e,t),W.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";r!=null&&(W.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";s!=null&&(W.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}},RMe=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:s,variance:a,offset:i,scale:o}=e;_.assert(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_.assert(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_.assert(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let u=[r,s,a],c=null;i!=null&&(c=i.shape,u.push(i));let d=null;o!=null&&(d=o.shape,u.push(o));let h=me().getBool("WEBGL_PACK_NORMALIZATION")?new AMe(r.shape,s.shape,a.shape,c,d,l):new EMe(r.shape,s.shape,a.shape,c,d,l);return t.runWebGLProgram(h,u,u[0].dtype)},DMe={kernelName:Vp,backendName:"webgl",kernelFunc:RMe},FMe=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=Cn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=OMe(this.rank),r,s=e.map((a,i)=>`sourceLoc.${jA[i]} = start[${i}] + coords.${jA[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},jA=["x","y","z","w","u","v"];function OMe(e){if(e===1)return"sourceLoc";if(e<=6)return jA.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var MMe=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Cn(this.rank),n=Ys("coords",this.rank),r=Ys("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,c)=>`start[${c}]`).join()});`:e.map((u,c)=>`${r[c]} = ${n[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function LMe(e,t,n,r){let s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Br.computeFlatOffset(t,_.computeStrides(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}function kb(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=Br.parseSliceParams(s,a,i);if(Br.assertParamsValid(s,o,l),_.sizeFromShape(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){let d=n.texData.get(s.dataId),h=$Fe(d.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,h)}let{isPacked:u}=n.texData.get(s.dataId),c=Br.isSliceContinous(s.shape,o,l);if(u||!c){let d=me().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new MMe(l):new FMe(l),h=[o];return n.runWebGLProgram(d,[s],s.dtype,h)}return n.uploadToGPU(s.dataId),LMe(s,o,l,n)}var PMe={kernelName:Hy,backendName:"webgl",kernelFunc:kb},zMe=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;_.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=a.reduce((b,x)=>b*x),l=W.getReshaped(s.shape,a,o),u=W.getPermuted(l.length,a.length),c=W.getReshapedPermuted(s.shape,a,o),d=W.getSliceBeginCoords(i,a.length),h=W.getSliceSize(c,i,a.length),p=[],f=Be({inputs:{x:s},backend:n,attrs:{shape:l}}),m=na({inputs:{x:f},backend:n,attrs:{perm:u}}),g=Be({inputs:{x:m},backend:n,attrs:{shape:c}}),y=kb({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},BMe={kernelName:ay,backendName:"webgl",kernelFunc:zMe};function WMe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=iY(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}var VMe={kernelName:iy,backendName:"webgl",kernelFunc:WMe};function UMe(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=W.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var GMe={kernelName:rw,backendName:"webgl",kernelFunc:UMe},HMe="return float(a != b);",vY=Cs({opSnippet:HMe,cpuKernelImpl:bFe,dtype:"bool"}),jMe={kernelName:Ry,backendName:"webgl",kernelFunc:vY};function e1(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return ti({inputs:{x:s.complexTensorInfos.real},backend:n})}var qMe={kernelName:uN,backendName:"webgl",kernelFunc:e1},KMe="return float(int(x));";function XMe(e,t){let n=new _l(e.shape,KMe),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function qA(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return ti({inputs:{x:s},backend:n});let i=sr(s.shape),o=qA({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Cd({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(s.dtype==="complex64"){let i=e1({inputs:{input:s},backend:n}),o=qA({inputs:{x:i},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(i),o}if(!_.hasEncodingLoss(s.dtype,a)){let i=ti({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(n.shouldExecuteOnCPU([s])){let i=n.texData.get(s.dataId).values,[o,l,u]=JDe(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}if(a==="int32")return XMe(s,n);if(a==="bool"){let i=n.makeTensorInfo([],"bool",_.getTypedArrayFromDType("bool",1)),o=vY({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}var YMe={kernelName:Np,backendName:"webgl",kernelFunc:qA},vU="return ceil(x);",ZMe=Jt({opSnippet:vU,packedOpSnippet:vU,cpuKernelImpl:QDe}),JMe={kernelName:$p,backendName:"webgl",kernelFunc:ZMe},QMe=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},e3e=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function t3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r,o;me().getBool("WEBGL_PACK_CLIP")?o=new e3e(s.shape):o=new QMe(s.shape);let l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}var n3e={kernelName:yd,backendName:"webgl",kernelFunc:t3e},r3e=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function kU(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function s3e(e){let{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new r3e(r.shape),i=[kU(r,s.complexTensorInfos.real),kU(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}var a3e={kernelName:sw,backendName:"webgl",kernelFunc:s3e},i3e=class{constructor(e){this.outputShape=[],this.outputShape=W.computeOutShape(e,1),this.variableNames=e.map((a,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){let i=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${i}));`)}let r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},o3e=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=W.computeOutShape(e,t);let n=this.outputShape,r=n.length,s=Cn(r),a=Ys("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((f,m)=>`T${m}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],u=i.slice(-2),c=i.join(),d=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${c}), vec2(${u.join()}));
        }`;for(let f=1;f<o.length;f++){let m=o[f-1];d+=`
        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {
          return getChannel(
            getT${f}(${mk(i,l,m)}),
            vec2(${mk(u,l,m)}));
        }`}let h=o.length,p=o[o.length-1];d+=`
        return getChannel(
          getT${h}(${mk(i,l,p)}),
          vec2(${mk(u,l,p)}));`,this.userCode=`
      float getValue(${i.map(f=>"int "+f)}) {
        ${d}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${n[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${n[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${n[r-2]} &&
            ${a[r-1]} < ${n[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function mk(e,t,n){let r=e.indexOf(t);return e.map((s,a)=>a===r?`${s} - ${n}`:s).join()}function y2(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return ti({inputs:{x:s.complexTensorInfos.imag},backend:n})}var l3e={kernelName:rN,backendName:"webgl",kernelFunc:y2};function kx(e,t,n){let r=e[0].dtype;if(r==="complex64"){let p=e.map(b=>e1({inputs:{input:b},backend:n})),f=e.map(b=>y2({inputs:{input:b},backend:n})),m=kx(p,t,n),g=kx(f,t,n),y=Cd({inputs:{real:m,imag:g},backend:n});return p.forEach(b=>n.disposeIntermediateTensorInfo(b)),f.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){let p=e.map(w=>{let v=[-1,_.sizeFromShape(w.shape.slice(t))];return Be({inputs:{x:w},backend:n,attrs:{shape:v}})}),f=p.map(w=>({vals:n.readSync(w.dataId),shape:w.shape})),m=W.computeOutShape(p.map(w=>w.shape),1),g=p[0].shape[0]===1,y=eFe(f,m,r,g),b=W.computeOutShape(e.map(w=>w.shape),t),x=n.makeTensorInfo(b,r,y);return p.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}let a=e.filter(p=>_.sizeFromShape(p.shape)>0),i=me().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){let p=i?new _l(e[0].shape,lc):new bc(e[0].shape,lc);return n.runWebGLProgram(p,e,r)}let o=me().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){let p=[];for(let m=0;m<a.length;m+=o){let g=a.slice(m,m+o);p.push(kx(g,t,n))}let f=kx(p,t,n);for(let m of p)n.disposeIntermediateTensorInfo(m);return f}if(i){let p=new o3e(a.map(f=>f.shape),t);return n.runWebGLProgram(p,a,r)}let{tensors2D:l,outShape:u}=u3e(a,t,n),c=new i3e(l.map(p=>p.shape)),d=n.runWebGLProgram(c,l,r);l.forEach(p=>n.disposeIntermediateTensorInfo(p));let h=Be({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function u3e(e,t,n){let r=W.computeOutShape(e.map(s=>s.shape),t);return{tensors2D:e.map(s=>Be({inputs:{x:s},attrs:{shape:[-1,_.sizeFromShape(s.shape.slice(t))]},backend:n})),outShape:r}}function kY(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=_.parseAxisParam(s,t[0].shape)[0],i=t.map(u=>u.shape);W.assertParamsConsistent(i,a);let o=W.computeOutShape(t.map(u=>u.shape),a);if(_.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(u=>_.sizeFromShape(u.shape)>0);return l.length===1?ti({inputs:{x:l[0]},backend:n}):kx(l,a,n)}var c3e={kernelName:oy,backendName:"webgl",kernelFunc:kY},IY=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=Math.floor(e.inChannels/4)*4,f=e.inChannels%4,m=e.dataFormat==="channelsLast",g=m?1:2,y=m?2:3,b=m?3:1,x="",w="";n&&(r?x=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?x=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:x=`
          float activation(float x) {
            ${n}
          }
        `,w="result = activation(result);");let v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${f===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${v}
        ${w}
        setOutput(result);
      }
    `}},d3e=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=Math.floor(e.inChannels/4)*4,f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${f===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},SY=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=zs(this.outputShape.length);let a=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u,d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<u;m++)d+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<u;m++)d+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(c+1)/2;m++){let g=m*2;if(d+=`
           xC = xCCorner + ${g*o};
           `,i===1){if(g<u&&(a%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `,o===1&&g>0?d+=`
                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `,g+1<u)){let y=a%2===0?_.nearestLargerEven(o):o;o%2===0&&a%2===1||o%2!==0&&a%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g+1}.zw = vec2(0.0);
                     }
                     xTexelC${g+1}Ready = 1;
                   }
                   `,o>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                     } else {
                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                     }
                     `:d+=`
                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                     `):y===1?d+=`
                     xC${g+1} = xTexelC${g};
                     `:d+=`
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g+1}.zw = vec2(0.0);
                       }
                       xTexelC${g+1}Ready = 1;
                     }

                     xC${g+1} = xTexelC${g+1};
                     `}}else g<u&&(a%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.0);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
               `,g+1<u&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g+1}.xy);
               `,g+1<u&&(d+=`
                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                 `)));g<u&&(d+=`
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,g+1<u&&(d+=`
               wTexel = getW(r, ${g+1}, d1, d2);
               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let h="",p="";n&&(r?h=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:s?h=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:h=`vec4 activation(vec4 x) {
           ${n}
         }`,p="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${h}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${f}
         ${p}
         setOutput(result);
       }
     `}},h3e=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length);let{dataFormat:n}=t,r=ua(),s=n==="channelsLast",a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let c=0;c<=1;c++)l+=`
          blockIndex = rc.z + ${c};
          pos = rc.y + ${u};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+c}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+c}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}};function vS(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function CY({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){let l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],h=n.outChannels,p=n.dataFormat==="channelsLast",f=!1,m=!1,g,y=[];if(a!=null){let b=vS(a.shape,p);b!=null&&(a=Be({inputs:{x:a},backend:r,attrs:{shape:b}}),y.push(a))}if(s!=null){let b=vS(s.shape,p);b!=null&&(s=Be({inputs:{x:s},backend:r,attrs:{shape:b}}),y.push(s))}if(!((d===1||h===1)&&c>yY)&&u.isPacked&&p&&u.texture!=null&&l[2]%2!==0&&_.arraysEqual(u.shape.slice(-3),l.slice(-3))){let b=l[0]*l[1]*(l[2]+1),x={dataId:e.dataId,shape:[1,b,n.inChannels],dtype:e.dtype},w=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,_.assert(C0(u.shape,x.shape),()=>`packed reshape ${u.shape} to ${x.shape} isn't free`);let v=Be({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(v);let k=wS({a:x,b:v,backend:r,transposeA:f,transposeB:m,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),I=r.texData.get(k.dataId);_.assert(I.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=w,I.shape=n.outShape,g=ti({inputs:{x:k},backend:r}),g.shape=n.outShape,y.push(k)}else{let b=n.outHeight*n.outWidth,x=Be({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,b,n.inChannels]:[n.batchSize,n.inChannels,b]}}),w=Be({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),v=wS({a:p?x:w,b:p?w:x,transposeA:!p,transposeB:m,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});g=Be({inputs:{x:v},backend:r,attrs:{shape:n.outShape}}),y.push(x),y.push(w),y.push(v)}for(let b of y)r.disposeIntermediateTensorInfo(b);return g}function NY({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=n,f=p==="channelsLast",m=l*u*c,g=h*d,y=[n.batchSize,m,g],b=!0,x=!1,w=[];if(a!=null){let P=vS(a.shape,f);P!=null&&(a=Be({inputs:{x:a},backend:r,attrs:{shape:P}}),w.push(a))}if(s!=null){let P=vS(s.shape,f);P!=null&&(s=Be({inputs:{x:s},backend:r,attrs:{shape:P}}),w.push(s))}let v=Be({inputs:{x:t},backend:r,attrs:{shape:[1,m,_.sizeFromShape(t.shape)/m]}});w.push(v);let k=new h3e(y,n),I=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],S=r.runWebGLProgram(k,[e],"float32",I),$=Be({inputs:{x:S},backend:r,attrs:{shape:y}});w.push(S),w.push($);let N=s!=null,T=a!=null,C=o==="leakyrelu",E=o?N0(o,!0):null,M=new gY(f?$.shape:v.shape,f?v.shape:$.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],b,x,N,E,T,C),F=f?[$,v]:[v,$];if(s&&F.push(s),T&&F.push(a),C){let P=r.makeTensorInfo([],"float32",_.createScalarValue(i,"float32"));F.push(P),w.push(P)}let z=r.runWebGLProgram(M,F,"float32"),H=Be({inputs:{x:z},backend:r,attrs:{shape:n.outShape}});w.push(z);for(let P of w)r.disposeIntermediateTensorInfo(P);return H}function p3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=W.convertConv2DDataFormat(l),h=W.computeConv2DInfo(s.shape,a.shape,i,u,o,c,!1,d),p;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID"))p=CY({x:s,filter:a,convInfo:h,backend:n});else if(h.strideWidth<=2&&d==="channelsLast"&&me().getBool("WEBGL_EXP_CONV")){let m=new SY(h),g=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(m,[s,a],"float32",g)}else if(me().getBool("WEBGL_CONV_IM2COL"))p=NY({x:s,filter:a,convInfo:h,backend:n});else{let m=new IY(h);p=n.runWebGLProgram(m,[s,a],"float32")}let f=Be({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}var f3e={kernelName:Tp,backendName:"webgl",kernelFunc:p3e},m3e=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},g3e=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=a?1:2,u=a?2:3,c=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},y3e=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},b3e=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function x3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=W.convertConv2DDataFormat(l),h=W.computeConv2DInfo(s.shape,c,i,1,o,u,!1,d),p=new m3e(h);return n.runWebGLProgram(p,[s,a],"float32")}var w3e={kernelName:ZC,backendName:"webgl",kernelFunc:x3e},v3e=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=zs(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function k3e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=W.convertConv2DDataFormat(u),h=W.computeConv2DInfo(i,a.shape,o,1,l,c,!1,d);if(me().getBool("WEBGL_PACK")&&d==="channelsLast"){let p=[[h.strideHeight,h.strideWidth]],f=new v3e(h);return n.runWebGLProgram(f,[s,a],"float32",p)}else{let p=new g3e(h);return n.runWebGLProgram(p,[s,a],"float32")}}var I3e={kernelName:_p,backendName:"webgl",kernelFunc:k3e};function S3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=W.computeConv3DInfo(s.shape,a.shape,i,l,o),c=new d3e(u);return n.runWebGLProgram(c,[s,a],"float32")}var C3e={kernelName:Ep,backendName:"webgl",kernelFunc:S3e};function N3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=W.computeConv3DInfo(s.shape,l,i,1,o),c=new y3e(u);return n.runWebGLProgram(c,[s,a],"float32")}var $3e={kernelName:ly,backendName:"webgl",kernelFunc:N3e};function T3e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=W.computeConv3DInfo(l,a.shape,o,1,i),c=new b3e(u);return n.runWebGLProgram(c,[s,a],"float32")}var _3e={kernelName:uy,backendName:"webgl",kernelFunc:T3e},E3e=vb+`
  return cos(x);
`,A3e=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Wf}
  return result;
`,R3e=Jt({opSnippet:E3e,packedOpSnippet:A3e}),D3e={kernelName:Ap,backendName:"webgl",kernelFunc:R3e},F3e=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,O3e=Jt({opSnippet:F3e}),M3e={kernelName:Rp,backendName:"webgl",kernelFunc:O3e},L3e=class{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[a,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];let h=r==="bilinear"?1:0,[p,f]=[`${i-1}.0`,`${o-1}.0`],[m,g,y]=c>1?[`${(i-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,x,w]=d>1?[`${(o-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${x};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${w};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},P3e=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new L3e(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")},z3e={kernelName:dy,backendName:"webgl",kernelFunc:P3e},T0;(function(e){e.Prod="*",e.Sum="+"})(T0||(T0={}));var IU=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,a=this.op===T0.Prod?"1.0":"0.0",i=n?a:`getX(${SU(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?`end != ${o-1}`:"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Cn(s)} coords = getOutputCoords();
        int end = ${CU(s,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${CU(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${SU(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function SU(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function CU(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function $Y(e,t,n,r,s,a){let i=t.shape.length,o=W.getAxesPermutation([r],i),l=t;o!=null&&(l=na({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=W.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let c=l.shape[u],d=ti({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){let p=new IU(e,l.shape,!1,a),f=[[h]],m=d;d=n.runWebGLProgram(p,[d],d.dtype,f),n.disposeIntermediateTensorInfo(m)}if(s){let h=new IU(e,l.shape,s,a),p=d;d=n.runWebGLProgram(h,[d],d.dtype),n.disposeIntermediateTensorInfo(p)}if(o!=null){let h=W.getUndoAxesPermutation(o),p=na({inputs:{x:d},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),p}return d}function B3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return $Y(T0.Prod,s,n,a,i,o)}var W3e={kernelName:cy,backendName:"webgl",kernelFunc:B3e};function V3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return $Y(T0.Sum,s,n,a,i,o)}var U3e={kernelName:Dp,backendName:"webgl",kernelFunc:V3e};function G3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){let l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=iY(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){let l=n.bufferSync(s),u=n.bufferSync(a),c=ZDe(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var H3e={kernelName:aw,backendName:"webgl",kernelFunc:G3e},j3e=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function q3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],u=i==="NHWC"?s.shape[2]:s.shape[3],c=i==="NHWC"?s.shape[3]:s.shape[1],d=l*a,h=u*a,p=c/(a*a),f=i==="NHWC"?[o,d,h,p]:[o,p,d,h],m=new j3e(f,a,i);return n.runWebGLProgram(m,[s],s.dtype)}var K3e={kernelName:hy,backendName:"webgl",kernelFunc:q3e},TY=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=zs(this.outputShape.length);let a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,u="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${u}
        setOutput(result);
      }
    `}},_Y=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=zs(this.outputShape.length);let a=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c,h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)h+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;h+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let g=0;g<c;g++)h+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(d+1)/2;g++){let y=g*2;if(h+=`
          xC = xCCorner + ${y*l};
          `,o===1){if(y<c&&(i%2===1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,l===1&&y>0?h+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<c)){let b=i%2===0?_.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,l>1?h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                    } else {
                     xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                    }
                    `:h+=`
                    xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                    `):b===1?h+=`
                    xC${y+1} = xTexelC${y};
                    `:h+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<c&&(i%2===1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<c&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<c&&(h+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<c&&(h+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<c&&(h+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let p="",f="";n&&(r?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:p=`vec4 activation(vec4 x) {
          ${n}
        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${f}
        setOutput(result);
      }
    `}};function X3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r,c=l;c==null&&(c=[1,1]),_.assert(W.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let d=W.computeConv2DInfo(s.shape,a.shape,i,c,o,u,!0),h;me().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?h=new _Y(d):h=new TY(d);let p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[s,a],"float32",p)}var Y3e={kernelName:Fp,backendName:"webgl",kernelFunc:X3e},Z3e=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},J3e=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Q3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=W.computeConv2DInfo(s.shape,c,i,o,l,u,!0),h=new Z3e(d);return n.runWebGLProgram(h,[s,a],"float32")}var eLe={kernelName:JC,backendName:"webgl",kernelFunc:Q3e};function tLe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=W.computeConv2DInfo(c,a.shape,i,o,l,u,!0),h=new J3e(d);return n.runWebGLProgram(h,[s,a],"float32")}var nLe={kernelName:QC,backendName:"webgl",kernelFunc:tLe},rLe=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function sLe(e){let{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=_.sizeFromShape(r.shape),i=Be({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new rLe(a),l=n.runWebGLProgram(o,[i],i.dtype),u=Be({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var aLe={kernelName:iw,backendName:"webgl",kernelFunc:sLe},iLe=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${c}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function oLe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=W.computeDilation2DInfo(s.shape,a.shape,i,o,"NHWC",l),c,d=new iLe(u);c=n.runWebGLProgram(d,[s,a],"float32");let h=Be({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}var lLe={kernelName:Op,backendName:"webgl",kernelFunc:oLe};function uLe(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=W.decodeEinsumEquation(s,a.length);W.checkEinsumDimSizes(i.length,l,a);let{path:u,steps:c}=W.getEinsumComputePath(o,l),d=c.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let g of c[m]){let{permutationIndices:y,expandDims:b}=W.getEinsumPermutation(p,l[g]),x;W.isIdentityPermutation(y)?x=a[g]:(x=na({inputs:{x:a[g]},backend:n,attrs:{perm:y}}),f.push(x));let w=x.shape.slice();for(let v=0;v<b.length;++v)w.splice(b[v],0,1);_.arraysEqual(x.shape,w)||(x=Be({inputs:{x},backend:n,attrs:{shape:w}}),f.push(x)),h===null?h=x:(h=pL({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=g2({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}var cLe={kernelName:eN,backendName:"webgl",kernelFunc:uLe},dLe="return (x >= 0.0) ? x : (exp(x) - 1.0);",hLe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,pLe=Jt({opSnippet:dLe,packedOpSnippet:hLe}),fLe={kernelName:Lp,backendName:"webgl",kernelFunc:pLe},mLe="return (b >= 0.0) ? a : a * (b + 1.0);",gLe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,yLe=e=>{let{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=me().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qw(gLe,r.shape,s.shape):new Eg(mLe,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)},bLe={kernelName:py,backendName:"webgl",kernelFunc:yLe},xLe=`
  return vec4(equal(a, b));
`,wLe="return float(a == b);",vLe=Cs({opSnippet:wLe,packedOpSnippet:xLe,dtype:"bool",cpuKernelImpl:tFe}),kLe={kernelName:my,backendName:"webgl",kernelFunc:vLe},ILe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${W.ERF_P};
  float a1 = ${W.ERF_A1};
  float a2 = ${W.ERF_A2};
  float a3 = ${W.ERF_A3};
  float a4 = ${W.ERF_A4};
  float a5 = ${W.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,SLe=Jt({opSnippet:ILe}),CLe={kernelName:fy,backendName:"webgl",kernelFunc:SLe},NLe=vb+`
  return exp(x);
`,$Le=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,EY=Jt({opSnippet:NLe,packedOpSnippet:$Le,cpuKernelImpl:nFe,dtype:"float32"}),TLe={kernelName:Pp,backendName:"webgl",kernelFunc:EY};function KA(e){let{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(_.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),Be({inputs:{x:a},backend:r,attrs:{shape:o}})}var _Le={kernelName:gy,backendName:"webgl",kernelFunc:KA},NU="return exp(x) - 1.0;",ELe=Jt({opSnippet:NU,packedOpSnippet:NU,cpuKernelImpl:rFe}),ALe={kernelName:zp,backendName:"webgl",kernelFunc:ELe},$U=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function AY(e,t,n){let r=n.texData.get(e.dataId),s=_.sizeFromShape(e.shape),a=e.shape[e.shape.length-1],i=s/a,o=Be({inputs:{x:e},backend:n,attrs:{shape:[i,a]}}),l=o.shape,u=new $U("real",l,t),c=new $U("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=n.runWebGLProgram(u,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=Cd({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);let m=Be({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}function RLe(e){let{inputs:t,backend:n}=e,{input:r}=t;return AY(r,!1,n)}var DLe={kernelName:tN,backendName:"webgl",kernelFunc:RLe},FLe=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function t1(e){let{backend:t,attrs:n}=e,{shape:r,value:s}=n,{dtype:a}=n;if(a=a||_.inferDtype(s),a==="string"){let i=_.getArrayFromDType(a,_.sizeFromShape(r));return i.fill(s),t.makeTensorInfo(r,a,i)}else{let i=new FLe(r,s),o=[[s]];return t.runWebGLProgram(i,[],a,o)}}var OLe={kernelName:ow,backendName:"webgl",kernelFunc:t1},MLe=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},LLe={kernelName:yy,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,s=new MLe(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},TU="return floor(x);",PLe=Jt({opSnippet:TU,packedOpSnippet:TU,cpuKernelImpl:sFe}),zLe={kernelName:Bp,backendName:"webgl",kernelFunc:PLe},BLe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,WLe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,VLe=Cs({opSnippet:BLe,packedOpSnippet:WLe,dtype:"int32"}),ULe={kernelName:Wp,backendName:"webgl",kernelFunc:VLe},GLe=class{constructor(e){this.variableNames=["A"];let t=ua(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},HLe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=ua(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},jLe={kernelName:ZI,backendName:"webgl",kernelFunc:qLe},om,y_=me().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function qLe(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:s}=t,{numChannels:a}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,a];if(o||i){let m=me().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(om==null||m!==y_)&&(y_=m,om=document.createElement("canvas").getContext("2d",{willReadFrequently:y_})),om.canvas.width=l,om.canvas.height=u,om.drawImage(s,0,0,l,u),s=om.canvas}let h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=xi.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),s);let p=me().getBool("WEBGL_PACK")?new HLe(d):new GLe(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}function KLe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=W.convertConv2DDataFormat(c),g=W.computeConv2DInfo(s.shape,a.shape,l,d,u,h,!1,m),y,b=[],x=i!=null,w=o!=null,v=p==="leakyrelu",k=()=>{let S=[s,a],$=(N,T)=>{if(T==="NCHW"&&N.shape.length===1&&N.shape[0]!==1){let C=Be({inputs:{x:N},backend:n,attrs:{shape:[N.shape[0],1,1]}});return b.push(C),C}return N};if(x&&S.push($(i,c)),w&&S.push($(o,c)),v){let N=n.makeTensorInfo([],"float32",_.createScalarValue(f,"float32"));S.push(N),b.push(N)}return S};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=CY({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&me().getBool("WEBGL_EXP_CONV")){let S=p?N0(p,!0):null,$=new SY(g,x,S,w,v),N=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],T=k();y=n.runWebGLProgram($,T,"float32",N)}else if(me().getBool("WEBGL_CONV_IM2COL"))y=NY({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{let S=p?N0(p,!1):null,$=new IY(g,x,S,w,v),N=k();y=n.runWebGLProgram($,N,"float32")}let I=Be({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(S=>n.disposeIntermediateTensorInfo(S)),I}var XLe={kernelName:Ph,backendName:"webgl",kernelFunc:KLe};function YLe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[],m=c;m==null&&(m=[1,1]),_.assert(W.eitherStridesOrDilationsAreOne(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let g=W.computeConv2DInfo(s.shape,a.shape,l,m,u,d,!0),y=me().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=h?N0(h,y):null,x=[s,a],w=i!=null,v=o!=null,k=h==="leakyrelu";if(w&&x.push(i),v&&x.push(o),k){let N=n.makeTensorInfo([],"float32",_.createScalarValue(p,"float32"));x.push(N),f.push(N)}let I;y?I=new _Y(g,w,b,v,k):I=new TY(g,w,b,v,k);let S=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],$=n.runWebGLProgram(I,x,"float32",S);return f.forEach(N=>n.disposeIntermediateTensorInfo(N)),$}var ZLe={kernelName:zh,backendName:"webgl",kernelFunc:YLe},JLe=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let s=Cn(n.length),a=`
    int index;`;for(let i=0;i<this.sliceDim;i++)a+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function QLe(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=_.sizeFromShape(r.shape),[l,u,c,d]=W.prepareAndValidate(r,s),h=Be({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=Be({inputs:{x:r},backend:n,attrs:{shape:[_.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let y=n.readSync(s.dataId),b=n.bufferSync(r),x=aFe(y,b,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,x.values)}let f=new JLe(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=Be({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}var ePe={kernelName:xy,backendName:"webgl",kernelFunc:QLe},tPe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=Cn(this.rank),r=nPe(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function nPe(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}function RY(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=_.parseAxisParam(i,s.shape)[0];if(me().get("DEBUG")){let b=n.readSync(a.dataId),x=s.shape[l];for(let w=0;w<b.length;++w){let v=b[w];_.assert(v<=x-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${x-1}]`)}}let u=W.segment_util.collectGatherOpShapeInfo(s,a,l,o),c=_.sizeFromShape(a.shape),d=[],h=Be({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=Be({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);let f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||s.dtype==="string"){let b=n.bufferSync(p),x=n.bufferSync(h),w=iFe(x,b,f);return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(u.outputShape,w.dtype,w.values)}let m=new tPe(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);let y=Be({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}var rPe={kernelName:by,backendName:"webgl",kernelFunc:RY},sPe="return float(a > b);",aPe=`
  return vec4(greaterThan(a, b));
`,iPe=Cs({opSnippet:sPe,packedOpSnippet:aPe,cpuKernelImpl:oFe,dtype:"bool"}),oPe={kernelName:wy,backendName:"webgl",kernelFunc:iPe},lPe="return float(a >= b);",uPe=`
  return vec4(greaterThanEqual(a, b));
`,cPe=Cs({opSnippet:lPe,packedOpSnippet:uPe,dtype:"bool",cpuKernelImpl:lFe}),dPe={kernelName:Up,backendName:"webgl",kernelFunc:cPe};function hPe(e){let{inputs:t,backend:n}=e,{input:r}=t;return AY(r,!0,n)}var pPe={kernelName:nN,backendName:"webgl",kernelFunc:hPe},fPe="return float(!isnan(x) && !isinf(x));",mPe=Jt({opSnippet:fPe,dtype:"bool"}),gPe={kernelName:Hp,backendName:"webgl",kernelFunc:mPe},yPe="return float(isinf(x));",bPe=Jt({opSnippet:yPe,dtype:"bool"}),xPe={kernelName:jp,backendName:"webgl",kernelFunc:bPe},wPe="return float(isnan(x));",vPe=Jt({opSnippet:wPe,dtype:"bool"}),kPe={kernelName:qp,backendName:"webgl",kernelFunc:vPe},IPe="return float(a < b);",SPe=`
  return vec4(lessThan(a, b));
`,CPe=Cs({opSnippet:IPe,packedOpSnippet:SPe,cpuKernelImpl:uFe,dtype:"bool"}),NPe={kernelName:vy,backendName:"webgl",kernelFunc:CPe},$Pe="return float(a <= b);",TPe=`
  return vec4(lessThanEqual(a, b));
`,_Pe=Cs({opSnippet:$Pe,packedOpSnippet:TPe,cpuKernelImpl:cFe,dtype:"bool"}),EPe={kernelName:ky,backendName:"webgl",kernelFunc:_Pe};function APe(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=dFe(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}var RPe={kernelName:Iy,backendName:"webgl",kernelFunc:APe},DPe=vb+`
  return x < 0.0 ? 0./0. : log(x);
`,FPe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,OPe=Jt({opSnippet:DPe,packedOpSnippet:FPe,cpuKernelImpl:hFe}),MPe={kernelName:Xp,backendName:"webgl",kernelFunc:OPe},LPe=vb+`
  return log(1.0 + x);
`,PPe=Jt({opSnippet:LPe}),zPe={kernelName:Yp,backendName:"webgl",kernelFunc:PPe},BPe="return float(a >= 1.0 && b >= 1.0);",WPe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,VPe=Cs({opSnippet:BPe,packedOpSnippet:WPe,dtype:"bool"}),UPe={kernelName:Sy,backendName:"webgl",kernelFunc:VPe},GPe="return float(!(x >= 1.0));",HPe=Jt({opSnippet:GPe}),jPe={kernelName:Cy,backendName:"webgl",kernelFunc:HPe},qPe="return float(a >= 1.0 || b >= 1.0);",KPe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,XPe=Cs({opSnippet:qPe,packedOpSnippet:KPe,dtype:"bool"}),YPe={kernelName:Ny,backendName:"webgl",kernelFunc:XPe},ZPe=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];let a=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;s===.5?o=`inversesqrt(${l})`:s===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},JPe=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;s===.5?o=`inversesqrt(${l})`:s===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},QPe=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=me().getBool("WEBGL_PACK_NORMALIZATION")?new JPe(s.shape,a,i,o,l):new ZPe(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)},eze={kernelName:Zp,backendName:"webgl",kernelFunc:QPe},tze=class{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},nze=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new tze(s.shape,o,l,u,c);return n.runWebGLProgram(d,[s,a,i],s.dtype)},rze={kernelName:$y,backendName:"webgl",kernelFunc:nze};function sze(e,t,n,r){let s=_.sizeFromShape(t),a=_.sizeFromShape(e.shape)/s,i=Be({inputs:{x:e},attrs:{shape:[a,s]},backend:r}),o=Vf(i,e.dtype,"max",r),l=Be({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}function DY(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=_.parseAxisParam(a,s.shape),u=l,c=W.getAxesPermutation(u,o),d=c!=null,h=n.shouldExecuteOnCPU([s]),p=s;if(d){if(h){let b=n.texData.get(p.dataId).values,x=new Array(o);for(let k=0;k<x.length;k++)x[k]=s.shape[c[k]];let w=dL(b,s.shape,s.dtype,c,x);p=n.makeTensorInfo(x,s.dtype);let v=n.texData.get(p.dataId);v.values=w}else p=m2(s,c,n);u=W.getInnerMostAxes(u.length,o)}W.assertAxesAreInnerMostDims("max",u,o);let[f,m]=W.computeOutAndReduceShapes(p.shape,u),g=f;i&&(g=W.expandShapeToKeepDim(f,l));let y;if(h){let b=n.texData.get(p.dataId).values,x=pFe(b,_.sizeFromShape(m),g,s.dtype);y=n.makeTensorInfo(g,s.dtype);let w=n.texData.get(y.dataId);w.values=x}else y=sze(p,m,g,n);return d&&n.disposeIntermediateTensorInfo(p),y}var aze={kernelName:Jp,backendName:"webgl",kernelFunc:DY},ize=hL+`
  return max(a, b);
`,oze=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Wf+`
  return result;
`,lze=Cs({opSnippet:ize,packedOpSnippet:oze,cpuKernelImpl:fFe}),uze={kernelName:Qp,backendName:"webgl",kernelFunc:lze};function cze(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;gb(s,"maxPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;_.assert(W.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=W.computePool2DInfo(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&_.arraysEqual(c.inShape,c.outShape))return ti({inputs:{x:s},backend:n});let d=new $0(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}var dze={kernelName:ef,backendName:"webgl",kernelFunc:cze};function hze(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],d=W.computePool3DInfo(s.shape,a,i,c,o,u,l),h=new fL(d,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}var pze={kernelName:Ty,backendName:"webgl",kernelFunc:hze},fze=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,l=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},mze=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${d}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function gze(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],h=W.computePool3DInfo(i.shape,o,l,d,u,c),p=new fL(h,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new mze(h),g=n.runWebGLProgram(m,[s,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}var yze={kernelName:lw,backendName:"webgl",kernelFunc:gze};function bze(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;gb([a,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=W.computePool2DInfo(o.shape,l,u,1,c,d),p=!0,f=new $0(h,"max",p),m=n.runWebGLProgram(f,[o],o.dtype),g=new fze(h),y=n.runWebGLProgram(g,[s,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}var xze={kernelName:sN,backendName:"webgl",kernelFunc:bze};function wze(e,t,n,r){let s=new $0(n,"max",!1),a=r.runWebGLProgram(s,[e],"float32");s=new $0(n,"max",!0,!0,t);let i=r.runWebGLProgram(s,[e],"float32");return[a,i]}var vze={kernelName:aN,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;_.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];_.assert(W.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=W.computePool2DInfo(r.shape,s,a,u,i),[d,h]=wze(r,o,c,l);return[d,h]}};function kze(e,t,n,r){let s=_.sizeFromShape(t),a=_.sizeFromShape(e.shape)/s,i=Be({inputs:{x:e},attrs:{shape:[a,s]},backend:r}),o=Vf(i,"float32","mean",r),l=Be({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}var Ize={kernelName:tf,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,l=_.parseAxisParam(a,r.shape),u=l,c=W.getAxesPermutation(u,o),d=c!=null,h=i.shouldExecuteOnCPU([r]),p=[],f=r;if(d){if(h){let x=i.texData.get(f.dataId).values,w=new Array(o);for(let I=0;I<w.length;I++)w[I]=r.shape[c[I]];let v=dL(x,r.shape,r.dtype,c,w);f=i.makeTensorInfo(w,r.dtype);let k=i.texData.get(f.dataId);k.values=v}else f=m2(r,c,i);p.push(f),u=W.getInnerMostAxes(u.length,o)}W.assertAxesAreInnerMostDims("sum",u,o);let[m,g]=W.computeOutAndReduceShapes(f.shape,u),y=m;s&&(y=W.expandShapeToKeepDim(m,l));let b=kze(f,g,y,i);for(let x of p)i.disposeIntermediateTensorInfo(x);return b}};function Sze(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=_.parseAxisParam(a,s.shape),u=l,c=W.getAxesPermutation(u,o),d=s;c!=null&&(d=na({inputs:{x:s},backend:n,attrs:{perm:c}}),u=W.getInnerMostAxes(u.length,s.shape.length)),W.assertAxesAreInnerMostDims("min",u,o);let[h,p]=W.computeOutAndReduceShapes(d.shape,u),f=_.sizeFromShape(p),m=Be({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=Vf(m,m.dtype,"min",n),y;if(i){let b=W.expandShapeToKeepDim(h,l);y=Be({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=Be({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}var Cze={kernelName:nf,backendName:"webgl",kernelFunc:Sze},Nze=hL+`
  return min(a, b);
`,$ze=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Wf+`
  return result;
`,Tze=Cs({opSnippet:Nze,packedOpSnippet:$ze,cpuKernelImpl:mFe}),_ze={kernelName:rf,backendName:"webgl",kernelFunc:Tze},Eze=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);let r=e.length,s=Cn(r),a=t.map(u=>u[0]).join(","),i=t.map((u,c)=>u[0]+e[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},Aze=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,f)=>p[0]+e[f]+p[1]);let r=e.length,s=Cn(r),a=t.map(p=>p[0]).join(","),i=t.map((p,f)=>p[0]+e[f]).join(","),o=Ys("rc",r),l=Ys("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${l.slice(-2).join()})`,d=n==="reflect"?0:1,h="";if(r===1){let p=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;h=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${o[r-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
      `}else{let p=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;h=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${o[r-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
        rc = outputLoc;
        ${o[r-2]} += 1;
        if(${o[r-2]} < ${this.outputShape[r-2]}) {
          ${p}
          result[2] = getChannel(getX(${l.join()}), ${c});
          ${o[r-1]} += 1;
          if(${u}) {
            ${p}
            result[3] = getChannel(getX(${l.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}},Rze=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:s,mode:a}=n,i=me().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Aze(r.shape,s,a):new Eze(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)},Dze={kernelName:sf,backendName:"webgl",kernelFunc:Rze},Fze=`if (b == 0.0) return NAN;
  return mod(a, b);`,Oze=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Wf+`
  return result;
`,Mze=Cs({opSnippet:Fze,packedOpSnippet:Oze}),Lze={kernelName:_y,backendName:"webgl",kernelFunc:Mze},Pze=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},zze=`
if (a == b) {
  return 1.0;
};
return a / b;`,Bze=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,FY=Cs({opSnippet:zze,packedOpSnippet:Bze,checkOutOfBounds:!0}),Wze={kernelName:Mp,backendName:"webgl",kernelFunc:FY},_U="return a - b;",OY=Cs({opSnippet:_U,packedOpSnippet:_U,supportsComplex:!0,cpuKernelImpl:MFe}),Vze={kernelName:_f,backendName:"webgl",kernelFunc:OY};function MY(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=_.parseAxisParam([a],s.shape),o=DY({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=W.expandShapeToKeepDim(o.shape,i),u=Be({inputs:{x:o},backend:n,attrs:{shape:l}}),c=OY({inputs:{a:s,b:u},backend:n}),d=EY({inputs:{x:c},backend:n}),h=g2({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=Be({inputs:{x:h},backend:n,attrs:{shape:l}}),f=FY({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}var Uze={kernelName:$f,backendName:"webgl",kernelFunc:MY};function Gze(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:MY({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new Pze(u,c,a),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}var Hze={kernelName:Ey,backendName:"webgl",kernelFunc:Gze},jze=So+`
  return -x;
`,qze=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Kze(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let a=n.texData.get(r.dataId),[i,o]=yFe(a.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let s;return me().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new bc(r.shape,qze):s=new _l(r.shape,jze),n.runWebGLProgram(s,[r],r.dtype)}var Xze={kernelName:Ay,backendName:"webgl",kernelFunc:Kze},Yze=Yl.nonMaxSuppressionV3Impl;function Zze(e){W.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=Yze(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var Jze={kernelName:Dy,backendName:"webgl",kernelFunc:Zze},Qze=Yl.nonMaxSuppressionV4Impl;function eBe(e){W.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),{selectedIndices:h,validOutputs:p}=Qze(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}var tBe={kernelName:Fy,backendName:"webgl",kernelFunc:eBe},nBe=Yl.nonMaxSuppressionV5Impl;function rBe(e){W.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=nBe(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var sBe={kernelName:Oy,backendName:"webgl",kernelFunc:rBe},aBe=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},iBe=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=_.sizeFromShape(s.shape),c=new aBe(u,i,o,l),d=Be({inputs:{x:s},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],a);n.disposeIntermediateTensorInfo(d);let p=[...s.shape,i],f=Be({inputs:{x:h},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(h),f},oBe={kernelName:of,backendName:"webgl",kernelFunc:iBe};function kS(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let s=e1({inputs:{input:r},backend:n}),a=kS({inputs:{x:s},backend:n}),i=y2({inputs:{input:r},backend:n}),o=kS({inputs:{x:i},backend:n}),l=Cd({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return t1({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var lBe={kernelName:tb,backendName:"webgl",kernelFunc:kS};function LY(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let s=e1({inputs:{input:r},backend:n}),a=LY({inputs:{x:s},backend:n}),i=y2({inputs:{input:r},backend:n}),o=kS({inputs:{x:i},backend:n}),l=Cd({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return t1({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var uBe={kernelName:My,backendName:"webgl",kernelFunc:LY};function cBe(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return KA({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,i=t[0].dtype;t.forEach(c=>{_.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),_.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(c=>{let d=KA({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=kY({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var dBe={kernelName:Ly,backendName:"webgl",kernelFunc:cBe},hBe=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,u)=>l[0]+e[u]+l[1]);let r=e.length,s=Cn(r),a=t.map(l=>l[0]).join(","),i=t.map((l,u)=>l[0]+e[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},pBe=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);let r=e.length,s=Cn(r),a=t.map(f=>f[0]).join(","),i=t.map((f,m)=>f[0]+e[m]).join(","),o=Ys("rc",r),l=Ys("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;
       if(${u}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${o[r-2]} += 1;
       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${o[r-1]} += 1;
         if(${u}) {`],h=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",p="";for(let f=0,m=r===1?2:4;f<m;f++)p+=`
        ${d[f]}
        if (${h}) {
          result[${f}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${f}] = getChannel(getX(${l.join()}), ${c});
        }
      `;p+=r===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}},PY=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(_.sizeFromShape(s.shape)===0){let u=a.map((c,d)=>c[0]+s.shape[d]+c[1]);return t1({backend:n,attrs:{shape:u,value:i,dtype:s.dtype}})}let o=me().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new pBe(s.shape,a,i):new hBe(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},fBe={kernelName:lf,backendName:"webgl",kernelFunc:PY},mBe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,gBe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Wf+`
  return result;
`,yBe=Cs({opSnippet:mBe,packedOpSnippet:gBe}),bBe={kernelName:uf,backendName:"webgl",kernelFunc:yBe};function xBe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=_.parseAxisParam(a,s.shape),c=u,d=W.getAxesPermutation(c,o),h=s;d!=null&&(h=na({inputs:{x:s},backend:n,attrs:{perm:d}}),c=W.getInnerMostAxes(c.length,o),l.push(h)),W.assertAxesAreInnerMostDims("prod",c,o);let p;if(n.shouldExecuteOnCPU([h])){let f=n.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=xFe(h.shape,h.dtype,f,c);p=n.makeTensorInfo(g,y,m)}else{let[f,m]=W.computeOutAndReduceShapes(h.shape,c),g=_.sizeFromShape(m),y=Be({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),b=dN(s.dtype),x=Vf(y,b,"prod",n);p=Be({inputs:{x},backend:n,attrs:{shape:f}}),l.push(y),l.push(x)}if(i){l.push(p);let f=W.expandShapeToKeepDim(p.shape,u);p=Be({inputs:{x:p},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}var wBe={kernelName:df,backendName:"webgl",kernelFunc:xBe};function vBe(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map(y=>n.readSync(y.dataId)),u=s.map(y=>y.shape),c=n.readSync(a.dataId),d=n.readSync(i.dataId),[h,p,f]=wFe(l,u,c,a.shape,a.dtype,d,i.shape,o),m=h.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}var kBe={kernelName:iN,backendName:"webgl",kernelFunc:vBe};function IBe(e){let{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=vFe(i,r.shape,r.dtype,o,s.shape,l,a.shape),d=n.makeTensorInfo([u.length],"int32",u),h=n.makeTensorInfo([c.length],r.dtype,c);return[d,h]}var SBe={kernelName:oN,backendName:"webgl",kernelFunc:IBe};function CBe(e){let{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),d=n.readSync(i.dataId),h=o.map(g=>n.readSync(g.dataId)),p=o.map(g=>g.shape),[f,m]=kFe(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}var NBe={kernelName:lN,backendName:"webgl",kernelFunc:CBe},zY=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=IFe(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},$Be={kernelName:uw,backendName:"webgl",kernelFunc:zY},TBe="return 1.0 / x;",_Be=Jt({opSnippet:TBe}),EBe={kernelName:hf,backendName:"webgl",kernelFunc:_Be},ABe=So+`
  return (x < 0.0) ? 0.0 : x;
`,RBe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,DBe=Jt({opSnippet:ABe,packedOpSnippet:RBe}),FBe={kernelName:pf,backendName:"webgl",kernelFunc:DBe},OBe=So+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,MBe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,LBe=Jt({opSnippet:OBe,packedOpSnippet:MBe}),PBe={kernelName:gf,backendName:"webgl",kernelFunc:LBe},zBe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[a,i,o,l]=e;this.outputShape=[a,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;s?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},BBe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,o,l]=e;this.outputShape=[a,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;s?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/c[0]},
          ${u[1]/c[1]},
          ${u[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function WBe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=me().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new BBe(s.shape,l,u,a,i):new zBe(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}var VBe={kernelName:mf,backendName:"webgl",kernelFunc:WBe},UBe=class{constructor(t,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;let[,s,a]=n,[,i,o]=t,l=[r&&i>1?s-1:s,r&&o>1?a-1:a],u=[r&&i>1?i-1:i,r&&o>1?o-1:o],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=Math.ceil(h)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function GBe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new UBe(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}var HBe={kernelName:By,backendName:"webgl",kernelFunc:GBe},jBe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[a,i,o,l]=e;this.outputShape=[a,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0",h;s?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},qBe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,o,l]=e;this.outputShape=[a,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0",h;s?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/c[0]},
          ${u[1]/c[1]},
          ${u[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function KBe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=me().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qBe(s.shape,l,u,a,i):new jBe(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}var XBe={kernelName:ff,backendName:"webgl",kernelFunc:KBe},YBe=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=Math.ceil(d)*2+2,f=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function ZBe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new YBe(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}var JBe={kernelName:zy,backendName:"webgl",kernelFunc:ZBe},QBe=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,s=e.map((i,o)=>r(o)).join(","),a=Cn(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}},e4e=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=Ys("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Cn(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(r.slice())};
          if(${s}){
            result.g = ${l(r.slice())};
          }
          if(${a}) {
            result.b = ${u(r.slice())};
            if(${s}) {
              result.a = ${c(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(p){return d(p)}function l(p){return p[n-1]="("+p[n-1]+" + 1)",d(p)}function u(p){return p[n-2]="("+p[n-2]+" + 1)",d(p)}function c(p){return p[n-1]="("+p[n-1]+" + 1)",p[n-2]="("+p[n-2]+" + 1)",d(p)}function d(p){let f=e.map((y,b)=>h(b,p)),m=f.join(","),g=f.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${g}))`}function h(p,f){return t.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${f[p]} - 1`:`${f[p]}`}}};function t4e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=_.parseAxisParam(a,s.shape);if(i===0)return ti({inputs:{x:s},backend:n});let l=me().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new e4e(s.shape,o):new QBe(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}var n4e={kernelName:yf,backendName:"webgl",kernelFunc:t4e},r4e=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},s4e={kernelName:nb,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=new r4e(r.shape,a),[u,c]=W.getImageCenter(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(l,[r],r.dtype,d)}},a4e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,i4e=Jt({opSnippet:a4e}),o4e={kernelName:bf,backendName:"webgl",kernelFunc:i4e},l4e="return inversesqrt(x);",u4e=Jt({opSnippet:l4e,cpuKernelImpl:SFe}),c4e={kernelName:xf,backendName:"webgl",kernelFunc:u4e},mL=class{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;let l=Cn(s.length),u=Cn(a.length),c="";n===1?c="i":n===2&&(c="i, j");let d=`getIndices(${c})`,h="";r===1?h="i":r===2&&(h="i, coords[1]");let p=`getUpdates(${h})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${g};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}},d4e=class{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;let l=Cn(s.length),u=Cn(a.length),c="";n===1?c="i":n===2&&(c="i, j");let d=`getIndices(${c})`,h="";r===1?h="i":r===2&&(h="i, coords[1]");let p=`getUpdates(${h})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${g};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}};function h4e(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=W.calculateShapes(a,s,i),h=[d/u,u];if(d===0)return n.makeTensorInfo(i,s.dtype);let p=Be({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=Be({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g;me().getBool("WEBGL_PACK")?g=new d4e(l,o,p.shape.length,f.shape.length,c,h):g=new mL(l,o,p.shape.length,f.shape.length,c,h);let y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=Be({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}var p4e={kernelName:Wy,backendName:"webgl",kernelFunc:h4e},f4e=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let s="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=me().getNumber("WEBGL_VERSION")===2?s:a,o=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function m4e(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new f4e(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}var g4e={kernelName:Uy,backendName:"webgl",kernelFunc:m4e},y4e=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",r="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let u=0;u<t.length;u++)l.push(`${i[u]}`),u<e&&o.push(`${i[u]}`);r=o.join(),s=l.join()}let a=Cn(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function b4e(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new y4e(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],$i(s.dtype,a.dtype))}var x4e={kernelName:Gy,backendName:"webgl",kernelFunc:b4e},w4e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${W.SELU_SCALEALPHA};
  float scale = ${W.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,v4e=Jt({opSnippet:w4e}),k4e={kernelName:wf,backendName:"webgl",kernelFunc:v4e},I4e=vb+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,S4e=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,C4e=Jt({opSnippet:I4e,packedOpSnippet:S4e,cpuKernelImpl:NFe}),N4e={kernelName:If,backendName:"webgl",kernelFunc:C4e},$4e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,T4e=Jt({opSnippet:$4e}),_4e={kernelName:kf,backendName:"webgl",kernelFunc:T4e},E4e=vb+`
  return sin(x);
`,A4e=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Wf}
  return result;
`,R4e=Jt({opSnippet:E4e,packedOpSnippet:A4e}),D4e={kernelName:vf,backendName:"webgl",kernelFunc:R4e},F4e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,O4e=Jt({opSnippet:F4e}),M4e={kernelName:jy,backendName:"webgl",kernelFunc:O4e},L4e=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,P4e=Jt({opSnippet:L4e}),z4e={kernelName:Sf,backendName:"webgl",kernelFunc:P4e},B4e=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;_.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=a.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+a.length;y<s.shape.length;++y)l.push([0,0]);let u=[],c=PY({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=W.getReshaped(c.shape,a,o,!1),h=W.getPermuted(d.length,a.length,!1),p=W.getReshapedPermuted(c.shape,a,o,!1),f=Be({inputs:{x:c},backend:n,attrs:{shape:d}}),m=na({inputs:{x:f},backend:n,attrs:{perm:h}}),g=Be({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(y=>n.disposeIntermediateTensorInfo(y)),g},W4e={kernelName:qy,backendName:"webgl",kernelFunc:B4e};function V4e(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=TFe(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var U4e={kernelName:cw,backendName:"webgl",kernelFunc:V4e};function G4e(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,d]=_Fe(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var H4e={kernelName:Xy,backendName:"webgl",kernelFunc:G4e};function j4e(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);let i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=lY(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var q4e={kernelName:dw,backendName:"webgl",kernelFunc:j4e};function K4e(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);let i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=lY(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}var X4e={kernelName:hw,backendName:"webgl",kernelFunc:K4e};function Y4e(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=W.calculateShapes(a,s,o),p=!1;if(a.dtype==="string"){let y=n.bufferSync(s),b=n.bufferSync(a),x=_.decodeString(n.readSync(i.dataId)[0]),w=CFe(y,b,o,h,c,u,l,d,x,p);return n.makeTensorInfo(o,w.dtype,w.values)}let f=new mL(u,l,s.shape.length,a.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=Be({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}var Z4e={kernelName:Yy,backendName:"webgl",kernelFunc:Y4e};function J4e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=_.parseAxisParam(i,s.shape)[0],l=W.prepareSplitSize(s,a,o),u=s.shape.length,c=new Array(u).fill(0),d=s.shape.slice();return l.map(h=>{let p=[...d];p[o]=h;let f=kb({inputs:{x:s},backend:n,attrs:{begin:c,size:p}});return c[o]+=h,f})}var Q4e={kernelName:Ky,backendName:"webgl",kernelFunc:J4e},EU="return sqrt(x);",eWe=Jt({opSnippet:EU,packedOpSnippet:EU,cpuKernelImpl:EFe}),tWe={kernelName:Cf,backendName:"webgl",kernelFunc:eWe},nWe="return x * x;",rWe=Jt({opSnippet:nWe}),sWe={kernelName:pw,backendName:"webgl",kernelFunc:rWe},AU="return (a - b) * (a - b);",aWe=Cs({opSnippet:AU,packedOpSnippet:AU}),iWe={kernelName:Tf,backendName:"webgl",kernelFunc:aWe};function oWe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");let a=n.readSync(s.dataId),i=W.fromUint8ToStringArray(a),o=AFe(i,"string",r);return n.makeTensorInfo(s.shape,"string",o)}var lWe={kernelName:fw,backendName:"webgl",kernelFunc:oWe};function uWe({inputs:e,attrs:t,backend:n}){let{x:r}=e,s=So+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new _l(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}var cWe={kernelName:xd,backendName:"webgl",kernelFunc:uWe},dWe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,s=Cn(n.length),a=Cn(n.length),i="";if(r===1)i="coords * strides + begin";else{let o=0;i=n.map((l,u)=>(o++,n.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${o-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function hWe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=Br.sliceInfo(s.shape,a,i,o,l,u,c,d,h),v;if(m)v=Be({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){_.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let I=Br.computeOutShape(b,x,w),S=kb({inputs:{x:s},backend:n,attrs:{begin:b,size:I}});v=Be({inputs:{x:S},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(S)}else if(n.shouldExecuteOnCPU([s])){let I=n.readSync(s.dataId),S=Ot(s.shape,s.dtype,I),$=RFe(p,S,w,b);v=n.makeTensorInfo(f,s.dtype,$.values)}else{let I=new dWe(b,w,p);v=n.runWebGLProgram(I,[s],s.dtype)}let k=Be({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(v),k}var pWe={kernelName:Zy,backendName:"webgl",kernelFunc:hWe};function fWe(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=DFe(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var mWe={kernelName:mw,backendName:"webgl",kernelFunc:fWe};function gWe(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=FFe(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var yWe={kernelName:gw,backendName:"webgl",kernelFunc:gWe};function bWe(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(a.dataId),o=OFe(i,s);return n.makeTensorInfo(a.shape,"int32",o)}var xWe={kernelName:yw,backendName:"webgl",kernelFunc:bWe},wWe="return tan(x);",vWe=Jt({opSnippet:wWe}),kWe={kernelName:Ef,backendName:"webgl",kernelFunc:vWe},IWe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,SWe=Jt({opSnippet:IWe}),CWe={kernelName:Af,backendName:"webgl",kernelFunc:SWe};function NWe(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=W.calculateShapes(i,a,s.shape),h=[d/u,u];if(d===0)return n.makeTensorInfo(s.shape,a.dtype);let p=Be({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=Be({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=Be({inputs:{x:s},backend:n,attrs:{shape:h}}),g=new mL(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=Be({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}var $We={kernelName:Vy,backendName:"webgl",kernelFunc:NWe},TWe=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;let r=Cn(this.rank),s=_We(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function _We(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}function BY(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if(s.dtype==="string"||s.shape.length>5){let o=n.readSync(s.dataId),l=s.dtype==="string"?o.map(d=>_.decodeString(d)):o,u=Ot(s.shape,s.dtype,l),c=LFe(u,a);return n.makeTensorInfo(c.shape,c.dtype,c.values)}let i=new TWe(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}var EWe={kernelName:bd,backendName:"webgl",kernelFunc:BY},AWe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},RWe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Hd(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function RU(e){let t=1;for(;t<e;)t*=2;return t}function DWe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=me().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=me().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){let $=n.readSync(s.dataId),[N,T]=PFe($,u,s.dtype,a,i);return[n.makeTensorInfo(N.shape,N.dtype,N.values),n.makeTensorInfo(T.shape,T.dtype,T.values)]}if(a===0)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[s,t1({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let d=n.texData.get(s.dataId),h=d!==null&&d.isPacked,p=h?n.unpackTensor(s):s,f=_.sizeFromShape(u)/c,m=Be({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&Hd(n,p);let g=RU(a),y=RU(c),b=null,x=()=>b===null?[m,m]:[m,b],w=($,N,T)=>{let C=x(),E=new AWe(T),M=[[c],[b===null?1:0],[Number.NEGATIVE_INFINITY],[$],[N]],F=b;b=n.runWebGLProgram(E,C,"int32",M),Hd(n,F)};for(let $=1;$<g;$*=2){let N=$*2;for(let T=$;T>=1;T/=2)w(N,T,[f,y])}for(let $=y;$>g;$/=2){let N=x(),T=new RWe([f,$/2]),C=[[c],[b===null?1:0],[g]],E=b;b=n.runWebGLProgram(T,N,"int32",C),Hd(n,E);let M=g/2,F=M*2;for(let z=M;z>=1;z/=2)w(F,z,b.shape)}let v=b;b=kb({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,a]}}),Hd(n,v);let k=RY({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});Hd(n,m);let I=u.slice(0,-1);I.push(a),v=b,b=Be({inputs:{x:b},attrs:{shape:I},backend:n}),Hd(n,v);let S=k;return k=Be({inputs:{x:k},attrs:{shape:I},backend:n}),Hd(n,S),[k,b]}var FWe={kernelName:Jy,backendName:"webgl",kernelFunc:DWe},OWe=class{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;let i=n==="nearest"?1:2,o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function MWe(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,m]=u??[d,h],g=[c,f,m,p],y=new OWe(d,h,i,o,l,g);return n.runWebGLProgram(y,[s,a],"float32")}var LWe={kernelName:Qy,backendName:"webgl",kernelFunc:MWe};function PWe(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;gb(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=zFe(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var zWe={kernelName:bw,backendName:"webgl",kernelFunc:PWe};function BWe(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1),c=0;for(let m=0;m<o;m++)m!==a&&(u[c++]=i.shape[m]);let d=[],h=new Array(o).fill(0),p=i.shape.slice();p[a]=1;let f=new Array(l);for(let m=0;m<f.length;m++){h[a]=m;let g=kb({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),y=Be({inputs:{x:g},backend:n,attrs:{shape:u}});f[m]=y,d.push(g)}return d.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var WWe={kernelName:eb,backendName:"webgl",kernelFunc:BWe},VWe=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];let o="0.0",l="sumValue",u=Math.floor(n/4)*4,c=n%4,d=`
        sumValue += dot(values, segFilter);
    `,h="";s%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function UWe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[],u=0,c=W.getAxesPermutation([u],o),d=s;c!=null&&(d=na({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(d),u=W.getInnerMostAxes(1,o)[0]);let h=W.segment_util.computeOutShape(d.shape,u,i),p=_.sizeFromShape([d.shape[u]]),f=Be({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);let m=dN(s.dtype),g=(w,v,k,I,S)=>{let $=w.shape[0],N=w.shape[1],T=W.segment_util.segOpComputeOptimalWindowSize(N,S),C={windowSize:T,inSize:N,batchSize:$,numSegments:S},E=new VWe(C,v),M=n.compileAndRun(E,[w,k],I);if(l.push(M),M.shape[1]===S)return M;let F=zY({backend:n,attrs:{start:0,stop:S,step:1,dtype:"float32"}}),z=BY({inputs:{x:F},backend:n,attrs:{reps:[N/T]}});return l.push(F),l.push(z),g(M,v,z,I,S)},y=g(f,"unsortedSegmentSum",a,m,i),b=Be({inputs:{x:y},backend:n,attrs:{shape:h}}),x=b;if(c!=null){l.push(b);let w=W.getUndoAxesPermutation(c);x=na({inputs:{x},backend:n,attrs:{perm:w}})}return l.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}var GWe={kernelName:xw,backendName:"webgl",kernelFunc:UWe},HWe=[ROe,FOe,LOe,BOe,VOe,HOe,qOe,XOe,QOe,tMe,sMe,oMe,cMe,fMe,yMe,xMe,vMe,CMe,$Me,_Me,DMe,BMe,VMe,GMe,YMe,JMe,n3e,mOe,a3e,c3e,f3e,w3e,I3e,C3e,$3e,_3e,D3e,M3e,z3e,W3e,U3e,H3e,K3e,Y3e,eLe,nLe,aLe,lLe,cLe,fLe,bLe,kLe,CLe,TLe,_Le,ALe,DLe,OLe,LLe,zLe,ULe,jLe,XLe,ZLe,ePe,rPe,oPe,dPe,fOe,pPe,l3e,gPe,xPe,kPe,yOe,NPe,EPe,RPe,MPe,zPe,UPe,jPe,YPe,eze,rze,aze,uze,dze,pze,yze,xze,vze,Ize,Cze,_ze,Dze,Lze,Hze,wOe,Xze,Jze,tBe,sBe,jMe,oBe,uBe,dBe,fBe,bBe,xOe,wBe,kBe,SBe,NBe,$Be,qMe,Wze,EBe,FBe,PBe,kOe,VBe,HBe,XBe,JBe,n4e,s4e,o4e,c4e,p4e,g4e,x4e,k4e,N4e,_4e,D4e,M4e,PMe,Uze,z4e,W4e,U4e,H4e,q4e,X4e,Z4e,Q4e,tWe,sWe,iWe,lWe,cWe,pWe,mWe,yWe,xWe,Vze,_Oe,kWe,CWe,$We,EWe,FWe,LWe,EOe,zWe,WWe,GWe,lBe];for(let e of HWe)ww(e);var hn;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(hn||(hn={}));var _0;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(_0||(_0={}));var WY;function jWe(e){WY=e.wasm.cwrap(Lh,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function qWe(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r,h=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(a.dataId).id,f=0;if(i!=null){let S=n.dataIdMap.get(i.dataId);if(S.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${S.shape.length}.`);f=S.id}let m=o==null?0:n.dataIdMap.get(o.dataId).id,g=_0[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?s.shape[2]:s.shape[1],b=u?a.shape[1]:a.shape[2],x=rb.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)),w=n.makeOutput([...x,y,b],s.dtype),v=n.dataIdMap.get(w.dataId).id,k=new Uint8Array(new Int32Array(s.shape).buffer),I=new Uint8Array(new Int32Array(a.shape).buffer);return WY(h,k,s.shape.length,p,I,a.shape.length,l,u,g,f,m,d||0,v),w}var KWe={kernelName:Lh,backendName:"wasm",setupFunc:jWe,kernelFunc:qWe};function sn(e,t){let n;function r(a){n=a.wasm.cwrap(e,null,["number","number","number"])}function s(a){let{backend:i,inputs:{x:o}}=a,l=i.dataIdMap.get(o.dataId).id,u=i.makeOutput(o.shape,t||o.dtype),c=i.dataIdMap.get(u.dataId).id;return _.sizeFromShape(u.shape)===0||n(l,hn[o.dtype],c),u}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:s}}var XWe=sn(Qg),YWe=sn(gp),ZWe=sn(yp);function us(e,t,n){let r;function s(i){r=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function a(i){let{backend:o,inputs:l}=i,{a:u,b:c}=l,d=o.dataIdMap.get(u.dataId).id,h=o.dataIdMap.get(c.dataId).id,p=n??u.dtype,f=W.assertAndGetBroadcastShape(u.shape,c.shape),m=o.makeOutput(f,p);if(_.sizeFromShape(f)===0)return m;let g=new Uint8Array(new Int32Array(u.shape).buffer),y=new Uint8Array(new Int32Array(c.shape).buffer),b=o.dataIdMap.get(m.dataId).id;return r(d,g,u.shape.length,h,y,c.shape.length,hn[u.dtype],b),m}return{kernelName:e,backendName:"wasm",setupFunc:s,kernelFunc:a}}var JWe=us(gd),VY;function QWe(e){VY=e.wasm.cwrap(bp,null,["array","number","number","number"])}function eVe(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(_.sizeFromShape(r.shape)===0)return r;let s=t.map(o=>n.dataIdMap.get(o.dataId).id),a=new Uint8Array(new Int32Array(s).buffer),i=n.dataIdMap.get(r.dataId).id;return VY(a,s.length,hn[r.dtype],i),r}var tVe={kernelName:bp,backendName:"wasm",setupFunc:QWe,kernelFunc:eVe};function b2(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return Js(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(s),r}var nVe={kernelName:Gp,backendName:"wasm",kernelFunc:b2},UY;function rVe(e){UY=e.wasm.cwrap(Cu,null,["number","array","number","number","number","array","number"])}function Qc(e){let{inputs:t,backend:n,attrs:r}=e,[s,a]=aVe(t.x.shape,r.perm),i=!0;for(let f=0;f<a.length;f++)a[f]!==f&&(i=!1);let o=sVe(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:s,dtype:t.x.dtype};if(i){let f=b2({inputs:t,backend:n});return f.shape=o,f}let u=n.makeOutput(o,l.dtype),c=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,h=new Uint8Array(new Int32Array(a).buffer),p=new Uint8Array(new Int32Array(l.shape).buffer);return UY(c,p,l.shape.length,hn[l.dtype],d,h,a.length),u}function sVe(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function aVe(e,t){let n=[],r=[];for(let s=0;s<e.length;++s)e[s]!==1&&n.push(e[s]),e[t[s]]!==1&&r.push(t[s]);for(let s=0;s<r.length;++s){let a=-1;for(let i=0;i<r.length;++i)r[i]>=s&&(a===-1||r[a]>r[i])&&(a=i);r[a]=s}return[n,r]}var iVe={kernelName:Cu,backendName:"wasm",kernelFunc:Qc,setupFunc:rVe};function Nd(e,t,n){let r=e.shape,s=e.shape.length,a=_.parseAxisParam(t,r),i=a,o=W.getAxesPermutation(i,s),l=null,u=!1;if(o!=null){let c=new Array(s);for(let h=0;h<c.length;h++)c[h]=r[o[h]];i=W.getInnerMostAxes(i.length,s),l=Qc({inputs:{x:e},attrs:{perm:o},backend:n});let d=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==d&&(u=!0)}return{transposed:l,originalAxes:a,axes:i,inputWasTransposed:u}}var GY;function oVe(e){GY=e.wasm.cwrap(ey,null,["number, number, number"])}function lVe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=Nd(i,s,t);if(h){let b=t.dataIdMap.get(u.dataId).id;l=u,o=b}let p=l.shape.length;W.assertAxesAreInnerMostDims("all",c,p);let[f,m]=W.computeOutAndReduceShapes(l.shape,c),g=_.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(_.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;GY(o,g,b)}if(h&&t.disposeData(u.dataId),a){let b=W.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var uVe={kernelName:ey,backendName:"wasm",setupFunc:oVe,kernelFunc:lVe},HY;function cVe(e){HY=e.wasm.cwrap(ty,null,["number, number, number"])}function dVe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=Nd(i,s,t);if(h){let b=t.dataIdMap.get(u.dataId).id;l=u,o=b}let p=l.shape.length;W.assertAxesAreInnerMostDims("any",c,p);let[f,m]=W.computeOutAndReduceShapes(l.shape,c),g=_.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(_.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;HY(o,g,b)}if(h&&t.disposeData(u.dataId),a){let b=W.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var hVe={kernelName:ty,backendName:"wasm",setupFunc:cVe,kernelFunc:dVe};function jY(e){let t;function n(s){t=s.wasm.cwrap(e,null,["number","number","number","number","number"])}function r(s){let{backend:a,inputs:i,attrs:o}=s,{axis:l}=o,{x:u}=i,c=a.dataIdMap.get(u.dataId).id,d=c,h=u,{transposed:p,axes:f,inputWasTransposed:m}=Nd(u,l,a);if(m){let v=a.dataIdMap.get(p.dataId).id;v!==c&&(h=p,d=v)}let g=h.shape.slice(0,-1),y=a.makeOutput(g,"int32"),b=a.dataIdMap.get(y.dataId).id,x=_.sizeFromShape(y.shape),w=h.shape[f[0]];return t(d,hn[h.dtype],x,w,b),m&&a.disposeData(p.dataId),y}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}var pVe=jY(ny),fVe=jY(ry),mVe=sn(xp),gVe=sn(wp),yVe=sn(vp),bVe=us(Ip),xVe=sn(kp),qY;function wVe(e){qY=e.wasm.cwrap(Sp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function vVe(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=W.computePool2DInfo(s.shape,i,o,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,b=c.strideWidth,x=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let w=r.makeOutput(c.outShape,"float32"),v=r.dataIdMap.get(w.dataId).id;return qY(a,s.shape[0],s.shape[1],s.shape[2],d,h,p,f,m,g,y,b,x,v),w}var kVe={kernelName:Sp,backendName:"wasm",setupFunc:wVe,kernelFunc:vVe},KY;function IVe(e){KY=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function SVe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=W.computePool3DInfo(s.shape,a,i,1,o,l,u),d=n.makeOutput(c.outShape,s.dtype);return KY(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}var CVe={kernelName:sy,backendName:"wasm",setupFunc:IVe,kernelFunc:SVe},XY;function NVe(e){XY=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function $Ve(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=W.computePool3DInfo(a.shape,i,o,1,l,u),d=n.makeOutput(a.shape,a.dtype);return XY(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),d}var TVe={kernelName:nw,backendName:"wasm",setupFunc:NVe,kernelFunc:$Ve};function Ca(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:s}=n,a=_.sizeFromShape(r.shape),i=_.inferFromImplicitShape(s,a);return _.assert(a===_.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var _Ve={kernelName:Py,backendName:"wasm",kernelFunc:Ca},YY;function EVe(e){YY=e.wasm.cwrap(Cp,null,["number","array","number","number","array","number","number","number","number"])}function AVe(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=o?a.shape[u-1]:a.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=_.sizeFromShape(f),y=_.sizeFromShape(m),b=rb.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);_.assert(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,c,h]:[g,h,c],w=o?[y,p,d]:[y,d,p],v=Ca({inputs:{x:s},backend:n,attrs:{shape:x}}),k=Ca({inputs:{x:a},backend:n,attrs:{shape:w}}),I=n.dataIdMap.get(v.dataId).id,S=n.dataIdMap.get(k.dataId).id,$=i?v.shape[2]:v.shape[1],N=o?k.shape[1]:k.shape[2],T=Math.max(g,y),C=n.makeOutput([T,$,N],v.dtype),E=n.dataIdMap.get(C.dataId).id,M=new Uint8Array(new Int32Array(v.shape).buffer),F=new Uint8Array(new Int32Array(k.shape).buffer);return YY(I,M,v.shape.length,S,F,k.shape.length,i,o,E),n.disposeData(v.dataId),n.disposeData(k.dataId),C.shape=b,C}var RVe={kernelName:Cp,backendName:"wasm",setupFunc:EVe,kernelFunc:AVe};function ep(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:s}=e,[a,i]=Br.parseSliceParams(t,n,r),o=Br.isSliceContinous(t.shape,a,i),l=s.readSync(t.dataId),u=s.makeOutput(i,t.dtype),c=_.computeStrides(t.shape),d=s.dataIdMap.get(u.dataId);if(o){let f=Br.computeFlatOffset(a,c);return t.dtype==="string"?d.stringBytes=l.slice(f,f+_.sizeFromShape(i)):s.typedArrayFromHeap(u).set(l.subarray(f,f+_.sizeFromShape(i))),u}if(t.dtype==="string"){let f=gS(l,a,i,t.shape,t.dtype);return d.stringBytes=f,u}let h=s.typedArrayFromHeap(u),p=t.shape.length;if(p===2)DVe(l,c[0],h,a,i);else if(p===3)FVe(l,c[0],c[1],h,a,i);else if(p===4)OVe(l,c[0],c[1],c[2],h,a,i);else{let f=gS(l,a,i,t.shape,t.dtype);h.set(f)}return u}function DVe(e,t,n,r,s){let a=0,i=r[0],o=r[1],l=i+s[0];for(let u=i;u<l;u++){let c=u*t+o;n.set(e.subarray(c,c+s[1]),a),a+=s[1]}}function FVe(e,t,n,r,s,a){let i=0,o=s[0],l=s[1],u=s[2],c=o+a[0],d=l+a[1];for(let h=o;h<c;h++)for(let p=l;p<d;p++){let f=h*t+p*n+u;r.set(e.subarray(f,f+a[2]),i),i+=a[2]}}function OVe(e,t,n,r,s,a,i){let o=0,l=a[0],u=a[1],c=a[2],d=l+i[0],h=u+i[1],p=c+i[2],f=a[3];for(let m=l;m<d;m++)for(let g=u;g<h;g++)for(let y=c;y<p;y++){let b=m*t+g*n+y*r+f;s.set(e.subarray(b,b+i[3]),o),o+=i[3]}}var MVe={kernelName:Hy,backendName:"wasm",kernelFunc:ep};function LVe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r,o=a.reduce((y,b)=>y*b),l=W.getReshaped(s.shape,a,o),u=W.getPermuted(l.length,a.length),c=W.getReshapedPermuted(s.shape,a,o),d=W.getSliceBeginCoords(i,a.length),h=W.getSliceSize(c,i,a.length),p=Ca({inputs:{x:s},backend:n,attrs:{shape:l}}),f=Qc({inputs:{x:p},backend:n,attrs:{perm:u}}),m=Ca({inputs:{x:f},backend:n,attrs:{shape:c}}),g=ep({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(p.dataId),g}var PVe={kernelName:ay,backendName:"wasm",kernelFunc:LVe},ZY;function zVe(e){ZY=e.wasm.cwrap(iy,null,["number","number","boolean","number","number","number"])}function BVe(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,weights:a}=n,{size:i}=r,o=a.shape.reduce((d,h)=>d*h,1)!==0,l=s.shape.length===1?[i]:[s.shape[0],i],u=t.makeOutput(l,a.dtype);function c(d){return t.dataIdMap.get(d.dataId).id}return ZY(c(s),i,o,c(a),hn[a.dtype],c(u)),u}var WVe={kernelName:iy,backendName:"wasm",setupFunc:zVe,kernelFunc:BVe};function VVe(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(s),o=W.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var UVe={kernelName:rw,backendName:"wasm",kernelFunc:VVe};function $d(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,s=r.makeOutput(t.shape,n),a=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(s).set(a),s}var GVe={kernelName:Np,backendName:"wasm",kernelFunc:$d},HVe=sn($p),JY;function jVe(e){JY=e.wasm.cwrap(yd,null,["number","number","number","number"])}function qVe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r,o=n.dataIdMap.get(s.dataId).id,l=n.makeOutput(s.shape,s.dtype),u=n.dataIdMap.get(l.dataId).id;return JY(o,a,i,u),l}var KVe={kernelName:yd,backendName:"wasm",setupFunc:jVe,kernelFunc:qVe};function QY(e){let{inputs:t,backend:n}=e,r=_.parseAxisParam(e.attrs.axis,t[0].shape)[0],s=t.map(p=>p.shape);W.assertParamsConsistent(s,r);let a=W.computeOutShape(t.map(p=>p.shape),r),i=t.filter(p=>_.sizeFromShape(p.shape)>0);if(i.length===1)return b2({inputs:{x:i[0]},backend:n});let o=n.makeOutput(a,t[0].dtype);if(_.sizeFromShape(a)===0)return o;if(i[0].dtype==="string"){let p=i.map(x=>{let w=[-1,_.sizeFromShape(x.shape.slice(r))];return Ca({inputs:{x},backend:n,attrs:{shape:w}})}),f=p.map(x=>({vals:n.readSync(x.dataId),shape:x.shape}));a=W.computeOutShape(p.map(x=>x.shape),1);let m=p[0].shape[0]===1,g=V3(f,a,t[0].dtype,m),y=W.computeOutShape(i.map(x=>x.shape),r);o.shape=y;let b=n.dataIdMap.get(o.dataId);return b.stringBytes=W.fromStringArrayToUint8(g),p.forEach(x=>n.disposeData(x.dataId)),o}let l=_.sizeFromShape(i[0].shape.slice(0,r)),u=0,c=i.map(p=>{let f=_.sizeFromShape(p.shape.slice(r));return u+=f,f}),d=i.map(p=>n.typedArrayFromHeap(p)),h=n.typedArrayFromHeap(o);for(let p=0;p<l;p++){let f=p*u;for(let m=0;m<d.length;m++){let g=c[m],y=p*g,b=d[m].subarray(y,y+g);h.set(b,f),f+=g}}return o}var XVe={kernelName:oy,backendName:"wasm",kernelFunc:QY},eZ;function YVe(e){eZ=e.wasm.cwrap(Tp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ZVe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,i=r.dataIdMap.get(s.dataId).id,o=r.dataIdMap.get(a.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d,dataFormat:h}=n,p=W.convertConv2DDataFormat(h),f=W.computeConv2DInfo(s.shape,a.shape,l,u,c,d,!1,p),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,x=f.padInfo.bottom,w=f.padInfo.left,v=f.dilationHeight,k=f.dilationWidth,I=f.strideHeight,S=f.strideWidth,$=f.inChannels,N=f.outChannels,T=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(f.outShape,"float32"),E=r.dataIdMap.get(C.dataId).id;return eZ(i,s.shape[0],s.shape[1],s.shape[2],o,m,g,y,b,x,w,T,v,k,I,S,$,N,E),C}var JVe={kernelName:Tp,backendName:"wasm",setupFunc:YVe,kernelFunc:ZVe},tZ;function QVe(e){tZ=e.wasm.cwrap(_p,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function eUe(e){let{backend:t,inputs:n,attrs:r}=e,{dy:s,filter:a}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:c}=r,d=1,h=W.convertConv2DDataFormat(l),p=W.computeConv2DInfo(c,a.shape,i,d,o,u,!1,h),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:y,inHeight:b,inWidth:x,outChannels:w,outHeight:v,outWidth:k,strideHeight:I,strideWidth:S}=p,$=m-1-p.padInfo.top,N=g-1-p.padInfo.left,T=p.dataFormat==="channelsLast",C=_.computeStrides(p.inShape),E=_.computeStrides(s.shape),[M,F,z]=_.computeStrides(a.shape),H=C[0],P=T?C[1]:C[2],O=T?C[2]:1,L=T?1:C[1],V=E[0],q=T?E[1]:E[2],B=T?E[2]:1,X=T?1:E[1],ee=t.makeOutput(p.inShape,"float32"),Z=t.dataIdMap.get(ee.dataId).id,fe=t.dataIdMap.get(s.dataId).id,Q=t.dataIdMap.get(a.dataId).id;return tZ(fe,Q,f,m,g,b,x,y,v,k,w,I,S,$,N,M,F,z,H,P,O,L,V,q,B,X,Z),ee}var tUe={kernelName:_p,backendName:"wasm",setupFunc:QVe,kernelFunc:eUe},nZ;function nUe(e){nZ=e.wasm.cwrap(Ep,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function rUe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;if(s.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let u=W.computeConv3DInfo(s.shape,a.shape,i,l,o),c=n.makeOutput(u.outShape,s.dtype);return nZ(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var sUe={kernelName:Ep,backendName:"wasm",setupFunc:nUe,kernelFunc:rUe},rZ;function aUe(e){rZ=e.wasm.cwrap(ly,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function iUe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;if(s.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let u=W.computeConv3DInfo(s.shape,l,i,1,o),c=n.makeOutput(u.filterShape,a.dtype);return rZ(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var oUe={kernelName:ly,backendName:"wasm",setupFunc:aUe,kernelFunc:iUe},sZ;function lUe(e){sZ=e.wasm.cwrap(uy,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function uUe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;if(s.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let u=W.computeConv3DInfo(l,a.shape,o,1,i),c=n.makeOutput(u.inShape,s.dtype);return sZ(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var cUe={kernelName:uy,backendName:"wasm",setupFunc:lUe,kernelFunc:uUe},dUe=sn(Ap),hUe=sn(Rp),XA;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(XA||(XA={}));var aZ;function pUe(e){aZ=e.wasm.cwrap(dy,null,["number","number","number","number","array","number","number","number","number","number"])}function fUe(e){let{backend:t,inputs:n,attrs:r}=e,{method:s,extrapolationValue:a,cropSize:i}=r,{image:o,boxes:l,boxInd:u}=n,c=l.shape[0],[d,h]=i,p=[c,d,h,o.shape[3]],f=t.dataIdMap.get(o.dataId),m;o.dtype!=="float32"&&(m=$d({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(m.dataId));let g=f.id,y=t.dataIdMap.get(l.dataId).id,b=t.dataIdMap.get(u.dataId).id,x=t.makeOutput(p,"float32"),w=t.dataIdMap.get(x.dataId).id,v=new Uint8Array(new Int32Array(o.shape).buffer);return aZ(g,y,b,c,v,d,h,XA[s],a,w),m!=null&&t.disposeData(m.dataId),x}var mUe={kernelName:dy,backendName:"wasm",setupFunc:pUe,kernelFunc:fUe},iZ;function gUe(e){iZ=e.wasm.cwrap(cy,null,["number","number","number","number","number","number"])}function yUe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r,l=s.shape.length;_.assert(s.dtype==="float32"||s.dtype==="int32",()=>`cumprod does not support ${s.dtype} tensors in the WASM backend`);let u=W.getAxesPermutation([a],l),c=s;u!==null&&(c=Qc({inputs:{x:s},attrs:{perm:u},backend:n}));let d=W.getInnerMostAxes(1,l)[0];W.assertAxesAreInnerMostDims("cumprod",[d],l);let h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(h.dataId).id;iZ(f,i?1:0,o?1:0,p,m,hn[s.dtype]);let g=h;if(u!==null){let y=W.getUndoAxesPermutation(u);g=Qc({inputs:{x:h},attrs:{perm:y},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return g}var bUe={kernelName:cy,backendName:"wasm",setupFunc:gUe,kernelFunc:yUe},oZ;function xUe(e){oZ=e.wasm.cwrap(Dp,null,["number","number","number","number","number","number"])}function wUe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r,l=s.shape.length;_.assert(s.dtype==="float32"||s.dtype==="int32",()=>`cumsum does not support ${s.dtype} tensors in the WASM backend`);let u=W.getAxesPermutation([a],l),c=s;u!==null&&(c=Qc({inputs:{x:s},attrs:{perm:u},backend:n}));let d=W.getInnerMostAxes(1,l)[0];W.assertAxesAreInnerMostDims("cumsum",[d],l);let h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(h.dataId).id;oZ(f,i?1:0,o?1:0,p,m,hn[s.dtype]);let g=h;if(u!==null){let y=W.getUndoAxesPermutation(u);g=Qc({inputs:{x:h},attrs:{perm:y},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return g}var vUe={kernelName:Dp,backendName:"wasm",setupFunc:xUe,kernelFunc:wUe},lZ;function kUe(e){lZ=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function IUe(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,weights:a}=n,{size:i,binaryOutput:o}=r,l=a.shape.reduce((h,p)=>h*p,1)!==0,u=s.shape.length===1?[i]:[s.shape[0],i],c=t.makeOutput(u,a.dtype);function d(h){return t.dataIdMap.get(h.dataId).id}return lZ(d(s),new Uint8Array(new Int32Array(s.shape).buffer),s.shape.length,i,l,d(a),hn[a.dtype],o,d(c)),c}var SUe={kernelName:aw,backendName:"wasm",setupFunc:kUe,kernelFunc:IUe},uZ;function CUe(e){uZ=e.wasm.cwrap(hy,null,["number","number","number","array","number","array","array","number","number"])}function NUe(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],u=i==="NHWC"?s.shape[2]:s.shape[3],c=i==="NHWC"?s.shape[3]:s.shape[1],d=l*a,h=u*a,p=c/(a*a),f=i==="NHWC"?[o,d,h,p]:[o,p,d,h],m=t.makeOutput(f,"float32"),g=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(_.computeStrides(s.shape)).buffer),b=new Uint8Array(new Int32Array(f).buffer),x=new Uint8Array(new Int32Array(_.computeStrides(f)).buffer),w=t.dataIdMap.get(m.dataId).id;return uZ(g,a,i==="NHWC"?1:0,y,s.shape.length-1,b,x,f.length,w),m}var $Ue={kernelName:hy,backendName:"wasm",setupFunc:CUe,kernelFunc:NUe},cZ;function TUe(e){cZ=e.wasm.cwrap(Fp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function _Ue(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,i=r.dataIdMap.get(s.dataId).id,o=r.dataIdMap.get(a.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d}=n,h=u??[1,1],p=W.computeConv2DInfo(s.shape,a.shape,l,h,c,d,!0),f=p.filterHeight,m=p.filterWidth,g=p.padInfo.top,y=p.padInfo.right,b=p.padInfo.bottom,x=p.padInfo.left,w=p.dilationHeight,v=p.dilationWidth,k=p.strideHeight,I=p.strideWidth,S=p.inChannels,$=p.outChannels,N=p.padInfo.type==="SAME"?1:0;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let T=r.makeOutput(p.outShape,"float32"),C=r.dataIdMap.get(T.dataId).id;return cZ(i,s.shape[0],s.shape[1],s.shape[2],o,f,m,g,y,b,x,N,w,v,k,I,S,$,C),T}var EUe={kernelName:Fp,backendName:"wasm",setupFunc:TUe,kernelFunc:_Ue},dZ;function AUe(e){dZ=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function RUe(e){let{inputs:t,backend:n}=e,{x:r}=t,s=_.sizeFromShape(r.shape),a=n.makeOutput([...r.shape,...r.shape],r.dtype);return dZ(n.dataIdMap.get(r.dataId).id,hn[r.dtype],s,n.dataIdMap.get(a.dataId).id),a}var DUe={kernelName:iw,backendName:"wasm",setupFunc:AUe,kernelFunc:RUe},hZ;function FUe(e){hZ=e.wasm.cwrap(Op,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function OUe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;if(s.dtype!==a.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${s.dtype} and ${a.dtype}`);let u=W.computeDilation2DInfo(s.shape,a.shape,i,o,"NHWC",l),c=n.makeOutput(u.outShape,s.dtype);return hZ(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,hn[s.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),c}var MUe={kernelName:Op,backendName:"wasm",setupFunc:FUe,kernelFunc:OUe},pZ;function LUe(e){pZ=e.wasm.cwrap(hg,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function PUe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(s.dtype!==a.dtype||s.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${s.dtype}, ${a.dtype}, and ${i.dtype}`);let c=W.computeDilation2DInfo(s.shape,a.shape,o,l,"NHWC",u),d=n.makeOutput(a.shape,a.dtype);return pZ(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,hn[s.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}var zUe={kernelName:hg,backendName:"wasm",setupFunc:LUe,kernelFunc:PUe},fZ;function BUe(e){fZ=e.wasm.cwrap(dg,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function WUe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(s.dtype!==a.dtype||s.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${s.dtype}, ${a.dtype}, and ${i.dtype}`);let c=W.computeDilation2DInfo(s.shape,a.shape,o,l,"NHWC",u),d=n.makeOutput(s.shape,s.dtype);return fZ(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,hn[s.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}var VUe={kernelName:dg,backendName:"wasm",setupFunc:BUe,kernelFunc:WUe},UUe=sn(Lp),mZ;function GUe(e){mZ=e.wasm.cwrap(py,null,["number","number","number"])}function HUe(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=n.makeOutput(s.shape,"float32"),i=o=>n.dataIdMap.get(o.dataId).id;return mZ(i(s),i(r),i(a)),a}var jUe={kernelName:py,backendName:"wasm",setupFunc:GUe,kernelFunc:HUe},qUe=!1,KUe=us(my,qUe,"bool"),XUe=sn(Pp,"float32");function YA(e){let{inputs:t,attrs:n,backend:r}=e,{input:s}=t,{dim:a}=n,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(_.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),Ca({inputs:{x:s},backend:r,attrs:{shape:o}})}var YUe={kernelName:gy,backendName:"wasm",kernelFunc:YA},ZUe=sn(zp,"float32");function gZ(e){let{attrs:{shape:t,value:n,dtype:r},backend:s}=e,a=s.makeOutput(t,r);return s.typedArrayFromHeap(a).fill(n),a}var JUe={kernelName:ow,backendName:"wasm",kernelFunc:gZ},yZ;function QUe(e){yZ=e.wasm.cwrap(yy,null,["number","number","number","number","number","number"])}function eGe(e){let{inputs:t,backend:n}=e,{image:r}=t,s=n.makeOutput(r.shape,r.dtype),a=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id,[o,l,u,c]=r.shape;return yZ(a,o,l,u,c,i),s}var tGe={kernelName:yy,backendName:"wasm",kernelFunc:eGe,setupFunc:QUe},nGe=sn(Bp),rGe=us(Wp),bZ;function sGe(e){bZ=e.wasm.cwrap(Vp,null,["number","number","number","number","number","number","number"])}function aGe(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:s}=r,{x:a,mean:i,variance:o,offset:l,scale:u}=n,c=t.dataIdMap.get(a.dataId).id,d=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(o.dataId).id,p=l!=null?t.dataIdMap.get(l.dataId).id:0,f=u!=null?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(a.shape,a.dtype);if(_.sizeFromShape(a.shape)===0)return m;let g=t.dataIdMap.get(m.dataId).id;return bZ(c,d,h,p,f,s,g),m}var iGe={kernelName:Vp,backendName:"wasm",setupFunc:sGe,kernelFunc:aGe},xZ;function oGe(e){xZ=e.wasm.cwrap(Ph,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function lGe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=W.computeConv2DInfo(s.shape,a.shape,l,c,u,h),g=_0[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(s.dataId).id,b=r.dataIdMap.get(a.dataId).id,x=m.outChannels,w=0;if(i!=null){let B=r.dataIdMap.get(i.dataId);if(B.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${B.shape.length}.`);if(B.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${B.shape}) does not match the number of output channels (${x})`);w=B.id}let v=m.filterHeight,k=m.filterWidth,I=m.padInfo.top,S=m.padInfo.right,$=m.padInfo.bottom,N=m.padInfo.left,T=m.dilationHeight,C=m.dilationWidth,E=m.strideHeight,M=m.strideWidth,F=m.inChannels,z=m.padInfo.type==="SAME"?1:0,H=m.batchSize,P=m.inHeight,O=m.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let L=r.makeOutput(m.outShape,"float32"),V=r.dataIdMap.get(L.dataId).id,q=o==null?0:r.dataIdMap.get(o.dataId).id;return xZ(y,H,P,O,b,v,k,w,I,S,$,N,z,T,C,E,M,F,x,g,q,f||0,V),L}var uGe={kernelName:Ph,backendName:"wasm",setupFunc:oGe,kernelFunc:lGe},wZ;function cGe(e){wZ=e.wasm.cwrap(zh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function dGe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=W.computeConv2DInfo(s.shape,a.shape,l,c,u,h,!0),g=_0[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(s.dataId).id,b=r.dataIdMap.get(a.dataId).id,x=m.outChannels,w=0;if(i!=null){let B=r.dataIdMap.get(i.dataId);if(B.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${B.shape.length}.`);if(B.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${B.shape}) does not match the number of output channels (${x})`);w=B.id}let v=m.filterHeight,k=m.filterWidth,I=m.padInfo.top,S=m.padInfo.right,$=m.padInfo.bottom,N=m.padInfo.left,T=m.dilationHeight,C=m.dilationWidth,E=m.strideHeight,M=m.strideWidth,F=m.inChannels,z=m.padInfo.type==="SAME"?1:0,H=m.batchSize,P=m.inHeight,O=m.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let L=r.makeOutput(m.outShape,"float32"),V=r.dataIdMap.get(L.dataId).id,q=o==null?0:r.dataIdMap.get(o.dataId).id;return wZ(y,H,P,O,b,v,k,w,I,S,$,N,z,T,C,E,M,F,x,g,q,f||0,V),L}var hGe={kernelName:zh,backendName:"wasm",setupFunc:cGe,kernelFunc:dGe},vZ;function pGe(e){vZ=e.wasm.cwrap(xy,null,["number","number","number","number","number","number","array","number"])}function fGe(e){let{backend:t,inputs:n}=e,{params:r,indices:s}=n,[a,i,o,l]=nM.prepareAndValidate(r,s),u=t.makeOutput(a,r.dtype);if(i===0)return u;let c=s.shape,d=c[c.length-1],h=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(s.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return vZ(h,hn[r.dtype],p,i,d,o,f,m),u}var mGe={kernelName:xy,backendName:"wasm",setupFunc:pGe,kernelFunc:fGe},kZ;function gGe(e){kZ=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function yGe(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,indices:a}=n,{axis:i,batchDims:o}=r,l=_.parseAxisParam(i,s.shape)[0],u=t.readSync(a.dataId),c=s.shape[l];for(let I=0;I<u.length;++I){let S=u[I];_.assert(S<=c-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${c-1}]`)}let d=W.segment_util.collectGatherOpShapeInfo(s,a,l,o),h=Ca({inputs:{x:s},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),p=_.sizeFromShape(a.shape),f=Ca({inputs:{x:a},attrs:{shape:[d.batchSize,p/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize],g=t.makeOutput(m,s.dtype);if(_.sizeFromShape(s.shape)===0)return g;let y=h.shape.length-1,b=t.dataIdMap.get(h.dataId).id,x=t.dataIdMap.get(f.dataId).id,w=t.dataIdMap.get(g.dataId).id,v=new Uint8Array(new Int32Array(_.computeStrides(h.shape)).buffer),k=new Uint8Array(new Int32Array(_.computeStrides(m)).buffer);return kZ(b,hn[s.dtype],v,y,x,d.batchSize,k,w),t.disposeData(h.dataId),t.disposeData(f.dataId),g.shape=d.outputShape,g}var bGe={kernelName:by,backendName:"wasm",setupFunc:gGe,kernelFunc:yGe},xGe=!1,wGe=us(wy,xGe,"bool"),vGe=!1,kGe=us(Up,vGe,"bool"),IGe=sn(Hp,"bool"),SGe=sn(jp,"bool"),CGe=sn(qp,"bool"),IZ;function NGe(e){IZ=e.wasm.cwrap(Kp,null,["number","number","number","number"])}function $Ge(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,s=r.dataIdMap.get(t.dataId).id,a=r.makeOutput(t.shape,"float32");if(_.sizeFromShape(t.shape)!==0){let i=r.dataIdMap.get(a.dataId).id;IZ(s,hn[t.dtype],n,i)}return a}var TGe={kernelName:Kp,backendName:"wasm",setupFunc:NGe,kernelFunc:$Ge},_Ge=!1,EGe=us(vy,_Ge,"bool"),AGe=!1,RGe=us(ky,AGe,"bool"),SZ;function DGe(e){SZ=e.wasm.cwrap(Iy,null,["number","number","number","number"])}function FGe(e){let{attrs:t,backend:n}=e,{start:r,stop:s,num:a}=t,i=Math.floor(a),o=n.makeOutput([i],"float32");return SZ(n.dataIdMap.get(o.dataId).id,r,s,i),o}var OGe={kernelName:Iy,backendName:"wasm",setupFunc:DGe,kernelFunc:FGe},MGe=sn(Xp),LGe=sn(Yp),PGe=!1,zGe=us(Sy,PGe,"bool"),BGe=sn(Cy),WGe=!1,VGe=us(Ny,WGe,"bool"),UGe=!1,GGe=us(Q6,UGe,"bool"),CZ;function HGe(e){CZ=e.wasm.cwrap(Zp,null,["number","number","number","number","number","number","number"])}function jGe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;if(s.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(s.shape,s.dtype);return CZ(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,s.shape[3],a,i,o,l),u}var qGe={kernelName:Zp,backendName:"wasm",setupFunc:HGe,kernelFunc:jGe},NZ;function KGe(e){NZ=e.wasm.cwrap($y,null,["number","number","number","number","number","number","number","number","number"])}function XGe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;if(s.dtype!=="float32"||a.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let d=n.makeOutput(s.shape,s.dtype);return NZ(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,l,u,c),d}var YGe={kernelName:$y,backendName:"wasm",setupFunc:KGe,kernelFunc:XGe},$Z;function ZGe(e){$Z=e.wasm.cwrap(Jp,null,["number","number","number","number"])}function JGe(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=Nd(i,s,t);if(h){let b=t.dataIdMap.get(u.dataId).id;l=u,o=b}let p=l.shape.length;W.assertAxesAreInnerMostDims("max",c,p);let[f,m]=W.computeOutAndReduceShapes(l.shape,c),g=_.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(_.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;$Z(o,hn[i.dtype],g,b)}if(h&&t.disposeData(u.dataId),a){let b=W.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var QGe={kernelName:Jp,backendName:"wasm",setupFunc:ZGe,kernelFunc:JGe},eHe=us(Qp),TZ;function tHe(e){TZ=e.wasm.cwrap(ef,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function nHe(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id;_.assert(s.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${s.dtype}.`);let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=W.computePool2DInfo(s.shape,i,o,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,b=c.dilationWidth,x=c.strideHeight,w=c.strideWidth,v=c.inChannels,k=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let I=r.makeOutput(c.outShape,"float32"),S=r.dataIdMap.get(I.dataId).id;return TZ(a,s.shape[0],s.shape[1],s.shape[2],d,h,p,f,m,g,y,b,x,w,v,k,S),I}var rHe={kernelName:ef,backendName:"wasm",setupFunc:tHe,kernelFunc:nHe},_Z;function sHe(e){_Z=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function aHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=W.computePool3DInfo(s.shape,a,i,1,o,l,u),d=n.makeOutput(c.outShape,s.dtype);return _Z(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}var iHe={kernelName:Ty,backendName:"wasm",setupFunc:sHe,kernelFunc:aHe},EZ;function oHe(e){EZ=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function lHe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=W.computePool3DInfo(a.shape,i,o,1,l,u),d=n.makeOutput(a.shape,a.dtype);return EZ(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}var uHe={kernelName:lw,backendName:"wasm",setupFunc:oHe,kernelFunc:lHe},AZ;function cHe(e){AZ=e.wasm.cwrap(tf,null,["number, number, number"])}function dHe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=Nd(i,s,t),f=d;if(p){let w=t.dataIdMap.get(c.dataId).id;w!==o&&(u=c,l=w,f=W.getInnerMostAxes(f.length,u.shape.length))}W.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[m,g]=W.computeOutAndReduceShapes(u.shape,f),y=_.sizeFromShape(g),b=u;u.dtype!=="float32"&&(b=$d({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let x=t.makeOutput(m,"float32");if(_.sizeFromShape(u.shape)!==0){let w=t.dataIdMap.get(x.dataId).id;AZ(l,y,w)}if(p&&t.disposeData(c.dataId),a){let w=W.expandShapeToKeepDim(x.shape,h);x.shape=w}return u.dtype!=="float32"&&t.disposeData(b.dataId),x}var hHe={kernelName:tf,backendName:"wasm",setupFunc:cHe,kernelFunc:dHe},RZ;function pHe(e){RZ=e.wasm.cwrap(nf,null,["number","number","number","number"])}function fHe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=Nd(i,s,t);if(p){let x=t.dataIdMap.get(c.dataId).id;x!==o&&(u=c,l=x)}let f=u.shape.length;W.assertAxesAreInnerMostDims("min",d,f);let[m,g]=W.computeOutAndReduceShapes(u.shape,d),y=_.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(_.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;RZ(l,hn[i.dtype],y,x)}if(p&&t.disposeData(c.dataId),a){let x=W.expandShapeToKeepDim(b.shape,h);b.shape=x}return b}var mHe={kernelName:nf,backendName:"wasm",setupFunc:pHe,kernelFunc:fHe},gHe=us(rf),ZA;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(ZA||(ZA={}));var DZ;function yHe(e){DZ=e.wasm.cwrap(sf,null,["number","array","number","number","array","array","number","number"])}function bHe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:s}}=e,a=r.map((f,m)=>f[0]+t.shape[m]+f[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(a,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map(f=>f[0]),d=r.map(f=>f[1]),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return DZ(i,u,t.shape.length,hn[t.dtype],h,p,ZA[s],l),o}var xHe={kernelName:sf,backendName:"wasm",kernelFunc:bHe,setupFunc:yHe},FZ;function wHe(e){FZ=e.wasm.cwrap($f,null,["number","number","number","number"])}function OZ(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,s=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(a.dataId).id,o=n.shape[r],l=_.sizeFromShape(n.shape)/o;return _.sizeFromShape(a.shape)===0||FZ(s,i,o,l),a}var vHe={kernelName:$f,backendName:"wasm",setupFunc:wHe,kernelFunc:OZ},MZ;function kHe(e){MZ=e.wasm.cwrap(Ey,null,["number","number","number","number","number","number"])}function IHe(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;if(s.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${s.dtype}`);let l=o?s:OZ({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),[u,c]=l.shape,d=n.makeOutput([u,a],"int32");return MZ(n.dataIdMap.get(l.dataId).id,u,c,a,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(l.dataId),d}var SHe={kernelName:Ey,backendName:"wasm",setupFunc:kHe,kernelFunc:IHe},CHe=us(af),NHe=sn(Ay);function gL(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],s=n[1],a=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:s,pSelectedScores:a,pValidOutputs:i}}var LZ;function $He(e){LZ=e.wasm.cwrap(Dy,"number",["number","number","number","number","number"])}function THe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(l.dataId).id,d=LZ(u,c,a,s,i),{pSelectedIndices:h,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=gL(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([p],"int32",h)}var _He={kernelName:Dy,backendName:"wasm",setupFunc:$He,kernelFunc:THe},PZ;function EHe(e){PZ=e.wasm.cwrap(Fy,"number",["number","number","number","number","number","bool"])}function AHe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=PZ(c,d,a,s,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=gL(t,h);t.wasm._free(m);let y=t.makeOutput([f],"int32",p),b=t.makeOutput([],"int32",g);return[y,b]}var RHe={kernelName:Fy,backendName:"wasm",setupFunc:EHe,kernelFunc:AHe},zZ;function DHe(e){zZ=e.wasm.cwrap(Oy,"number",["number","number","number","number","number","number"])}function FHe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=zZ(c,d,a,s,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=gL(t,h);t.wasm._free(g);let y=t.makeOutput([f],"int32",p),b=t.makeOutput([f],"float32",m);return[y,b]}var OHe={kernelName:Oy,backendName:"wasm",setupFunc:DHe,kernelFunc:FHe},MHe=!1,LHe=us(Ry,MHe,"bool"),BZ;function PHe(e){BZ=e.wasm.cwrap(of,null,["number","number","number","number","number"])}function zHe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=n.makeOutput([...s.shape,i],a),c=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(s.dataId).id;return BZ(d,i,o,l,c),u}var BHe={kernelName:of,backendName:"wasm",setupFunc:PHe,kernelFunc:zHe};function WHe(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var VHe={kernelName:My,backendName:"wasm",kernelFunc:WHe};function UHe(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return YA({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,i=t[0].dtype;t.forEach(c=>{_.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),_.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(c=>{let d=YA({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=QY({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeData(c.dataId)),u}var GHe={kernelName:Ly,backendName:"wasm",kernelFunc:UHe},WZ;function HHe(e){WZ=e.wasm.cwrap(lf,null,["number","array","number","number","array","array","number","number"])}function jHe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:s}}=e,a=r.map((f,m)=>f[0]+t.shape[m]+f[1]);if(_.sizeFromShape(t.shape)===0)return gZ({backend:n,attrs:{shape:a,value:s,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(a,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map(f=>f[0]),d=r.map(f=>f[1]),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return WZ(i,u,t.shape.length,hn[t.dtype],h,p,s,l),o}var VZ={kernelName:lf,backendName:"wasm",kernelFunc:jHe,setupFunc:HHe},qHe=us(uf),UZ;function KHe(e){UZ=e.wasm.cwrap(cf,null,["number","number","number"])}function XHe(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id,o=a,l=r,u=l;l.dtype!=="float32"&&(u=$d({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let c=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(c.dataId).id;return UZ(o,i,d),l.dtype!=="float32"&&n.disposeData(u.dataId),c}var YHe={kernelName:cf,backendName:"wasm",setupFunc:KHe,kernelFunc:XHe},GZ;function ZHe(e){GZ=e.wasm.cwrap(df,null,["number","number","number","number"])}function JHe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=Nd(i,s,t),f=d;if(p){let x=t.dataIdMap.get(c.dataId).id;x!==o&&(u=c,l=x,f=W.getInnerMostAxes(f.length,u.shape.length))}W.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[m,g]=W.computeOutAndReduceShapes(u.shape,f),y=_.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(_.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;GZ(l,y,hn[b.dtype],x)}if(p&&t.disposeData(c.dataId),a){let x=W.expandShapeToKeepDim(b.shape,h);b.shape=x}return b}var QHe={kernelName:df,backendName:"wasm",setupFunc:ZHe,kernelFunc:JHe},e5e=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=H3(r,s,a,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},t5e={kernelName:uw,backendName:"wasm",kernelFunc:e5e},n5e=us(Mp),r5e=sn(hf),s5e=sn(pf),a5e=sn(gf),HZ;function i5e(e){HZ=e.wasm.cwrap(mf,null,["number","number","number","number","number","number","number","number","number","number"])}function o5e(e){let{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,[c,d,h,p]=s.shape,f=[c,l,u,p],m=t.dataIdMap.get(s.dataId),g;m.dtype!=="float32"&&(g=$d({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));let y=m.id,b=t.makeOutput(f,"float32");if(_.sizeFromShape(s.shape)===0)return b;let x=t.dataIdMap.get(b.dataId).id;return HZ(y,c,d,h,p,l,u,a?1:0,i?1:0,x),g!=null&&t.disposeData(g.dataId),b}var l5e={kernelName:mf,backendName:"wasm",setupFunc:i5e,kernelFunc:o5e},jZ;function u5e(e){jZ=e.wasm.cwrap(By,null,["number","number","number","array","array","boolean"])}function c5e(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=n.makeOutput(s.shape,"float32"),l=n.dataIdMap.get(s.dataId),u;return l.dtype!=="float32"&&(u=$d({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),jZ(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var d5e={kernelName:By,backendName:"wasm",setupFunc:u5e,kernelFunc:c5e},qZ;function h5e(e){qZ=e.wasm.cwrap(ff,null,["number","number","number","number","number","number","number","number","number","number"])}function p5e(e){let{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,[c,d,h,p]=s.shape,f=[c,l,u,p],m=t.makeOutput(f,"float32");if(_.sizeFromShape(s.shape)===0)return m;let g=t.dataIdMap.get(s.dataId),y;g.dtype!=="float32"&&(y=$d({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(y.dataId));let b=g.id,x=t.dataIdMap.get(m.dataId).id;return qZ(b,c,d,h,p,l,u,a?1:0,i?1:0,x),y!=null&&t.disposeData(y.dataId),m}var f5e={kernelName:ff,backendName:"wasm",setupFunc:h5e,kernelFunc:p5e},KZ;function m5e(e){KZ=e.wasm.cwrap(zy,null,["number","number","number","array","array","boolean"])}function g5e(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=n.makeOutput(s.shape,"float32"),l=n.dataIdMap.get(s.dataId),u;return l.dtype!=="float32"&&(u=$d({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),KZ(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var y5e={kernelName:zy,backendName:"wasm",setupFunc:m5e,kernelFunc:g5e},XZ;function b5e(e){XZ=e.wasm.cwrap(yf,null,["number","array","number","array","number","number"])}function x5e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=_.parseAxisParam(a,s.shape);if(s.shape.length===0)return b2({inputs:{x:s},backend:n});let o=n.makeOutput(s.shape,s.dtype),l=n.dataIdMap.get(s.dataId).id,u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(s.shape).buffer);XZ(l,c,i.length,d,s.shape.length,u);let h=Ca({inputs:{x:o},attrs:{shape:s.shape},backend:n});return n.disposeData(o.dataId),h}var w5e={kernelName:yf,backendName:"wasm",kernelFunc:x5e,setupFunc:b5e},YZ;function v5e(e){YZ=e.wasm.cwrap(nb,null,["number","number","number","number","number","number","number","number","array","number","number"])}function k5e(e){let{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{radians:a,fillValue:i,center:o}=r,l=n.makeOutput(s.shape,s.dtype),u=n.dataIdMap.get(s.dataId).id,c=n.dataIdMap.get(l.dataId).id,[d,h,p,f]=s.shape,[m,g]=W.getImageCenter(o,h,p),y=i===0,b=255,x=typeof i=="number"?[i,i,i,y?0:b]:[...i,b],w=new Uint8Array(new Int32Array(x).buffer);return YZ(u,d,h,p,f,a,m,g,w,x.length,c),l}var I5e={kernelName:nb,backendName:"wasm",kernelFunc:k5e,setupFunc:v5e},S5e=sn(bf),C5e=sn(xf),ZZ;function N5e(e){ZZ=e.wasm.cwrap(Wy,null,["number","number","number","number","number","number","array","number","number"])}function $5e(e){let{backend:t,inputs:n,attrs:r}=e,{indices:s,updates:a}=n,{shape:i}=r,o=t.makeOutput(i,a.dtype);if(_.sizeFromShape(i)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=MN.calculateShapes(a,s,i),p=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(a.dataId).id,m=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(o.dataId).id;return ZZ(p,f,hn[a.dtype],l,u,c,m,h,g),o}var T5e={kernelName:Wy,backendName:"wasm",setupFunc:N5e,kernelFunc:$5e},JZ;function _5e(e){JZ=e.wasm.cwrap(Uy,null,["number","number","number","number","number","number","bool","number"])}function E5e(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r;if(s.dtype!==a.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${s.dtype} and ${a.dtype}`);let o=n.makeOutput(a.shape,"int32");function l(u){return n.dataIdMap.get(u.dataId).id}return JZ(l(s),l(a),s.shape[0],s.shape[1],a.shape[1],hn[s.dtype],i==="left",l(o)),o}var A5e={kernelName:Uy,backendName:"wasm",setupFunc:_5e,kernelFunc:E5e},QZ;function R5e(e){QZ=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function D5e(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(s.dataId).id,l=n.dataIdMap.get(a.dataId).id,u=n.makeOutput(s.shape,s.dtype),c=n.dataIdMap.get(u.dataId).id,d=r.shape.length,h=s.shape.length,p=d===0||d>1||h===1?1:_.sizeFromShape(s.shape.slice(1));return QZ(i,o,l,p,c),u}var F5e={kernelName:Gy,backendName:"wasm",kernelFunc:D5e,setupFunc:R5e},O5e=sn(wf),eJ;function M5e(e){eJ=e.wasm.cwrap(If,null,["number","number"])}function L5e(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),a=t.dataIdMap.get(s.dataId).id;return _.sizeFromShape(s.shape)===0||eJ(r,a),s}var P5e={kernelName:"Sigmoid",backendName:"wasm",setupFunc:M5e,kernelFunc:L5e},z5e=sn(kf),B5e=sn(vf),W5e=sn(Sf);function V5e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r,o=_.sizeFromShape(a),l=[[0,0]];l.push(...i);for(let g=1+a.length;g<s.shape.length;++g)l.push([0,0]);let u=VZ.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=W.getReshaped(u.shape,a,o,!1),d=W.getPermuted(c.length,a.length,!1),h=W.getReshapedPermuted(u.shape,a,o,!1),p=Ca({inputs:{x:u},backend:n,attrs:{shape:c}}),f=Qc({inputs:{x:p},backend:n,attrs:{perm:d}}),m=Ca({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeData(u.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}var U5e={kernelName:qy,backendName:"wasm",kernelFunc:V5e},tJ;function G5e(e){tJ=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function H5e(e){let{backend:t,inputs:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=n,o=r.shape[0],l=r.shape[1],u=t.readSync(a.dataId)[0],c=[o+u,l],d=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id,f=t.makeOutput(c,r.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(c.slice(0,1),s.dtype),y=t.dataIdMap.get(g.dataId).id,b=t.makeOutput([u],"bool"),x=t.dataIdMap.get(b.dataId).id,w=t.makeOutput([o],r.dtype),v=t.dataIdMap.get(w.dataId).id,k=t.makeOutput([4],"int32"),I=t.dataIdMap.get(k.dataId).id,S=tJ(d,h,hn[s.dtype],o,u,l,p,m,y,x,v,I),$=t.readSync(k.dataId),N;switch($[0]){case 1:{N=W.getSparseFillEmptyRowsIndicesDenseShapeMismatch($[1]);break}case 2:{N=W.getSparseFillEmptyRowsNegativeIndexErrorMessage($[1],$[2]);break}case 3:N=W.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage($[1],$[2],$[3]);break;default:N=""}if(t.disposeData(k.dataId),N)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(b.dataId),t.disposeData(w.dataId),new Error(N);let T=f,C=g;return S!==c[0]&&(T=ep({inputs:{x:f},attrs:{begin:0,size:[S,l]},backend:t}),C=ep({inputs:{x:g},attrs:{begin:0,size:S},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[T,C,b,w]}var j5e={kernelName:cw,backendName:"wasm",setupFunc:G5e,kernelFunc:H5e},nJ;function q5e(e){nJ=e.wasm.cwrap(Xy,null,["number","number","number","number","number","number","number"])}function K5e(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:s,newShape:a}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(a.dataId).id,u=r.shape[0],c=_.sizeFromShape(a.shape),d=t.makeOutput([u,c],r.dtype),h=t.dataIdMap.get(d.dataId).id,p=t.makeOutput([c],a.dtype),f=t.dataIdMap.get(p.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;nJ(i,o,l,u,h,f,g);let y=t.readSync(m.dataId),b;switch(y[0]){case 0:{b=W.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break}case 1:{b=W.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break}case 2:b=W.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let x=Array.from(t.readSync(s.dataId)),w=Array.from(t.readSync(p.dataId));b=W.getSparseReshapeInputOutputMultipleErrorMessage(x,w);break}case 4:{let x=Array.from(t.readSync(s.dataId)),w=Array.from(t.readSync(p.dataId));b=W.getSparseReshapeInputOutputMismatchErrorMessage(x,w);break}default:b=""}if(t.disposeData(m.dataId),b)throw t.disposeData(d.dataId),t.disposeData(p.dataId),new Error(b);return[d,p]}var X5e={kernelName:Xy,backendName:"wasm",setupFunc:q5e,kernelFunc:K5e},rJ;function sJ(e){rJ=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function aJ(e,t){let{backend:n,inputs:r}=e,{data:s,indices:a,segmentIds:i}=r,o=a.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(W.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=s.shape.slice();c[0]=u;let d=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(c,s.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;rJ(d,hn[s.dtype],s.shape[0],h,p,m,y,t,0);let b=n.readSync(g.dataId),x;switch(b[0]){case 0:{x=W.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{x=W.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:x=W.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b[1],b[2]);break;case 3:x=W.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(b[1],b[2],b[3]);break;default:x=""}if(n.disposeData(g.dataId),x)throw n.disposeData(f.dataId),new Error(x);return f}function Y5e(e){return aJ(e,!0)}var Z5e={kernelName:dw,backendName:"wasm",setupFunc:sJ,kernelFunc:Y5e};function J5e(e){return aJ(e,!1)}var Q5e={kernelName:hw,backendName:"wasm",setupFunc:sJ,kernelFunc:J5e},iJ;function eje(e){iJ=e.wasm.cwrap(Yy,null,["number","number","number","number","number","number","number","number","array","number","number"])}function tje(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=n,{outputShape:o}=r,l=t.makeOutput(o,i.dtype);if(_.sizeFromShape(o)===0)return l;let{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=W.calculateShapes(a,s,o),f=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(h).buffer),b=t.dataIdMap.get(l.dataId).id;return iJ(f,m,a.shape.length,g,hn[i.dtype],u,c,d,y,p,b),l}var nje={kernelName:Yy,backendName:"wasm",setupFunc:eje,kernelFunc:tje};function rje(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=n,o=_.parseAxisParam(i,s.shape)[0],l=W.prepareSplitSize(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{let h=[...c];h[o]=d;let p=ep({inputs:{x:s},attrs:{begin:u,size:h},backend:r});return u[o]+=d,p})}var sje={kernelName:Ky,backendName:"wasm",kernelFunc:rje},aje=sn(Cf),ije=sn(pw),oje=us(Tf),oJ;function lje(e){oJ=e.wasm.cwrap(xd,null,["number","number","number","number"])}function uje(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:s}=r,{x:a}=n,i=t.dataIdMap.get(a.dataId).id,o=t.makeOutput(a.shape,a.dtype),l=t.dataIdMap.get(o.dataId).id;return oJ(i,s,hn[a.dtype],l),o}var cje={kernelName:xd,backendName:"wasm",setupFunc:lje,kernelFunc:uje},lJ;function dje(e){lJ=e.wasm.cwrap(Zy,null,["number","array","number","array","array","array","array","array","number","number"])}function hje(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=Br.sliceInfo(s.shape,a,i,o,l,u,c,d,h),v;if(m)v=Ca({inputs:{x:s},backend:t,attrs:{shape:f}});else if(g||y){_.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let k=Br.computeOutShape(b,x,w),I=ep({inputs:{x:s},backend:t,attrs:{begin:b,size:k}});v=Ca({inputs:{x:I},backend:t,attrs:{shape:f}}),t.disposeData(I.dataId)}else{let k=t.makeOutput(p,"float32"),I=t.dataIdMap.get(s.dataId).id,S=new Uint8Array(new Int32Array(_.computeStrides(s.shape)).buffer),$=new Uint8Array(new Int32Array(b).buffer),N=new Uint8Array(new Int32Array(x).buffer),T=new Uint8Array(new Int32Array(w).buffer),C=new Uint8Array(new Int32Array(p).buffer),E=new Uint8Array(new Int32Array(_.computeStrides(p)).buffer),M=t.dataIdMap.get(k.dataId).id;lJ(I,S,s.shape.length,$,N,T,C,E,p.length,M),v=Ca({inputs:{x:k},backend:t,attrs:{shape:f}}),t.disposeData(k.dataId)}return v}var pje={kernelName:Zy,backendName:"wasm",setupFunc:dje,kernelFunc:hje};function fje(e){let{backend:t,inputs:n,attrs:r}=e,{data:s,dataSplits:a}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:u,padWidth:c,preserveShortSequences:d}=r,h=t.readSync(s.dataId),p=t.readSync(a.dataId),[f,m]=q3(h,p,i,o,l,u,c,d),g=t.makeOutput([f.length],"string"),y=t.dataIdMap.get(g.dataId);y.stringBytes=f;let b=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(b).set(m),[g,b]}var mje={kernelName:mw,backendName:"wasm",kernelFunc:fje};function gje(e){let{backend:t,inputs:n,attrs:r}=e,{input:s,delimiter:a}=n,{skipEmpty:i}=r,o=t.readSync(s.dataId),l=t.readSync(a.dataId),[u,c,d]=K3(o,l[0],i),h=c.length,p=t.makeOutput([h,2],"int32");t.typedArrayFromHeap(p).set(u);let f=t.makeOutput([h],"string"),m=t.dataIdMap.get(f.dataId);m.stringBytes=c;let g=t.makeOutput([2],"int32");return t.typedArrayFromHeap(g).set(d),[p,f,g]}var yje={kernelName:gw,backendName:"wasm",kernelFunc:gje};function bje(e){let{backend:t,inputs:n,attrs:r}=e,{input:s}=n,{numBuckets:a}=r,i=t.readSync(s.dataId),o=X3(i,a),l=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(l).set(o),l}var xje={kernelName:yw,backendName:"wasm",kernelFunc:bje},wje=us(_f),uJ;function vje(e){uJ=e.wasm.cwrap(Nf,null,["number","number","number","number"])}function kje(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=Nd(i,s,t),f=d;if(p){let x=t.dataIdMap.get(c.dataId).id;x!==o&&(u=c,l=x,f=W.getInnerMostAxes(f.length,u.shape.length))}W.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[m,g]=W.computeOutAndReduceShapes(u.shape,f),y=_.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(_.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;uJ(l,y,hn[b.dtype],x)}if(p&&t.disposeData(c.dataId),a){let x=W.expandShapeToKeepDim(b.shape,h);b.shape=x}return b}var Ije={kernelName:Nf,backendName:"wasm",setupFunc:vje,kernelFunc:kje},Sje=sn(Ef),Cje=sn(Af),cJ;function Nje(e){cJ=e.wasm.cwrap(Vy,null,["number","number","number","number","number","number","array","number","number","number"])}function $je(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=n,o=t.makeOutput(s.shape,s.dtype);if(_.sizeFromShape(s.shape)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=MN.calculateShapes(i,a,s.shape),p=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),y=t.dataIdMap.get(o.dataId).id;return cJ(p,f,hn[i.dtype],l,u,c,g,h,y,m),o}var Tje={kernelName:Vy,backendName:"wasm",setupFunc:Nje,kernelFunc:$je},dJ;function _je(e){dJ=e.wasm.cwrap(bd,null,["number","array","number","array","number","number"])}function Eje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,a=n.dataIdMap.get(s.dataId).id,{reps:i}=r,o=new Array(s.shape.length);for(let h=0;h<o.length;h++)o[h]=s.shape[h]*i[h];let l=new Uint8Array(new Int32Array(s.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),c=n.makeOutput(o,s.dtype),d=n.dataIdMap.get(c.dataId).id;return dJ(a,l,s.shape.length,u,o.length,hn[c.dtype],d),c}var Aje={kernelName:bd,backendName:"wasm",setupFunc:_je,kernelFunc:Eje},hJ;function Rje(e){hJ=e.wasm.cwrap(Jy,null,["number","array","number","number","number","bool","number","number"])}var Dje=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:s,sorted:a}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=s;let u=t.makeOutput(l,r.dtype),c=t.dataIdMap.get(u.dataId).id,d=t.makeOutput(l,"int32"),h=t.dataIdMap.get(d.dataId).id;return hJ(i,o,r.shape.length,hn[r.dtype],s,a,c,h),[u,d]},Fje={kernelName:Jy,backendName:"wasm",setupFunc:Rje,kernelFunc:Dje},pJ;function Oje(e){pJ=e.wasm.cwrap(Qy,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function Mje(e){let{backend:t,inputs:n,attrs:r}=e,{image:s,transforms:a}=n,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,m]=u??[d,h],g=[c,f,m,p],y=new Uint8Array(new Int32Array(_.computeStrides(s.shape)).buffer),b=new Uint8Array(new Int32Array(_.computeStrides(g)).buffer),x=t.makeOutput(g,s.dtype),w=t.dataIdMap.get(x.dataId).id,v=t.dataIdMap.get(s.dataId).id,k=t.dataIdMap.get(a.dataId).id,I=i==="nearest"?1:2,S;switch(o){case"constant":S=1;break;case"reflect":S=2;break;case"wrap":S=3;break;case"nearest":S=4;break;default:S=1;break}return pJ(v,k,a.shape[0]>1,c,f,m,p,h,d,y,s.shape.length-1,b,g.length-1,I,S,l,w),x}var Lje={kernelName:Qy,backendName:"wasm",setupFunc:Oje,kernelFunc:Mje};function Pje(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t,{outputValues:i,outputShape:o,indices:l}=Z3(r.readSync(a.dataId),s,a.shape,a.dtype);return[r.makeOutput(o,a.dtype,void 0,i),r.makeOutput([l.length],"int32",void 0,l)]}var zje={kernelName:bw,backendName:"wasm",kernelFunc:Pje};function Bje(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let i=s.shape[a],o=s.shape.length,l=new Array(o-1),u=0;for(let p=0;p<o;p++)p!==a&&(l[u++]=s.shape[p]);let c=new Array(i),d=new Array(o).fill(0),h=s.shape.slice();h[a]=1;for(let p=0;p<c.length;p++)d[a]=p,c[p]=ep({inputs:{x:s},attrs:{begin:d,size:h},backend:n});return c.map(({dataId:p,dtype:f})=>({dataId:p,dtype:f,shape:l}))}var Wje={kernelName:eb,backendName:"wasm",kernelFunc:Bje};function Vje(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var Uje={kernelName:tb,backendName:"wasm",kernelFunc:Vje},Gje=[KWe,XWe,YWe,ZWe,JWe,tVe,uVe,hVe,pVe,fVe,mVe,gVe,yVe,bVe,xVe,kVe,CVe,TVe,RVe,PVe,WVe,UVe,GVe,HVe,KVe,XVe,JVe,tUe,sUe,oUe,cUe,dUe,hUe,mUe,bUe,vUe,SUe,$Ue,EUe,DUe,MUe,zUe,VUe,UUe,jUe,KUe,XUe,YUe,ZUe,JUe,tGe,nGe,rGe,iGe,uGe,hGe,mGe,bGe,wGe,kGe,nVe,IGe,SGe,CGe,TGe,EGe,RGe,OGe,LGe,MGe,zGe,BGe,VGe,GGe,qGe,YGe,QGe,eHe,rHe,iHe,uHe,hHe,mHe,gHe,xHe,SHe,CHe,NHe,_He,RHe,OHe,LHe,BHe,VHe,GHe,VZ,qHe,YHe,QHe,t5e,n5e,r5e,s5e,a5e,_Ve,l5e,d5e,f5e,y5e,w5e,I5e,S5e,C5e,T5e,A5e,F5e,O5e,P5e,z5e,B5e,MVe,vHe,W5e,U5e,j5e,X5e,Z5e,Q5e,nje,sje,aje,ije,oje,cje,pje,mje,yje,xje,wje,Ije,Sje,Cje,Tje,Aje,Fje,Lje,iVe,zje,Wje,Uje];for(let e of Gje)ww(e);var JA=me();JA.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});JA.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(JA.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var DU=fd(bhe()),Hje=fd(xhe()),FU=fd(whe()),OU=DU.default||DU,jje=FU.default||FU,fJ=class extends ew{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(mJ),QA=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new jC(this,Xi())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=_.now();return e(),{kernelMs:_.now()-t}}move(e,t,n,r,s){let a=this.dataIdNextNumber++;if(r==="string"){let u=t;this.dataIdMap.set(e,{id:a,stringBytes:u,shape:n,dtype:r,memoryOffset:null,refCount:s});return}let i=_.sizeFromShape(n),o=i*_.bytesPerElement(r),l=this.wasm._malloc(o);this.dataIdMap.set(e,{id:a,memoryOffset:l,shape:n,dtype:r,refCount:s}),this.wasm.tfjs.registerTensor(a,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:s,shape:a,stringBytes:i}=this.dataIdMap.get(e);if(s==="string")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||_.sizeFromShape(a);let o=_.bytesPerElement(s),l=this.wasm.HEAPU8.slice(r+t*o,r+n*o);return Xje(l.buffer,s)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let s;if(n==null)s=this.write(r??null,e,t);else{let a=this.dataIdNextNumber++;s={id:a},this.dataIdMap.set(s,{id:a,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=_.sizeFromShape(e);this.wasm.tfjs.registerTensor(a,i,n)}return{dataId:s,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),a=_.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,s,a);case"int32":return new Int32Array(r,s,a);case"bool":return new Uint8Array(r,s,a);default:throw new Error(`Unknown dtype ${t}`)}}};function qje(e){return(t,n)=>(_.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(s=>{WebAssembly.instantiate(s,t).then(a=>{n(a.instance,a.module)})})}),{})}function MU(e,t,n){if(IS!=null)return IS;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),Vx!=null&&Vx[r]!=null?Vx[r]:n+r}async function Kje(){let[e,t]=await Promise.all([me().getAsync("WASM_HAS_SIMD_SUPPORT"),me().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let s={};s.locateFile=(o,l)=>{if(o.endsWith(".worker.js")){let u=Hje.wasmWorkerContents.replace(/\n/g,"\\n"),c=new Blob([u],{type:"application/javascript"});return URL.createObjectURL(c)}return o.endsWith(".wasm")?MU(e,t,Ix??l):l+o},yL&&(s.instantiateWasm=qje(MU(e,t,Ix??"")));let a=!1;s.onAbort=()=>{a||Ux||(Ux=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&IS==null?(s.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+OU.toString()],{type:"text/javascript"}),i=OU(s)):i=jje(s),i.then(o=>{a=!0,Ux=!1;let l=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",l,["number"]),dispose:o.cwrap("dispose",l,[])},n({wasm:o})}).catch(r)})}function Xje(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var Yje=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],IS=null,Ix=null,Vx={},Ux=!1,yL=!1;function Zje(e,t=!1){if(Iq("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Ux)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");IS=e,yL=t}function Jje(e,t=!1){if(Ux)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")Ix=e;else{Vx=e;let n=Yje.filter(r=>Vx[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}yL=t}var mJ=-1,QA=-1;function Qje(e){mJ=e}function e6e(){if(QA===-1)throw new Error("WASM backend not initialized.");return QA}var t6e="4.3.0",n6e=2;hN("wasm",async()=>{let{wasm:e}=await Kje();return new fJ(e)},n6e);var LU="4.3.0",r6e="4.3.0",s6e="4.3.0",a6e="4.3.0",i6e="4.3.0",o6e={tfjs:LU,"tfjs-core":LU,"tfjs-converter":r6e,"tfjs-backend-cpu":s6e,"tfjs-backend-webgl":a6e,"tfjs-backend-wasm":i6e},Ll={};TF(Ll,{AnchorPosition:()=>NJ,DrawBox:()=>TJ,DrawBoxOptions:()=>$J,DrawFaceLandmarks:()=>UJ,DrawFaceLandmarksOptions:()=>VJ,DrawTextField:()=>w2,DrawTextFieldOptions:()=>IL,drawContour:()=>ac,drawDetections:()=>w6e,drawFaceExpressions:()=>D6e,drawFaceLandmarks:()=>O6e});function ac(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:r,y:s},a)=>{let i=t[a];e.moveTo(i.x,i.y),e.lineTo(r,s)}),n){let r=t[t.length-1],s=t[0];if(!r||!s)return;e.moveTo(r.x,r.y),e.lineTo(s.x,s.y)}e.stroke()}var l6e={};TF(l6e,{computeReshapedDimensions:()=>bJ,getCenterPoint:()=>bL,isDimensions:()=>tR,isEven:()=>eR,isFloat:()=>yJ,isTensor:()=>Ib,isTensor1D:()=>u6e,isTensor2D:()=>gJ,isTensor3D:()=>n1,isTensor4D:()=>$u,isValidNumber:()=>$h,isValidProbablitiy:()=>c6e,range:()=>Ag,round:()=>x2});var Oc=class{constructor(e,t){if(!$h(e)||!$h(t))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:e,height:t})}`);this._width=e,this._height=t}get width(){return this._width}get height(){return this._height}reverse(){return new Oc(1/this.width,1/this.height)}};function Ib(e,t){return e instanceof Tt&&e.shape.length===t}function u6e(e){return Ib(e,1)}function gJ(e){return Ib(e,2)}function n1(e){return Ib(e,3)}function $u(e){return Ib(e,4)}function yJ(e){return e%1!==0}function eR(e){return e%2===0}function x2(e,t=2){let n=10**t;return Math.floor(e*n)/n}function tR(e){return e&&e.width&&e.height}function bJ({width:e,height:t},n){let r=n/Math.max(t,e);return new Oc(Math.round(e*r),Math.round(t*r))}function bL(e){return e.reduce((t,n)=>t.add(n),new nn(0,0)).div(new nn(e.length,e.length))}function Ag(e,t,n){return Array(e).fill(0).map((r,s)=>t+s*n)}function $h(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function c6e(e){return $h(e)&&e>=0&&e<=1}var nn=class{constructor(e,t){this._x=e,this._y=t}get x(){return this._x}get y(){return this._y}add(e){return new nn(this.x+e.x,this.y+e.y)}sub(e){return new nn(this.x-e.x,this.y-e.y)}mul(e){return new nn(this.x*e.x,this.y*e.y)}div(e){return new nn(this.x/e.x,this.y/e.y)}abs(){return new nn(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new nn(Math.floor(this.x),Math.floor(this.y))}},Rs=class{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every($h)}static assertIsValidBox(e,t,n=!1){if(!Rs.isRect(e))throw new Error(`${t} - invalid box: ${JSON.stringify(e)}, expected object with properties x, y, width, height`);if(!n&&(e.width<0||e.height<0))throw new Error(`${t} - width (${e.width}) and height (${e.height}) must be positive numbers`)}constructor(e,t=!0){let n=e||{},r=[n.left,n.top,n.right,n.bottom].every($h),s=[n.x,n.y,n.width,n.height].every($h);if(!s&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(n)}`);let[a,i,o,l]=s?[n.x,n.y,n.width,n.height]:[n.left,n.top,n.right-n.left,n.bottom-n.top];Rs.assertIsValidBox({x:a,y:i,width:o,height:l},"Box.constructor",t),this._x=a,this._y=i,this._width=o,this._height=l}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new nn(this.left,this.top)}get topRight(){return new nn(this.right,this.top)}get bottomLeft(){return new nn(this.left,this.bottom)}get bottomRight(){return new nn(this.right,this.bottom)}round(){let[e,t,n,r]=[this.x,this.y,this.width,this.height].map(s=>Math.round(s));return new Rs({x:e,y:t,width:n,height:r})}floor(){let[e,t,n,r]=[this.x,this.y,this.width,this.height].map(s=>Math.floor(s));return new Rs({x:e,y:t,width:n,height:r})}toSquare(){let{x:e,y:t,width:n,height:r}=this,s=Math.abs(n-r);return n<r&&(e-=s/2,n+=s),r<n&&(t-=s/2,r+=s),new Rs({x:e,y:t,width:n,height:r})}rescale(e){let t=tR(e)?e.width:e,n=tR(e)?e.height:e;return new Rs({x:this.x*t,y:this.y*n,width:this.width*t,height:this.height*n})}pad(e,t){let[n,r,s,a]=[this.x-e/2,this.y-t/2,this.width+e,this.height+t];return new Rs({x:n,y:r,width:s,height:a})}clipAtImageBorders(e,t){let{x:n,y:r,right:s,bottom:a}=this,i=Math.max(n,0),o=Math.max(r,0),l=s-i,u=a-o,c=Math.min(l,e-i),d=Math.min(u,t-o);return new Rs({x:i,y:o,width:c,height:d}).floor()}shift(e,t){let{width:n,height:r}=this,s=this.x+e,a=this.y+t;return new Rs({x:s,y:a,width:n,height:r})}padAtBorders(e,t){let n=this.width+1,r=this.height+1,s=1,a=1,i=n,o=r,l=this.left,u=this.top,c=this.right,d=this.bottom;return c>t&&(i=-c+t+n,c=t),d>e&&(o=-d+e+r,d=e),l<1&&(o=2-l,l=1),u<1&&(o=2-u,u=1),{dy:a,edy:o,dx:s,edx:i,y:u,ey:d,x:l,ex:c,w:n,h:r}}calibrate(e){return new Rs({left:this.left+e.left*this.width,top:this.top+e.top*this.height,right:this.right+e.right*this.width,bottom:this.bottom+e.bottom*this.height}).toSquare().round()}},xJ=class extends Rs{constructor(e,t,n,r,s=!1){super({left:e,top:t,right:n,bottom:r},s)}},xL=class{constructor(e,t,n,r,s){this._imageDims=new Oc(s.width,s.height),this._score=e,this._classScore=t,this._className=n,this._box=new Rs(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Rs(this._box).rescale(this.imageDims.reverse())}forSize(e,t){return new xL(this.score,this.classScore,this.className,this.relativeBox,{width:e,height:t})}},_i=class extends xL{constructor(e,t,n){super(e,e,"",t,n)}forSize(e,t){let{score:n,relativeBox:r,imageDims:s}=super.forSize(e,t);return new _i(n,r,s)}};function d6e(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),s=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),a=r*s;return n?a/(e.area+t.area-a):a/Math.min(e.area,t.area)}function h6e(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),r=t.reduce((o,l)=>l<o?l:o,1/0),s=n.reduce((o,l)=>l<o?l:o,1/0),a=t.reduce((o,l)=>o<l?l:o,0),i=n.reduce((o,l)=>o<l?l:o,0);return new xJ(r,s,a,i)}function p6e(e,t,n,r=!0){let s=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),a=[];for(;s.length>0;){let i=s.pop();a.push(i);let o=s,l=[];for(let u=0;u<o.length;u++){let c=o[u],d=e[i],h=e[c];l.push(d6e(d,h,r))}s=s.filter((u,c)=>l[c]<=n)}return a}function r1(e,t){return ue(()=>{let[n,r,s]=t,a=Ya([...e.shape.slice(0,3),1],n,"float32"),i=Ya([...e.shape.slice(0,3),1],r,"float32"),o=Ya([...e.shape.slice(0,3),1],s,"float32"),l=In([a,i,o],3);return qe(e,l)})}function f6e(e,t=!1){return ue(()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let s=Math.abs(n-r),a=Math.round(s*(t?.5:1)),i=n>r?2:1,o=d=>{let h=e.shape.slice();return h[i]=d,Ya(h,0,"float32")},l=o(a),u=s-l.shape[i],c=[t&&u?o(u):null,e,l].filter(d=>!!d).map(d=>Me(d,"float32"));return In(c,i)})}function b_(e){return 1/(1+Math.exp(-e))}var wJ=class extends Rs{constructor(e,t,n,r,s=!1){super({x:e,y:t,width:n,height:r},s)}},m6e=.5,g6e=.43,y6e=.45,E0=class{constructor(e,t,n=new nn(0,0)){let{width:r,height:s}=t;this._imgDims=new Oc(r,s),this._shift=n,this._positions=e.map(a=>a.mul(new nn(r,s)).add(n))}get shift(){return new nn(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new nn(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new nn(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let s=e instanceof _i?e.box.floor():new Rs(e);return this.shiftBy(s.x,s.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,s=c=>r.sub(c).magnitude(),a=(s(t)+s(n))/2,i=Math.floor(a/y6e),o=bL(e),l=Math.floor(Math.max(0,o.x-m6e*i)),u=Math.floor(Math.max(0,o.y-g6e*i));return new wJ(l,u,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+u))}alignMinBbox(e){let t=h6e(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},vJ=class extends E0{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(bL)}},PU=class{constructor(e,t){this._label=e,this._distance=t}get label(){return this._label}get distance(){return this._distance}toString(e=!0){return`${this.label}${e?` (${x2(this.distance)})`:""}`}},xc=class{constructor(e,t){if(typeof e!="string")throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(t)||t.some(n=>!(n instanceof Float32Array)))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=e,this._descriptors=t}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map(e=>Array.from(e))}}static fromJSON(e){let t=e.descriptors.map(n=>new Float32Array(n));return new xc(e.label,t)}};function A0(e){return e.detection instanceof _i}function SS(e,t){return{...e,detection:t}}function kJ(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function wL(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function IJ(e){let t="";if(!e&&wL())try{e=Yde("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((r,s)=>{e.readFile(n,(a,i)=>a?s(a):r(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function SJ(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},s=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},a=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=global.fetch,o=IJ();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:r,createImageElement:s,createVideoElement:a,fetch:i,...o}}function CJ(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var Xr;function b6e(){if(!Xr)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Xr}function nR(e){Xr=e}function vL(){return CJ()?nR(kJ()):wL()?nR(SJ()):null}function x6e(e){if(Xr||vL(),!Xr)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Xr.Canvas,Image:n=Xr.Image}=e;Xr.Canvas=t,Xr.Image=n,Xr.createCanvasElement=e.createCanvasElement||(()=>new t),Xr.createImageElement=e.createImageElement||(()=>new n),Xr.ImageData=e.ImageData||Xr.ImageData,Xr.Video=e.Video||Xr.Video,Xr.fetch=e.fetch||Xr.fetch,Xr.readFile=e.readFile||Xr.readFile}var ra={getEnv:b6e,setEnv:nR,initialize:vL,createBrowserEnv:kJ,createFileSystem:IJ,createNodejsEnv:SJ,monkeyPatch:x6e,isBrowser:CJ,isNodejs:wL};vL();function kL(e){return!ra.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function ed(e){let{Canvas:t,CanvasRenderingContext2D:n}=ra.getEnv();if(e instanceof n)return e;let r=kL(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let s=r.getContext("2d");if(!s)throw new Error("resolveContext2d - canvas 2d context is null");return s}var NJ=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(NJ||{}),IL=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:s,fontStyle:a,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=s||14,this.fontStyle=a||"Georgia",this.padding=i||4}},w2=class{constructor(e,t,n={}){this.text=typeof e=="string"?[e]:e instanceof w2?e.text:e,this.anchor=t,this.options=new IL(n)}measureWidth(e){let{padding:t}=this.options;return this.text.map(n=>e.measureText(n).width).reduce((n,r)=>n<r?r:n,0)+2*t}measureHeight(){let{fontSize:e,padding:t}=this.options;return this.text.length*e+2*t}getUpperLeft(e,t){let{anchorPosition:n}=this.options,r=n==="BOTTOM_RIGHT"||n==="TOP_RIGHT",s=n==="BOTTOM_LEFT"||n==="BOTTOM_RIGHT",a=this.measureWidth(e),i=this.measureHeight(),o=r?this.anchor.x-a:this.anchor.x,l=s?this.anchor.y-i:this.anchor.y;if(t){let{width:u,height:c}=t,d=Math.max(Math.min(o,u-a),0),h=Math.max(Math.min(l,c-i),0);return{x:d,y:h}}return{x:o,y:l}}draw(e){let t=kL(e),n=ed(t),{backgroundColor:r,fontColor:s,fontSize:a,fontStyle:i,padding:o}=this.options;n.font=`${a}px ${i}`;let l=this.measureWidth(n),u=this.measureHeight();n.fillStyle=r;let c=this.getUpperLeft(n,t);n.fillRect(c.x,c.y,l,u),n.fillStyle=s,this.text.forEach((d,h)=>{let p=o+c.x,f=o+c.y+(h+1)*a;n.fillText(d,p,f)})}},$J=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:s}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let a={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new IL({...a,...s})}},TJ=class{constructor(e,t={}){this.box=new Rs(e),this.options=new $J(t)}draw(e){let t=ed(e),{boxColor:n,lineWidth:r}=this.options,{x:s,y:a,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(s,a,i,o);let{label:l}=this.options;l&&new w2([l],{x:s-r/2,y:a},this.options.drawLabelOptions).draw(e)}};function w6e(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof _i?n.score:A0(n)?n.detection.score:void 0,s=n instanceof _i?n.box:A0(n)?n.detection.box:new Rs(n),a=r?`${x2(r)}`:void 0;new TJ(s,{label:a}).draw(e)})}function _J(e){let{Image:t,Video:n}=ra.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function v6e(e){return new Promise((t,n)=>{(e instanceof ra.getEnv().Canvas||_J(e))&&t(null);function r(a){a.currentTarget&&(a.currentTarget.removeEventListener("load",s),a.currentTarget.removeEventListener("error",r),n(a))}function s(a){a.currentTarget&&(a.currentTarget.removeEventListener("load",s),a.currentTarget.removeEventListener("error",r),t(a))}e.addEventListener("load",s),e.addEventListener("error",r)})}function k6e(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error("bufferToImage - expected buf to be of type: Blob"));let r=new FileReader;r.onload=()=>{typeof r.result!="string"&&n(new Error("bufferToImage - expected reader.result to be a string, in onload"));let s=ra.getEnv().createImageElement();s.onload=()=>t(s),s.onerror=n,s.src=r.result},r.onerror=n,r.readAsDataURL(e)})}function SL(e){let{Image:t,Video:n}=ra.getEnv();return e instanceof t?new Oc(e.naturalWidth,e.naturalHeight):e instanceof n?new Oc(e.videoWidth,e.videoHeight):new Oc(e.width,e.height)}function CS({width:e,height:t}){let{createCanvasElement:n}=ra.getEnv(),r=n();return r.width=e,r.height=t,r}function EJ(e,t){let{ImageData:n}=ra.getEnv();if(!(e instanceof n)&&!_J(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:s}=t||SL(e),a=CS({width:r,height:s});return e instanceof n?ed(a).putImageData(e,0,0):ed(a).drawImage(e,0,0,r,s),a}async function I6e(e,t){let n=t||ra.getEnv().createCanvasElement(),[r,s,a]=e.shape.slice($u(e)?1:0),i=ue(()=>e.as3D(r,s,a).toInt());return await Pw.toPixels(i,n),i.dispose(),n}function zU(e){let{Image:t,Canvas:n,Video:r}=ra.getEnv();return e instanceof t||e instanceof n||e instanceof r}function S6e(e,t,n=!1){let{Image:r,Canvas:s}=ra.getEnv();if(!(e instanceof r||e instanceof s))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return CS({width:1,height:1});let a=SL(e),i=t/Math.max(a.height,a.width),o=i*a.width,l=i*a.height,u=CS({width:t,height:t}),c=e instanceof s?e:EJ(e),d=Math.abs(o-l)/2,h=n&&o<l?d:0,p=n&&l<o?d:0;return c.width>0&&c.height>0&&ed(u).drawImage(c,h,p,o,l),u}var NS=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,r)=>{if(n1(n)){this._imageTensors[r]=n,this._inputDimensions[r]=n.shape;return}if($u(n)){let a=n.shape[0];if(a!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${a} passed, but not supported in input array`);this._imageTensors[r]=n,this._inputDimensions[r]=n.shape.slice(1);return}let s=n instanceof ra.getEnv().Canvas?n:EJ(n);this._canvases[r]=s,this._inputDimensions[r]=[s.height,s.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return Ag(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return bJ({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,ue(()=>{let n=Ag(this.batchSize,0,1).map(r=>{let s=this.getInput(r);if(s instanceof Tt){let a=$u(s)?s:ms(s);return a=f6e(a,t),(a.shape[1]!==e||a.shape[2]!==e)&&(a=Po.resizeBilinear(a,[e,e],!1,!1)),a.as3D(e,e,3)}if(s instanceof ra.getEnv().Canvas)return Pw.fromPixels(S6e(s,e,t));throw new Error(`toBatchTensor - at batchIdx ${r}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${s}`)});return zr(n.map(r=>Me(r,"float32"))).as4D(this.batchSize,e,e,3)})}};async function sa(e){if(e instanceof NS)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=s=>Array.isArray(e)?` at input index ${s}:`:"",r=t.map(kL);return r.forEach((s,a)=>{if(!zU(s)&&!n1(s)&&!$u(s))throw typeof t[a]=="string"?new Error(`toNetInput -${n(a)} string passed, but could not resolve HTMLElement for element id ${t[a]}`):new Error(`toNetInput -${n(a)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if($u(s)){let i=s.shape[0];if(i!==1)throw new Error(`toNetInput -${n(a)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(r.map(s=>zU(s)&&v6e(s))),new NS(r,Array.isArray(e))}async function CL(e,t){let{Canvas:n}=ra.getEnv(),r=e;if(!(e instanceof n)){let a=await sa(e);if(a.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=a.getInput(0);r=i instanceof n?i:await I6e(i)}let s=ed(r);return t.map(a=>a instanceof _i?a.forSize(r.width,r.height).box.floor():a).map(a=>a.clipAtImageBorders(r.width,r.height)).map(({x:a,y:i,width:o,height:l})=>{let u=CS({width:o,height:l});return o>0&&l>0&&ed(u).putImageData(s.getImageData(a,i,o,l),0,0),u})}async function NL(e,t){if(!n1(e)&&!$u(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if($u(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return ue(()=>{let[n,r,s]=e.shape.slice($u(e)?1:0);return t.map(a=>a instanceof _i?a.forSize(r,n).box:a).map(a=>a.clipAtImageBorders(r,n)).filter(a=>a.width>0&&a.height>0).map(({x:a,y:i,width:o,height:l})=>cb(e.as3D(n,r,s),[i,a,0],[l,o,s]))})}async function AJ(e,t){let{fetch:n}=ra.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function $L(e){let t=await AJ(e),n=await t.blob();if(!n.type.startsWith("image/"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${t.url}`);return k6e(n)}async function C6e(e){return(await AJ(e)).json()}function RJ(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let s=e.split("/").filter(o=>o),a=e.endsWith(".json")?s[s.length-1]:n,i=r+(e.endsWith(".json")?s.slice(0,s.length-1):s).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${a}`:`${i}/${a}`}}async function N6e(e,t){let{manifestUri:n,modelBaseUri:r}=RJ(e,t),s=await C6e(n);return ws.loadWeights(s,r)}function TL(e,t,n=!1){let{width:r,height:s}=n?SL(t):t;return e.width=r,e.height=s,{width:r,height:s}}var Td=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Bh)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Bh))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=Js(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await N6e(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=ra.getEnv(),{manifestUri:n,modelBaseUri:r}=RJ(e,this.getDefaultModelName()),s=l=>Promise.all(l.map(u=>t(u).then(c=>c.buffer))),a=ws.weightsLoaderFactory(s),i=JSON.parse((await t(n)).toString()),o=await a(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((s,a)=>{if(!s.nextObj.hasOwnProperty(a))throw new Error(`traversePropertyPath - object does not have property ${a}, for path ${e}`);return{obj:s.nextObj,objProp:a,nextObj:s.nextObj[a]}},{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof Tt))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function vi(e,t,n){return ue(()=>{let r=ub(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=Ie(r,t.bias),r})}function x_(e,t,n=!1){return ue(()=>{let r=yn(n?Ie(ea(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):vi(e,t.conv0,[2,2])),s=vi(r,t.conv1,[1,1]),a=yn(Ie(r,s)),i=vi(a,t.conv2,[1,1]);return yn(Ie(r,Ie(s,i)))})}function gk(e,t,n=!1,r=!0){return ue(()=>{let s=yn(n?Ie(ea(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):vi(e,t.conv0,r?[2,2]:[1,1])),a=vi(s,t.conv1,[1,1]),i=yn(Ie(s,a)),o=vi(i,t.conv2,[1,1]),l=yn(Ie(s,Ie(a,o))),u=vi(l,t.conv3,[1,1]);return yn(Ie(s,Ie(a,Ie(o,u))))})}function Gx(e,t,n="same",r=!1){return ue(()=>{let s=Ie(ea(e,t.filters,[1,1],n),t.bias);return r?yn(s):s})}function _d(e,t){Object.keys(e).forEach(n=>{t.some(r=>r.originalPath===n)||e[n].dispose()})}function _L(e,t){return(n,r,s,a)=>{let i=qc(e(n*r*s*s),[s,s,n,r]),o=gn(e(r));return t.push({paramPath:`${a}/filters`},{paramPath:`${a}/bias`}),{filters:i,bias:o}}}function DJ(e,t){return(n,r,s)=>{let a=Ol(e(n*r),[n,r]),i=gn(e(r));return t.push({paramPath:`${s}/weights`},{paramPath:`${s}/bias`}),{weights:a,bias:i}}}var FJ=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function EL(e,t){return(n,r,s)=>{let a=qc(e(9*n),[3,3,n,1]),i=qc(e(n*r),[1,1,n,r]),o=gn(e(r));return t.push({paramPath:`${s}/depthwise_filter`},{paramPath:`${s}/pointwise_filter`},{paramPath:`${s}/bias`}),new FJ(a,i,o)}}function AL(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),s=e(`${t}/bias`,1);return new FJ(n,r,s)}}function Uf(e,t){return(n,r,s)=>{let a=e[n];if(!Ib(a,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${a}`);return t.push({originalPath:n,paramPath:s||n}),a}}function Ed(e){let t=e;function n(s){let a=t.slice(0,s);return t=t.slice(s),a}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function OJ(e,t){let n=_L(e,t),r=EL(e,t);function s(i,o,l,u=!1){let c=u?n(i,o,3,`${l}/conv0`):r(i,o,`${l}/conv0`),d=r(o,o,`${l}/conv1`),h=r(o,o,`${l}/conv2`);return{conv0:c,conv1:d,conv2:h}}function a(i,o,l,u=!1){let{conv0:c,conv1:d,conv2:h}=s(i,o,l,u),p=r(o,o,`${l}/conv3`);return{conv0:c,conv1:d,conv2:h,conv3:p}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:a}}function $6e(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ed(e),{extractDenseBlock4Params:s}=OJ(n,t),a=s(3,32,"dense0",!0),i=s(32,64,"dense1"),o=s(64,128,"dense2"),l=s(128,256,"dense3");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:a,dense1:i,dense2:o,dense3:l}}}function MJ(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function LJ(e,t){let n=Uf(e,t),r=MJ(n),s=AL(n);function a(o,l=!1){let u=l?r(`${o}/conv0`):s(`${o}/conv0`),c=s(`${o}/conv1`),d=s(`${o}/conv2`);return{conv0:u,conv1:c,conv2:d}}function i(o,l=!1){let u=l?r(`${o}/conv0`):s(`${o}/conv0`),c=s(`${o}/conv1`),d=s(`${o}/conv2`),h=s(`${o}/conv3`);return{conv0:u,conv1:c,conv2:d,conv3:h}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:i}}function T6e(e){let t=[],{extractDenseBlock4Params:n}=LJ(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return _d(e,t),{params:r,paramMappings:t}}var PJ=class extends Td{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return ue(()=>{let n=Me(e.toBatchTensor(112,!0),"float32"),r=r1(n,[122.782,117.001,104.298]).div(255),s=gk(r,t.dense0,!0);return s=gk(s,t.dense1),s=gk(s,t.dense2),s=gk(s,t.dense3),s=Vu(s,[7,7],[2,2],"valid"),s})}async forward(e){return this.forwardInput(await sa(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return T6e(e)}extractParams(e){return $6e(e)}};function rR(e,t){return ue(()=>Ie(At(e,t.weights),t.bias))}function _6e(e,t,n){let r=[],{extractWeights:s,getRemainingWeights:a}=Ed(e),i=DJ(s,r)(t,n,"fc");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:r,params:{fc:i}}}function E6e(e){let t=[],n=Uf(e,t);function r(a){let i=n(`${a}/weights`,2),o=n(`${a}/bias`,1);return{weights:i,bias:o}}let s={fc:r("fc")};return _d(e,t),{params:s,paramMappings:t}}function zJ(e){let t={},n={};return Object.keys(e).forEach(r=>{let s=r.startsWith("fc")?n:t;s[r]=e[r]}),{featureExtractorMap:t,classifierMap:n}}var BJ=class extends Td{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ue(()=>{let n=e instanceof NS?this.faceFeatureExtractor.forwardInput(e):e;return rR(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return _6e(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=zJ(e);return this.faceFeatureExtractor.loadFromWeightMap(t),E6e(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,s=e.slice(0,e.length-r),a=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(s),this.extractClassifierParams(a)}},BU=["neutral","happy","sad","angry","fearful","disgusted","surprised"],RL=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);BU.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return BU.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},A6e=class extends BJ{constructor(e=new PJ){super("FaceExpressionNet",e)}forwardInput(e){return ue(()=>kd(this.runNet(e)))}async forward(e){return this.forwardInput(await sa(e))}async predictExpressions(e){let t=await sa(e),n=await this.forwardInput(t),r=await Promise.all(fr(n).map(async a=>{let i=a.dataSync();return a.dispose(),i}));n.dispose();let s=r.map(a=>new RL(a));return t.isBatchInput?s:s[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function R6e(e){return e.expressions instanceof RL}function WJ(e,t){return{...e,expressions:t}}function D6e(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach(s=>{let a=s instanceof RL?s:R6e(s)?s.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=a.asSortedArray().filter(l=>l.probability>n),o=A0(s)?s.detection.box.bottomLeft:r||new nn(0,0);new w2(i.map(l=>`${l.expression} (${x2(l.probability)})`),o).draw(e)})}function DL(e){return A0(e)&&e.landmarks instanceof E0&&e.unshiftedLandmarks instanceof E0&&e.alignedRect instanceof _i}function F6e(e){let t=l=>l*180/Math.PI,n=(l,u)=>Math.sqrt((l._x-u._x)**2+(l._y-u._y)**2),r={roll:void 0,pitch:void 0,yaw:void 0},s=(l,u,c)=>{let d=Math.floor(l._x-u._x),h=Math.floor(u._x-c._x);return d-h},a=(l,u)=>{let c=Math.hypot(u._x-l._x,u._y-l._y),d=u._y-l._y,h=Math.asin(d/c),p=t(h),f=Math.floor(90-p),m=u._x-l._x<0?-1:1;return f*m},i=(l,u,c)=>{let d=n(l,c),h={_x:(l._x+c._x)/2,_y:(l._y+c._y)/2},p=n(u,h),f=Math.atan(p/d),m=Math.floor(t(f)),g=h._y-u._y<0?-1:1;return m*g};if(!e||!e._positions||e._positions.length!==68)return r;let o=e._positions;return r.roll=a(o[27],o[66]),r.pitch=i(o[14],o[30],o[2]),r.yaw=s(o[14],o[33],o[2]),r}function FL(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),s=r.align(),{imageDims:a}=e.detection,i=new _i(e.detection.score,s.rescale(a.reverse()),a),o=F6e(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var VJ=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:s,pointSize:a,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=a||2,this.lineColor=s||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},UJ=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new VJ(t)}draw(e){let t=ed(e),{drawLines:n,drawPoints:r,lineWidth:s,lineColor:a,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof vJ&&(t.strokeStyle=a,t.lineWidth=s,ac(t,this.faceLandmarks.getJawOutline()),ac(t,this.faceLandmarks.getLeftEyeBrow()),ac(t,this.faceLandmarks.getRightEyeBrow()),ac(t,this.faceLandmarks.getNose()),ac(t,this.faceLandmarks.getLeftEye(),!0),ac(t,this.faceLandmarks.getRightEye(),!0),ac(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let l=u=>{t.beginPath(),t.arc(u.x,u.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(l)}}};function O6e(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof E0?n:DL(n)?n.landmarks:void 0;if(!r)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new UJ(r).draw(e)})}function M6e(e,t){let n=_L(e,t),r=EL(e,t);function s(i,o,l){let u=r(i,o,`${l}/separable_conv0`),c=r(o,o,`${l}/separable_conv1`),d=n(i,o,1,`${l}/expansion_conv`);return{separable_conv0:u,separable_conv1:c,expansion_conv:d}}function a(i,o){let l=r(i,i,`${o}/separable_conv0`),u=r(i,i,`${o}/separable_conv1`),c=r(i,i,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:c}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:a}}function L6e(e,t){let n=[],{extractWeights:r,getRemainingWeights:s}=Ed(e),{extractConvParams:a,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=M6e(r,n),u=a(3,32,3,"entry_flow/conv_in"),c=o(32,64,"entry_flow/reduction_block_0"),d=o(64,128,"entry_flow/reduction_block_1"),h={conv_in:u,reduction_block_0:c,reduction_block_1:d},p={};Ag(t,0,1).forEach(y=>{p[`main_block_${y}`]=l(128,`middle_flow/main_block_${y}`)});let f=o(128,256,"exit_flow/reduction_block"),m=i(256,512,"exit_flow/separable_conv"),g={reduction_block:f,separable_conv:m};if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:n,params:{entry_flow:h,middle_flow:p,exit_flow:g}}}function P6e(e,t){let n=Uf(e,t),r=MJ(n),s=AL(n);function a(o){let l=s(`${o}/separable_conv0`),u=s(`${o}/separable_conv1`),c=r(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:u,expansion_conv:c}}function i(o){let l=s(`${o}/separable_conv0`),u=s(`${o}/separable_conv1`),c=s(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:c}}return{extractConvParams:r,extractSeparableConvParams:s,extractReductionBlockParams:a,extractMainBlockParams:i}}function z6e(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:s,extractReductionBlockParams:a,extractMainBlockParams:i}=P6e(e,n),o=r("entry_flow/conv_in"),l=a("entry_flow/reduction_block_0"),u=a("entry_flow/reduction_block_1"),c={conv_in:o,reduction_block_0:l,reduction_block_1:u},d={};Ag(t,0,1).forEach(m=>{d[`main_block_${m}`]=i(`middle_flow/main_block_${m}`)});let h=a("exit_flow/reduction_block"),p=s("exit_flow/separable_conv"),f={reduction_block:h,separable_conv:p};return _d(e,n),{params:{entry_flow:c,middle_flow:d,exit_flow:f},paramMappings:n}}function GJ(e,t,n){return Ie(ea(e,t.filters,n,"same"),t.bias)}function w_(e,t,n=!0){let r=n?yn(e):e;return r=vi(r,t.separable_conv0,[1,1]),r=vi(yn(r),t.separable_conv1,[1,1]),r=Yr(r,[3,3],[2,2],"same"),r=Ie(r,GJ(e,t.expansion_conv,[2,2])),r}function B6e(e,t){let n=vi(yn(e),t.separable_conv0,[1,1]);return n=vi(yn(n),t.separable_conv1,[1,1]),n=vi(yn(n),t.separable_conv2,[1,1]),n=Ie(n,e),n}var W6e=class extends Td{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return ue(()=>{let n=Me(e.toBatchTensor(112,!0),"float32"),r=r1(n,[122.782,117.001,104.298]).div(255),s=yn(GJ(r,t.entry_flow.conv_in,[2,2]));return s=w_(s,t.entry_flow.reduction_block_0,!1),s=w_(s,t.entry_flow.reduction_block_1),Ag(this._numMainBlocks,0,1).forEach(a=>{s=B6e(s,t.middle_flow[`main_block_${a}`])}),s=w_(s,t.exit_flow.reduction_block),s=yn(vi(s,t.exit_flow.separable_conv,[1,1])),s})}async forward(e){return this.forwardInput(await sa(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return z6e(e,this._numMainBlocks)}extractParams(e){return L6e(e,this._numMainBlocks)}};function V6e(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ed(e),s=DJ(n,t),a=s(512,1,"fc/age"),i=s(512,2,"fc/gender");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:a,gender:i}}}}function U6e(e){let t=[],n=Uf(e,t);function r(a){let i=n(`${a}/weights`,2),o=n(`${a}/bias`,1);return{weights:i,bias:o}}let s={fc:{age:r("fc/age"),gender:r("fc/gender")}};return _d(e,t),{params:s,paramMappings:t}}var G6e=(e=>(e.FEMALE="female",e.MALE="male",e))(G6e||{}),H6e=class extends Td{constructor(e=new W6e(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ue(()=>{let n=e instanceof NS?this.faceFeatureExtractor.forwardInput(e):e,r=Vu(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),s=rR(r,t.fc.age).as1D(),a=rR(r,t.fc.gender);return{age:s,gender:a}})}forwardInput(e){return ue(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:kd(n)}})}async forward(e){return this.forwardInput(await sa(e))}async predictAgeAndGender(e){let t=await sa(e),n=await this.forwardInput(t),r=fr(n.age),s=fr(n.gender),a=r.map((o,l)=>({ageTensor:o,genderTensor:s[l]})),i=await Promise.all(a.map(async({ageTensor:o,genderTensor:l})=>{let u=o.dataSync()[0],c=l.dataSync()[0],d=c>.5,h=d?"male":"female",p=d?c:1-c;return o.dispose(),l.dispose(),{age:u,gender:h,genderProbability:p}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return V6e(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=zJ(e);return this.faceFeatureExtractor.loadFromWeightMap(t),U6e(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},HJ=class extends BJ{postProcess(e,t,n){let r=n.map(({width:a,height:i})=>{let o=t/Math.max(i,a);return{width:a*o,height:i*o}}),s=r.length;return ue(()=>{let a=(u,c)=>zr([Ya([68],u,"float32"),Ya([68],c,"float32")],1).as2D(1,136).as1D(),i=(u,c)=>{let{width:d,height:h}=r[u];return c(d,h)?Math.abs(d-h)/2:0},o=u=>i(u,(c,d)=>c<d),l=u=>i(u,(c,d)=>d<c);return e.mul(Ya([s,136],t,"float32")).sub(zr(Array.from(Array(s),(u,c)=>a(o(c),l(c))))).div(zr(Array.from(Array(s),(u,c)=>a(r[c].width,r[c].height))))})}forwardInput(e){return ue(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,r])=>({height:n,width:r})))})}async forward(e){return this.forwardInput(await sa(e))}async detectLandmarks(e){let t=await sa(e),n=ue(()=>fr(this.forwardInput(t))),r=await Promise.all(n.map(async(s,a)=>{let i=Array.from(s.dataSync()),o=i.filter((u,c)=>eR(c)),l=i.filter((u,c)=>!eR(c));return new vJ(Array(68).fill(0).map((u,c)=>new nn(o[c],l[c])),{height:t.getInputHeight(a),width:t.getInputWidth(a)})}));return n.forEach(s=>s.dispose()),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},j6e=class extends HJ{constructor(e=new PJ){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function q6e(e){let t=[],{extractDenseBlock3Params:n}=LJ(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return _d(e,t),{params:r,paramMappings:t}}function K6e(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ed(e),{extractDenseBlock3Params:s}=OJ(n,t),a=s(3,32,"dense0",!0),i=s(32,64,"dense1"),o=s(64,128,"dense2");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:a,dense1:i,dense2:o}}}var X6e=class extends Td{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return ue(()=>{let n=Me(e.toBatchTensor(112,!0),"float32"),r=r1(n,[122.782,117.001,104.298]).div(255),s=x_(r,t.dense0,!0);return s=x_(s,t.dense1),s=x_(s,t.dense2),s=Vu(s,[14,14],[2,2],"valid"),s})}async forward(e){return this.forwardInput(await sa(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return q6e(e)}extractParams(e){return K6e(e)}},Y6e=class extends HJ{constructor(e=new X6e){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function Z6e(e,t){return Ie(ae(e,t.weights),t.biases)}function OL(e,t,n,r,s="same"){let{filters:a,bias:i}=t.conv,o=ea(e,a,n,s);return o=Ie(o,i),o=Z6e(o,t.scale),r?yn(o):o}function J6e(e,t){return OL(e,t,[1,1],!0)}function jJ(e,t){return OL(e,t,[1,1],!1)}function qJ(e,t){return OL(e,t,[2,2],!0,"valid")}function Q6e(e,t){function n(o,l,u){let c=e(o),d=c.length/(l*u*u);if(yJ(d))throw new Error(`depth has to be an integer: ${d}, weights.length: ${c.length}, numFilters: ${l}, filterSize: ${u}`);return ue(()=>Ft(qc(c,[l,d,u,u]),[2,3,1,0]))}function r(o,l,u,c){let d=n(o,l,u),h=gn(e(l));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/bias`}),{filters:d,bias:h}}function s(o,l){let u=gn(e(o)),c=gn(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:u,biases:c}}function a(o,l,u,c){let d=r(o,l,u,`${c}/conv`),h=s(l,`${c}/scale`);return{conv:d,scale:h}}function i(o,l,u,c,d=!1){let h=a((d?.5:1)*o,l,u,`${c}/conv1`),p=a(o,l,u,`${c}/conv2`);return{conv1:h,conv2:p}}return{extractConvLayerParams:a,extractResidualLayerParams:i}}function eqe(e){let{extractWeights:t,getRemainingWeights:n}=Ed(e),r=[],{extractConvLayerParams:s,extractResidualLayerParams:a}=Q6e(t,r),i=s(4704,32,7,"conv32_down"),o=a(9216,32,3,"conv32_1"),l=a(9216,32,3,"conv32_2"),u=a(9216,32,3,"conv32_3"),c=a(36864,64,3,"conv64_down",!0),d=a(36864,64,3,"conv64_1"),h=a(36864,64,3,"conv64_2"),p=a(36864,64,3,"conv64_3"),f=a(147456,128,3,"conv128_down",!0),m=a(147456,128,3,"conv128_1"),g=a(147456,128,3,"conv128_2"),y=a(589824,256,3,"conv256_down",!0),b=a(589824,256,3,"conv256_1"),x=a(589824,256,3,"conv256_2"),w=a(589824,256,3,"conv256_down_out"),v=ue(()=>Ft(Ol(t(256*128),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:c,conv64_1:d,conv64_2:h,conv64_3:p,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:x,conv256_down_out:w,fc:v},paramMappings:r}}function tqe(e,t){let n=Uf(e,t);function r(i){let o=n(`${i}/scale/weights`,1),l=n(`${i}/scale/biases`,1);return{weights:o,biases:l}}function s(i){let o=n(`${i}/conv/filters`,4),l=n(`${i}/conv/bias`,1),u=r(i);return{conv:{filters:o,bias:l},scale:u}}function a(i){return{conv1:s(`${i}/conv1`),conv2:s(`${i}/conv2`)}}return{extractConvLayerParams:s,extractResidualLayerParams:a}}function nqe(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=tqe(e,t),s=n("conv32_down"),a=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),c=r("conv64_2"),d=r("conv64_3"),h=r("conv128_down"),p=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:x}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!gJ(x))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${x}`);let w={conv32_down:s,conv32_1:a,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:c,conv64_3:d,conv128_down:h,conv128_1:p,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:x};return _d(e,t),{params:w,paramMappings:t}}function fl(e,t){let n=J6e(e,t.conv1);return n=jJ(n,t.conv2),n=Ie(n,e),n=yn(n),n}function yk(e,t){let n=qJ(e,t.conv1);n=jJ(n,t.conv2);let r=Vu(e,2,2,"valid"),s=sr(r.shape),a=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let o=sr(i);n=In([n,o],1);let l=[...n.shape];l[2]=1;let u=sr(l);n=In([n,u],2)}return r=a?In([r,s],3):r,n=Ie(r,n),n=yn(n),n}var rqe=class extends Td{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return ue(()=>{let n=Me(e.toBatchTensor(150,!0),"float32"),r=r1(n,[122.782,117.001,104.298]).div(255),s=qJ(r,t.conv32_down);s=Yr(s,3,2,"valid"),s=fl(s,t.conv32_1),s=fl(s,t.conv32_2),s=fl(s,t.conv32_3),s=yk(s,t.conv64_down),s=fl(s,t.conv64_1),s=fl(s,t.conv64_2),s=fl(s,t.conv64_3),s=yk(s,t.conv128_down),s=fl(s,t.conv128_1),s=fl(s,t.conv128_2),s=yk(s,t.conv256_down),s=fl(s,t.conv256_1),s=fl(s,t.conv256_2),s=yk(s,t.conv256_down_out);let a=s.mean([1,2]);return At(a,t.fc)})}async forward(e){return this.forwardInput(await sa(e))}async computeFaceDescriptor(e){var t;if((t=e==null?void 0:e.shape)!=null&&t.some(a=>a<=0))return new Float32Array(128);let n=await sa(e),r=ue(()=>fr(this.forwardInput(n))),s=await Promise.all(r.map(a=>a.data()));return r.forEach(a=>a.dispose()),n.isBatchInput?s:s[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return nqe(e)}extractParams(e){return eqe(e)}};function KJ(e,t){return{...e,descriptor:t}}function XJ(e,t){return{...e,age:t}}function YJ(e,t,n){return{...e,gender:t,genderProbability:n}}function sqe(e,t){function n(l,u){let c=qc(e(9*l),[3,3,l,1]),d=gn(e(l)),h=gn(e(l)),p=gn(e(l)),f=gn(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/batch_norm_scale`},{paramPath:`${u}/batch_norm_offset`},{paramPath:`${u}/batch_norm_mean`},{paramPath:`${u}/batch_norm_variance`}),{filters:c,batch_norm_scale:d,batch_norm_offset:h,batch_norm_mean:p,batch_norm_variance:f}}function r(l,u,c,d,h){let p=qc(e(l*u*c*c),[c,c,l,u]),f=gn(e(u));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/${h?"batch_norm_offset":"bias"}`}),{filters:p,bias:f}}function s(l,u,c,d){let{filters:h,bias:p}=r(l,u,c,d,!0);return{filters:h,batch_norm_offset:p}}function a(l,u,c){let d=n(l,`${c}/depthwise_conv`),h=s(l,u,1,`${c}/pointwise_conv`);return{depthwise_conv:d,pointwise_conv:h}}function i(){let l=s(3,32,3,"mobilenetv1/conv_0"),u=a(32,64,"mobilenetv1/conv_1"),c=a(64,128,"mobilenetv1/conv_2"),d=a(128,128,"mobilenetv1/conv_3"),h=a(128,256,"mobilenetv1/conv_4"),p=a(256,256,"mobilenetv1/conv_5"),f=a(256,512,"mobilenetv1/conv_6"),m=a(512,512,"mobilenetv1/conv_7"),g=a(512,512,"mobilenetv1/conv_8"),y=a(512,512,"mobilenetv1/conv_9"),b=a(512,512,"mobilenetv1/conv_10"),x=a(512,512,"mobilenetv1/conv_11"),w=a(512,1024,"mobilenetv1/conv_12"),v=a(1024,1024,"mobilenetv1/conv_13");return{conv_0:l,conv_1:u,conv_2:c,conv_3:d,conv_4:h,conv_5:p,conv_6:f,conv_7:m,conv_8:g,conv_9:y,conv_10:b,conv_11:x,conv_12:w,conv_13:v}}function o(){let l=s(1024,256,1,"prediction_layer/conv_0"),u=s(256,512,3,"prediction_layer/conv_1"),c=s(512,128,1,"prediction_layer/conv_2"),d=s(128,256,3,"prediction_layer/conv_3"),h=s(256,128,1,"prediction_layer/conv_4"),p=s(128,256,3,"prediction_layer/conv_5"),f=s(256,64,1,"prediction_layer/conv_6"),m=s(64,128,3,"prediction_layer/conv_7"),g=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),y=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),b=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),x=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),w=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),v=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),k=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),I=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),S=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),$=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),N=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),T=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:l,conv_1:u,conv_2:c,conv_3:d,conv_4:h,conv_5:p,conv_6:f,conv_7:m,box_predictor_0:{box_encoding_predictor:g,class_predictor:y},box_predictor_1:{box_encoding_predictor:b,class_predictor:x},box_predictor_2:{box_encoding_predictor:w,class_predictor:v},box_predictor_3:{box_encoding_predictor:k,class_predictor:I},box_predictor_4:{box_encoding_predictor:S,class_predictor:$},box_predictor_5:{box_encoding_predictor:N,class_predictor:T}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function aqe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ed(e),{extractMobilenetV1Params:s,extractPredictionLayerParams:a}=sqe(n,t),i=s(),o=a(),l={extra_dim:ON(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function iqe(e,t){let n=Uf(e,t);function r(u,c,d){let h=n(`${u}/Conv2d_${c}_pointwise/weights`,4,`${d}/filters`),p=n(`${u}/Conv2d_${c}_pointwise/convolution_bn_offset`,1,`${d}/batch_norm_offset`);return{filters:h,batch_norm_offset:p}}function s(u){let c=`mobilenetv1/conv_${u}`,d=`MobilenetV1/Conv2d_${u}_depthwise`,h=`${c}/depthwise_conv`,p=`${c}/pointwise_conv`,f=n(`${d}/depthwise_weights`,4,`${h}/filters`),m=n(`${d}/BatchNorm/gamma`,1,`${h}/batch_norm_scale`),g=n(`${d}/BatchNorm/beta`,1,`${h}/batch_norm_offset`),y=n(`${d}/BatchNorm/moving_mean`,1,`${h}/batch_norm_mean`),b=n(`${d}/BatchNorm/moving_variance`,1,`${h}/batch_norm_variance`);return{depthwise_conv:{filters:f,batch_norm_scale:m,batch_norm_offset:g,batch_norm_mean:y,batch_norm_variance:b},pointwise_conv:r("MobilenetV1",u,p)}}function a(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:s(1),conv_2:s(2),conv_3:s(3),conv_4:s(4),conv_5:s(5),conv_6:s(6),conv_7:s(7),conv_8:s(8),conv_9:s(9),conv_10:s(10),conv_11:s(11),conv_12:s(12),conv_13:s(13)}}function i(u,c){let d=n(`${u}/weights`,4,`${c}/filters`),h=n(`${u}/biases`,1,`${c}/bias`);return{filters:d,bias:h}}function o(u){let c=i(`Prediction/BoxPredictor_${u}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${u}/box_encoding_predictor`),d=i(`Prediction/BoxPredictor_${u}/ClassPredictor`,`prediction_layer/box_predictor_${u}/class_predictor`);return{box_encoding_predictor:c,class_predictor:d}}function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:a,extractPredictionLayerParams:l}}function oqe(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=iqe(e,t),s=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!n1(s))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${s}`);let a={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:s}};return _d(e,t),{params:a,paramMappings:t}}function bl(e,t,n){return ue(()=>{let r=ea(e,t.filters,n,"same");return r=Ie(r,t.batch_norm_offset),Ms(r,0,6)})}var lqe=.0010000000474974513;function uqe(e,t,n){return ue(()=>{let r=Df(e,t.filters,n,"same");return r=Rf(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,lqe),Ms(r,0,6)})}function cqe(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function dqe(e,t){return ue(()=>{let n,r=bl(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((s,a)=>{let i=a+1,o=cqe(i);r=uqe(r,s.depthwise_conv,o),r=bl(r,s.pointwise_conv,[1,1]),i===11&&(n=r)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}function hqe(e,t,n){let r=e.arraySync(),s=Math.min(r[t][0],r[t][2]),a=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),c=Math.max(r[n][0],r[n][2]),d=Math.max(r[n][1],r[n][3]),h=(i-s)*(o-a),p=(c-l)*(d-u);if(h<=0||p<=0)return 0;let f=Math.max(s,l),m=Math.max(a,u),g=Math.min(i,c),y=Math.min(o,d),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(h+p-b)}function pqe(e,t,n,r,s){let a=e.shape[0],i=Math.min(n,a),o=t.map((c,d)=>({score:c,boxIndex:d})).filter(c=>c.score>s).sort((c,d)=>d.score-c.score),l=c=>c<=r?1:0,u=[];return o.forEach(c=>{if(u.length>=i)return;let d=c.score;for(let h=u.length-1;h>=0;--h){let p=hqe(e,c.boxIndex,u[h]);if(p!==0&&(c.score*=l(p),c.score<=s))break}d===c.score&&u.push(c.boxIndex)}),u}function fqe(e){let t=fr(Ft(e,[1,0])),n=[qe(t[2],t[0]),qe(t[3],t[1])],r=[Ie(t[0],tt(n[0],2)),Ie(t[1],tt(n[1],2))];return{sizes:n,centers:r}}function mqe(e,t){let{sizes:n,centers:r}=fqe(e),s=fr(Ft(t,[1,0])),a=tt(ae(ta(tt(s[2],5)),n[0]),2),i=Ie(ae(tt(s[0],10),n[0]),r[0]),o=tt(ae(ta(tt(s[3],5)),n[1]),2),l=Ie(ae(tt(s[1],10),n[1]),r[1]);return Ft(zr([qe(i,a),qe(l,o),Ie(i,a),Ie(l,o)]),[1,0])}function gqe(e,t,n){return ue(()=>{let r=e.shape[0],s=mqe(oe(Ga(n.extra_dim,[r,1,1]),[-1,4]),oe(e,[-1,4]));s=oe(s,[r,s.shape[0]/r,4]);let a=ho(Vt(t,[0,0,1],[-1,-1,-1])),i=Vt(a,[0,0,0],[-1,-1,1]);i=oe(i,[r,i.shape[1]]);let o=fr(s),l=fr(i);return{boxes:o,scores:l}})}function lm(e,t){return ue(()=>{let n=e.shape[0],r=oe(Gx(e,t.box_encoding_predictor),[n,-1,1,4]),s=oe(Gx(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:s}})}function yqe(e,t,n){return ue(()=>{let r=bl(e,n.conv_0,[1,1]),s=bl(r,n.conv_1,[2,2]),a=bl(s,n.conv_2,[1,1]),i=bl(a,n.conv_3,[2,2]),o=bl(i,n.conv_4,[1,1]),l=bl(o,n.conv_5,[2,2]),u=bl(l,n.conv_6,[1,1]),c=bl(u,n.conv_7,[2,2]),d=lm(t,n.box_predictor_0),h=lm(e,n.box_predictor_1),p=lm(s,n.box_predictor_2),f=lm(i,n.box_predictor_3),m=lm(l,n.box_predictor_4),g=lm(c,n.box_predictor_5),y=In([d.boxPredictionEncoding,h.boxPredictionEncoding,p.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),b=In([d.classPrediction,h.classPrediction,p.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1);return{boxPredictions:y,classPredictions:b}})}var s1=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},bqe=class extends Td{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return ue(()=>{let n=Me(e.toBatchTensor(512,!1),"float32"),r=qe(tt(n,127.5),1),s=dqe(r,t.mobilenetv1),{boxPredictions:a,classPredictions:i}=yqe(s.out,s.conv11,t.prediction_layer);return gqe(a,i,t.output_layer)})}async forward(e){return this.forwardInput(await sa(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new s1(t),s=await sa(e),{boxes:a,scores:i}=this.forwardInput(s),o=a[0],l=i[0];for(let y=1;y<a.length;y++)a[y].dispose(),i[y].dispose();let u=Array.from(l.dataSync()),c=pqe(o,u,n,.5,r),d=s.getReshapedInputDimensions(0),h=s.inputSize,p=h/d.width,f=h/d.height,m=o.arraySync(),g=c.map(y=>{let[b,x]=[Math.max(0,m[y][0]),Math.min(1,m[y][2])].map(k=>k*f),[w,v]=[Math.max(0,m[y][1]),Math.min(1,m[y][3])].map(k=>k*p);return new _i(u[y],new wJ(w,b,v-w,x-b),{height:s.getInputHeight(0),width:s.getInputWidth(0)})});return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return oqe(e)}extractParams(e){return aqe(e)}},xqe=.4,wqe=[new nn(.738768,.874946),new nn(2.42204,2.65704),new nn(4.30971,7.04493),new nn(10.246,4.59428),new nn(12.6868,11.8741)],vqe=[new nn(1.603231,2.094468),new nn(6.041143,7.080126),new nn(2.882459,3.518061),new nn(4.266906,5.178857),new nn(9.041765,10.66308)],kqe=[117.001,114.697,97.404],Iqe="tiny_yolov2_model",Sqe="tiny_yolov2_separable_conv_model",bk=e=>typeof e=="number";function Cqe(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!bk(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>bk(t.x)&&bk(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(bk)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function ML(e){return ue(()=>{let t=ae(e,mt(.10000000149011612));return Ie(yn(qe(e,t)),t)})}function tc(e,t){return ue(()=>{let n=ll(e,[[0,0],[1,1],[1,1],[0,0]]);return n=ea(n,t.conv.filters,[1,1],"valid"),n=qe(n,t.bn.sub),n=ae(n,t.bn.truediv),n=Ie(n,t.conv.bias),ML(n)})}function nc(e,t){return ue(()=>{let n=ll(e,[[0,0],[1,1],[1,1],[0,0]]);return n=ub(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=Ie(n,t.bias),ML(n)})}function Nqe(e,t){let n=_L(e,t);function r(i,o){let l=gn(e(i)),u=gn(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:u}}function s(i,o,l){let u=n(i,o,3,`${l}/conv`),c=r(o,`${l}/bn`);return{conv:u,bn:c}}let a=EL(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}}function $qe(e,t,n,r){let{extractWeights:s,getRemainingWeights:a}=Ed(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:u}=Nqe(s,i),c;if(t.withSeparableConvs){let[d,h,p,f,m,g,y,b,x]=r,w=t.isFirstLayerConv2d?o(d,h,3,"conv0"):u(d,h,"conv0"),v=u(h,p,"conv1"),k=u(p,f,"conv2"),I=u(f,m,"conv3"),S=u(m,g,"conv4"),$=u(g,y,"conv5"),N=b?u(y,b,"conv6"):void 0,T=x?u(b,x,"conv7"):void 0,C=o(x||b||y,5*n,1,"conv8");c={conv0:w,conv1:v,conv2:k,conv3:I,conv4:S,conv5:$,conv6:N,conv7:T,conv8:C}}else{let[d,h,p,f,m,g,y,b,x]=r,w=l(d,h,"conv0"),v=l(h,p,"conv1"),k=l(p,f,"conv2"),I=l(f,m,"conv3"),S=l(m,g,"conv4"),$=l(g,y,"conv5"),N=l(y,b,"conv6"),T=l(b,x,"conv7"),C=o(x,5*n,1,"conv8");c={conv0:w,conv1:v,conv2:k,conv3:I,conv4:S,conv5:$,conv6:N,conv7:T,conv8:C}}if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:c,paramMappings:i}}function Tqe(e,t){let n=Uf(e,t);function r(o){let l=n(`${o}/sub`,1),u=n(`${o}/truediv`,1);return{sub:l,truediv:u}}function s(o){let l=n(`${o}/filters`,4),u=n(`${o}/bias`,1);return{filters:l,bias:u}}function a(o){let l=s(`${o}/conv`),u=r(`${o}/bn`);return{conv:l,bn:u}}let i=AL(n);return{extractConvParams:s,extractConvWithBatchNormParams:a,extractSeparableConvParams:i}}function _qe(e,t){let n=[],{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}=Tqe(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?r("conv0"):a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:o>7?a("conv6"):void 0,conv7:o>8?a("conv7"):void 0,conv8:r("conv8")}}else i={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:r("conv8")};return _d(e,n),{params:i,paramMappings:n}}var LL=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},ZJ=class extends Td{constructor(e){super("TinyYolov2"),Cqe(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,t){let n=tc(e,t.conv0);return n=Yr(n,[2,2],[2,2],"same"),n=tc(n,t.conv1),n=Yr(n,[2,2],[2,2],"same"),n=tc(n,t.conv2),n=Yr(n,[2,2],[2,2],"same"),n=tc(n,t.conv3),n=Yr(n,[2,2],[2,2],"same"),n=tc(n,t.conv4),n=Yr(n,[2,2],[2,2],"same"),n=tc(n,t.conv5),n=Yr(n,[2,2],[1,1],"same"),n=tc(n,t.conv6),n=tc(n,t.conv7),Gx(n,t.conv8,"valid",!1)}runMobilenet(e,t){let n=this.config.isFirstLayerConv2d?ML(Gx(e,t.conv0,"valid",!1)):nc(e,t.conv0);return n=Yr(n,[2,2],[2,2],"same"),n=nc(n,t.conv1),n=Yr(n,[2,2],[2,2],"same"),n=nc(n,t.conv2),n=Yr(n,[2,2],[2,2],"same"),n=nc(n,t.conv3),n=Yr(n,[2,2],[2,2],"same"),n=nc(n,t.conv4),n=Yr(n,[2,2],[2,2],"same"),n=nc(n,t.conv5),n=Yr(n,[2,2],[1,1],"same"),n=t.conv6?nc(n,t.conv6):n,n=t.conv7?nc(n,t.conv7):n,Gx(n,t.conv8,"valid",!1)}forwardInput(e,t){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return ue(()=>{let r=Me(e.toBatchTensor(t,!1),"float32");return r=this.config.meanRgb?r1(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,n):this.runTinyYolov2(r,n)})}async forward(e,t){return this.forwardInput(await sa(e),t)}async detect(e,t={}){let{inputSize:n,scoreThreshold:r}=new LL(t),s=await sa(e),a=await this.forwardInput(s,n),i=ue(()=>fr(a)[0].expandDims()),o={width:s.getInputWidth(0),height:s.getInputHeight(0)},l=await this.extractBoxes(i,s.getReshapedInputDimensions(0),r);a.dispose(),i.dispose();let u=l.map(p=>p.box),c=l.map(p=>p.score),d=l.map(p=>p.classScore),h=l.map(p=>this.config.classes[p.label]);return p6e(u.map(p=>p.rescale(n)),c,this.config.iouThreshold,!0).map(p=>new xL(c[p],d[p],h[p],u[p],o))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return _qe(e,this.config)}extractParams(e){let t=this.config.filterSizes||ZJ.DEFAULT_FILTER_SIZES,n=t?t.length:void 0;if(n!==7&&n!==8&&n!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${n} filterSizes in config`);return $qe(e,this.config,this.boxEncodingSize,t)}async extractBoxes(e,t,n){let{width:r,height:s}=t,a=Math.max(r,s),i=a/r,o=a/s,l=e.shape[1],u=this.config.anchors.length,[c,d,h]=ue(()=>{let g=e.reshape([l,l,u,this.boxEncodingSize]),y=g.slice([0,0,0,0],[l,l,u,4]),b=g.slice([0,0,0,4],[l,l,u,1]),x=this.withClassScores?kd(g.slice([0,0,0,5],[l,l,u,this.config.classes.length]),3):mt(0);return[y,b,x]}),p=[],f=await d.array(),m=await c.array();for(let g=0;g<l;g++)for(let y=0;y<l;y++)for(let b=0;b<u;b++){let x=b_(f[g][y][b][0]);if(!n||x>n){let w=(y+b_(m[g][y][b][0]))/l*i,v=(g+b_(m[g][y][b][1]))/l*o,k=Math.exp(m[g][y][b][2])*this.config.anchors[b].x/l*i,I=Math.exp(m[g][y][b][3])*this.config.anchors[b].y/l*o,S=w-k/2,$=v-I/2,N={row:g,col:y,anchor:b},{classScore:T,label:C}=this.withClassScores?await this.extractPredictedClass(h,N):{classScore:1,label:0};p.push({box:new xJ(S,$,S+k,$+I),score:x,classScore:x*T,label:C,...N})}}return c.dispose(),d.dispose(),h.dispose(),p}async extractPredictedClass(e,t){let{row:n,col:r,anchor:s}=t,a=await e.array();return Array(this.config.classes.length).fill(0).map((i,o)=>a[n][r][s][o]).map((i,o)=>({classScore:i,label:o})).reduce((i,o)=>i.classScore>o.classScore?i:o)}},PL=ZJ;PL.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var Eqe=class extends PL{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:xqe,classes:["face"],...e?{anchors:vqe,meanRgb:kqe}:{anchors:wqe,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new _i(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?Sqe:Iqe}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},v2=class extends LL{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},a1=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function k2(e,t,n,r,s=({alignedRect:a})=>a){let a=e.map(l=>DL(l)?s(l):l.detection),i=r||(t instanceof Tt?await NL(t,a):await CL(t,a)),o=await n(i);return i.forEach(l=>l instanceof Tt&&l.dispose()),o}async function zL(e,t,n,r,s){return k2([e],t,async a=>n(a[0]),r,s)}var Aqe=.4,Rqe=[new nn(1.603231,2.094468),new nn(6.041143,7.080126),new nn(2.882459,3.518061),new nn(4.266906,5.178857),new nn(9.041765,10.66308)],Dqe=[117.001,114.697,97.404],Fqe=class extends PL{constructor(){let e={withSeparableConvs:!0,iouThreshold:Aqe,classes:["face"],anchors:Rqe,meanRgb:Dqe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new _i(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},wn={ssdMobilenetv1:new bqe,tinyFaceDetector:new Fqe,tinyYolov2:new Eqe,faceLandmark68Net:new j6e,faceLandmark68TinyNet:new Y6e,faceRecognitionNet:new rqe,faceExpressionNet:new A6e,ageGenderNet:new H6e},JJ=class extends a1{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},BL=class extends JJ{async run(){let e=await this.parentTask,t=await k2(e,this.input,async n=>Promise.all(n.map(r=>wn.faceExpressionNet.predictExpressions(r))),this.extractedFaces);return e.map((n,r)=>WJ(n,t[r]))}withAgeAndGender(){return new GL(this,this.input)}},WL=class extends JJ{async run(){let e=await this.parentTask;if(!e)return;let t=await zL(e,this.input,n=>wn.faceExpressionNet.predictExpressions(n),this.extractedFaces);return WJ(e,t)}withAgeAndGender(){return new HL(this,this.input)}},VL=class extends BL{withAgeAndGender(){return new jL(this,this.input)}withFaceDescriptors(){return new KL(this,this.input)}},UL=class extends WL{withAgeAndGender(){return new qL(this,this.input)}withFaceDescriptor(){return new XL(this,this.input)}},QJ=class extends a1{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},GL=class extends QJ{async run(){let e=await this.parentTask,t=await k2(e,this.input,async n=>Promise.all(n.map(r=>wn.ageGenderNet.predictAgeAndGender(r))),this.extractedFaces);return e.map((n,r)=>{let{age:s,gender:a,genderProbability:i}=t[r];return XJ(YJ(n,a,i),s)})}withFaceExpressions(){return new BL(this,this.input)}},HL=class extends QJ{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await zL(e,this.input,s=>wn.ageGenderNet.predictAgeAndGender(s),this.extractedFaces);return XJ(YJ(e,n,r),t)}withFaceExpressions(){return new WL(this,this.input)}},jL=class extends GL{withFaceExpressions(){return new VL(this,this.input)}withFaceDescriptors(){return new KL(this,this.input)}},qL=class extends HL{withFaceExpressions(){return new UL(this,this.input)}withFaceDescriptor(){return new XL(this,this.input)}},eQ=class extends a1{constructor(e,t){super(),this.parentTask=e,this.input=t}},KL=class extends eQ{async run(){let e=await this.parentTask;return(await k2(e,this.input,t=>Promise.all(t.map(n=>wn.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>KJ(e[n],t))}withFaceExpressions(){return new VL(this,this.input)}withAgeAndGender(){return new jL(this,this.input)}},XL=class extends eQ{async run(){let e=await this.parentTask;if(!e)return;let t=await zL(e,this.input,n=>wn.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return KJ(e,t)}withFaceExpressions(){return new UL(this,this.input)}withAgeAndGender(){return new qL(this,this.input)}},tQ=class extends a1{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?wn.faceLandmark68TinyNet:wn.faceLandmark68Net}},Oqe=class extends tQ{async run(){let e=await this.parentTask,t=e.map(s=>s.detection),n=this.input instanceof Tt?await NL(this.input,t):await CL(this.input,t),r=await Promise.all(n.map(s=>this.landmarkNet.detectLandmarks(s)));return n.forEach(s=>s instanceof Tt&&s.dispose()),e.filter((s,a)=>r[a]).map((s,a)=>FL(s,r[a]))}withFaceExpressions(){return new VL(this,this.input)}withAgeAndGender(){return new jL(this,this.input)}withFaceDescriptors(){return new KL(this,this.input)}},Mqe=class extends tQ{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof Tt?await NL(this.input,[t]):await CL(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(s=>s instanceof Tt&&s.dispose()),FL(e,r)}withFaceExpressions(){return new UL(this,this.input)}withAgeAndGender(){return new qL(this,this.input)}withFaceDescriptor(){return new XL(this,this.input)}},nQ=class extends a1{constructor(e,t=new s1){super(),this.input=e,this.options=t}},rQ=class extends nQ{async run(){let{input:e,options:t}=this,n;if(t instanceof v2)n=wn.tinyFaceDetector.locateFaces(e,t);else if(t instanceof s1)n=wn.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof LL)n=wn.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(r=>SS({},r)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new Oqe(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new BL(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new GL(this.runAndExtendWithFaceDetections(),this.input)}},Lqe=class extends nQ{async run(){let e=await new rQ(this.input,this.options),t=e[0];return e.forEach(n=>{n.score>t.score&&(t=n)}),t}runAndExtendWithFaceDetection(){return new Promise(async e=>{let t=await this.run();e(t?SS({},t):void 0)})}withFaceLandmarks(e=!1){return new Mqe(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new WL(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new HL(this.runAndExtendWithFaceDetection(),this.input)}};function YL(e,t=new s1){return new Lqe(e,t)}function ZL(e,t=new s1){return new rQ(e,t)}function Pqe(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),r=Array.from(t);return Math.sqrt(n.map((s,a)=>s-r[a]).reduce((s,a)=>s+a*a,0))}var I2=class{constructor(e,t=.6){this._distanceThreshold=t;let n=Array.isArray(e)?e:[e];if(!n.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let r=1,s=()=>`person ${r++}`;this._labeledDescriptors=n.map(a=>{if(a instanceof xc)return a;if(a instanceof Float32Array)return new xc(s(),[a]);if(a.descriptor&&a.descriptor instanceof Float32Array)return new xc(s(),[a.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")})}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(e,t){return t.map(n=>Pqe(n,e)).reduce((n,r)=>n+r,0)/(t.length||1)}matchDescriptor(e){return this.labeledDescriptors.map(({descriptors:t,label:n})=>new PU(n,this.computeMeanDistance(e,t))).reduce((t,n)=>t.distance<n.distance?t:n)}findBestMatch(e){let t=this.matchDescriptor(e);return t.distance<this._distanceThreshold?t:new PU("unknown",t.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map(e=>e.toJSON())}}static fromJSON(e){let t=e.labeledDescriptors.map(n=>xc.fromJSON(n));return new I2(t,e.distanceThreshold)}};function S2(e,t){let{width:n,height:r}=new Oc(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map(s=>S2(s,{width:n,height:r}));if(DL(e)){let s=e.detection.forSize(n,r),a=e.unshiftedLandmarks.forSize(s.box.width,s.box.height);return FL(SS(e,s),a)}return A0(e)?SS(e,e.detection.forSize(n,r)):e instanceof E0||e instanceof _i?e.forSize(n,r):e}const zqe=({returnResult:e,lang:t})=>{const n=fn(t),[r,s]=J.useState(!1),[a,i]=J.useState(!1),[o,l]=J.useState([]),[u,c]=J.useState("default"),[d,h]=J.useState(!0),p=J.useRef(null),f=340,m=420,g=J.useRef(null),y=J.useRef(null);J.useEffect(()=>{(async()=>{const S=un.FACES_MODELS_URL;Promise.all([wn.tinyFaceDetector.loadFromUri(S),wn.faceLandmark68Net.loadFromUri(S),wn.faceRecognitionNet.loadFromUri(S),wn.faceExpressionNet.loadFromUri(S),wn.ageGenderNet.loadFromUri(S),wn.ssdMobilenetv1.loadFromUri(S)]).then(async()=>{s(!0);const $="SELECT id, CONVERT(img1 USING utf8) as img1, CONVERT(img2 USING utf8) as img2, CONVERT(img3 USING utf8) as img3, username,  date FROM face_img_storage";await it.post(Ye.custom_query.get,{query:$}).then(N=>{l(N.data)})})})()},[]);const b=()=>{i(!0)},x=async()=>{if(typeof p.current<"u"&&p.current!==null&&p.current.video){const I=Object.keys(o);return Promise.all(I.map(async S=>{let $=[];const N=o[S];for(let T=1;T==1;T++){const C=N[`img${T}`],E=await $L(C),M=await YL(E).withFaceLandmarks().withFaceDescriptor();$.push(M==null?void 0:M.descriptor)}if(typeof $<"u")return new xc(N.username,$)}))}},w=async()=>{if(typeof p.current<"u"&&p.current!==null&&p.current.video){const I=await x(),S=new I2(I),$={width:m,height:f};TL(g.current,$),h(!1),setInterval(async()=>{var N;if((N=p.current)!=null&&N.video){const T=await ZL(p.current.video,new v2).withFaceLandmarks().withFaceDescriptors(),C=S2(T,$);g&&g.current&&g.current.getContext("2d").clearRect(0,0,m,f),g&&g.current&&Ll.drawDetections(g.current,C),g&&g.current&&Ll.drawFaceLandmarks(g.current,C),C.map(M=>S.findBestMatch(M.descriptor)).forEach(async(M,F)=>{const z=C[F].detection.box,H=new Ll.DrawBox(z,{label:M});await v(H),H.draw(g.current)})}},100)}},v=async I=>{Object.keys(o).map(async $=>{o[$].username==await I.options.label._label&&e({result:"Login",userName:o[$].username})})};J.useMemo(()=>{if(a){const I=setInterval(()=>{typeof p.current<"u"&&p.current!==null&&p.current.video&&(clearInterval(I),w())},100)}},[a]);const k=()=>{if(u=="startLogin")return K("div",{children:[D(Wqe,{}),K(Vqe,{children:[K(Bqe,{children:[K("div",{style:{display:"flex",justifyContent:"center",padding:"10px"},children:[D(Mh,{ref:p,height:f,width:m,style:{borderRadius:"10px"}}),D("canvas",{ref:g,style:{position:"absolute"}})]}),d&&D(hce,{})]}),!d&&D(Ue,{style:{float:"right",backgroundColor:"black"},onClick:()=>{c("")},id:"close",children:n.common.close})]})]})};return K("div",{style:{display:"flex",flexDirection:"column"},children:[K("div",{style:{textAlign:"center",display:o[0]?"flex":"none",justifyItems:"center",flexDirection:"column"},children:[n.common.or,D(Ue,{onClick:()=>{b(),c("startLogin")},children:n.login_form.button_scan})]}),a?r?D("div",{children:k()}):D("div",{children:"loading..."}):D(wD,{children:"  "}),D("canvas",{style:{width:640,height:480,margin:5,display:"none"},ref:y})]})},Bqe=pe.div.withConfig({displayName:"Container",componentId:"sc-mgdmyw-0"})([""]),Wqe=pe.div.withConfig({displayName:"Shade",componentId:"sc-mgdmyw-1"})(["display:block;position:fixed;z-index:100;top:0;left:0;width:100%;height:100%;background:black;opacity:0.5;filter:alpha(opacity=50);"]),Vqe=pe.div.withConfig({displayName:"Modal",componentId:"sc-mgdmyw-2"})(["display:block;position:fixed;z-index:101;top:10%;left:center;"]),Uqe=({result:e,lang:t})=>{const n=fn(t),[r,s]=J.useState("limon"),[a,i]=J.useState("limon"),[o,l]=J.useState("limon"),[u,c]=J.useState(!1),d=m=>{const{id:g,value:y}=m.target;g==="username"&&s(y),g==="password"&&i(y)},h=async()=>{const m=`select password, username from account_credentials where username='${r}'`;await it.post(Ye.custom_query.get,{query:m}).then(g=>{typeof g.data[0]<"u"?g.data[0].password==a&&g.data[0].username==r?(c(!0),l("none"),e({result:"Login",userName:g.data[0].username})):(l("wrongPassword"),c(!1)):(l("wrongUsername"),c(!1))}).catch(g=>{console.log("send status :(",g)})},p=()=>D("div",{style:{display:u?"":"none"},children:D("h1",{children:n.login_form.succes_login})}),f=()=>K("div",{children:[K("div",{style:{display:o=="wrongPassword"?"":"none"},children:["    ",D("h3",{children:n.login_form.warn_wrong_pass}),"   "]}),K("div",{style:{display:o=="wrongUsername"?"":"none"},children:["    ",D("h3",{children:n.login_form.warn_wrong_username}),"   "]})]});return D(Gqe,{className:"form",children:D(vo,{children:K(Hqe,{children:[D(v_,{children:D("h1",{children:n.login_form.header})}),K(v_,{children:[K("label",{children:[n.login_form.username," "]}),D(WU,{style:{borderColor:o=="wrongUsername"?"red":""},type:"text",id:"username",onChange:m=>d(m),placeholder:n.login_form.username})]}),K(v_,{children:[D("label",{children:n.login_form.password}),D(WU,{style:{borderColor:o=="wrongPassword"?"red":""},className:"form__input",type:"password",id:"password",onChange:m=>d(m),placeholder:n.login_form.password})]}),f(),p(),D("div",{children:D(Ue,{onClick:()=>h(),type:"submit",children:n.login_form.button_sign_in})}),D(zqe,{lang:t,returnResult:m=>{e(m)}})]})})})},Gqe=pe.div.withConfig({displayName:"Container",componentId:"sc-h5xmul-0"})(["padding:0 15px;margin:5px;display:flex;flex-direction:column;align-items:center;justify-content:center;position:absolute;top:20%;z-index:4;width:100%;"]),WU=pe.input.withConfig({displayName:"Input",componentId:"sc-h5xmul-1"})(["background-color:",";width:60%;color:",";height:30px;::placeholder{color:gray}border-radius:10px;border:1px solid;border-color:rgba(255,255,255,.35);"],({theme:e})=>e.colors.foreground,({theme:e})=>e.colors.typography),Hqe=pe.div.withConfig({displayName:"TableContainer",componentId:"sc-h5xmul-2"})(["border:1px solid;border-color:rgba(255,255,255,.55);border-radius:10px;justify-content:center;border-radius:5px;width:550px;margin:20px auto;padding:20px;"]),v_=pe.div.withConfig({displayName:"Cell",componentId:"sc-h5xmul-3"})(["padding:5px;display:flex;flex-direction:row;justify-content:space-between;"]),jqe=({lang:e})=>{const t=fn(e);return D(qqe,{children:K(Xqe,{children:[D(Yqe,{}),K(Kqe,{children:[D(xk,{children:t.about_page.text_1}),D(xk,{children:t.about_page.text_2}),D(xk,{children:t.about_page.text_3}),D(xk,{children:t.about_page.text_4})]})]})})},qqe=pe.div.withConfig({displayName:"Container",componentId:"sc-nx5e17-0"})(["padding:0 15px;margin:5px;display:flex;flex-direction:column;align-items:center;justify-content:center;position:absolute;top:20%;z-index:4;width:100%;"]);pe.input.withConfig({displayName:"Input",componentId:"sc-nx5e17-1"})(["background-color:",";width:60%;color:",";height:30px;::placeholder{color:gray}border-radius:10px;border:1px solid;border-color:rgba(255,255,255,.35);"],({theme:e})=>e.colors.foreground,({theme:e})=>e.colors.typography);const Kqe=pe.div.withConfig({displayName:"TableContainer",componentId:"sc-nx5e17-2"})(["justify-content:center;border-radius:5px;width:80%;margin:20px auto;padding:20px;position:absolute;top:0;left:0;width:100%;height:100%;"]),Xqe=pe.div.withConfig({displayName:"RelativeContainer",componentId:"sc-nx5e17-3"})(["position:relative;border:1px solid;border-color:rgba(255,255,255,.55);border-radius:10px;top:20%;width:80%;height:350px;"]),Yqe=pe.div.withConfig({displayName:"BackgroundDiv",componentId:"sc-nx5e17-4"})(["position:absolute;top:0;left:0;height:100%;width:100%;background-color:black;opacity:30%;border-radius:10px;"]),xk=pe.h3.withConfig({displayName:"Text",componentId:"sc-nx5e17-5"})(["opacity:100%;"]),Zqe=({choosenWeb:e,language:t})=>{const[n,r]=J.useState("Start"),[s,a]=J.useState("en"),i=fn(s);return K(Jqe,{image_url:un.GALAXY_START_IMAGE,children:[D($ce,{language:o=>{t(o),a(o)},insideChoice:o=>{r(o)},choosenWeb:o=>{e(o)}}),n=="Start"&&D(Qqe,{children:K("div",{style:{margin:"20px"},children:[D("h1",{children:i.start_page.welcome_text_1}),D(VU,{children:i.start_page.welcome_text_2}),D(VU,{children:i.start_page.welcome_text_3})]})}),K("div",{className:"circles",style:{position:"absolute"},children:[D("div",{}),D("div",{}),D("div",{}),D("div",{}),D("div",{}),D("div",{}),D("div",{}),D("div",{}),D("div",{}),D("div",{})]}),n=="Register"&&D(Hde,{lang:s,result:o=>{e(o)}}),n=="Login"&&D(Uqe,{lang:s,result:o=>{e(o)}}),n=="AboutPage"&&D(jqe,{lang:s}),D(wce,{lang:s})]})},Jqe=pe.div.withConfig({displayName:"Container",componentId:"sc-bxp06q-0"})(["background-image:url(",");width:100%;height:100vh;background-size:cover;display:flex;flex-direction:column;justify-content:space-between;z-index:1;overflow-wrap:normal;"],e=>e.image_url),VU=pe.h3.withConfig({displayName:"H2s",componentId:"sc-bxp06q-1"})(["width:50%;"]),Qqe=pe.div.withConfig({displayName:"ContainerMain",componentId:"sc-bxp06q-2"})(["position:absolute;width:70%;top:20%;display:flex;flex-direction:row;align-items:center;justify-content:center;"]);pe.div.withConfig({displayName:"Containerr",componentId:"sc-bxp06q-3"})(["display:flex;flex-direction:column;align-items:center;justify-content:center;"]);const e8e=({choosenWeb:e,userName:t,lang:n})=>{const r=fn(n),[s,a]=J.useState(),[i,o]=J.useState(),l=J.useRef(null),u=J.useRef(null);J.useEffect(()=>{c()},[]);const c=async()=>{const f=`select CONVERT(img1 USING utf8) as img1 from face_img_storage where username='${t}'`;await it.post(Ye.custom_query.get,{query:f}).then(m=>{a(m.data[0].img1)}).catch(m=>{console.log("send status :(",m)})},d=()=>{o(K("div",{children:[D(i8e,{ref:l,onClick:p}),K(o8e,{ref:u,children:[K(jd,{onClick:()=>{e("UserProfile"),p()},children:["  ",D(um,{src:un.USER_IMAGE_MENU,alt:""}),"   ",r.dashboard_header.dropdown_profile," "]}),K(jd,{onClick:()=>{e("RegisterFaceRecognition"),p()},children:[" ",D(um,{src:un.FACEID_IMAGR,alt:""}),"  ",r.dashboard_header.dropdown_faceid]}),K(jd,{onClick:()=>{e("UserIonAnalysis"),p()},children:[" ",D(um,{src:un.ION_ANNALYS_IMAGE,alt:""}),r.dashboard_header.dropdown_ion]}),K(jd,{onClick:()=>{e("UserPHAnalysis"),p()},children:[" ",D(um,{src:un.PH_ANALYS_IMAGE,alt:""}),r.dashboard_header.dropdown_ph]}),K(jd,{onClick:()=>{e("UserHelp"),p()},children:[" ",D(um,{src:un.HELP_IMAGE,alt:""}),r.dashboard_header.dropdown_help]}),K(jd,{onClick:()=>{e("UserSettings"),p()},children:[" ",D(um,{src:un.SETTINGS_IMAGE,alt:""}),r.dashboard_header.dropdown_Settings]}),D(jd,{onClick:()=>{location.reload(),p()},children:r.dashboard_header.dropdown_signout})]})]})),l.current.style.display=u.current.style.display="flex"},h=()=>i,p=()=>{l.current.style.display=u.current.style.display="none"};return K(t8e,{children:[K(n8e,{children:[D(s8e,{onClick:()=>{e("Start")},children:D(r8e,{children:r.components.header.title})}),D("img",{src:un.LOGO_URL,alt:"",height:25,width:25})]}),K(UU,{children:[K(Ue,{onClick:()=>{e("Analysis")},children:[r.dashboard_header.analysis," "]}),K(Ue,{onClick:()=>{e("pH")},children:[" ",r.dashboard_header.ph,"  "]}),K(Ue,{onClick:()=>{e("DataBase")},children:[" ",r.dashboard_header.database,"  "]}),K(Ue,{onClick:()=>{e("FaceRecognition")},children:[" ",r.dashboard_header.face_recognition,"  "]}),K(Ue,{onClick:()=>{e("Screenshot")},children:[" ",r.dashboard_header.others,"  "]})]}),K(UU,{children:[K("div",{children:[r.dashboard_header.user_id," ",t]}),D(a8e,{onClick:()=>{d()},src:s||un.USER_IMG_URL,alt:""}),"      ",h()]})]})},t8e=pe.div.withConfig({displayName:"HeaderContainer",componentId:"sc-1uut8jc-0"})(["height:60px;padding:0 15px;display:flex;flex-direction:row;align-items:center;justify-content:space-between;"]),n8e=pe.div.withConfig({displayName:"LogoContainer",componentId:"sc-1uut8jc-1"})(["display:flex;flex-direction:row;align-items:center;"]),r8e=pe.h1.withConfig({displayName:"Title",componentId:"sc-1uut8jc-2"})(["display:inline;font-size:20px;color:",";"],({theme:e})=>e.colors.typography),UU=pe.div.withConfig({displayName:"LinkContainer",componentId:"sc-1uut8jc-3"})(["display:flex;flex-direction:row;align-items:center;"]),s8e=pe.a.withConfig({displayName:"Linkos",componentId:"sc-1uut8jc-4"})(["color:",";text-decoration:underline;cursor:pointer;padding:0 10px;text-decoration:none;"],({theme:e})=>e.colors.typography),a8e=pe.img.withConfig({displayName:"UserImage",componentId:"sc-1uut8jc-5"})(["cursor:pointer;background-color:rgb(200,214,229);border-radius:15px;margin:10px;height:30px;width:30px;"]),um=pe.img.withConfig({displayName:"CustomImage",componentId:"sc-1uut8jc-6"})(["cursor:pointer;zoom:0.5;height:40px;width:40px;"]),i8e=pe.div.withConfig({displayName:"Shade",componentId:"sc-1uut8jc-7"})(["display:block;position:fixed;z-index:100;top:0;left:0;width:100%;height:100%;background:rgba(110,118,129,0.4);filter:alpha(opacity=50);"]),o8e=pe.div.withConfig({displayName:"Modal",componentId:"sc-1uut8jc-8"})(["display:flex;flex-direction:column;background-color:#282728;position:absolute;z-index:101;top:10%;right:5px;width:200px;"]),jd=pe(Ue).withConfig({displayName:"MenuButton",componentId:"sc-1uut8jc-9"})(["display:flex;justify-content:space-between;justify-items:center;flex-direction:row;z-index:101;background-color:black;margin:2px;"]),sR=({rout_name:e,lang:t,user:n,userName:r})=>{const s=fn(t),[a,i]=J.useState([]),[o,l]=J.useState(!1),[u,c]=J.useState(!1),[d,h]=J.useState(1),[p,f]=J.useState(),m=()=>{h(Math.random())},g=e=="cation_analysis_result"?"cation_analysis_result":"anion_analysis_result",y=e=="cation_analysis_result"?s.databse.cation_analysis:s.databse.anion_analisys,b=["id","name"],x=e=="cation_analysis_result"?["Stage 1","Stage 2","Stage 3","Stage 4","Stage 5","Stage 6","Stage 7"]:["Stage 1","Stage 2","Stage 3","Stage 4"],w=e=="cation_analysis_result"?["f1","f2","f3","f4","f5","f6","f7"]:["f1","f2","f3","f4"],v=e=="cation_analysis_result"?["img1","img2","img3","img4","img5","img6","img7"]:["img1","img2","img3","img4"],k=["end","result"],I=b.concat(["user"].concat(x.concat(v.concat(k))));J.useEffect(()=>{S()},[]);const S=()=>{it.get(e=="cation_analysis_result"?Ye.cation_analysis_result.get:Ye.anion_analysis_result.get).then(E=>{i(E.data)}).then(()=>{m()}).catch(E=>{console.log("db status :(",E)})},$=E=>{it.delete(Ye[e].delete+`/${E}`).then(M=>{S()}).then(()=>{m()}).catch(M=>{console.log(M)})},N=()=>{if(confirm(s.databse.all_data_del_confirm)){const E=`DELETE FROM ${g}`;it.post(Ye.custom_query.get,{query:E}).then(()=>{S()}).then(()=>{m()}).catch(M=>{console.log("db status :(",M)})}},T=E=>{f(K(wF,{children:[" ",D("img",{width:640,height:480,src:E})," "]})),m()},C=()=>p;return J.useMemo(()=>{a.length&&m()},[a]),K(vo,{children:[D(vk,{style:{display:n?"none":"block"},children:D(Ue,{onClick:N,children:s.databse.clear_all_bt})}),!u&&a.length&&D(vk,{children:K(vk,{children:[K(vk,{children:[y," "]}),K(co,{children:[C(),D("table",{style:{tableLayout:"fixed"},children:K("tbody",{children:[D(Yo,{children:I.map((E,M)=>D(l8e,{children:E},M))}),a.slice(0).reverse().map((E,M)=>{if(n){if(E.user_id==r)return K("tr",{children:[b.map((F,z)=>D(rc,{children:E[F]},z)),D(rc,{children:E.user_id}),w.map((F,z)=>D(rc,{children:s.analysis_results_names[E[F]]},z)),v.map((F,z)=>E[F]!=null?K(bi,{children:["  ",D(Uo,{onClick:()=>{T(E[F])},src:E[F]})]},z):D(bi,{style:{cursor:"auto"}},z)),k.map((F,z)=>D(rc,{style:{background:E[F]=="success"?"#618685":E[F]=="fail"?"#c44569":"none"},children:E[F]},z)),!o&&D(wk,{style:{cursor:"pointer",display:n?"none":"block"},onClick:()=>{l(!0)},children:D(Jo,{children:D(Qo,{src:un.EDIT_BTN_IMG})})}),o&&D(wk,{onClick:()=>{$(E.id)},children:D(Zo,{children:s.databse.remove_bt})})]},M)}else return K("tr",{children:[b.map((F,z)=>D(rc,{children:E[F]},z)),D(rc,{children:E.user_id}),w.map((F,z)=>D(rc,{children:s.analysis_results_names[E[F]]},z)),v.map((F,z)=>E[F]!=null?K(bi,{children:["  ",D(Uo,{onClick:()=>{T(E[F])},src:E[F]})]},z):D(bi,{style:{cursor:"auto"}},z)),k.map((F,z)=>D(rc,{style:{background:E[F]=="success"?"#618685":E[F]=="fail"?"#c44569":"none"},children:E[F]},z)),!o&&D(wk,{style:{cursor:"pointer",display:n?"none":"block"},onClick:()=>{l(!0)},children:D(Jo,{children:D(Qo,{src:un.EDIT_BTN_IMG})})}),o&&D(wk,{onClick:()=>{$(E.id)},children:D(Zo,{children:s.databse.remove_bt})})]},M)})]})})]},d)]})},d)]})},rc=pe.td.withConfig({displayName:"Td",componentId:"sc-18y4k4e-0"})(["border:1px solid gray;justify-content:center;text-align:center;word-wrap:break-word;"]),wk=pe.td.withConfig({displayName:"Td_container",componentId:"sc-18y4k4e-1"})(["justify-content:center;text-align:center;"]),l8e=pe.th.withConfig({displayName:"Th",componentId:"sc-18y4k4e-2"})(["border:1px solid gray;justify-content:center;"]),vk=pe.div.withConfig({displayName:"Container",componentId:"sc-18y4k4e-3"})([" "]),GU=({rout_name:e,lang:t})=>{const n=fn(t),[r,s]=J.useState(),[a,i]=J.useState([]),[o,l]=J.useState(!1),[u,c]=J.useState(),[d,h]=J.useState(),[p,f]=J.useState(),[m,g]=J.useState(),[y,b]=J.useState(),[x,w]=J.useState(),[v,k]=J.useState(),[I,S]=J.useState(1),[$,N]=J.useState("start"),T=()=>{S(Math.random())},C=e=="cation_voice_script"?n.databse.cation_voicescript:n.databse.anion_voicescript,E=["id","phase","f6","f7","match_id","script"],M=[h,g,b,w,k,f],F=t=="EN"?e=="anion_voice_script"?Ye.anion_voice_script_en.get:Ye.cation_voice_script_en.get:e=="anion_voice_script"?Ye.anion_voice_script.get:Ye.cation_voice_script.get,z=t=="EN"?e=="anion_voice_script"?Ye.anion_voice_script_en.put:Ye.cation_voice_script_en.put:e=="anion_voice_script"?Ye.anion_voice_script.put:Ye.cation_voice_script.put;J.useEffect(()=>{H()},[]);const H=async()=>{await it.get(F).then(B=>{i(B.data)}).catch(B=>{console.log("db status :(",B)})},P=async B=>{const X=a[B-1];M.map((ee,Z)=>{ee(X[E[Z]])}),c(B)},O=B=>{it.put(z,{id:B,phase:m,script:p,f6:y,f7:x,match_id:v}).then(X=>{H()}).then(()=>{T()}).then(()=>{M.map(X=>{X(void 0)})}).catch(X=>{console.log(X)})},L=async()=>{it.post(Ye[e].post,{id:d,phase:m,script:p,f6:y,f7:x,match_id:v}).then(B=>{H()}).then(()=>{T()}).then(()=>{M.map(B=>{B(void 0)})}).catch(B=>{console.log(B)}),M.map(B=>{B(void 0)})},V=B=>{},q=()=>{if($=="start")return K(su,{children:[D(su,{children:C}),D(co,{children:D("table",{children:K("tbody",{children:[D(Yo,{children:E.map((B,X)=>D(c8e,{children:B},X))}),a.slice(0).reverse().map(B=>K("tr",{children:[E.map((X,ee)=>D(u8e,{children:B[X]},ee)),D(k_,{style:{cursor:"pointer",display:r==`${B.id}`?"none":"block"},onClick:()=>{s(B.id)},children:D(Jo,{children:D(Qo,{src:un.EDIT_BTN_IMG})})}),D(k_,{style:{display:r==`${B.id}`?"flex":"none"},onClick:()=>{V(B.id)},children:D(Zo,{children:n.databse.remove_bt})}),D(k_,{style:{display:r==`${B.id}`?"flex":"none"},onClick:()=>{l(!0),P(B.id),N("modify")},children:D(BC,{children:n.databse.mod_bt})})]},B.id))]})})},I)]});if($=="add")return K(su,{children:[D(su,{children:E.map((B,X)=>K(su,{children:[D("label",{children:E[X]}),D("input",{style:{backgroundColor:"gray"},type:"text",name:E[X],onChange:ee=>{M[X](ee.target.value)}})]},X))}),D(Ue,{onClick:()=>{L(),N("start")},children:n.databse.submit_bt}),D(Ue,{onClick:()=>{N("start")},children:n.common.back})]},I+1);if($=="modify"&&u)return K(su,{children:[n.databse.entry_modification," ",u,D(su,{children:E.map((B,X)=>K(su,{children:[D("label",{children:E[X]}),D("input",{onClick:()=>{M[X](a[u-1][B])},defaultValue:a[u-1][B],style:{backgroundColor:"gray"},type:"text",name:E[X],onChange:ee=>{M[X](ee.target.value)}})]},X))}),D(Ue,{onClick:()=>{l(!o),O(u),T(),N("start")},children:n.databse.update_data}),D(Ue,{onClick:()=>{l(!o),N("start")},children:n.common.back})]})};return K(vo,{children:[D(su,{children:D(Ue,{style:{display:$=="start"?"block":"none"},onClick:()=>{N("add")},children:n.databse.add_new})}),q()]},I)},u8e=pe.td.withConfig({displayName:"Td",componentId:"sc-16qx7dd-0"})(["border:1px solid gray;justify-content:center;text-align:center;"]),k_=pe.td.withConfig({displayName:"Td_container",componentId:"sc-16qx7dd-1"})(["justify-content:center;text-align:center;"]),c8e=pe.th.withConfig({displayName:"Th",componentId:"sc-16qx7dd-2"})(["border:1px solid gray;justify-content:center;"]),su=pe.div.withConfig({displayName:"Container",componentId:"sc-16qx7dd-3"})([" "]),HU=({rout_name:e,lang:t})=>{const n=fn(t),[r,s]=J.useState(),[a,i]=J.useState([]),[o,l]=J.useState(!1),[u,c]=J.useState(),[d,h]=J.useState(),[p,f]=J.useState(),[m,g]=J.useState(),[y,b]=J.useState(),[x,w]=J.useState(),[v,k]=J.useState(),[I,S]=J.useState(),[$,N]=J.useState(),[T,C]=J.useState(),[E,M]=J.useState(1),[F,z]=J.useState("start"),H=()=>{M(Math.random())},P=["id","symbol"],O=e=="cation_script_flow"?n.databse.cation_scriptflow:n.databse.anion_scriptflow,L=e=="cation_script_flow"?["f1","f2","f3","f4","f5","f6","f7"]:["f1","f2","f3","f4"],V=e=="cation_script_flow"?[h,f,g,b,w,k,S,N,C]:[h,f,g,b,w,k],q=P.concat(L);J.useEffect(()=>{B()},[]);const B=async()=>{await it.get(e=="anion_script_flow"?Ye.anion_script_flow.get:Ye.cation_script_flow.get).then(Q=>{i(Q.data)}).catch(Q=>{console.log("db status :(",Q)})},X=async Q=>{const be=a[Q-1];V.map((we,Ne)=>{we(be[L[Ne]])}),c(Q)},ee=async()=>{it.post(Ye[e].post,e=="cation_script_flow"?{id:d,symbol:p,f1:m,f2:y,f3:x,f4:v,f5:I,f6:$,f7:T}:{id:d,symbol:p,f1:m,f2:y,f3:x,f4:v}).then(Q=>{B()}).then(()=>{H()}).then(()=>{V.map(Q=>{Q(void 0)})}).catch(Q=>{console.log(Q)}),V.map(Q=>{Q(void 0)})},Z=Q=>{},fe=()=>{if(F=="start")return K(au,{children:[K(au,{children:[O," "]}),D(co,{children:D("table",{style:{tableLayout:"fixed"},children:K("tbody",{children:[D(Yo,{children:q.map((Q,be)=>D(d8e,{children:Q},be))}),a.slice(0).reverse().map(Q=>K("tr",{children:[P.map((be,we)=>D(jU,{children:Q[be]},we)),L.map((be,we)=>D(jU,{children:n.analysis_results_names[Q[be]]},we)),D(I_,{style:{cursor:"pointer",display:r==`${Q.id}`?"none":"block"},onClick:()=>{s(Q.id)},children:D(Jo,{children:D(Qo,{src:un.EDIT_BTN_IMG})})}),D(I_,{style:{display:r==`${Q.id}`?"flex":"none"},onClick:()=>{l(!0),X(Q.id),z("modify")},children:D(BC,{children:n.databse.mod_bt})}),D(I_,{style:{display:r==`${Q.id}`?"flex":"none"},onClick:()=>{Z(Q.id)},children:D(Zo,{children:n.databse.remove_bt})})]},Q.id))]})})},E)]});if(F=="add")return K(au,{children:[D(au,{children:L.map((Q,be)=>K(au,{children:[D("label",{children:L[be]}),D("input",{style:{backgroundColor:"gray"},type:"text",name:L[be],onChange:we=>{V[be](we.target.value)}})]},be))}),D(Ue,{onClick:()=>{ee(),z("start")},children:n.databse.submit_bt}),D(Ue,{onClick:()=>{z("start")},children:n.common.back})]},E+1);if(F=="modify"&&u)return K(au,{children:[n.databse.entry_modification," ",u,D(au,{children:L.map((Q,be)=>K(au,{children:[D("label",{children:L[be]}),D("input",{onClick:()=>{V[be](a[u-1][Q])},defaultValue:a[u-1][Q],style:{backgroundColor:"gray"},type:"text",name:L[be],onChange:we=>{V[be](we.target.value)}})]},be))}),D(Ue,{onClick:()=>{l(!o),H(),z("start")},children:n.databse.update_data}),D(Ue,{onClick:()=>{l(!o),z("start")},children:n.common.back})]})};return K(vo,{children:[D(au,{children:D(Ue,{style:{display:F=="start"?"block":"none"},onClick:()=>{z("add")},children:n.databse.add_new})}),fe()]},E)},jU=pe.td.withConfig({displayName:"Td",componentId:"sc-1ls3kyc-0"})(["border:1px solid gray;justify-content:center;text-align:center;word-wrap:break-word;"]),I_=pe.td.withConfig({displayName:"Td_container",componentId:"sc-1ls3kyc-1"})(["justify-content:center;text-align:center;"]),d8e=pe.th.withConfig({displayName:"Th",componentId:"sc-1ls3kyc-2"})(["border:1px solid gray;justify-content:center;"]),au=pe.div.withConfig({displayName:"Container",componentId:"sc-1ls3kyc-3"})([" "]),h8e=({lang:e})=>{const t=fn(e),[n,r]=J.useState(),[s,a]=J.useState([]),[i,o]=J.useState(!1),[l,u]=J.useState(),[c,d]=J.useState(),[h,p]=J.useState(),[f,m]=J.useState(),[g,y]=J.useState(1),[b,x]=J.useState("start"),w=()=>{y(Math.random())},v="Test images",k=["id","img","label"],I=[d,p,m];J.useEffect(()=>{S()},[]);const S=async()=>{await it.get(Ye.test_images.get).then(E=>{a(E.data)}).catch(E=>{console.log("db status :(",E)})},$=async E=>{const M=s[E-1];I.map((F,z)=>{F(M[k[z]])}),u(E)},N=async()=>{},T=E=>{},C=()=>{if(b=="start")return K(iu,{children:[K(iu,{children:[v,"  "]}),D(co,{children:D("table",{children:K("tbody",{children:[D(Yo,{children:k.map((E,M)=>D(p8e,{children:E},M))}),s.slice(0).reverse().map(E=>K("tr",{children:[K(S_,{children:[E.id," "]}),D(S_,{children:D(Uo,{style:{height:"150px",width:"150px"},src:E.img})}),K(S_,{children:[t.analysis_results_names[E.label]," "]}),D(C_,{style:{cursor:"pointer",display:n==`${E.id}`?"none":"block"},onClick:()=>{r(E.id)},children:D(Jo,{children:D(Qo,{src:un.EDIT_BTN_IMG})})}),D(C_,{style:{display:n==`${E.id}`?"flex":"none"},onClick:()=>{T(E.id)},children:D(Zo,{children:t.databse.remove_bt})}),D(C_,{style:{display:n==`${E.id}`?"flex":"none"},onClick:()=>{o(!0),$(E.id),x("modify")},children:D(BC,{children:t.databse.mod_bt})})]},E.id))]})})},g)]});if(b=="add")return K(iu,{children:[D(iu,{children:k.map((E,M)=>K(iu,{children:[D("label",{children:k[M]}),D("input",{style:{backgroundColor:"gray"},type:"text",name:k[M],onChange:F=>{I[M](F.target.value)}})]},M))}),D("button",{onClick:()=>{N(),x("start")},children:t.databse.submit_bt}),D("button",{onClick:()=>{x("start")},children:t.common.back})]},g+1);if(b=="modify"&&l)return K(iu,{children:["Modyfikacja wersetu nr: ",l,D(iu,{children:k.map((E,M)=>K(iu,{children:[D("label",{children:k[M]}),D("input",{onClick:()=>{I[M](s[l-1][E])},defaultValue:s[l-1][E],style:{backgroundColor:"gray"},type:"text",name:k[M],onChange:F=>{I[M](F.target.value)}})]},M))}),D("button",{onClick:()=>{o(!i),w(),x("start")},children:"Update data"}),D("button",{onClick:()=>{o(!i),x("start")},children:"Back"})]})};return K(vo,{children:[K(iu,{children:[D(Ue,{style:{display:b=="start"?"block":"none"},onClick:()=>{x("add")},children:"Add new"}),D(Ue,{style:{display:b=="start"?"none":"block"},onClick:()=>{x("start")},children:"Table"})]}),C()]},g)},S_=pe.td.withConfig({displayName:"Td",componentId:"sc-d6vrfa-0"})(["border:1px solid gray;justify-content:center;text-align:center;"]),C_=pe.td.withConfig({displayName:"Td_container",componentId:"sc-d6vrfa-1"})(["justify-content:center;text-align:center;"]),p8e=pe.th.withConfig({displayName:"Th",componentId:"sc-d6vrfa-2"})(["border:1px solid gray;justify-content:center;"]),iu=pe.div.withConfig({displayName:"Container",componentId:"sc-d6vrfa-3"})([" "]),f8e=({rout_name:e,lang:t})=>{const n=fn(t),[r,s]=J.useState([]),[a,i]=J.useState(!1),[o,l]=J.useState(!1),[u,c]=J.useState(1),d=()=>{c(Math.random())};J.useEffect(()=>{p()},[]);const h=()=>{if(confirm(n.databse.all_data_del_confirm)){const y="DELETE FROM chat_messages";it.post(Ye.custom_query.get,{query:y}).then(()=>{p()}).then(()=>{d()}).catch(b=>{console.log("db status :(",b)})}},p=async()=>{await it.get(Ye.chat_messages.get_all).then(y=>{s(y.data)}).then(()=>{d()}).catch(y=>{console.log("db status :(",y)})},f=y=>{it.delete(Ye[e].delete+`/${y}`).then(b=>{p()}).then(()=>{d()}).catch(b=>{console.log(b)})},m=()=>{if(r[0])return Object.keys(r[0]).map((b,x)=>D(m8e,{children:b},x))},g=()=>{if(r[0])return r.map((y,b)=>{const x=Object.keys(r[0]);return K("tr",{children:[x.map((w,v)=>D(qU,{children:y[w]},v)),!a&&D(KU,{style:{cursor:"pointer"},onClick:()=>{i(!0)},children:D(Jo,{children:D(Qo,{src:un.EDIT_BTN_IMG})})}),a&&D(KU,{onClick:()=>{f(y.id)},children:D(Zo,{children:n.databse.remove_bt})}),K(qU,{style:{cursor:"pointer",display:"none"},children:[" ",y.end=="end"?"ZOBACZ":"KONTYNYUJ"," "]})]},b)})};return K(vo,{children:[D(kk,{children:D(Ue,{onClick:h,children:"Clear all"})}),!o&&D(kk,{children:K(kk,{children:[D(kk,{children:" Chat history "}),D(co,{children:D("table",{children:K("tbody",{children:[D(Yo,{children:m()}),g()]})})},u)]})})]})},qU=pe.td.withConfig({displayName:"Td",componentId:"sc-igr0pt-0"})(["border:1px solid gray;justify-content:center;text-align:center;"]),KU=pe.td.withConfig({displayName:"Td_container",componentId:"sc-igr0pt-1"})(["justify-content:center;text-align:center;"]),m8e=pe.th.withConfig({displayName:"Th",componentId:"sc-igr0pt-2"})(["border:1px solid gray;justify-content:center;"]);pe.tr.withConfig({displayName:"Tr",componentId:"sc-igr0pt-3"})(["position:-webkit-sticky;position:sticky;top:0;z-index:1;background-color:gray;"]);const kk=pe.div.withConfig({displayName:"Container",componentId:"sc-igr0pt-4"})([" "]),g8e=({lang:e})=>{const t=fn(e),[n,r]=J.useState(),[s,a]=J.useState([]),[i,o]=J.useState(),[l,u]=J.useState(!1),[c,d]=J.useState(),[h,p]=J.useState(),[f,m]=J.useState(),[g,y]=J.useState(),[b,x]=J.useState(1),[w,v]=J.useState("start"),[k,I]=J.useState(!1),S=()=>{x(Math.random())},$="image_storage",N="image_storage ",T=["label"],C=[y];J.useEffect(()=>{E()},[]);const E=async()=>{await it.get(Ye.image_storage.get).then(O=>{a(O.data)}).catch(O=>{console.log("db status :(",O)})},M=async O=>{const L=s[O];y(L.label),m(L.img),d(O)},F=O=>{it.put(Ye.image_storage.put,{id:O,img:f,label:g}).then(L=>{E()}).then(()=>{S()}).then(()=>{C.map(L=>{L(void 0)})}).catch(L=>{console.log(L)})},z=async(O,L)=>{it.post(Ye[$].post,{id:h,img:L,label:O}).then(V=>{E()}).then(()=>{S()}).then(()=>{C.map(V=>{V(void 0)}),m(void 0)}).catch(V=>{console.log(V)})},H=O=>{it.delete(Ye[$].delete+`/${O}`).then(L=>{E()}).then(()=>{S()}).catch(L=>{console.log(L)})};J.useMemo(async()=>{k&&i&&Object.keys(i).map(L=>{const V=i[L].name;let q=new FileReader;q.readAsDataURL(i[L]),q.onloadend=()=>{let B=q.result;z(typeof g>"u"?V:g,B)}}),I(!1)},[k]);const P=()=>{if(w=="start"&&typeof s[0]<"u"){const O=Object.keys(s[0]);return K(ou,{children:[K(ou,{children:[N,"  "]}),D(co,{children:D("table",{children:K("tbody",{children:[D(Yo,{children:s&&O.map((L,V)=>D(y8e,{children:L},V))}),s&&s.slice(0).reverse().map((L,V)=>{const q=L.date.replace("T"," | ").slice(0,-8);return K("tr",{children:[K(Ik,{children:[L.id," "]}),D(Ik,{children:D(Uo,{style:{height:"150px",width:"150px"},src:L.img})}),K(Ik,{children:[L.label," "]}),K(Ik,{children:[q," "]}),D(N_,{style:{cursor:"pointer",display:n==`${L.id}`?"none":"block"},onClick:()=>{r(L.id)},children:D(Jo,{children:D(Qo,{src:un.EDIT_BTN_IMG})})}),D(N_,{style:{display:n==`${L.id}`?"flex":"none"},onClick:()=>{H(L.id)},children:D(Zo,{children:t.databse.remove_bt})}),D(N_,{style:{display:n==`${L.id}`?"flex":"none"},onClick:()=>{u(!0),M(V),v("modify")},children:D(BC,{children:t.databse.mod_bt})})]},L.id)})]})})},b)]})}if(w=="add")return K(ou,{children:[K(ou,{children:[T.map((O,L)=>K(ou,{children:[D("label",{children:T[L]}),D("input",{style:{backgroundColor:"gray"},type:"text",name:T[L],onChange:V=>{C[L](V.target.value)}})]},L)),D("input",{type:"file",name:"myImage",multiple:!0,onChange:O=>{const L=O.target.files;o(L),O.target.files[0].name.slice(0,-4)}})]}),D(Ue,{onClick:()=>{I(!0),v("start")},children:"Submit data to database"}),D(Ue,{onClick:()=>{v("start")},children:"back"}),f&&D("img",{height:100,width:100,src:f,alt:""})]},b+1);if(w=="modify"&&c)return K(ou,{children:["Modyfikacja wersetu nr: ",c,D(ou,{children:T.map((O,L)=>K(ou,{children:[D("label",{children:T[L]}),D("input",{onClick:()=>{C[L](s[c][O])},defaultValue:s[c][O],style:{backgroundColor:"gray"},type:"text",name:T[L],onChange:V=>{C[L](V.target.value)}})]},L))}),D("button",{onClick:()=>{u(!l),F(s[c].id),S(),v("start")},children:"Update data"}),D("button",{onClick:()=>{u(!l),v("start")},children:"Back"})]})};return K(vo,{children:[K(ou,{children:[D(Ue,{style:{display:w=="start"?"block":"none"},onClick:()=>{v("add")},children:"Add new"}),D(Ue,{style:{display:w=="start"?"none":"block"},onClick:()=>{v("start")},children:"Table"})]}),P()]},b)},Ik=pe.td.withConfig({displayName:"Td",componentId:"sc-17x6l1p-0"})(["border:1px solid gray;justify-content:center;text-align:center;"]),N_=pe.td.withConfig({displayName:"Td_container",componentId:"sc-17x6l1p-1"})(["justify-content:center;text-align:center;"]),y8e=pe.th.withConfig({displayName:"Th",componentId:"sc-17x6l1p-2"})(["border:1px solid gray;justify-content:center;"]),ou=pe.div.withConfig({displayName:"Container",componentId:"sc-17x6l1p-3"})([" "]),b8e=({lang:e,user:t,userName:n})=>{const r=fn(e),[s,a]=J.useState(),[i,o]=J.useState([]),[l,u]=J.useState(),[c,d]=J.useState(1),[h,p]=J.useState("start"),f=()=>{d(Math.random())},m="face images ";J.useEffect(()=>{g()},[]);const g=async()=>{const v="SELECT id, CONVERT(img1 USING utf8) as img1, CONVERT(img2 USING utf8) as img2, CONVERT(img3 USING utf8) as img3, username, date FROM face_img_storage";await it.post(Ye.custom_query.get,{query:v}).then(k=>{o(k.data)}).catch(k=>{console.log("db status :(",k)})},y=v=>{const k=`DELETE FROM face_img_storage WHERE id=${v}`;it.post(Ye.custom_query.get,{query:k}).then(I=>{g()}).then(()=>{f()}).catch(I=>{console.log(I)})},b=v=>{u(K(wF,{children:[" ",D("img",{width:640,height:480,src:v})," "]})),f()},x=()=>l;return K(vo,{children:[D(T_,{}),(()=>{if(h=="start"&&typeof i[0]<"u"){const v=Object.keys(i[0]);return K(T_,{children:[K(T_,{children:[m," "]}),K(co,{children:[x(),D("table",{children:K("tbody",{children:[D(Yo,{children:i&&v.map((k,I)=>D(x8e,{children:k},I))}),i&&i.slice(0).reverse().map((k,I)=>K("tr",{children:[K($_,{children:[k.id," "]}),D(bi,{children:D(Uo,{onClick:()=>{b(k.img1)},style:{height:"150px",width:"150px"},src:k.img1})}),D(bi,{children:D(Uo,{onClick:()=>{b(k.img1)},style:{height:"150px",width:"150px"},src:k.img2})}),D(bi,{children:D(Uo,{onClick:()=>{b(k.img1)},style:{height:"150px",width:"150px"},src:k.img3})}),K($_,{children:[k.username," "]}),K($_,{children:[k.date," "]}),!t&&D(XU,{style:{cursor:"pointer",display:s==`${k.id}`?"none":"block"},onClick:()=>{a(k.id)},children:D(Jo,{children:D(Qo,{src:un.EDIT_BTN_IMG})})}),!t&&D(XU,{style:{display:s==`${k.id}`?"flex":"none"},onClick:()=>{y(k.id)},children:D(Zo,{children:r.databse.remove_bt})})]},k.id))]})})]},c)]})}})()]},c)},$_=pe.td.withConfig({displayName:"Td",componentId:"sc-aj0kkb-0"})(["border:1px solid gray;justify-content:center;text-align:center;"]),XU=pe.td.withConfig({displayName:"Td_container",componentId:"sc-aj0kkb-1"})(["justify-content:center;text-align:center;"]),x8e=pe.th.withConfig({displayName:"Th",componentId:"sc-aj0kkb-2"})(["border:1px solid gray;justify-content:center;"]),T_=pe.div.withConfig({displayName:"Container",componentId:"sc-aj0kkb-3"})([" "]),w8e=({lang:e})=>{const t=fn(e),[n,r]=J.useState(),[s,a]=J.useState([]),[i,o]=J.useState(1),[l,u]=J.useState("start"),c=["Username","Name","Surname","Email","Phone","Authcode","Password","Account type","Registered at"],d=()=>{o(Math.random())},h="User table ";J.useEffect(()=>{p()},[]);const p=async()=>{const g="SELECT * FROM account_credentials";await it.post(Ye.custom_query.get,{query:g}).then(y=>{a(y.data)}).catch(y=>{console.log("db status :(",y)})},f=g=>{const y=`DELETE FROM account_credentials WHERE id=${g}`;it.post(Ye.custom_query.get,{query:y}).then(b=>{p()}).then(()=>{d()}).catch(b=>{console.log(b)})};return K(vo,{children:[D(__,{}),(()=>{if(l=="start"&&typeof s[0]<"u")return Object.keys(s[0]),K(__,{children:[K(__,{children:[h," "]}),D(co,{children:D("table",{children:K("tbody",{children:[D(Yo,{children:s&&c.map((g,y)=>D(v8e,{children:g},y))}),s&&s.map((g,y)=>{const b=g.date.replace("T"," | ").slice(0,-8);return K("tr",{children:[K(lu,{children:[g.username?g.username:t.common.no_data," "]}),K(lu,{children:[g.first_name?g.first_name:t.common.no_data," "]}),K(lu,{children:[g.last_name?g.last_name:t.common.no_data," "]}),K(lu,{children:[g.email?g.email:t.common.no_data," "]}),K(lu,{children:[g.phone?g.phone:t.common.no_data," "]}),K(lu,{children:[g.id?g.id:t.common.no_data," "]}),K(lu,{children:[g.password?g.password:t.common.no_data," "]}),K(lu,{children:[g.status?g.status:t.common.no_data," "]}),K(lu,{children:[b," "]}),D(YU,{style:{cursor:"pointer",display:n==`${g.id}`?"none":"block"},onClick:()=>{r(g.id)},children:D(Jo,{children:D(Qo,{src:un.EDIT_BTN_IMG})})}),D(YU,{style:{display:n==`${g.id}`?"flex":"none"},onClick:()=>{f(g.id)},children:D(Zo,{children:t.databse.remove_bt})})]},g.id)})]})})},i)]})})()]},i)},lu=pe.td.withConfig({displayName:"Td",componentId:"sc-b9b5b0-0"})(["border:1px solid;border-color:rgba(255,255,255,.15);background-color:#161b22;justify-content:center;text-align:center;"]),YU=pe.td.withConfig({displayName:"Td_container",componentId:"sc-b9b5b0-1"})(["justify-content:center;text-align:center;"]),v8e=pe.th.withConfig({displayName:"Th",componentId:"sc-b9b5b0-2"})(["border:1px solid;border-color:rgba(255,255,255,.15);justify-content:center;"]),__=pe.div.withConfig({displayName:"Container",componentId:"sc-b9b5b0-3"})([" "]),sQ=({lang:e,user:t,userName:n})=>{const r=fn(e),[s,a]=J.useState([]),[i,o]=J.useState(!1),[l,u]=J.useState(!1),[c,d]=J.useState(1),[h,p]=J.useState(),f=()=>{d(Math.random())},m="ph analysis",g=["id","username","analysis_name"],y=["img"],b=["ph","rgb","date","R","G","B"],x=g.concat(y.concat(b));J.useEffect(()=>{w()},[]);const w=()=>{const $="SELECT id, CONVERT(img USING utf8) as img, username, ph, rgb, date, analysis_name,R,G,B,ph_number FROM ph_analysis ";it.post(Ye.custom_query.get,{query:$}).then(N=>{a(N.data)}).then(()=>{f()}).catch(N=>{console.log("db status :(",N)})},v=$=>{const N=`DELETE FROM ph_analysis WHERE id=${$}`;it.post(Ye.custom_query.get,{query:N}).then(T=>{w()}).then(()=>{f()}).catch(T=>{console.log(T)})},k=()=>{if(confirm("Na pewno chcesz usunąć wszystkie zapisane kalibracje?")){const $="DELETE FROM ph_analysis";it.post(Ye.custom_query.get,{query:$}).then(()=>{w()}).then(()=>{f()}).catch(N=>{console.log("db status :(")})}},I=$=>{p(K(wF,{children:[" ",D("img",{width:640,height:480,src:$})," "]})),f()},S=()=>h;return K(vo,{children:[D(Ck,{style:{display:t?"none":"block"},children:D(Ue,{onClick:k,children:r.databse.clear_all_bt})}),!l&&D(Ck,{children:K(Ck,{children:[K(Ck,{children:[m," "]}),K(co,{children:[S(),D("table",{children:K("tbody",{children:[D(Yo,{children:x.map(($,N)=>D(k8e,{children:$},N))}),s.map(($,N)=>{if(t){if($.username==n)return K("tr",{children:[g.map((T,C)=>D(cm,{children:$[T]},C)),y.map((T,C)=>$[T]!=null?K(bi,{children:["  ",D(Uo,{onClick:()=>{I($[T])},src:$[T]})]},C):D(bi,{style:{cursor:"auto"}},C)),b.map((T,C)=>D(cm,{style:{background:$[T]=="end"?"#618685":$[T]=="fail"?"#c44569":"none"},children:$[T]},C)),!i&&D(Sk,{style:{cursor:"pointer",display:t?"none":"block"},onClick:()=>{o(!0)},children:D(Jo,{children:D(Qo,{src:un.EDIT_BTN_IMG})})}),i&&D(Sk,{onClick:()=>{v($.id)},children:D(Zo,{children:r.databse.remove_bt})}),K(cm,{style:{cursor:"pointer",display:"none"},children:[" ",$.end=="end"?"ZOBACZ":"KONTYNYUJ"," "]})]},N)}else return K("tr",{children:[g.map((T,C)=>D(cm,{children:$[T]},C)),y.map((T,C)=>$[T]!=null?K(bi,{children:["  ",D(Uo,{onClick:()=>{I($[T])},src:$[T]})]},C):D(bi,{style:{cursor:"auto"}},C)),b.map((T,C)=>D(cm,{style:{background:$[T]=="end"?"#618685":$[T]=="fail"?"#c44569":"none"},children:$[T]},C)),!i&&D(Sk,{style:{cursor:"pointer",display:t?"none":"block"},onClick:()=>{o(!0)},children:D(Jo,{children:D(Qo,{src:un.EDIT_BTN_IMG})})}),i&&D(Sk,{onClick:()=>{v($.id)},children:D(Zo,{children:r.databse.remove_bt})}),K(cm,{style:{cursor:"pointer",display:"none"},children:[" ",$.end=="end"?"ZOBACZ":"KONTYNYUJ"," "]})]},N)})]})})]},c)]})})]})},cm=pe.td.withConfig({displayName:"Td",componentId:"sc-jpmrfd-0"})(["border:1px solid gray;justify-content:center;text-align:center;"]),Sk=pe.td.withConfig({displayName:"Td_container",componentId:"sc-jpmrfd-1"})(["justify-content:center;text-align:center;"]),k8e=pe.th.withConfig({displayName:"Th",componentId:"sc-jpmrfd-2"})(["border:1px solid gray;justify-content:center;"]),Ck=pe.div.withConfig({displayName:"Container",componentId:"sc-jpmrfd-3"})([" "]),I8e=({lang:e})=>{const t=fn(e),[n,r]=J.useState(),[s,a]=J.useState(1),i=()=>{a(Math.random())},o=p=>{r(p),i()},l=()=>n,u=()=>K("div",{className:"dropdown",children:[D(Ue,{className:"dropbtn",children:t.database_buttons.ion_analysis}),K("div",{className:"dropdown-content",children:[K("a",{onClick:()=>{o(D(sR,{lang:e,rout_name:"anion_analysis_result"},s))},children:[" ",t.database_buttons.anion," "]}),K("a",{onClick:()=>{o(D(sR,{lang:e,rout_name:"cation_analysis_result"},s))},children:[" ",t.database_buttons.cation," "]})]})]}),c=()=>K("div",{className:"dropdown",children:[D(Ue,{className:"dropbtn",children:t.database_buttons.dataflow}),K("div",{className:"dropdown-content",children:[K("a",{onClick:()=>{o(D(HU,{lang:e,rout_name:"anion_script_flow"},s))},children:[" ",t.database_buttons.anion," "]}),K("a",{onClick:()=>{o(D(HU,{lang:e,rout_name:"cation_script_flow"},s))},children:[" ",t.database_buttons.cation," "]})]})]}),d=()=>K("div",{className:"dropdown",children:[D(Ue,{className:"dropbtn",children:t.database_buttons.voicescript}),K("div",{className:"dropdown-content",children:[K("a",{onClick:()=>{o(D(GU,{lang:e,rout_name:"anion_voice_script"},s))},children:[" ",t.database_buttons.anion," "]}),K("a",{onClick:()=>{o(D(GU,{lang:e,rout_name:"cation_voice_script"},s))},children:[" ",t.database_buttons.cation," "]})]})]}),h=()=>K("div",{className:"dropdown",children:[D(Ue,{className:"dropbtn",children:t.database_buttons.images}),K("div",{className:"dropdown-content",children:[K("a",{onClick:()=>{o(D(h8e,{lang:e},s))},children:[" ",t.database_buttons.img_1," "]}),K("a",{onClick:()=>{o(D(g8e,{lang:e},s))},children:[" ",t.database_buttons.img_2," "]}),K("a",{onClick:()=>{o(D(b8e,{lang:e},s))},children:[" ",t.database_buttons.img_3," "]})]})]});return K(S8e,{children:[K(C8e,{children:[D(u,{}),K(Ue,{onClick:()=>{o(D(sQ,{lang:e},s))},children:[" ",t.database_buttons.ph," "]}),D(c,{}),D(d,{}),D(h,{}),K(Ue,{onClick:()=>{o(D(f8e,{lang:e},s))},children:[" ",t.database_buttons.chat," "]}),K(Ue,{onClick:()=>{o(D(w8e,{lang:e},s))},children:[" ",t.database_buttons.users," "]})]}),l()]})},S8e=pe.div.withConfig({displayName:"Container",componentId:"sc-xv04vf-0"})(["position:absolute;width:100%;top:20%;display:flex;flex-direction:column;align-items:center;justify-content:center;border:1px solid;border-color:rgba(255,255,255,.15);"]),C8e=pe.div.withConfig({displayName:"HeaderContainer",componentId:"sc-xv04vf-1"})(["height:60px;background-color:#161b22;padding:0 15px;display:flex;flex-direction:row;align-items:center;border:1px solid;border-color:rgba(255,255,255,.15);"]),N8e=()=>{const[e,t]=J.useState([]),[n,r]=J.useState(!1),[s,a]=J.useState(1),[i,o]=J.useState(),[l,u]=J.useState([]),c=i?"cation_analysis_result":"anion_analysis_result",d=()=>{a(Math.random())},h=async()=>{await it.get(Ye[c].get).then(m=>{t(m.data),u(Object.keys(m.data[0]))}).then(()=>{d()}).catch(m=>{console.log("db status :(")})},p=async m=>{await it.delete(Ye[c].delete+`/${m}`).then(g=>{h()}).then(()=>{d()}).catch(g=>{console.log(g)})},f=()=>{if(l.length!==0&&e[0]){const m=i?["id","name","f1","f2","f3","f4","f5","f6","f7"]:["id","name","f1","f2","f3","f4"],g=i?["img1","img2","img3","img4","img5","img6","img7"]:["img1","img2","img3","img4"];return D(A8e,{children:D("table",{children:K("tbody",{children:[D("tr",{children:l.map((y,b)=>D("th",{children:y},b))}),e.map((y,b)=>K("tr",{children:[m.map((x,w)=>D(qd,{children:y[x]},w)),g.map((x,w)=>D(qd,{children:D(_8e,{src:y[x]})},w)),D(qd,{children:y.end},b),D(qd,{children:y.result},b+1),D(qd,{style:{cursor:"pointer",background:"red"},onClick:()=>{p(y.id)},children:"USUŃ "}),D(qd,{style:{cursor:"pointer",background:"gray"},children:"MOD "}),K(qd,{style:{cursor:"pointer"},children:[" ",y.end=="end"?"ZOBACZ":"KONTYNYUJ"," "]})]},b))]})})},s)}};return J.useMemo(()=>{},[i]),D(T8e,{children:K(E8e,{children:[n&&K(ZU,{children:[D(Ue,{onClick:()=>{r(!n)},children:"Ukryj panel"}),D(ZU,{children:f()})]}),!n&&K($8e,{children:[D(Ue,{onClick:()=>{o(!0),r(!n),h()},children:"Kationy"}),D(Ue,{onClick:()=>{o(!1),r(!n),h()},children:"Aniony"})]})]})})},$8e=pe.div.withConfig({displayName:"HeaderContainer",componentId:"sc-cgng2i-0"})(["height:60px;padding:0 15px;display:flex;flex-direction:row;align-items:center;"]),T8e=pe.div.withConfig({displayName:"ContainerP",componentId:"sc-cgng2i-1"})(["color:",";display:flex;flex-direction:row;justify-content:center;flex:1;"],({theme:e})=>e.colors.typography),_8e=pe.img.withConfig({displayName:"MyImage",componentId:"sc-cgng2i-2"})(["width:50px;height:50px;"]),qd=pe.td.withConfig({displayName:"Td",componentId:"sc-cgng2i-3"})(["border:1px solid gray;justify-content:center;"]),ZU=pe.div.withConfig({displayName:"Container",componentId:"sc-cgng2i-4"})([""]),E8e=pe.div.withConfig({displayName:"Container12",componentId:"sc-cgng2i-5"})([""]);pe.div.withConfig({displayName:"Contr",componentId:"sc-cgng2i-6"})(["display:flex;flex-direction:row;"]);pe.button.withConfig({displayName:"SmallButton",componentId:"sc-cgng2i-7"})(["background-color:gray;border:1px solid red;margin-left:10px;cursor:pointer;"]);const A8e=pe.div.withConfig({displayName:"TableContainer",componentId:"sc-cgng2i-8"})(["height:400px;overflow-y:scroll;border:5px solid gray;"]),R8e=({cation:e,lang:t})=>{const n=fn(t),[r,s]=J.useState(),[a,i]=J.useState([]),[o,l]=J.useState([]),[u,c]=J.useState(),d=J.useRef(null),h=e?"cation_analysis_result":"anion_analysis_result",p=e?"cation_script_flow":"anion_script_flow",f=n.analysis.propability;J.useEffect(()=>{m()},[]);const m=async()=>{let x=!1;if(await it.get(Ye[h].get).then(w=>{i(w.data),x=!0,g(w.data)}).catch(w=>{console.log("db status :(",w)}),x)return"ok"},g=async x=>{const w=x[x.length-1];if(typeof w<"u"){if(w.end=="incomplete"){if(w.f1==null)return s(1),!0;if(w.f2==null)return s(2),!0;if(w.f3==null)return s(3),!0;if(w.f4==null)return s(4),!0;if(w.f5==null)return s(5),!0;if(w.f6==null)return s(6),!0;if(w.f7==null)return s(7),!0}w.end=="end"&&r!==100&&s(8)}},y=async()=>{if(r!==1&&typeof r<"u"){const x=a[a.length-1],w=r-1;await it.put(Ye.shuffle_match.get,{phase:w,label:x[`f${w}`],db_type:p}).then(v=>{v.data.map(I=>{r==2&&I.f1==x.f1&&l(S=>[...S,I.symbol]),r==3&&(I.f1==x.f1&&I.f2==x.f2&&l(S=>[...S,I.symbol]),I.f1==x.f1&&I.f2==x.f2&&I.f3=="-"&&c(I.symbol)),r==4&&(I.f1==x.f1&&I.f2==x.f2&&I.f3==x.f3&&l(S=>[...S,I.symbol]),I.f1==x.f1&&I.f2==x.f2&&I.f3==x.f3&&I.f4=="-"&&c(I.symbol)),r==5&&(I.f1==x.f1&&I.f2==x.f2&&I.f3==x.f3&&I.f4==x.f4&&l(S=>[...S,I.symbol]),I.f1==x.f1&&I.f2==x.f2&&I.f3==x.f3&&I.f4==x.f4&&I.f5=="-"&&c(I.symbol)),r==6&&(I.f1==x.f1&&I.f2==x.f2&&I.f3==x.f3&&I.f4==x.f4&&I.f5==x.f5&&l(S=>[...S,I.symbol]),I.f1==x.f1&&I.f2==x.f2&&I.f3==x.f3&&I.f4==x.f4&&I.f5==x.f5&&I.f6=="-"&&c(I.symbol)),r==7&&(I.f1==x.f1&&I.f2==x.f2&&I.f3==x.f3&&I.f4==x.f4&&I.f5==x.f5&&I.f6==x.f6&&l(S=>[...S,I.symbol]),I.f1==x.f1&&I.f2==x.f2&&I.f3==x.f3&&I.f4==x.f4&&I.f5==x.f5&&I.f6==x.f6&&I.f7=="-"&&c(I.symbol)),r==8&&I.f1==x.f1&&I.f2==x.f2&&I.f3==x.f3&&I.f4==x.f4&&I.f5==x.f5&&I.f6==x.f6&&I.f7==x.f7&&c(I.symbol)})}).catch(v=>{console.log("db status :(",v)})}};return J.useMemo(()=>{typeof r<"u"&&y()},[r]),D(Nk,{children:(()=>{if(typeof r<"u"){if(typeof u<"u")return K(Nk,{children:[n.analysis.ion_found,u]});if(o.length==0&&r!==1){const x=a[a.length-1];return x.end=="end"&&x.f7!=="brak"?D(Nk,{children:n.analysis.end_analysis}):D(Nk,{children:n.analysis.wrong_result})}else return K(D8e,{ref:d,children:[f,D("div",{style:{width:"40px"}}),o.map((x,w)=>x+" ")]})}})()})},Nk=pe.div.withConfig({displayName:"Container",componentId:"sc-6g9j21-0"})(["    "]),D8e=pe.div.withConfig({displayName:"ShuffleContainer",componentId:"sc-6g9j21-1"})(["border:1px solid;border-color:rgba(255,255,255,.35);border-radius:10px;justify-content:center;padding:5px;"]),F8e=["brak","bialy","czarny","zolty","pomaranczowy","zielony","niebieski","nieb_rozowy","cielisty","pomaranczowy_p","fioletowy_p","zolty_p"],O8e=()=>F8e,M8e=({cation:e,lang:t})=>{const n=fn(t),[r,s]=J.useState([]),[a,i]=J.useState(1),[o,l]=J.useState(),u=J.useRef(null),c=J.useRef(null),d=()=>{u.current.style.display=c.current.style.display="none"},h=e?"cation_analysis_result":"anion_analysis_result";J.useEffect(()=>{p()},[]);const p=()=>{it.get(Ye[h].get).then(y=>{const b=y.data;s(b[b.length-1])}).catch(y=>{console.log("db status :(",y)})},f=y=>{l(K("div",{children:[D(U8e,{ref:u}),K(G8e,{ref:c,children:[D("img",{width:540,height:380,src:y}),D(Ue,{style:{float:"right",backgroundColor:"black"},onClick:d,id:"close",children:n.common.close})]})]})),u.current.style.display=c.current.style.display="block"},m=()=>o;return D(V8e,{children:D(W8e,{children:(()=>{if(r){const y=t=="EN"?e?["Stage 1","Stage 2","Stage 3","Stage 4","Stage 5","Stage 6","Stage 7"]:["Stage 1","Stage 2","Stage 3","Stage 4"]:e?["Faza 1","Faza 2","Faza 3","Faza 4","Faza 5","Faza 6","Faza 7"]:["Faza 1","Faza 2","Faza 3","Faza 4"],b=e?["f1","f2","f3","f4","f5","f6","f7"]:["f1","f2","f3","f4"],x=e?["img1","img2","img3","img4","img5","img6","img7"]:["img1","img2","img3","img4"];return K(z8e,{children:[m(),n.analysis.analysis_progress,D("table",{children:K("tbody",{children:[D(P8e,{children:y.map((w,v)=>D(L8e,{children:w},v))}),D("tr",{children:b.map((w,v)=>D(B8e,{style:{maxWidth:"55px",overflow:"hidden"},children:n.analysis_results_names[r[w]]},v))},a+2),D("tr",{children:x.map((w,v)=>D(bi,{children:D(Uo,{onClick:()=>{f(r[w])},style:{display:r[w]==null?"none":"flex"},src:r[w]})},v))},a+1)]})})]},a)}})()})})},L8e=pe.th.withConfig({displayName:"Th",componentId:"sc-1rfz46y-0"})(["border:1px solid;border-color:rgba(255,255,255,.35);justify-content:center;"]),P8e=pe.tr.withConfig({displayName:"Tr",componentId:"sc-1rfz46y-1"})(["position:sticky;top:0;z-index:1;"]),z8e=pe.div.withConfig({displayName:"TableContainer",componentId:"sc-1rfz46y-2"})(["border:1px solid;border-color:rgba(255,255,255,.35);border-radius:10px;justify-content:center;align-items:center;padding:5px;"]),B8e=pe.td.withConfig({displayName:"Td",componentId:"sc-1rfz46y-3"})(["border:1px solid;border-color:rgba(255,255,255,.35);justify-content:center;text-align:center;"]),W8e=pe.div.withConfig({displayName:"Container",componentId:"sc-1rfz46y-4"})(["justify-content:center;"]),V8e=pe.div.withConfig({displayName:"Container12",componentId:"sc-1rfz46y-5"})(["width:400px;"]),U8e=pe.div.withConfig({displayName:"Shade",componentId:"sc-1rfz46y-6"})(["display:block;position:fixed;z-index:100;top:0;left:0;width:100%;height:100%;background:silver;opacity:0.5;filter:alpha(opacity=50);"]),G8e=pe.div.withConfig({displayName:"Modal",componentId:"sc-1rfz46y-7"})(["display:block;position:fixed;z-index:101;top:10%;left:center;"]);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H8e=1e-7,j8e=1e-4;class aQ{constructor(t,n){this.backend=t,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,n){this.dataIdsCount++,this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class JL{refCount(t){return Ma("refCount")}incRef(t){return Ma("incRef")}timerAvailable(){return!0}time(t){return Ma("time")}read(t){return Ma("read")}readSync(t){return Ma("readSync")}readToGPU(t,n){return Ma("readToGPU")}numDataIds(){return Ma("numDataIds")}disposeData(t,n){return Ma("disposeData")}write(t,n,r){return Ma("write")}move(t,n,r,s,a){return Ma("move")}createTensorFromGPUData(t,n,r){return Ma("createTensorFromGPUData")}memory(){return Ma("memory")}floatPrecision(){return Ma("floatPrecision")}epsilon(){return this.floatPrecision()===32?H8e:j8e}dispose(){return Ma("dispose")}}function Ma(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q8e(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,ym(e,t,n)}function tp(e,t,n){return Math.max(e,Math.min(t,n))}function QL(e){return e%2===0?e:e+1}function ym(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function K8e(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function U(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function oi(e,t,n=""){U(Xt(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Sb(e){U(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ve(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Xt(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Rg(e){return e%1===0}function aR(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function jm(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function JU(e,t=s=>0,n,r){return new Promise((s,a)=>{let i=0;const o=()=>{if(e()){s();return}i++;const l=t(i);if(n!=null&&i>=n){a();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function iQ(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(e[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function Bt(e,t){const n=t.length;return e=e==null?t.map((r,s)=>s):[].concat(e),U(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),U(e.every(r=>Rg(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function Ad(e,t){const n=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||s?null:Bt(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(a!=null){if(a[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(a[i]==null||a[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function Is(e,t){return yr(e,t)}function yr(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function X8e(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function Y8e(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function oQ(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function $S(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function Z8e(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function i1(e){return typeof e=="string"||e instanceof String}function J8e(e){return typeof e=="boolean"}function iR(e){return typeof e=="number"}function Cb(e){return Array.isArray(e)?Cb(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":iR(e)?"float32":i1(e)?"string":J8e(e)?"bool":"float32"}function oR(e){return!!(e&&e.constructor&&e.call&&e.apply)}function lR(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function yt(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function lQ(e,t,n,r=!1){const s=new Array;if(t.length===1){const a=t[0]*(r?2:1);for(let i=0;i<a;i++)s[i]=n[e+i]}else{const a=t[0],i=t.slice(1),o=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<a;l++)s[l]=lQ(e+l*o,i,n,r)}return s}function po(e,t,n=!1){if(e.length===0)return t[0];const r=e.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return lQ(0,e,t,n)}function Q8e(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function eP(e,t){const n=Ls(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Ls(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function uQ(e,t){const n=e.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return po(e,new Float32Array(n));if(t==="int32")return po(e,new Int32Array(n));if(t==="bool")return po(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Pi(e){e.forEach(t=>{U(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function Pl(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function Nb(e,t,n){if(t===0)return[];if(t===1)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function np(e){return e&&e.then&&typeof e.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QU="tfjsflags";class eKe{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=tKe,this.populateURLFlags()}setPlatform(t,n){this.platform!=null&&(xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,r){if(this.flagRegistry[t]={evaluationFn:n,setHook:r},this.urlFlags[t]!=null){const s=this.urlFlags[t];xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if(np(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);QU in t&&t[QU].split(",").forEach(r=>{const[s,a]=r.split(":");this.urlFlags[s]=rKe(s,a)})}}function tKe(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(nKe(t,r[0],r[1]),r.join("="))),t}function nKe(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function rKe(e,t){const n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function xe(){return cQ}let cQ=null;function sKe(e){cQ=e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let E_;function dQ(){if(E_==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");E_=e}return E_}function aKe(){const e=dQ();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function tP(e,t){const n=aKe();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const C2="Abs",o1="Acos",l1="Acosh",$b="Add",N2="AddN",nP="All",rP="Any",$2="ArgMax",T2="ArgMin",u1="Asin",c1="Asinh",d1="Atan",h1="Atanh",p1="Atan2",_2="AvgPool",sP="AvgPoolGrad",E2="AvgPool3D",aP="AvgPool3DGrad",A2="BatchMatMul",R2="BatchToSpaceND",iP="Bincount",iKe="BroadcastTo",oP="BroadcastArgs",f1="Cast",m1="Ceil",g1="ClipByValue",lP="Complex",D2="ComplexAbs",F2="Concat",O2="Conv2D",uP="Conv2DBackpropFilter",M2="Conv2DBackpropInput",L2="Conv3D",cP="Conv3DBackpropFilterV2",dP="Conv3DBackpropInputV2",y1="Cos",b1="Cosh",hP="Cumprod",P2="Cumsum",pP="CropAndResize",fP="DenseBincount",mP="DepthToSpace",z2="DepthwiseConv2dNative",gP="DepthwiseConv2dNativeBackpropFilter",yP="DepthwiseConv2dNativeBackpropInput",bP="Diag",B2="Dilation2D",uR="Dilation2DBackpropInput",cR="Dilation2DBackpropFilter",x1="RealDiv",xP="Einsum",w1="Elu",wP="EluGrad",v1="Erf",W2="Equal",k1="Exp",V2="ExpandDims",I1="Expm1",vP="FFT",kP="Fill",IP="FlipLeftRight",S1="Floor",C1="FloorDiv",U2="FusedBatchNorm",G2="GatherV2",SP="GatherNd",H2="Greater",N1="GreaterEqual",$1="Identity",CP="IFFT",NP="Imag",T1="IsFinite",_1="IsInf",E1="IsNan",j2="LeakyRelu",q2="Less",K2="LessEqual",$P="LinSpace",A1="Log",R1="Log1p",X2="LogicalAnd",Y2="LogicalNot",Z2="LogicalOr",oKe="LogSoftmax",J2="LRN",TP="LRNGrad",Q2="Max",D1="Maximum",e$="MaxPool",_P="MaxPoolGrad",t$="MaxPool3D",EP="MaxPool3DGrad",AP="MaxPoolWithArgmax",n$="Mean",r$="Min",F1="Minimum",s$="MirrorPad",O1="Mod",RP="Multinomial",M1="Multiply",a$="Neg",i$="NotEqual",DP="NonMaxSuppressionV3",FP="NonMaxSuppressionV4",OP="NonMaxSuppressionV5",o$="OnesLike",l$="OneHot",u$="Pack",c$="PadV2",L1="Pow",d$="Prelu",h$="Prod",MP="RaggedGather",LP="RaggedRange",PP="RaggedTensorToTensor",zP="Range",BP="Real",P1="Reciprocal",z1="Relu",p$="Reshape",f$="ResizeNearestNeighbor",WP="ResizeNearestNeighborGrad",m$="ResizeBilinear",VP="ResizeBilinearGrad",B1="Relu6",g$="Reverse",W1="Round",V1="Rsqrt",UP="ScatterNd",GP="TensorScatterUpdate",HP="SearchSorted",y$="Select",U1="Selu",b$="Slice",G1="Sin",H1="Sinh",j1="Sign",q1="Sigmoid",K1="Softplus",X1="Sqrt",x$="Sum",w$="SpaceToBatchND",v$="SplitV",k$="Softmax",jP="SparseFillEmptyRows",qP="SparseReshape",KP="SparseSegmentMean",XP="SparseSegmentSum",YP="SparseToDense",Y1="SquaredDifference",ZP="Square",I$="StaticRegexReplace",JP="StridedSlice",QP="StringNGrams",ez="StringSplit",tz="StringToHashBucketFast",Z1="Sub",J1="Tan",Q1="Tanh",ev="Tile",nz="TopK",rz="Transform",qm="Transpose",sz="Unique",S$="Unpack",C$="UnsortedSegmentSum",N$="ZerosLike",tv="Step",dR="FromPixels",az="RotateWithOffset",TS="_FusedMatMul",_S="FusedConv2D",ES="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gi(...e){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(...e)}function lKe(...e){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.log(...e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AS=tP("kernelRegistry",()=>new Map),hR=tP("gradRegistry",()=>new Map);function pR(e,t){const n=pQ(e,t);return AS.get(n)}function eG(e){return hR.get(e)}function tG(e){const t=AS.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function hQ(e){const{kernelName:t,backendName:n}=e,r=pQ(t,n);AS.has(r)&&gi(`The kernel '${t}' for backend '${n}' is already registered`),AS.set(r,e)}function uKe(e){const{kernelName:t}=e;hR.has(t)&&xe().getBool("DEBUG")&&gi(`Overriding the gradient for '${t}'`),hR.set(t,e)}function pQ(e,t){return`${t}_${e}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fQ(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var fR=Un,no=null;try{no=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Un(e,t,n){this.low=e|0,this.high=t|0,this.unsigned=!!n}Un.prototype.__isLong__;Object.defineProperty(Un.prototype,"__isLong__",{value:!0});function li(e){return(e&&e.__isLong__)===!0}Un.isLong=li;var nG={},rG={};function Gf(e,t){var n,r,s;return t?(e>>>=0,(s=0<=e&&e<256)&&(r=rG[e],r)?r:(n=Gn(e,(e|0)<0?-1:0,!0),s&&(rG[e]=n),n)):(e|=0,(s=-128<=e&&e<128)&&(r=nG[e],r)?r:(n=Gn(e,e<0?-1:0,!1),s&&(nG[e]=n),n))}Un.fromInt=Gf;function ro(e,t){if(isNaN(e))return t?xh:so;if(t){if(e<0)return xh;if(e>=mQ)return bQ}else{if(e<=-aG)return ja;if(e+1>=aG)return yQ}return e<0?ro(-e,t).neg():Gn(e%Dg|0,e/Dg|0,t)}Un.fromNumber=ro;function Gn(e,t,n){return new Un(e,t,n)}Un.fromBits=Gn;var RS=Math.pow;function iz(e,t,n){if(e.length===0)throw Error("empty string");if(e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return so;if(typeof t=="number"?(n=t,t=!1):t=!!t,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return iz(e.substring(1),t,n).neg();for(var s=ro(RS(n,8)),a=so,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),l=parseInt(e.substring(i,i+o),n);if(o<8){var u=ro(RS(n,o));a=a.mul(u).add(ro(l))}else a=a.mul(s),a=a.add(ro(l))}return a.unsigned=t,a}Un.fromString=iz;function cl(e,t){return typeof e=="number"?ro(e,t):typeof e=="string"?iz(e,t):Gn(e.low,e.high,typeof t=="boolean"?t:e.unsigned)}Un.fromValue=cl;var sG=1<<16,cKe=1<<24,Dg=sG*sG,mQ=Dg*Dg,aG=mQ/2,iG=Gf(cKe),so=Gf(0);Un.ZERO=so;var xh=Gf(0,!0);Un.UZERO=xh;var Om=Gf(1);Un.ONE=Om;var gQ=Gf(1,!0);Un.UONE=gQ;var mR=Gf(-1);Un.NEG_ONE=mR;var yQ=Gn(-1,2147483647,!1);Un.MAX_VALUE=yQ;var bQ=Gn(-1,-1,!0);Un.MAX_UNSIGNED_VALUE=bQ;var ja=Gn(0,-2147483648,!1);Un.MIN_VALUE=ja;var Ge=Un.prototype;Ge.toInt=function(){return this.unsigned?this.low>>>0:this.low};Ge.toNumber=function(){return this.unsigned?(this.high>>>0)*Dg+(this.low>>>0):this.high*Dg+(this.low>>>0)};Ge.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(ja)){var n=ro(t),r=this.div(n),s=r.mul(n).sub(this);return r.toString(t)+s.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var a=ro(RS(t,6),this.unsigned),i=this,o="";;){var l=i.div(a),u=i.sub(l.mul(a)).toInt()>>>0,c=u.toString(t);if(i=l,i.isZero())return c+o;for(;c.length<6;)c="0"+c;o=""+c+o}};Ge.getHighBits=function(){return this.high};Ge.getHighBitsUnsigned=function(){return this.high>>>0};Ge.getLowBits=function(){return this.low};Ge.getLowBitsUnsigned=function(){return this.low>>>0};Ge.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ja)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,n=31;n>0&&!(t&1<<n);n--);return this.high!=0?n+33:n+1};Ge.isZero=function(){return this.high===0&&this.low===0};Ge.eqz=Ge.isZero;Ge.isNegative=function(){return!this.unsigned&&this.high<0};Ge.isPositive=function(){return this.unsigned||this.high>=0};Ge.isOdd=function(){return(this.low&1)===1};Ge.isEven=function(){return(this.low&1)===0};Ge.equals=function(t){return li(t)||(t=cl(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};Ge.eq=Ge.equals;Ge.notEquals=function(t){return!this.eq(t)};Ge.neq=Ge.notEquals;Ge.ne=Ge.notEquals;Ge.lessThan=function(t){return this.comp(t)<0};Ge.lt=Ge.lessThan;Ge.lessThanOrEqual=function(t){return this.comp(t)<=0};Ge.lte=Ge.lessThanOrEqual;Ge.le=Ge.lessThanOrEqual;Ge.greaterThan=function(t){return this.comp(t)>0};Ge.gt=Ge.greaterThan;Ge.greaterThanOrEqual=function(t){return this.comp(t)>=0};Ge.gte=Ge.greaterThanOrEqual;Ge.ge=Ge.greaterThanOrEqual;Ge.compare=function(t){if(li(t)||(t=cl(t)),this.eq(t))return 0;var n=this.isNegative(),r=t.isNegative();return n&&!r?-1:!n&&r?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};Ge.comp=Ge.compare;Ge.negate=function(){return!this.unsigned&&this.eq(ja)?ja:this.not().add(Om)};Ge.neg=Ge.negate;Ge.add=function(t){li(t)||(t=cl(t));var n=this.high>>>16,r=this.high&65535,s=this.low>>>16,a=this.low&65535,i=t.high>>>16,o=t.high&65535,l=t.low>>>16,u=t.low&65535,c=0,d=0,h=0,p=0;return p+=a+u,h+=p>>>16,p&=65535,h+=s+l,d+=h>>>16,h&=65535,d+=r+o,c+=d>>>16,d&=65535,c+=n+i,c&=65535,Gn(h<<16|p,c<<16|d,this.unsigned)};Ge.subtract=function(t){return li(t)||(t=cl(t)),this.add(t.neg())};Ge.sub=Ge.subtract;Ge.multiply=function(t){if(this.isZero())return so;if(li(t)||(t=cl(t)),no){var n=no.mul(this.low,this.high,t.low,t.high);return Gn(n,no.get_high(),this.unsigned)}if(t.isZero())return so;if(this.eq(ja))return t.isOdd()?ja:so;if(t.eq(ja))return this.isOdd()?ja:so;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(iG)&&t.lt(iG))return ro(this.toNumber()*t.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,a=this.low>>>16,i=this.low&65535,o=t.high>>>16,l=t.high&65535,u=t.low>>>16,c=t.low&65535,d=0,h=0,p=0,f=0;return f+=i*c,p+=f>>>16,f&=65535,p+=a*c,h+=p>>>16,p&=65535,p+=i*u,h+=p>>>16,p&=65535,h+=s*c,d+=h>>>16,h&=65535,h+=a*u,d+=h>>>16,h&=65535,h+=i*l,d+=h>>>16,h&=65535,d+=r*c+s*u+a*l+i*o,d&=65535,Gn(p<<16|f,d<<16|h,this.unsigned)};Ge.mul=Ge.multiply;Ge.divide=function(t){if(li(t)||(t=cl(t)),t.isZero())throw Error("division by zero");if(no){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var n=(this.unsigned?no.div_u:no.div_s)(this.low,this.high,t.low,t.high);return Gn(n,no.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?xh:so;var r,s,a;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return xh;if(t.gt(this.shru(1)))return gQ;a=xh}else{if(this.eq(ja)){if(t.eq(Om)||t.eq(mR))return ja;if(t.eq(ja))return Om;var i=this.shr(1);return r=i.div(t).shl(1),r.eq(so)?t.isNegative()?Om:mR:(s=this.sub(t.mul(r)),a=r.add(s.div(t)),a)}else if(t.eq(ja))return this.unsigned?xh:so;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();a=so}for(s=this;s.gte(t);){r=Math.max(1,Math.floor(s.toNumber()/t.toNumber()));for(var o=Math.ceil(Math.log(r)/Math.LN2),l=o<=48?1:RS(2,o-48),u=ro(r),c=u.mul(t);c.isNegative()||c.gt(s);)r-=l,u=ro(r,this.unsigned),c=u.mul(t);u.isZero()&&(u=Om),a=a.add(u),s=s.sub(c)}return a};Ge.div=Ge.divide;Ge.modulo=function(t){if(li(t)||(t=cl(t)),no){var n=(this.unsigned?no.rem_u:no.rem_s)(this.low,this.high,t.low,t.high);return Gn(n,no.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};Ge.mod=Ge.modulo;Ge.rem=Ge.modulo;Ge.not=function(){return Gn(~this.low,~this.high,this.unsigned)};Ge.and=function(t){return li(t)||(t=cl(t)),Gn(this.low&t.low,this.high&t.high,this.unsigned)};Ge.or=function(t){return li(t)||(t=cl(t)),Gn(this.low|t.low,this.high|t.high,this.unsigned)};Ge.xor=function(t){return li(t)||(t=cl(t)),Gn(this.low^t.low,this.high^t.high,this.unsigned)};Ge.shiftLeft=function(t){return li(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Gn(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):Gn(0,this.low<<t-32,this.unsigned)};Ge.shl=Ge.shiftLeft;Ge.shiftRight=function(t){return li(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Gn(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):Gn(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};Ge.shr=Ge.shiftRight;Ge.shiftRightUnsigned=function(t){if(li(t)&&(t=t.toInt()),t&=63,t===0)return this;var n=this.high;if(t<32){var r=this.low;return Gn(r>>>t|n<<32-t,n>>>t,this.unsigned)}else return t===32?Gn(n,0,this.unsigned):Gn(n>>>t-32,0,this.unsigned)};Ge.shru=Ge.shiftRightUnsigned;Ge.shr_u=Ge.shiftRightUnsigned;Ge.toSigned=function(){return this.unsigned?Gn(this.low,this.high,!1):this};Ge.toUnsigned=function(){return this.unsigned?this:Gn(this.low,this.high,!0)};Ge.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};Ge.toBytesLE=function(){var t=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};Ge.toBytesBE=function(){var t=this.high,n=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};Un.fromBytes=function(t,n,r){return r?Un.fromBytesLE(t,n):Un.fromBytesBE(t,n)};Un.fromBytesLE=function(t,n){return new Un(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,n)};Un.fromBytesBE=function(t,n){return new Un(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],n)};const dKe=Die({__proto__:null,default:fR},[fR]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uh=fR||dKe;function $$(e){return uh.fromString(e,!0,16)}const xQ=$$("c3a5c85c97cb3127"),sh=$$("b492b66fbe98f273"),Ks=$$("9ae16a3b2f90404f");function gR(e){return e.xor(e.shru(47))}function wQ(e,t,n){const r=e.slice(t,t+n);return uh.fromBytes(Array.from(r),!0,!0)}function Fn(e,t){return wQ(e,t,8)}function oG(e,t){return wQ(e,t,4)}function Qr(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Mc(e,t,n=$$("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function hKe(e,t,n,r,s,a){s=s.add(e),a=Qr(a.add(s).add(r),21);const i=s;return s=s.add(t),s=s.add(n),a=a.add(Qr(s,44)),[s.add(r),a.add(i)]}function $k(e,t,n,r){return hKe(Fn(e,t),Fn(e,t+8),Fn(e,t+16),Fn(e,t+24),n,r)}function pKe(e,t=e.length){if(t>=8){const n=Ks.add(t*2),r=Fn(e,0).add(Ks),s=Fn(e,t-8),a=Qr(s,37).mul(n).add(r),i=Qr(r,25).add(s).mul(n);return Mc(a,i,n)}if(t>=4){const n=Ks.add(t*2),r=oG(e,0);return Mc(r.shl(3).add(t),oG(e,t-4),n)}if(t>0){const n=e[0],r=e[t>>1],s=e[t-1],a=n+(r<<8),i=t+(s<<2);return gR(Ks.mul(a).xor(xQ.mul(i))).mul(Ks)}return Ks}function fKe(e,t=e.length){const n=Ks.add(t*2),r=Fn(e,0).mul(sh),s=Fn(e,8),a=Fn(e,t-8).mul(n),i=Fn(e,t-16).mul(Ks);return Mc(Qr(r.add(s),43).add(Qr(a,30)).add(i),r.add(Qr(s.add(Ks),18)).add(a),n)}function mKe(e,t=e.length){const n=Ks.add(t*2),r=Fn(e,0).mul(Ks),s=Fn(e,8),a=Fn(e,t-8).mul(n),i=Fn(e,t-16).mul(Ks),o=Qr(r.add(s),43).add(Qr(a,30)).add(i),l=Mc(o,r.add(Qr(s.add(Ks),18)).add(a),n),u=Fn(e,16).mul(n),c=Fn(e,24),d=o.add(Fn(e,t-32)).mul(n),h=l.add(Fn(e,t-24)).mul(n);return Mc(Qr(u.add(c),43).add(Qr(d,30)).add(h),u.add(Qr(c.add(r),18)).add(d),n)}function gKe(e,t=e.length){const n=uh.fromNumber(81,!0);if(t<=32)return t<=16?pKe(e,t):fKe(e,t);if(t<=64)return mKe(e,t);let r=n,s=n.mul(sh).add(113),a=gR(s.mul(Ks).add(113)).mul(Ks),i=[uh.UZERO,uh.UZERO],o=[uh.UZERO,uh.UZERO];r=r.mul(Ks).add(Fn(e,0));let l=0;const u=(t-1>>6)*64,c=u+(t-1&63)-63;do r=Qr(r.add(s).add(i[0]).add(Fn(e,l+8)),37).mul(sh),s=Qr(s.add(i[1]).add(Fn(e,l+48)),42).mul(sh),r=r.xor(o[1]),s=s.add(i[0]).add(Fn(e,l+40)),a=Qr(a.add(o[0]),33).mul(sh),i=$k(e,l,i[1].mul(sh),r.add(o[0])),o=$k(e,l+32,a.add(o[1]),s.add(Fn(e,l+16))),[a,r]=[r,a],l+=64;while(l!==u);const d=sh.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Qr(r.add(s).add(i[0]).add(Fn(e,l+8)),37).mul(d),s=Qr(s.add(i[1]).add(Fn(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Fn(e,l+40))),a=Qr(a.add(o[0]),33).mul(d),i=$k(e,l,i[1].mul(d),r.add(o[0])),o=$k(e,l+32,a.add(o[1]),s.add(Fn(e,l+16))),[a,r]=[r,a],Mc(Mc(i[0],o[0],d).add(gR(s).mul(xQ)).add(a),Mc(i[1],o[1],d).add(r),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rd(e,t){return t==="string"?Lc(e):Hf([e],t)}function yKe(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Hf(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=rp(e)),xe().getBool("DEBUG")&&X8e(e,t),yKe(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){const n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function ya(){return xe().platform.now()}function Lc(e,t="utf-8"){return t=t||"utf-8",xe().platform.encode(e,t)}function td(e,t="utf-8"){return t=t||"utf-8",xe().platform.decode(e,t)}function rl(e){return xe().platform.isTypedArray!=null?xe().platform.isTypedArray(e):fQ(e)}function rp(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||np(e)||e==null||rl(e)&&n)t.push(e);else if(Array.isArray(e)||rl(e))for(let r=0;r<e.length;++r)rp(e[r],t,n);else{let r=-1;for(const s of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)rp(e[s],t,n)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bKe{constructor(t,n){this.backendTimer=t,this.logger=n,n==null&&(this.logger=new wKe)}profileKernel(t,n,r){let s;const a=()=>{s=r()};let i;const o=ya();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(a);else{a();for(const u of s)u.dataSync();i=Promise.resolve({kernelMs:ya()-o})}if(xe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(d=>{xKe(d,c.dtype,t)})}return{kernelName:t,outputs:s,inputs:n,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:n,outputs:r,timeMs:s,inputs:a,extraInfo:i}=t;r.forEach(o=>{Promise.all([o.data(),s,i]).then(l=>{this.logger.logKernelProfile(n,o,l[0],l[1],a,l[2])})})}}function xKe(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){const s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class wKe{logKernelProfile(t,n,r,s,a,i){const o=typeof s=="number"?jm(`${s}ms`,9):s.error,l=jm(t,25),u=n.rank,c=n.size,d=jm(n.shape.toString(),14);let h="";for(const p in a){const f=a[p];if(f!=null){const m=f.shape||n.shape,g=m.length;h+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${o}	%c${u}D ${d}	%c${c}	%c${h}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vKe(e,t,n){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){const u=e[l],c=u.inputs;for(const d in c){const h=c[d];let p=!1;for(let f=0;f<t.length;f++)if(r[h.id]){u.outputs.forEach(m=>r[m.id]=!0),p=!0,s[u.id]=!0;break}if(p)break}}const a={};a[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const u=e[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(a[u.outputs[d].id]){for(const h in c)a[c[h].id]=!0,i[u.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const u=e[l];if(s[u.id]&&i[u.id]){const c={};for(const h in u.inputs){const p=u.inputs[h];r[p.id]&&(c[h]=p)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,o.push(d)}}return o}function kKe(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach(l=>{const u=e[l.id];u!=null?i.push(u):i.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const l in a.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const u=n(()=>o[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=a.inputs[l];if(!Xt(u.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=u;else{const d=e[c.id];e[c.id]=r(d,u),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lG=20,sx=3,A_=7;function IKe(e,t,n,r){const s=yt(t),a=SKe(e,t,n,s),i=t.length,o=mI(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join(`
`)),l.join(`
`)}function SKe(e,t,n,r){const s=ve(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l=n==="complex64"?Cx(e):e;if(o>1)for(let u=0;u<s/a;u++){const c=u*a;for(let d=0;d<a;d++)i[d]=Math.max(i[d],Sx(l[c+d],0,n).length)}return i}function Sx(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(A_))} + ${parseFloat(e[1].toFixed(A_))}j`:i1(e)?r=`'${e}'`:n==="bool"?r=vQ(e):r=parseFloat(e.toFixed(A_)).toString(),jm(r,t)}function vQ(e){return e===0?"false":"true"}function mI(e,t,n,r,s,a=!0){const i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){const m=Cx(e);return[Sx(m[0],0,n)]}return n==="bool"?[vQ(e[0])]:[e[0].toString()]}if(l===1){if(o>lG){const g=sx*i;let y=Array.from(e.slice(0,g)),b=Array.from(e.slice((o-sx)*i,o*i));return n==="complex64"&&(y=Cx(y),b=Cx(b)),["["+y.map((x,w)=>Sx(x,s[w],n)).join(", ")+", ..., "+b.map((x,w)=>Sx(x,s[o-sx+w],n)).join(", ")+"]"]}return["["+(n==="complex64"?Cx(e):Array.from(e)).map((g,y)=>Sx(g,s[y],n)).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>lG){for(let m=0;m<sx;m++){const g=m*d,y=g+d;h.push(...mI(e.slice(g,y),u,n,c,s,!1))}h.push("...");for(let m=o-sx;m<o;m++){const g=m*d,y=g+d;h.push(...mI(e.slice(g,y),u,n,c,s,m===o-1))}}else for(let m=0;m<o;m++){const g=m*d,y=g+d;h.push(...mI(e.slice(g,y),u,n,c,s,m===o-1))}const p=l===2?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(a?"":f),h}function Cx(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ur{constructor(t,n,r){if(this.dtype=n,this.shape=t.slice(),this.size=ve(t),r!=null){const s=r.length;U(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||yr(n,this.size),this.strides=yt(t)}set(t,...n){n.length===0&&(n=[0]),U(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(const s of t){if(s<0||s>=this.shape[n]){const a=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let r=0;r<t.length-1;++r)n+=this.strides[r]*t[r];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(t/this.strides[r]),t-=n[r]*this.strides[r];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return Mo().makeTensor(this.values,this.shape,this.dtype)}}let Mo=null,bm=null;function CKe(e){Mo=e}function NKe(e){bm=e}class Kn{constructor(t,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=ve(t),this.strides=yt(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return bm.buffer(this.shape,this.dtype,t)}bufferSync(){return bm.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return po(this.shape,t,this.dtype==="complex64")}arraySync(){return po(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Mo().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map(r=>td(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Mo().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Mo().readSync(this.dataId);if(this.dtype==="string")try{return t.map(n=>td(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Mo().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Mo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return bm.print(this,t)}clone(){return this.throwIfDisposed(),bm.clone(this)}toString(t=!1){const n=this.dataSync();return IKe(n,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),bm.cast(this,t)}variable(t=!0,n,r){return this.throwIfDisposed(),Mo().makeVariable(this,t,n,r)}}Object.defineProperty(Kn,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Ce(){return tP("Tensor",()=>Kn)}Ce();class DS extends Kn{constructor(t,n,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=n,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Xt(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Mo().disposeTensor(this),this.dataId=t.dataId,Mo().incRef(this,null)}dispose(){Mo().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(DS,Symbol.hasInstance,{value:e=>e instanceof Kn&&e.assign!=null&&e.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var uG;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(uG||(uG={}));var yR;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(yR||(yR={}));var bR;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(bR||(bR={}));var xR;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(xR||(xR={}));var wR;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(wR||(wR={}));const $Ke={float32:xR,int32:yR,bool:bR,complex64:wR};function ni(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return $Ke[e][t]}function oz(e){return ni(e,"int32")}function kQ(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function IQ(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mr(e,t){if(e.dtype===t.dtype)return[e,t];const n=ni(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function TKe(e,t){U(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function SQ(e){const t=[];return CQ(e,t,new Set),t}function CQ(e,t,n){if(e==null)return;if(e instanceof Kn){t.push(e);return}if(!_Ke(e))return;const r=e;for(const s in r){const a=r[s];n.has(a)||(n.add(a),CQ(a,t,n))}}function _Ke(e){return Array.isArray(e)||typeof e=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R_(e){return e.kernelName!=null}class cG{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Fg{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new cG}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const r=t[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(gi(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(t);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new bKe(this.backendInstance),!0}setupRegisteredKernels(){tG(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){tG(t).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[t])})}initializeBackend(t){const n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof JL)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,a=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,gi(`Initialization of backend ${t} failed`),gi(i.stack||i.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return gi(`Initialization of backend ${t} failed`),gi(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const r=t[n],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const r=this.state.tensorInfo.get(n),s=r.backend,a=this.readSync(n),i=s.refCount(n);s.disposeData(n,!0),r.backend=t,t.move(n,a,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let r=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,n,r){t();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return Fg.nextTensorId++}nextVariableId(){return Fg.nextVariableId++}clone(t){const n=ie.runKernel($1,{x:t}),r={x:t},s=i=>({x:()=>{const o="float32",l={x:i},u={dtype:o};return ie.runKernel(f1,l,u)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,a,{}),n}runKernel(t,n,r){if(this.backendName==null&&this.backend,!(pR(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){const s=this.backend.numDataIds();let a=0;r.forEach(l=>{a+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=s-n-a-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,r=[];const s=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const u=R_(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(R_(t)){const{kernelName:f,inputs:m,attrs:g}=t;this.backendName==null&&this.backend;const y=pR(f,this.backendName);U(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,x);const w=x.map(v=>v.rank!=null?v:this.makeTensorFromTensorInfo(v));if(s){const v=this.getTensorsForGradient(f,m,w);r=this.saveTensorsForBackwardMode(v)}return w}}else{const{forwardFunc:f}=t,m=g=>{s&&(r=g.map(y=>this.keep(this.clone(y))))};o=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,y),y}}const{inputs:c,attrs:d}=t,h=R_(t)?null:t.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(p=this.profiler.profileKernel(u,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),s&&this.addTapeNode(u,c,n,h,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(t,n,r){const s=eG(t);if(s!=null){const a=s.inputsToSave||[],i=s.outputsToSave||[];let o;s.saveAllInputs?(U(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(u=>n[u])):o=a.map(u=>n[u]);const l=r.filter((u,c)=>i[c]);return o.concat(l)}return[]}makeTensor(t,n,r,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=t;r==="string"&&i1(t[0])&&(a=t.map(l=>Lc(l)));const i=s.write(a,n,r),o=new Kn(n,r,i,this.nextTensorId());if(this.trackTensor(o,s),r==="string"){const l=this.state.tensorInfo.get(i),u=Z8e(a);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(t,n,r,s){r=r||"float32";const a={dataId:t,shape:n,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(t,n){const{dataId:r,shape:s,dtype:a}=t,i=new Kn(s,a,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));const a=new DS(t,n,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*$S(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof DS||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const r=t.size*$S(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,r,s,a,i){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:a},l=eG(t);l!=null&&(s=l.gradFunc),s!=null&&(o.gradient=u=>(u=u.map((c,d)=>{if(c==null){const h=r[d],p=Ls(h.size,h.dtype);return this.makeTensor(p,h.shape,h.dtype)}return c}),s(u.length>1?u:u[0],a,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=SQ(t),r=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const i=this.state.activeScope.track[a];!i.kept&&!r.has(i.id)&&i.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(t,n,r,s=!1){if(U(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));U(a instanceof Kn,()=>"The result y returned by f() must be a tensor.");const i=vKe(this.state.activeTape,n,a);if(!s&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[a.id]=r??EKe(a.shape),kKe(o,i,u=>this.tidy(u),AKe);const l=n.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:a,grads:l}})}customGrad(t){return U(oR(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{U(n.every(o=>o instanceof Kn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((o,l)=>{s[l]=o});const a=(o,l)=>(r=t(...n,l),U(r.value instanceof Kn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),U(oR(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(o,l)=>{const u=r.gradFunc(o,l),c=Array.isArray(u)?u:[u];U(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),U(c.every(h=>h instanceof Kn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return c.forEach((h,p)=>{d[p]=()=>h}),d};return this.runKernelFunc({forwardFunc:a,backwardsFunc:i,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){const n=ya(),r=await this.backend.time(t);return r.wallMs=ya()-n,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new cG;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Fg.nextTensorId=0;Fg.nextVariableId=0;function EKe(e){const t=eP(ve(e),"float32");return ie.makeTensor(t,e,"float32")}function NQ(){const e=dQ();if(e._tfengine==null){const t=new eKe(e);e._tfengine=new Fg(t)}return sKe(e._tfengine.ENV),CKe(()=>e._tfengine),e._tfengine}const ie=NQ();function AKe(e,t){const n={a:e,b:t};return ie.runKernel($b,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RKe(){return typeof navigator<"u"&&navigator!=null}function $Q(e){if(e||RKe()){if(e||(e=navigator),e.product==="ReactNative")return!0;const t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){const n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function TQ(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _a=xe();_a.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});_a.registerFlag("IS_BROWSER",()=>TQ());_a.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");_a.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));_a.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));_a.registerFlag("PROD",()=>!1);_a.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>_a.getBool("DEBUG"));_a.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);_a.registerFlag("IS_TEST",()=>!1);_a.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>_a.getBool("DEBUG"));_a.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);_a.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);_a.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dd(e,t){let n=e;if(rl(e))return t==="string"?[]:[e.length];if(kQ(e)){const s=e.channels||"RGBA";return[e.height,e.width*s.length]}else if(IQ(e))return[e.buffer.size/(t==null?4:$S(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||rl(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&xe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&_Q(e,r,[]),r}function _Q(e,t,n){if(n=n||[],!Array.isArray(e)&&!rl(e)){U(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}U(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),U(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const r=t.slice(1);for(let s=0;s<e.length;++s)_Q(e[s],r,n.concat(s))}function dG(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function j(e,t,n,r="numeric"){if(e instanceof Kn)return dG(r,e.dtype,t,n),e;let s=Cb(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),dG(r,s,t,n),e==null||!rl(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){const l=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const a=Dd(e,s);!rl(e)&&!Array.isArray(e)&&(e=[e]);const o=s!=="string"?Hf(e,s):rp(e,[],!0);return ie.makeTensor(o,a,s)}function FS(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,i)=>j(a,`${t}[${i}]`,n,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EQ="__op";function se(e){const t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+EQ;const s=(...a)=>{ie.startScope(n);try{const i=r(...a);return np(i)&&console.error("Cannot return a Promise inside of tidy."),ie.endScope(i),i}catch(i){throw ie.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DKe(e,t){const n=j(e,"real","complex"),r=j(t,"imag","complex");oi(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return ie.runKernel(lP,s)}const nd=se({complex_:DKe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fd(e,t,n,r){if(r==null)r=Cb(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(IQ(e)||kQ(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ie.backend.createTensorFromGPUData(e,t||n,r)}if(!rl(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Pi(t);const s=ve(t),a=ve(n);U(s===a,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${a}`);for(let i=0;i<n.length;++i){const o=n[i],l=i===n.length-1?o!==ve(t.slice(i)):!0;U(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!rl(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?Hf(e,r):rp(e,[],!0),ie.makeTensor(e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qo(e,t,n){const r=Dd(e,n);return Fd(e,t,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vR={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OS=4;async function kR(e,t){const n=[],r=[],s=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<s.length;++i){const o=s[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async d=>{const h=await l.bytes(),p=h.reduce((g,y)=>g+y.length,0)+OS*h.length,f=new Uint8Array(p);let m=0;for(let g=0;g<h.length;g++){const y=h[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(b,m),m+=OS,f.set(y,m),m+=y.length}d(f)});r.push(c)}else r.push(l.data());t!=null&&(u.group=t),n.push(u)}const a=await Promise.all(r);return{data:FKe(a),specs:n}}function AQ(e,t){const n={};let r,s=0;for(const a of t){const i=a.name,o=a.dtype,l=a.shape,u=ve(l);let c;if("quantization"in a){const d=a.quantization;if(d.dtype==="uint8"||d.dtype==="uint16"){if(!("min"in d&&"scale"in d))throw new Error(`Weight ${a.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else if(d.dtype==="float16"){if(o!=="float32")throw new Error(`Weight ${a.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${o}.`)}else throw new Error(`Weight ${a.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const h=vR[d.dtype],p=e.slice(s,s+u*h),f=d.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(o==="float32")if(d.dtype==="uint8"||d.dtype==="uint16"){c=new Float32Array(f.length);for(let m=0;m<f.length;m++){const g=f[m];c[m]=g*d.scale+d.min}}else if(d.dtype==="float16")r===void 0&&(r=BKe()),c=r(f);else throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);else if(o==="int32"){if(d.dtype!=="uint8"&&d.dtype!=="uint16")throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);c=new Int32Array(f.length);for(let m=0;m<f.length;m++){const g=f[m];c[m]=Math.round(g*d.scale+d.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${o}`);s+=u*h}else if(o==="string"){const d=ve(a.shape);c=[];for(let h=0;h<d;h++){const p=new Uint32Array(e.slice(s,s+OS))[0];s+=OS;const f=new Uint8Array(e.slice(s,s+p));c.push(f),s+=p}}else{const d=vR[o],h=e.slice(s,s+u*d);if(o==="float32")c=new Float32Array(h);else if(o==="int32")c=new Int32Array(h);else if(o==="bool")c=new Uint8Array(h);else if(o==="complex64"){c=new Float32Array(h);const p=new Float32Array(c.length/2),f=new Float32Array(c.length/2);for(let y=0;y<p.length;y++)p[y]=c[y*2],f[y]=c[y*2+1];const m=qo(p,l,"float32"),g=qo(f,l,"float32");n[i]=nd(m,g),m.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${o}`);s+=u*d}o!=="complex64"&&(n[i]=qo(c,l,o))}return n}function FKe(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const r=new Uint8Array(t);let s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}const lz=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function hG(e){return lz?Buffer.byteLength(e):new Blob([e]).size}function OKe(e){if(lz)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function MKe(e){if(lz){const r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function T$(e){if(e.length===1)return e[0];let t=0;e.forEach(s=>{t+=s.byteLength});const n=new Uint8Array(t);let r=0;return e.forEach(s=>{n.set(new Uint8Array(s),r),r+=s.byteLength}),n.buffer}function pG(e){const t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);const n=e.split(t);return n[n.length-1]}function RQ(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function DQ(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function uz(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),DQ(e,n,r)}function nv(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:hG(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:hG(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:e.weightData.byteLength}}function FQ(e){const t=[];for(const n of e)t.push(...n.weights);return t}function LKe(){const e=n=>{let r=n<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function PKe(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function zKe(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function BKe(){const e=LKe(),t=PKe(),n=zKe();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){const o=r[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];a[i]=l}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return tr.instance==null&&(tr.instance=new tr),tr.instance}static registerSaveRouter(t){tr.getInstance().saveRouters.push(t)}static registerLoadRouter(t){tr.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return tr.getHandlers(t,"save")}static getLoadHandlers(t,n){return tr.getHandlers(t,"load",n)}static getHandlers(t,n,r){const s=[];return(n==="load"?tr.getInstance().loadRouters:tr.getInstance().saveRouters).forEach(i=>{const o=i(t,r);o!==null&&s.push(o)}),s}}const WKe=e=>tr.registerSaveRouter(e),VKe=e=>tr.registerLoadRouter(e),OQ=e=>tr.getSaveHandlers(e),UKe=(e,t)=>tr.getLoadHandlers(e,t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IR="tensorflowjs",SR=1,wh="models_store",wc="model_info_store";function MQ(){if(!xe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function CR(e){const t=e.result;t.createObjectStore(wh,{keyPath:"modelPath"}),t.createObjectStore(wc,{keyPath:"modelPath"})}class sp{constructor(t){if(this.indexedDB=MQ(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((r,s)=>{const a=this.indexedDB.open(IR,SR);a.onupgradeneeded=()=>CR(a),a.onsuccess=()=>{const i=a.result;if(n==null){const o=i.transaction(wh,"readonly"),u=o.objectStore(wh).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return i.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(u.result.modelArtifacts)},u.onerror=c=>(i.close(),s(u.error)),o.oncomplete=()=>i.close()}else{const o=nv(n),l=i.transaction(wc,"readwrite");let u=l.objectStore(wc),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(h){return s(h)}let d;c.onsuccess=()=>{d=i.transaction(wh,"readwrite");const h=d.objectStore(wh);let p;try{p=h.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:o})}catch(f){return s(f)}p.onsuccess=()=>r({modelArtifactsInfo:o}),p.onerror=f=>{u=l.objectStore(wc);const m=u.delete(this.modelPath);m.onsuccess=()=>(i.close(),s(p.error)),m.onerror=g=>(i.close(),s(p.error))}},c.onerror=h=>(i.close(),s(c.error)),l.oncomplete=()=>{d==null?i.close():d.oncomplete=()=>i.close()}}},a.onerror=i=>s(a.error)})}}sp.URL_SCHEME="indexeddb://";const LQ=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(sp.URL_SCHEME)?GKe(e.slice(sp.URL_SCHEME.length)):null;tr.registerSaveRouter(LQ);tr.registerLoadRouter(LQ);function GKe(e){return new sp(e)}function HKe(e){return e.startsWith(sp.URL_SCHEME)?e.slice(sp.URL_SCHEME.length):e}class jKe{constructor(){this.indexedDB=MQ()}async listModels(){return new Promise((t,n)=>{const r=this.indexedDB.open(IR,SR);r.onupgradeneeded=()=>CR(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(wc,"readonly"),o=a.objectStore(wc).getAll();o.onsuccess=()=>{const l={};for(const u of o.result)l[u.modelPath]=u.modelArtifactsInfo;t(l)},o.onerror=l=>(s.close(),n(o.error)),a.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(t){return t=HKe(t),new Promise((n,r)=>{const s=this.indexedDB.open(IR,SR);s.onupgradeneeded=()=>CR(s),s.onsuccess=()=>{const a=s.result,i=a.transaction(wc,"readwrite"),o=i.objectStore(wc),l=o.get(t);let u;l.onsuccess=()=>{if(l.result==null)return a.close(),r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const c=o.delete(t),d=()=>{u=a.transaction(wh,"readwrite");const p=u.objectStore(wh).delete(t);p.onsuccess=()=>n(l.result.modelArtifactsInfo),p.onerror=f=>r(l.error)};c.onsuccess=d,c.onerror=h=>(d(),a.close(),r(l.error))}},l.onerror=c=>(a.close(),r(l.error)),i.oncomplete=()=>{u==null?a.close():u.oncomplete=()=>a.close()}},s.onerror=a=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wu="/",xm="tensorflowjs_models",PQ="info",qKe="model_topology",KKe="weight_specs",XKe="weight_data",YKe="model_metadata";function zQ(e){return{info:[xm,e,PQ].join(wu),topology:[xm,e,qKe].join(wu),weightSpecs:[xm,e,KKe].join(wu),weightData:[xm,e,XKe].join(wu),modelMetadata:[xm,e,YKe].join(wu)}}function BQ(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function ZKe(e){const t=e.split(wu);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(wu)}function JKe(e){return e.startsWith(ap.URL_SCHEME)?e.slice(ap.URL_SCHEME.length):e}class ap{constructor(t){if(!xe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=zQ(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),s=nv(t);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,OKe(t.weightData));const a={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch{throw BQ(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const o=JSON.parse(a);n.format=o.format,n.generatedBy=o.generatedBy,n.convertedBy=o.convertedBy,o.signature!=null&&(n.signature=o.signature),o.userDefinedMetadata!=null&&(n.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(n.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(n.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(n.trainingConfig=o.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=MKe(i),n}}ap.URL_SCHEME="localstorage://";const WQ=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ap.URL_SCHEME)?QKe(e.slice(ap.URL_SCHEME.length)):null;tr.registerSaveRouter(WQ);tr.registerLoadRouter(WQ);function QKe(e){return new ap(e)}class eXe{constructor(){U(xe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),U(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},n=xm+wu,r=wu+PQ;for(let s=0;s<this.LS.length;++s){const a=this.LS.key(s);if(a.startsWith(n)&&a.endsWith(r)){const i=ZKe(a);t[i]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){t=JKe(t);const n=zQ(t);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return BQ(n),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Km="://";class Hs{constructor(){this.managers={}}static getInstance(){return Hs.instance==null&&(Hs.instance=new Hs),Hs.instance}static registerManager(t,n){U(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Km)&&(t=t.slice(0,t.indexOf(Km))),U(t.length>0,()=>"scheme must not be an empty string.");const r=Hs.getInstance();U(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){const n=Hs.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(Hs.getInstance().managers)}}function gI(e){if(e.indexOf(Km)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Hs.getSchemes().join(",")}`);return{scheme:e.split(Km)[0],path:e.split(Km)[1]}}async function VQ(e,t,n=!1){U(e!==t,()=>`Old path and new path are the same: '${e}'`);const r=tr.getLoadHandlers(e);U(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),U(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);const s=r[0],a=tr.getSaveHandlers(t);U(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),U(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const i=a[0],o=gI(e).scheme,l=gI(e).path,u=o===gI(e).scheme,c=await s.load();n&&u&&await Hs.getManager(o).removeModel(l);const d=await i.save(c);return n&&!u&&await Hs.getManager(o).removeModel(l),d.modelArtifactsInfo}async function tXe(){const e=Hs.getSchemes(),t={};for(const n of e){const r=await Hs.getManager(n).listModels();for(const s in r){const a=n+Km+s;t[a]=r[s]}}return t}async function nXe(e){const t=gI(e);return Hs.getManager(t.scheme).removeModel(t.path)}async function rXe(e,t){return VQ(e,t,!1)}async function sXe(e,t){return VQ(e,t,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aXe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(typeof window>"u"||!xe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return fQ(t)}}if(xe().get("IS_BROWSER")){xe().setPlatform("browser",new aXe);try{Hs.registerManager(ap.URL_SCHEME,new eXe)}catch{}try{Hs.registerManager(sp.URL_SCHEME,new jKe)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iXe={importFetch:()=>require("node-fetch")};let D_;class oXe{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return xe().global.fetch!=null?xe().global.fetch(t,n):(D_==null&&(D_=iXe.importFetch()),D_(t,n))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(t)}decode(t,n){return t.length===0?"":new this.util.TextDecoder(n).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}xe().get("IS_NODE")&&!xe().get("IS_BROWSER")&&xe().setPlatform("node",new oXe);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mt(e,t="float32",n){return t=t||"float32",Pi(e),new Ur(e,t,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lXe(e,t){const n=j(e,"x","cast");if(!Y8e(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return ie.runKernel(f1,r,s)}const Xe=se({cast_:lXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uXe(e){const n={x:j(e,"x","clone","string_or_numeric")};return ie.runKernel($1,n)}const Tu=se({clone_:uXe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UQ(e,t=!1){console.log(e.toString(t))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */NQ();const cXe={buffer:Mt,cast:Xe,clone:Tu,print:UQ};NKe(cXe);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dXe(){ie.disposeVariables()}function xl(){return ie}function NR(){return ie.memory()}function ge(e,t){return ie.tidy(e,t)}function nt(e){SQ(e).forEach(n=>n.dispose())}function ns(e){return ie.keep(e)}function GQ(e,t,n=1){return ie.registerBackend(e,t,n)}function hXe(){return ie.backend}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pXe(e,t){let n=j(e,"a","add"),r=j(t,"b","add");[n,r]=mr(n,r);const s={a:n,b:r};return ie.runKernel($b,s)}const Ee=se({add_:pXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fXe(e,t){let n=j(e,"a","floorDiv"),r=j(t,"b","floorDiv");[n,r]=mr(n,r);const s={a:n,b:r};return ie.runKernel(C1,s)}const cz=se({floorDiv_:fXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mXe(e,t){let n=j(e,"a","div"),r=j(t,"b","div");if([n,r]=mr(n,r),n.dtype==="int32"&&r.dtype==="int32")return cz(n,r);const s={a:n,b:r},a={};return ie.runKernel(x1,s,a)}const ft=se({div_:mXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gXe(e,t){let n=j(e,"a","mul"),r=j(t,"b","mul");[n,r]=mr(n,r);const s={a:n,b:r};return ie.runKernel(M1,s)}const le=se({mul_:gXe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yXe(e){const t=j(e,"x","abs");if(t.dtype==="complex64"){const n={x:t};return ie.runKernel(D2,n)}else{const n={x:t};return ie.runKernel(C2,n)}}const Rr=se({abs_:yXe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bXe(e){const n={x:j(e,"x","acos")};return ie.runKernel(o1,n)}const HQ=se({acos_:bXe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xXe(e){const n={x:j(e,"x","acosh")};return ie.runKernel(l1,n)}const jQ=se({acosh_:xXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wXe(e){U(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),U(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);const t=e.map((s,a)=>j(s,`tensors${a}`,"addN")),n=t[0];t.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!Xt(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=t;return ie.runKernel(N2,r)}const vXe=se({addN_:wXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kXe(e,t=null,n=!1){const s={x:j(e,"x","all","bool")},a={axis:t,keepDims:n};return ie.runKernel(nP,s,a)}const dz=se({all_:kXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IXe(e,t=null,n=!1){const s={x:j(e,"x","any","bool")},a={axis:t,keepDims:n};return ie.runKernel(rP,s,a)}const MS=se({any_:IXe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SXe(e,t=0){const r={x:j(e,"x","argMax")},s={axis:t};return ie.runKernel($2,r,s)}const Og=se({argMax_:SXe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CXe(e,t=0){const r={x:j(e,"x","argMin")},s={axis:t};return ie.runKernel(T2,r,s)}const qQ=se({argMin_:CXe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NXe(e){const n={x:j(e,"x","asin")};return ie.runKernel(u1,n)}const KQ=se({asin_:NXe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Xe(e){const n={x:j(e,"x","asinh")};return ie.runKernel(c1,n)}const XQ=se({asinh_:$Xe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TXe(e){const n={x:j(e,"x","atan")};return ie.runKernel(d1,n)}const YQ=se({atan_:TXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Xe(e,t){let n=j(e,"a","atan2"),r=j(t,"b","atan2");[n,r]=mr(n,r);const s={a:n,b:r};return ie.runKernel(p1,s)}const ZQ=se({atan2_:_Xe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EXe(e){const n={x:j(e,"x","atanh")};return ie.runKernel(h1,n)}const JQ=se({atanh_:EXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rv(e,t,n,r,s="NHWC",a){const i=e[3],o=[...t,i],l=Ku(s);return cs(e,o,n,a,r,null,null,l)}function Co(e,t,n,r,s,a,i="channelsLast"){const[o,l]=R0(t);let u;if(i==="channelsLast")u=[o,l,e[3],e[3]];else if(i==="channelsFirst")u=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return cs(e,u,n,r,s,a,!1,i)}function qu(e,t,n,r,s,a,i="NDHWC"){const[o,l,u]=$R(t);let c,d;if(i==="NDHWC")d="channelsLast",c=[o,l,u,e[4],e[4]];else if(i==="NCDHW")d="channelsFirst",c=[o,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return Od(e,c,n,r,s,!1,d,a)}function cs(e,t,n,r,s,a,i=!1,o="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,d]=e;else if(o==="channelsFirst")[l,d,u,c]=e;else throw new Error(`Unknown dataFormat ${o}`);const[h,p,,f]=t,[m,g]=R0(n),[y,b]=R0(r),x=Xm(h,y),w=Xm(p,b),{padInfo:v,outHeight:k,outWidth:I}=DXe(s,u,c,m,g,x,w,a,o),S=i?f*d:f;let $;return o==="channelsFirst"?$=[l,S,k,I]:o==="channelsLast"&&($=[l,k,I,S]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:k,outWidth:I,outChannels:S,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:e,outShape:$,filterShape:t}}function Od(e,t,n,r,s,a=!1,i="channelsLast",o){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,d,h]=e;else if(i==="channelsFirst")[l,h,u,c,d]=e;else throw new Error(`Unknown dataFormat ${i}`);const[p,f,m,,g]=t,[y,b,x]=$R(n),[w,v,k]=$R(r),I=Xm(p,w),S=Xm(f,v),$=Xm(m,k),{padInfo:N,outDepth:T,outHeight:C,outWidth:E}=FXe(s,u,c,d,y,b,x,I,S,$,o),M=a?g*h:g;let F;return i==="channelsFirst"?F=[l,M,T,C,E]:i==="channelsLast"&&(F=[l,T,C,E,M]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:T,outHeight:C,outWidth:E,outChannels:M,padInfo:N,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:S,effectiveFilterWidth:$,dilationDepth:w,dilationHeight:v,dilationWidth:k,inShape:e,outShape:F,filterShape:t}}function AXe(e,t,n,r,s){r==null&&(r=hz(e,t,n));const a=e[0],i=e[1],o=D0((a-t+2*r)/n+1,s),l=D0((i-t+2*r)/n+1,s);return[o,l]}function RXe(e,t,n,r,s,a){s==null&&(s=hz(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=D0((e[o]-t[o]+2*s)/r[o]+1,a));return i}function hz(e,t,n,r=1){const s=Xm(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function R0(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function $R(e){return typeof e=="number"?[e,e,e]:e}function Xm(e,t){return t<=1?e:e+(e-1)*(t-1)}function DXe(e,t,n,r,s,a,i,o,l){let u,c,d;if(typeof e=="number"){u={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};const p=AXe([t,n],a,r,e,o);c=p[0],d=p[1]}else if(e==="same"){c=Math.ceil(t/r),d=Math.ceil(n/s);const h=Math.max(0,(c-1)*r+a-t),p=Math.max(0,(d-1)*s+i-n),f=Math.floor(h/2),m=h-f,g=Math.floor(p/2),y=p-g;u={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(e==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),d=Math.ceil((n-i+1)/s);else if(typeof e=="object"){const h=l==="channelsLast"?e[1][0]:e[2][0],p=l==="channelsLast"?e[1][1]:e[2][1],f=l==="channelsLast"?e[2][0]:e[3][0],m=l==="channelsLast"?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:h===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},c=D0((t-a+h+p)/r+1,o),d=D0((n-i+f+m)/s+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:c,outWidth:d}}function FXe(e,t,n,r,s,a,i,o,l,u,c){let d,h,p,f;if(e==="valid"&&(e=0),typeof e=="number"){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};const g=RXe([t,n,r,1],[o,l,u],1,[s,a,i],e,c);h=g[0],p=g[1],f=g[2]}else if(e==="same"){h=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const m=(h-1)*s+o-t,g=(p-1)*a+l-n,y=(f-1)*i+u-r,b=Math.floor(m/2),x=m-b,w=Math.floor(g/2),v=g-w,k=Math.floor(y/2),I=y-k;d={top:w,bottom:v,left:k,right:I,front:b,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}function D0(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function rd(e){const[t,n,r]=R0(e);return t===1&&n===1&&r===1}function Ns(e,t){return rd(e)||rd(t)}function ip(e){return R0(e).every(t=>t>0)}function Ku(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function ca(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")U(Rg(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(s=>{U(Rg(s),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OXe(e,t){const r={x:j(e,"x","reshape","string_or_numeric")},s={shape:t};return ie.runKernel(p$,r,s)}const ce=se({reshape_:OXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MXe(e,t,n,r,s){const a=j(e,"x","avgPool","float32"),i=1;U(Ns(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=a,l=!1;a.rank===3&&(l=!0,o=ce(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),ca("avgPool",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let d=ie.runKernel(_2,u,c);return d=Xe(d,a.dtype),l?ce(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const _$=se({avgPool_:MXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LXe(e,t,n,r,s,a="NDHWC"){const i=j(e,"x","avgPool3d","float32");let o=i,l=!1;i.rank===4&&(l=!0,o=ce(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),U(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),U(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),U(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),ca("avgPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let d=ie.runKernel(E2,u,c);return d=Xe(d,o.dtype),l?ce(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const QQ=se({avgPool3d_:LXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PXe(e,t=0){U(e.length>=1,()=>"Pass at least one tensor to concat");const n=FS(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return Tu(n[0]);const r=n,s={axis:t};return ie.runKernel(F2,r,s)}const $r=se({concat_:PXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zXe(e,t,n=!1,r=!1){let s=j(e,"a","matMul"),a=j(t,"b","matMul");[s,a]=mr(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return ie.runKernel(A2,i,o)}const Ut=se({matMul_:zXe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BXe(e){const n={x:j(e,"x","sigmoid","float32")};return ie.runKernel(q1,n)}const zl=se({sigmoid_:BXe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WXe(e,t,n){const r=j(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return ie.runKernel(b$,s,a)}const jt=se({slice_:WXe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VXe(e){const n={x:j(e,"x","tanh","float32")};return ie.runKernel(Q1,n)}const Mg=se({tanh_:VXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UXe(e,t,n,r,s,a){const i=j(e,"forgetBias","basicLSTMCell"),o=j(t,"lstmKernel","basicLSTMCell"),l=j(n,"lstmBias","basicLSTMCell"),u=j(r,"data","basicLSTMCell"),c=j(s,"c","basicLSTMCell"),d=j(a,"h","basicLSTMCell"),h=$r([u,d],1),p=Ut(h,o),f=Ee(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=jt(f,[0,0],y),x=jt(f,[0,g],y),w=jt(f,[0,g*2],y),v=jt(f,[0,g*3],y),k=Ee(le(zl(b),Mg(x)),le(c,zl(Ee(i,w)))),I=le(Mg(k),zl(v));return[k,I]}const GXe=se({basicLSTMCell_:UXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HXe(e,t,n){const r=j(e,"x","batchToSpaceND"),s=t.reduce((o,l)=>o*l);U(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),U(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),U(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);const a={x:r},i={blockShape:t,crops:n};return ie.runKernel(R2,a,i)}const E$=se({batchToSpaceND_:HXe});function jXe(e){let t;return e.rank===0||e.rank===1?t=ce(e,[1,1,1,e.size]):e.rank===2?t=ce(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=ce(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qXe(e,t,n,r,s,a){a==null&&(a=.001);const i=j(e,"x","batchNorm"),o=j(t,"mean","batchNorm"),l=j(n,"variance","batchNorm");let u;s!=null&&(u=j(s,"scale","batchNorm"));let c;r!=null&&(c=j(r,"offset","batchNorm")),U(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:jXe(i),scale:u,offset:c,mean:o,variance:l},p={varianceEpsilon:a},f=ie.runKernel(U2,h,p);return ce(f,i.shape)}const sv=se({batchNorm_:qXe});function KXe(e,t,n,r,s,a){const i=j(e,"x","batchNorm"),o=j(t,"mean","batchNorm"),l=j(n,"variance","batchNorm");let u;s!=null&&(u=j(s,"scale","batchNorm"));let c;return r!=null&&(c=j(r,"offset","batchNorm")),U(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),U(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),U(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&U(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&U(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),sv(i,o,l,c,u,a)}const eee=se({batchNorm2d_:KXe});function XXe(e,t,n,r,s,a){const i=j(e,"x","batchNorm"),o=j(t,"mean","batchNorm"),l=j(n,"variance","batchNorm");let u;s!=null&&(u=j(s,"scale","batchNorm"));let c;return r!=null&&(c=j(r,"offset","batchNorm")),U(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),U(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),U(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&U(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&U(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),sv(i,o,l,c,u,a)}const tee=se({batchNorm3d_:XXe});function YXe(e,t,n,r,s,a){const i=j(e,"x","batchNorm"),o=j(t,"mean","batchNorm"),l=j(n,"variance","batchNorm");let u;s!=null&&(u=j(s,"scale","batchNorm"));let c;return r!=null&&(c=j(r,"offset","batchNorm")),U(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),U(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),U(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&U(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&U(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),sv(i,o,l,c,u,a)}const nee=se({batchNorm4d_:YXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZXe(e,t,n){const r=j(e,"x","bincount"),s=j(t,"weights","bincount");U(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),U(n>=0,()=>`size must be non-negative, but got ${n}.`),U(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const a={x:r,weights:s},i={size:n};return ie.runKernel(iP,a,i)}const ree=se({bincount_:ZXe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JXe(e,t){const n=j(e,"s0","broadcastArgs","int32"),r=j(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return ie.runKernel(oP,s)}const QXe=se({broadcastArgs_:JXe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e7e(e,t){let n=j(e,"broadcastTo","x");const r=n.shape;if(Pi(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const u=n.shape.slice();for(;u.length<t.length;)u.unshift(1);n=ce(n,u)}const s=n.shape,a=Array.from(t);for(let u=t.length-1;u>=0;u--)if(s[u]===t[u])a[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(a.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return Tu(n);const o={x:n},l={reps:a};return ie.runKernel(ev,o,l)}const Ym=se({broadcastTo_:e7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t7e(e){const n={x:j(e,"x","ceil","float32")};return ie.runKernel(m1,n)}const see=se({ceil_:t7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tb(e,t,n){Pi(e),n=n||Cb(t);const r={shape:e,value:t,dtype:n};return ie.runKernel(kP,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n7e(e,t,n){const r=j(e,"x","clipByValue");if(U(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Tb(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return ie.runKernel(g1,s,a)}const ri=se({clipByValue_:n7e});function r7e(e){return $r(e,0)}const aee=se({concat1d_:r7e});function s7e(e,t){return $r(e,t)}const iee=se({concat2d_:s7e});function a7e(e,t){return $r(e,t)}const oee=se({concat3d_:a7e});function i7e(e,t){return $r(e,t)}const lee=se({concat4d_:i7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o7e(e,t,n,r,s="NHWC",a=[1,1],i){const o=j(e,"x","conv2d","float32"),l=j(t,"filter","conv2d","float32");let u=o,c=!1;o.rank===3&&(c=!0,u=ce(o,[1,o.shape[0],o.shape[1],o.shape[2]])),U(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),U(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ca("conv2d",r,i);const d=s==="NHWC"?u.shape[3]:u.shape[1];U(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),U(Ns(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),U(ip(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),U(ip(n),()=>"Error in conv2D: Strides should be larger than 0.");const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=ie.runKernel(O2,h,p);return c?ce(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const sd=se({conv2d_:o7e});function l7e(e,t,n,r,s="NWC",a=1,i){const o=j(e,"x","conv1d"),l=j(t,"filter","conv1d");let u=o,c=!1;o.rank===2&&(c=!0,u=ce(o,[1,o.shape[0],o.shape[1]])),U(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),U(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ca("conv1d",r,i),U(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),U(Ns(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),U(ip(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),U(ip(n),()=>"Error in conv1D: Stride should be larger than 0."),U(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=ce(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=ce(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=sd(h,d,[1,n],r,"NHWC",[1,a],i);return c?ce(g,[g.shape[2],g.shape[3]]):ce(g,[g.shape[0],g.shape[2],g.shape[3]])}const pz=se({conv1d_:l7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u7e(e,t,n,r,s,a="NHWC",i){U(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;t.rank===3&&(u=!0,l=ce(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),U(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),U(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),U(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=a==="NHWC"?o[3]:o[1],d=a==="NHWC"?l.shape[3]:l.shape[1];U(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),U(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),ca("conv2dDerInput",s,i);const h={dy:l,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=ie.runKernel(M2,h,p);return u?ce(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const fz=se({conv2DBackpropInput_:u7e});function c7e(e,t,n,r,s,a){const i=j(e,"x","conv2dTranspose"),o=j(t,"filter","conv2dTranspose");return fz(n,i,o,r,s,"NHWC",a)}const mz=se({conv2dTranspose_:c7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d7e(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=j(e,"x","conv3d"),o=j(t,"filter","conv3d");let l=i,u=!1;i.rank===4&&(u=!0,l=ce(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),U(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),U(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),U(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),U(Ns(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),U(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),U(ip(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),U(ip(n),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:o},d={strides:n,pad:r,dataFormat:s,dilations:a},h=ie.runKernel(L2,c,d);return u?ce(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const uee=se({conv3d_:d7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h7e(e,t,n,r,s){U(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,i=t,o=!1;t.rank===4&&(o=!0,i=ce(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const l=a[4],u=i.shape[4];U(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),U(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),U(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),U(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),U(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c={dy:i,filter:n},d={pad:s,strides:r,inputShape:a},h=ie.runKernel(dP,c,d);return o?ce(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const cee=se({conv3DBackpropInput_:h7e});function p7e(e,t,n,r,s){const a=j(e,"x","conv3dTranspose"),i=j(t,"filter","conv3dTranspose");return cee(n,a,i,r,s)}const dee=se({conv3dTranspose_:p7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f7e(e){const n={x:j(e,"x","cos","float32")};return ie.runKernel(y1,n)}const A$=se({cos_:f7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m7e(e){const n={x:j(e,"x","cosh","float32")};return ie.runKernel(b1,n)}const gz=se({cosh_:m7e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g7e(e,t=0,n=!1,r=!1){const a={x:j(e,"x","cumprod")},i={axis:t,exclusive:n,reverse:r};return ie.runKernel(hP,a,i)}const LS=se({cumprod_:g7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y7e(e,t=0,n=!1,r=!1){const a={x:j(e,"x","cumsum")},i={axis:t,exclusive:n,reverse:r};return ie.runKernel(P2,a,i)}const yz=se({cumsum_:y7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b7e(e,t,n,r=!1){const s=j(e,"x","denseBincount"),a=j(t,"weights","denseBincount");U(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),U(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),U(n>=0,()=>`size must be non-negative, but got ${n}.`),U(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);const i={x:s,weights:a},o={size:n,binaryOutput:r};return ie.runKernel(fP,i,o)}const TR=se({denseBincount_:b7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x7e(e,t,n="NHWC"){const r=j(e,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];U(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),U(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),U(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${r.shape}`),U(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);const o={x:r},l={blockSize:t,dataFormat:n};return ie.runKernel(mP,o,l)}const hee=se({depthToSpace_:x7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w7e(e,t,n,r,s="NHWC",a=[1,1],i){const o=j(e,"x","depthwiseConv2d","float32"),l=j(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;o.rank===3&&(c=!0,u=ce(o,[1,o.shape[0],o.shape[1],o.shape[2]])),U(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),U(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=s==="NHWC"?u.shape[3]:u.shape[1];U(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),ca("depthwiseConv2d",r,i);const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=ie.runKernel(z2,h,p);return c?ce(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const av=se({depthwiseConv2d_:w7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v7e(e){const n={x:j(e,"x","diag")};return ie.runKernel(bP,n)}const k7e=se({diag_:v7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I7e(e,t,n,r,s=[1,1],a="NHWC"){const i=j(e,"x","dilation2d"),o=j(t,"filter","dilation2d");U(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),U(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),U(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=i,u=!1;i.rank===3&&(l=ce(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),U(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const c={x:l,filter:o},d={strides:n,pad:r,dilations:s},h=ie.runKernel(B2,c,d);return u?ce(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const pee=se({dilation2d_:I7e});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lg(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&i===1&&r.unshift(a)}return r}function jr(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(s==null||s===1&&i>1)&&n.unshift(a)}return n}function Nt(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];a==null&&(a=1);let i=t[t.length-s-1];if(i==null&&(i=1),a===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=a;else if(a!==i){const o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else r[n-s-1]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S7e(e,t){let n=j(e,"a","equal","string_or_numeric"),r=j(t,"b","equal","string_or_numeric");[n,r]=mr(n,r),Nt(n.shape,r.shape);const s={a:n,b:r};return ie.runKernel(W2,s)}const sl=se({equal_:S7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C7e(e,t,n){const r=j(t,"a","where"),s=j(n,"b","where"),a=j(e,"condition","where","bool"),i=Nt(Nt(a.shape,r.shape),s.shape),o=Ym(a,i),l=Ym(r,i),u=Ym(s,i),c={condition:o,t:l,e:u};return ie.runKernel(y$,c)}const Fs=se({where_:C7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N7e(e){const n={x:j(e,"x","zerosLike")};return ie.runKernel(N$,n)}const Kt=se({zerosLike_:N7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $7e(e,t){let n=j(e,"a","div"),r=j(t,"b","div");[n,r]=mr(n,r);const s=ft(n,r),a=Kt(s),i=sl(r,a);return Fs(i,a,s)}const fee=se({divNoNan_:$7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T7e(e,t){const n=j(e,"t1","dot"),r=j(t,"t2","dot");U((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(U(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){const i=ce(n,[1,-1]),o=ce(r,[-1,1]),l=Ut(i,o);return ce(l,[])}else if(n.rank===1&&r.rank===2){const i=ce(n,[1,-1]),o=ce(r,[r.shape[0],r.shape[1]]),l=Ut(i,o);return ce(l,[l.size])}else if(n.rank===2&&r.rank===1){const i=ce(r,[-1,1]),o=Ut(n,i);return ce(o,[o.size])}else{const i=ce(r,[r.shape[0],r.shape[1]]);return Ut(n,i)}}const mee=se({dot_:T7e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _7e(e,...t){const n=t.map((s,a)=>j(s,`tensors${a}`,"einsum")),r={equation:e};return ie.runKernel(xP,n,r)}const E7e=se({einsum_:_7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A7e(e){const n={x:j(e,"x","elu","float32")};return ie.runKernel(w1,n)}const iv=se({elu_:A7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R7e(e){let t=j(e,"x","erf");U(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Xe(t,"float32"));const n={x:t};return ie.runKernel(v1,n)}const gee=se({erf_:R7e});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bz(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function yee(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?s.push(e[a++]):s.push(t[i++]);return s}function ds(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);const s=t.map(a=>e[a]);return[n,s]}function br(e,t){const n=t.map(r=>1);return yee(e,n,t)}function $s(e,t,n){U(bz(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function lr(e,t){if(bz(e,t))return null;const n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function Md(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function wr(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D7e(e,t=null,n=!1){const s={x:j(e,"x","max")},a={reductionIndices:t,keepDims:n};return ie.runKernel(Q2,s,a)}const fo=se({max_:D7e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F7e(e,t=null,n=!1){const s={x:j(e,"x","min")},a={axis:t,keepDims:n};return ie.runKernel(r$,s,a)}const F0=se({min_:F7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O7e(e,t){let n=j(e,"base","pow"),r=j(t,"exp","pow");[n,r]=mr(n,r);const s={a:n,b:r};return ie.runKernel(L1,s)}const ad=se({pow_:O7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bt(e,t){if((rl(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&rl(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Fd(e,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M7e(e){const n={x:j(e,"x","sqrt","float32")};return ie.runKernel(X1,n)}const Ps=se({sqrt_:M7e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L7e(e){const t=j(e,"x","square"),n={};return ie.runKernel("Square",{x:t},n)}const En=se({square_:L7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P7e(e,t=null,n=!1){let r=j(e,"x","sum");r.dtype==="bool"&&(r=Xe(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return ie.runKernel(x$,s,a)}const ot=se({sum_:P7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z7e(e,t="euclidean",n=null,r=!1){e=j(e,"x","norm");const s=bee(e,t,n);let a=s.shape;if(r){const i=Bt(n,e.shape);a=br(s.shape,i)}return ce(s,a)}function bee(e,t,n=null){if(e.rank===0)return Rr(e);if(e.rank!==1&&n===null)return bee(ce(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return ot(Rr(e),n);if(t===1/0)return fo(Rr(e),n);if(t===-1/0)return F0(Rr(e),n);if(t==="euclidean"||t===2)return Ps(ot(ad(Rr(e),bt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return fo(ot(Rr(e),n[0]),n[1]-1);if(t===1/0)return fo(ot(Rr(e),n[1]),n[0]);if(t===-1/0)return F0(ot(Rr(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return Ps(ot(En(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const ov=se({norm_:z7e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B7e(e,t=null,n=!1){return ov(e,"euclidean",t,n)}const xee=se({euclideanNorm_:B7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W7e(e){const n={x:j(e,"x","exp")};return ie.runKernel(k1,n)}const Ei=se({exp_:W7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V7e(e,t=0){const n=j(e,"x","expandDims","string_or_numeric");U(t<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:t};return ie.runKernel(V2,r,s)}const xa=se({expandDims_:V7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U7e(e){const n={x:j(e,"x","expm1")};return ie.runKernel(I1,n)}const wee=se({expm1_:U7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G7e(e,t){const n=j(e,"x","tile","string_or_numeric");U(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const r={x:n},s={reps:t};return ie.runKernel(ev,r,s)}const ao=se({tile_:G7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H7e(e,t,n,r="float32"){t==null&&(t=e);const s=Mt([e,t],r),a=e<=t?e:t;for(let o=0;o<a;++o)s.set(1,o,o);const i=ce(s.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return ao(xa(i,0),[n[0],1,1]);if(n.length===2)return ao(xa(xa(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return ao(xa(xa(xa(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const xz=se({eye_:H7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j7e(e){const n={x:j(e,"x","floor","float32")};return ie.runKernel(S1,n)}const lv=se({floor_:j7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q7e(e,t,n=0,r=0){const s=j(e,"x","gather"),a=j(t,"indices","gather","int32"),i={x:s,indices:a},o={axis:n,batchDims:r};return ie.runKernel(G2,i,o)}const uv=se({gather_:q7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K7e(e,t){let n=j(e,"a","greater","string_or_numeric"),r=j(t,"b","greater","string_or_numeric");[n,r]=mr(n,r),Nt(n.shape,r.shape);const s={a:n,b:r};return ie.runKernel(H2,s)}const ui=se({greater_:K7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X7e(e,t){let n=j(e,"a","greaterEqual","string_or_numeric"),r=j(t,"b","greaterEqual","string_or_numeric");[n,r]=mr(n,r),Nt(n.shape,r.shape);const s={a:n,b:r};return ie.runKernel(N1,s)}const Ld=se({greaterEqual_:X7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y7e(e){const n={input:j(e,"input","imag")};return ie.runKernel(NP,n)}const R$=se({imag_:Y7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z7e(e){const n={x:j(e,"x","isFinite")};return ie.runKernel(T1,n)}const vee=se({isFinite_:Z7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J7e(e){const n={x:j(e,"x","isInf")};return ie.runKernel(_1,n)}const kee=se({isInf_:J7e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q7e(e){const n={x:j(e,"x","isNaN")};return ie.runKernel(E1,n)}const Iee=se({isNaN_:Q7e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e9e(e,t=.2){const r={x:j(e,"x","leakyRelu")},s={alpha:t};return ie.runKernel(j2,r,s)}const D$=se({leakyRelu_:e9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t9e(e,t){let n=j(e,"a","less","string_or_numeric"),r=j(t,"b","less","string_or_numeric");[n,r]=mr(n,r),Nt(n.shape,r.shape);const s={a:n,b:r};return ie.runKernel(q2,s)}const O0=se({less_:t9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n9e(e,t){let n=j(e,"a","lessEqual","string_or_numeric"),r=j(t,"b","lessEqual","string_or_numeric");[n,r]=mr(n,r),Nt(n.shape,r.shape);const s={a:n,b:r};return ie.runKernel(K2,s)}const jf=se({lessEqual_:n9e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r9e(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return ie.runKernel($P,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s9e(e,t=5,n=1,r=1,s=.5){const a=j(e,"x","localResponseNormalization");U(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),U(Rg(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=a,o=!1;a.rank===3&&(o=!0,i=ce(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:s},c=ie.runKernel(J2,l,u);return o?ce(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const See=se({localResponseNormalization_:s9e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a9e(e){const n={x:j(e,"x","log","float32")};return ie.runKernel(A1,n)}const Ai=se({log_:a9e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i9e(e){const n={x:j(e,"x","log1p")};return ie.runKernel(R1,n)}const F$=se({log1p_:i9e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o9e(e,t){U(oR(e),()=>"The f passed in variableGrads(f) must be a function"),U(t==null||Array.isArray(t)&&t.every(u=>u instanceof DS),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=t!=null;if(!n){t=[];for(const u in ie.registeredVariables)t.push(ie.registeredVariables[u])}const r=n?t.filter(u=>!u.trainable):null,s=t.length;t=t.filter(u=>u.trainable),U(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const a=!0,{value:i,grads:o}=ie.gradients(e,t,null,a);U(o.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),U(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return t.forEach((u,c)=>{o[c]!=null&&(l[u.name]=o[c])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:i,grads:l}}function Lu(e){return ie.customGrad(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l9e(e){const n={x:j(e,"x","neg")};return ie.runKernel(a$,n)}const Hn=se({neg_:l9e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u9e(e){const n={x:j(e,"x","softplus")};return ie.runKernel(K1,n)}const _b=se({softplus_:u9e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c9e(e){const t=j(e,"x","logSigmoid");return Lu(r=>({value:Hn(_b(Hn(r))),gradFunc:i=>le(i,zl(Hn(r)))}))(t)}const Cee=se({logSigmoid_:c9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d9e(e,t){let n=j(e,"a","sub"),r=j(t,"b","sub");[n,r]=mr(n,r);const s={a:n,b:r};return ie.runKernel(Z1,s)}const rt=se({sub_:d9e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h9e(e,t=-1){const n=j(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Lu((s,a)=>{const o=fo(s,t,!0),l=rt(s,o),u=rt(Xe(l,"float32"),Ai(ot(Ei(l),t,!0)));return a([u]),{value:u,gradFunc:(d,h)=>{const[p]=h,f=!0,m=Ei(p);return rt(d,le(ot(d,t,f),m))}}})(n)}const wz=se({logSoftmax_:h9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p9e(e,t=null,n=!1){const r=j(e,"x","logSumExp"),s=Bt(t,r.shape),a=fo(r,s,!0),i=rt(r,a),o=Ei(i),l=ot(o,s),u=Ai(l),c=Ee(ce(a,u.shape),u);if(n){const d=br(c.shape,s);return ce(c,d)}return c}const vz=se({logSumExp_:p9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f9e(e,t){const n=j(e,"a","logicalAnd","bool"),r=j(t,"b","logicalAnd","bool");Nt(n.shape,r.shape);const s={a:n,b:r};return ie.runKernel(X2,s)}const jl=se({logicalAnd_:f9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m9e(e){const n={x:j(e,"x","logicalNot","bool")};return ie.runKernel(Y2,n)}const O$=se({logicalNot_:m9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g9e(e,t){const n=j(e,"a","logicalOr","bool"),r=j(t,"b","logicalOr","bool");Nt(n.shape,r.shape);const s={a:n,b:r};return ie.runKernel(Z2,s)}const kz=se({logicalOr_:g9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y9e(e,t){const n=j(e,"a","logicalXor","bool"),r=j(t,"b","logicalXor","bool");return Nt(n.shape,r.shape),jl(kz(e,t),O$(jl(e,t)))}const Nee=se({logicalXor_:y9e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tk=2147483648;function b9e(e,t,n="left"){const r=j(e,"sortedSequence","searchSorted"),s=j(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=ce(r,[-1,a]),l=ce(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ve(l.shape)>=Tk)throw new Error(`values tensor size must less than ${Tk}`);if(o.shape[1]>=Tk)throw new Error(`trailing dim_size must less than ${Tk} for int32 output type, was ${o.shape[1]}`);const u={sortedSequence:o,values:l},c={side:n};return ie.runKernel(HP,u,c)}const Iz=se({searchSorted_:b9e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x9e(e,t){return Iz(e,t,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w9e(e,t,n,r,s){const a=j(e,"x","maxPool"),i=1;let o=a,l=!1;a.rank===3&&(l=!0,o=ce(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),U(Ns(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),ca("maxPool",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=ie.runKernel(e$,u,c);return l?ce(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const M$=se({maxPool_:w9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v9e(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=j(e,"x","maxPool3d");let o=i,l=!1;i.rank===4&&(l=!0,o=ce(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),U(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),U(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),ca("maxPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=ie.runKernel(t$,u,c);return l?ce(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const $ee=se({maxPool3d_:v9e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k9e(e,t,n,r,s=!1){const i={x:j(e,"x","maxPoolWithArgmax")},o={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},l=ie.runKernel(AP,i,o);return{result:l[0],indexes:l[1]}}const I9e=se({maxPoolWithArgmax_:k9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S9e(e,t){let n=j(e,"a","maximum"),r=j(t,"b","maximum");[n,r]=mr(n,r),n.dtype==="bool"&&(n=Xe(n,"int32"),r=Xe(r,"int32")),Nt(n.shape,r.shape);const s={a:n,b:r};return ie.runKernel(D1,s)}const Xu=se({maximum_:S9e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C9e(e,t=null,n=!1){const s={x:j(e,"x","mean")},a={axis:t,keepDims:n};return ie.runKernel(n$,s,a)}const dr=se({mean_:C9e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fr(e,t="float32"){if(Pi(e),t==="complex64"){const r=Fr(e,"float32"),s=Fr(e,"float32");return nd(r,s)}const n=Ls(ve(e),t);return ie.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ki(e,t="float32"){if(Pi(e),t==="complex64"){const r=ki(e,"float32"),s=Fr(e,"float32");return nd(r,s)}const n=eP(ve(e),t);return ie.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N9e(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=j(e,"x","meshgrid",e instanceof Kn?e.dtype:"float32");if(t===void 0)return[r];let s=j(t,"y","meshgrid",t instanceof Kn?t.dtype:"float32");const a=ve(r.shape),i=ve(s.shape);return n==="xy"?(r=ce(r,[1,-1]),s=ce(s,[-1,1]),[Ut(ki([i,1],r.dtype),r),Ut(s,ki([1,a],s.dtype))]):(r=ce(r,[-1,1]),s=ce(s,[1,-1]),[Ut(r,ki([1,i],r.dtype)),Ut(ki([a,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $9e(e,t){let n=j(e,"a","minimum"),r=j(t,"b","minimum");[n,r]=mr(n,r),n.dtype==="bool"&&(n=Xe(n,"int32"),r=Xe(r,"int32")),Nt(n.shape,r.shape);const s={a:n,b:r};return ie.runKernel(F1,s)}const op=se({minimum_:$9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T9e(e,t,n){U(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=j(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");U(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)U(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),U(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`);const a={paddings:t,mode:n},i={x:r};return ie.runKernel(s$,i,a)}const Tee=se({mirrorPad_:T9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _9e(e,t){let n=j(e,"a","mod"),r=j(t,"b","mod");[n,r]=mr(n,r);const s={a:n,b:r};return ie.runKernel(O1,s)}const _ee=se({mod_:_9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E9e(e,t=null,n=!1){e=j(e,"x","moments");const r=Bt(t,e.shape),s=dr(e,r,n);let a=s.shape;n||(a=br(s.shape,r));const i=En(rt(Xe(e,"float32"),ce(s,a))),o=dr(i,r,n);return{mean:s,variance:o}}const L$=se({moments_:E9e});function A9e(e,t,n,r){const s=j(t,"data","multiRNNCell"),a=FS(n,"c","multiRNNCell"),i=FS(r,"h","multiRNNCell");let o=s;const l=[];for(let d=0;d<e.length;d++){const h=e[d](o,a[d],i[d]);l.push(h[0]),l.push(h[1]),o=h[1]}const u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}const R9e=se({multiRNNCell_:A9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D9e(e,t,n,r=!1){const s=j(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const l={logits:i===1?ce(s,[1,-1]):s},u={numSamples:t,seed:n,normalized:r},c=ie.runKernel(RP,l,u);return i===1?ce(c,[c.size]):c}const F9e=se({multinomial_:D9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O9e(e,t){let n=j(e,"a","notEqual","string_or_numeric"),r=j(t,"b","notEqual","string_or_numeric");[n,r]=mr(n,r),Nt(n.shape,r.shape);const s={a:n,b:r};return ie.runKernel(i$,s)}const Pg=se({notEqual_:O9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M9e(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const i={indices:j(e,"indices","oneHot","int32")},o={dtype:s,depth:t,onValue:n,offValue:r};return ie.runKernel(l$,i,o)}const Sz=se({oneHot_:M9e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L9e(e){const n={x:j(e,"x","onesLike")};return ie.runKernel(o$,n)}const Ri=se({onesLike_:L9e});function P9e(e,t){const n=j(e,"v1","outerProduct"),r=j(t,"v2","outerProduct");U(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=ce(n,[-1,1]),a=ce(r,[1,-1]);return Ut(s,a)}const z9e=se({outerProduct_:P9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B9e(e,t,n=0){const r=j(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return ie.runKernel(c$,a,s)}const Pd=se({pad_:B9e});function W9e(e,t,n=0){return U(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Pd(e,[t],n)}const V9e=se({pad1d_:W9e});function U9e(e,t,n=0){return U(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Pd(e,t,n)}const G9e=se({pad2d_:U9e});function H9e(e,t,n=0){return U(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Pd(e,t,n)}const j9e=se({pad3d_:H9e});function q9e(e,t,n=0){return U(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Pd(e,t,n)}const K9e=se({pad4d_:q9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X9e(e,t,n){const r=j(e,"x","spaceToBatchND");U(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),U(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),U(r.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const s={x:r},a={blockShape:t,paddings:n};return ie.runKernel(w$,s,a)}const P$=se({spaceToBatchND_:X9e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y9e(e,t,n,r,s,a,i){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");const o=j(e,"x","maxPool");let l=o,u=!1;o.rank===3&&(u=!0,l=ce(o,[1,o.shape[0],o.shape[1],o.shape[2]])),U(Ns(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const c=Co(l.shape,t,a,s,r),d=[c.dilationHeight,c.dilationWidth];let h;r==="same"?h=J9e([c.filterHeight,c.filterWidth],d):h=[[0,0],[0,0]];const p=d[0]===1&&d[1]===1,[f,m]=Z9e([c.inHeight,c.inWidth],d,h),g=p?r:"valid",y=p?l:P$(l,d,f),x=(n==="avg"?()=>_$(y,t,a,g,i):()=>M$(y,t,a,g,i))(),w=p?x:E$(x,d,m);return u?ce(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function Z9e(e,t,n){const r=n.map(c=>c[0]),s=n.map(c=>c[1]),a=e.concat(r,s),i=t.map((c,d)=>(c-a[d]%c)%c),o=s.map((c,d)=>c+i[d]),l=t.map((c,d)=>[r[d],o[d]]),u=t.map((c,d)=>[0,i[d]]);return[l,u]}function J9e(e,t){const r=e.map((i,o)=>i+(i-1)*(t[o]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),a=r.map((i,o)=>i-s[o]);return r.map((i,o)=>[s[o],a[o]])}const Eee=se({pool_:Y9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q9e(e,t){const n=j(e,"x","prelu"),r=j(t,"alpha","prelu"),s={x:n,alpha:r};return ie.runKernel(d$,s)}const z$=se({prelu_:Q9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eYe(e,t=null,n=!1){let r=j(e,"x","prod");r.dtype==="bool"&&(r=Xe(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return ie.runKernel(h$,s,a)}const Aee=se({prod_:eYe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tYe(e,t,n,r){const s=e.map((c,d)=>j(c,`tensors${d}`,"raggedGather","int32")),a=j(t,"paramsDenseValues","raggedGather"),i=j(n,"indices","raggedGather","int32"),o={paramsNestedSplits:s,paramsDenseValues:a,indices:i},l={outputRaggedRank:r},u=ie.runKernel(MP,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const nYe=se({raggedGather_:tYe});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rYe(e,t,n){const r=j(e,"starts","raggedRange"),s=j(t,"limits","raggedRange",r.dtype),a=j(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:s,deltas:a},o=ie.runKernel(LP,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const sYe=se({raggedRange_:rYe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aYe(e,t,n,r,s){const a=j(e,"shape","raggedTensorToTensor","int32"),i=j(t,"values","raggedTensorToTensor"),o=j(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((d,h)=>j(d,`tensors${h}`,"raggedTensorToTensor","int32")),u={shape:a,values:i,defaultValue:o,rowPartitionTensors:l},c={rowPartitionTypes:s};return ie.runKernel(PP,u,c)}const iYe=se({raggedTensorToTensor_:aYe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oYe(e,t,n){Pi(e);const r=ve(e);let s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<r;a++)s[a]=t();return ie.makeTensor(s,e,n)}const lYe=se({rand_:oYe});var _R={},uYe={get exports(){return _R},set exports(e){_R=e}};(function(e){(function(t,n,r){function s(l){var u=this,c=o();u.next=function(){var d=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=d-(u.c=d|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function a(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function i(l,u){var c=new s(l),d=u&&u.state,h=c.next;return h.int32=function(){return c.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,d&&(typeof d=="object"&&a(d,c),h.state=function(){return a(c,{})}),h}function o(){var l=4022871197,u=function(c){c=String(c);for(var d=0;d<c.length;d++){l+=c.charCodeAt(d);var h=.02519603282416938*l;l=h>>>0,h-=l,h*=l,l=h>>>0,h-=l,l+=h*4294967296}return(l>>>0)*23283064365386963e-26};return u}n&&n.exports?n.exports=i:r&&r.amd?r(function(){return i}):this.alea=i})(mi,e,!1)})(uYe);var ER={},cYe={get exports(){return ER},set exports(e){ER=e}};(function(e){(function(t,n,r){function s(o){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},o===(o|0)?l.x=o:u+=o;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function i(o,l){var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var h=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:r&&r.amd?r(function(){return i}):this.xor128=i})(mi,e,!1)})(cYe);var AR={},dYe={get exports(){return AR},set exports(e){AR=e}};(function(e){(function(t,n,r){function s(o){var l=this,u="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:u+=o;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function i(o,l){var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var h=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:r&&r.amd?r(function(){return i}):this.xorwow=i})(mi,e,!1)})(dYe);var RR={},hYe={get exports(){return RR},set exports(e){RR=e}};(function(e){(function(t,n,r){function s(o){var l=this;l.next=function(){var c=l.x,d=l.i,h,p;return h=c[d],h^=h>>>7,p=h^h<<24,h=c[d+1&7],p^=h^h>>>10,h=c[d+3&7],p^=h^h>>>3,h=c[d+4&7],p^=h^h<<7,h=c[d+7&7],h=h^h<<13,p^=h^h<<9,c[d]=p,l.i=d+1&7,p};function u(c,d){var h,p=[];if(d===(d|0))p[0]=d;else for(d=""+d,h=0;h<d.length;++h)p[h&7]=p[h&7]<<15^d.charCodeAt(h)+p[h+1&7]<<13;for(;p.length<8;)p.push(0);for(h=0;h<8&&p[h]===0;++h);for(h==8?p[7]=-1:p[h],c.x=p,c.i=0,h=256;h>0;--h)c.next()}u(l,o)}function a(o,l){return l.x=o.x.slice(),l.i=o.i,l}function i(o,l){o==null&&(o=+new Date);var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var h=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=u.next,d.quick=d,c&&(c.x&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:r&&r.amd?r(function(){return i}):this.xorshift7=i})(mi,e,!1)})(hYe);var DR={},pYe={get exports(){return DR},set exports(e){DR=e}};(function(e){(function(t,n,r){function s(o){var l=this;l.next=function(){var c=l.w,d=l.X,h=l.i,p,f;return l.w=c=c+1640531527|0,f=d[h+34&127],p=d[h=h+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=d[h]=f^p,l.i=h,f+(c^c>>>16)|0};function u(c,d){var h,p,f,m,g,y=[],b=128;for(d===(d|0)?(p=d,d=null):(d=d+"\0",p=0,b=Math.max(b,d.length)),f=0,m=-32;m<b;++m)d&&(p^=d.charCodeAt((m+32)%d.length)),m===0&&(g=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(g=g+1640531527|0,h=y[m&127]^=p+g,f=h==0?f+1:0);for(f>=128&&(y[(d&&d.length||0)&127]=-1),f=127,m=4*128;m>0;--m)p=y[f+34&127],h=y[f=f+1&127],p^=p<<13,h^=h<<17,p^=p>>>15,h^=h>>>12,y[f]=p^h;c.w=g,c.X=y,c.i=f}u(l,o)}function a(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function i(o,l){o==null&&(o=+new Date);var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var h=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=u.next,d.quick=d,c&&(c.X&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:r&&r.amd?r(function(){return i}):this.xor4096=i})(mi,e,!1)})(pYe);var FR={},fYe={get exports(){return FR},set exports(e){FR=e}};(function(e){(function(t,n,r){function s(o){var l=this,u="";l.next=function(){var d=l.b,h=l.c,p=l.d,f=l.a;return d=d<<25^d>>>7^h,h=h-p|0,p=p<<24^p>>>8^f,f=f-d|0,l.b=d=d<<20^d>>>12^h,l.c=h=h-p|0,l.d=p<<16^h>>>16^f,l.a=f-d|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):u+=o;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function a(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function i(o,l){var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var h=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:r&&r.amd?r(function(){return i}):this.tychei=i})(mi,e,!1)})(fYe);var OR={},mYe={get exports(){return OR},set exports(e){OR=e}};const gYe={},yYe=Object.freeze(Object.defineProperty({__proto__:null,default:gYe},Symbol.toStringTag,{value:"Module"})),bYe=Fie(yYe);(function(e){(function(t,n,r){var s=256,a=6,i=52,o="random",l=r.pow(s,a),u=r.pow(2,i),c=u*2,d=s-1,h;function p(w,v,k){var I=[];v=v==!0?{entropy:!0}:v||{};var S=y(g(v.entropy?[w,x(n)]:w??b(),3),I),$=new f(I),N=function(){for(var T=$.g(a),C=l,E=0;T<u;)T=(T+E)*s,C*=s,E=$.g(1);for(;T>=c;)T/=2,C/=2,E>>>=1;return(T+E)/C};return N.int32=function(){return $.g(4)|0},N.quick=function(){return $.g(4)/4294967296},N.double=N,y(x($.S),n),(v.pass||k||function(T,C,E,M){return M&&(M.S&&m(M,$),T.state=function(){return m($,{})}),E?(r[o]=T,C):T})(N,S,"global"in v?v.global:this==r,v.state)}function f(w){var v,k=w.length,I=this,S=0,$=I.i=I.j=0,N=I.S=[];for(k||(w=[k++]);S<s;)N[S]=S++;for(S=0;S<s;S++)N[S]=N[$=d&$+w[S%k]+(v=N[S])],N[$]=v;(I.g=function(T){for(var C,E=0,M=I.i,F=I.j,z=I.S;T--;)C=z[M=d&M+1],E=E*s+z[d&(z[M]=z[F=d&F+C])+(z[F]=C)];return I.i=M,I.j=F,E})(s)}function m(w,v){return v.i=w.i,v.j=w.j,v.S=w.S.slice(),v}function g(w,v){var k=[],I=typeof w,S;if(v&&I=="object")for(S in w)try{k.push(g(w[S],v-1))}catch{}return k.length?k:I=="string"?w:w+"\0"}function y(w,v){for(var k=w+"",I,S=0;S<k.length;)v[d&S]=d&(I^=v[d&S]*19)+k.charCodeAt(S++);return x(v)}function b(){try{var w;return h&&(w=h.randomBytes)?w=w(s):(w=new Uint8Array(s),(t.crypto||t.msCrypto).getRandomValues(w)),x(w)}catch{var v=t.navigator,k=v&&v.plugins;return[+new Date,t,k,t.screen,x(n)]}}function x(w){return String.fromCharCode.apply(0,w)}if(y(r.random(),n),e.exports){e.exports=p;try{h=bYe}catch{}}else r["seed"+o]=p})(typeof self<"u"?self:mi,[],Math)})(mYe);var xYe=_R,wYe=ER,vYe=AR,kYe=RR,IYe=DR,SYe=FR,qf=OR;qf.alea=xYe;qf.xor128=wYe;qf.xorwow=vYe;qf.xorshift7=kYe;qf.xor4096=IYe;qf.tychei=SYe;var B$=qf;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cz{constructor(t,n,r,s,a){this.mean=t,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=a||Math.random();this.random=B$.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,n,r=!1;for(;!r;){let s,a,i;do s=2*this.random()-1,a=2*this.random()-1,i=s*s+a*a;while(i>=1||i===0);const o=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*s*o,n=this.mean+this.stdDev*a*o,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class CYe{constructor(t,n,r,s){this.alpha=t,this.beta=1/n,this.dtype=r;const a=s||Math.random();this.randu=B$.alea(a.toString()),this.randn=new Cz(0,1,r,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,n,r,s,a,i;for(;;){do s=this.randn.nextValue(),i=1+this.c*s;while(i<=0);if(i*=i*i,t=s*s,n=1-.331*t*t,r=.5*t+this.d*(1-i+Math.log(i)),a=this.randu(),a<n||Math.log(a)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}}class NYe{constructor(t=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=n-t,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`);this.random=B$.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ye(e,t,n=1,r="float32",s){if(Pi(e),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const a=new CYe(t,n,r,s),i=Mt(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const TYe=se({randomGamma_:$Ye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ye(e,t=0,n=1,r,s){if(Pi(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const a=new Cz(t,n,r,!1,s),i=Mt(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Nz=se({randomNormal_:_Ye});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EYe(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return Nz(e,0,1,t,n)}const AYe=se({randomStandardNormal_:EYe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RYe(e,t=0,n=1,r="float32",s){Pi(e);const a=Mt(e,r),i=new NYe(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const Eb=se({randomUniform_:RYe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zg(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return ie.runKernel(zP,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DYe(e){const n={input:j(e,"input","real")};return ie.runKernel(BP,n)}const M0=se({real_:DYe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FYe(e){const n={x:j(e,"x","reciprocal")};return ie.runKernel(P1,n)}const Ree=se({reciprocal_:FYe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OYe(e){const n={x:j(e,"x","relu")};return ie.runKernel(z1,n)}const Ql=se({relu_:OYe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MYe(e){const n={x:j(e,"x","relu6")};return ie.runKernel(B1,n)}const $z=se({relu6_:MYe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LYe(e,t){const r={x:j(e,"x","reverse")},s={dims:t};return ie.runKernel(g$,r,s)}const bo=se({reverse_:LYe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PYe(e){const t=j(e,"x","reverse");return U(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),bo(t,0)}const zYe=se({reverse1d_:PYe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BYe(e,t){const n=j(e,"x","reverse");return U(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),bo(n,t)}const WYe=se({reverse2d_:BYe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VYe(e,t){const n=j(e,"x","reverse");return U(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),bo(n,t)}const UYe=se({reverse3d_:VYe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GYe(e,t){const n=j(e,"x","reverse");return U(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),bo(n,t)}const HYe=se({reverse4d_:GYe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jYe(e){const n={x:j(e,"x","round")};return ie.runKernel(W1,n)}const Tz=se({round_:jYe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qYe(e){const n={x:j(e,"x","rsqrt","float32")};return ie.runKernel(V1,n)}const _z=se({rsqrt_:qYe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KYe(e){const n={x:j(e,"x","selu")};return ie.runKernel(U1,n)}const Ez=se({selu_:KYe});function XYe(e,t,n,r,s,a=[1,1],i="NHWC"){const o=j(e,"x","separableConv2d"),l=j(t,"depthwiseFilter","separableConv2d"),u=j(n,"pointwiseFilter","separableConv2d");let c=o,d=!1;if(o.rank===3&&(d=!0,c=ce(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");U(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),U(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),U(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),U(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),U(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],p=l.shape[3];U(u.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`);const f=av(c,l,r,s,i,a),g=sd(f,u,1,"valid",i);return d?ce(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Az=se({separableConv2d_:XYe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function YYe(e,t){const n=j(e,"x","setdiff1d"),r=j(t,"y","setdiff1d");U(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),U(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),U(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let c=0;c<s.length;c++)i.has(s[c])||o++;const l=new Ur([o],n.dtype),u=new Ur([o],"int32");for(let c=0,d=0;c<s.length;c++)i.has(s[c])||(l.values[d]=s[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]}const ZYe=YYe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JYe(e){const n={x:j(e,"x","sign")};return ie.runKernel(j1,n)}const Dee=se({sign_:JYe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QYe(e){const n={x:j(e,"x","sin","float32")};return ie.runKernel(G1,n)}const Rz=se({sin_:QYe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eZe(e){const n={x:j(e,"x","sinh")};return ie.runKernel(H1,n)}const Dz=se({sinh_:eZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tZe(e,t,n){const r=j(e,"x","slice1d");return U(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),jt(r,[t],[n])}const W$=se({slice1d_:tZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nZe(e,t,n){const r=j(e,"x","slice2d");return U(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),jt(r,t,n)}const Fz=se({slice2d_:nZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rZe(e,t,n){const r=j(e,"x","slice3d");return U(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),jt(r,t,n)}const V$=se({slice3d_:rZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sZe(e,t,n){const r=j(e,"x","slice4d");return U(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),jt(r,t,n)}const L0=se({slice4d_:sZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aZe(e,t=-1){const n=j(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return ie.runKernel(k$,r,s)}const U$=se({softmax_:aZe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iZe(e){U(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return ie.runKernel(vP,t)}const G$=se({fft_:iZe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oZe(e){U(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return ie.runKernel(CP,t)}const P0=se({ifft_:oZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lZe(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=ce(e,[n,t]);r=P0(s)}else{const s=[n,2*(t-1)],a=ce(M0(e),[n,t]),i=ce(R$(e),[n,t]),o=bo(jt(a,[0,1],[n,t-2]),1),l=le(bo(jt(i,[0,1],[n,t-2]),1),bt(-1)),u=$r([a,o],1),c=$r([i,l],1),d=ce(nd(u,c),[s[0],s[1]]);r=P0(d)}if(r=M0(r),e.rank===3&&e.shape[0]!==0){const s=r,a=e.shape[0];r=ce(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}const Oz=se({irfft_:lZe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uZe(e,t,n=0){const s={x:j(e,"x","split")},a={numOrSizeSplits:t,axis:n};return ie.runKernel(v$,s,a)}const Za=se({split_:uZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cZe(e,t){U(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(t!=null&&t<n){const f=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,s=jt(e,f,m),n=t}else if(t!=null&&t>n){const f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,s=$r([e,Fr(f)],e.shape.length-1),n=t}else s=e;const a=Kt(s),i=ce(nd(s,a),[r,n]),o=G$(i),l=Math.floor(n/2)+1,u=M0(o),c=R$(o),d=Za(u,[l,n-l],u.shape.length-1),h=Za(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,ce(nd(d[0],h[0]),p)}const H$=se({rfft_:cZe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dZe(e,t){let n=j(e,"a","squaredDifference"),r=j(t,"b","squaredDifference");[n,r]=mr(n,r),Nt(n.shape,r.shape);const s={a:n,b:r},a={};return ie.runKernel(Y1,s,a)}const Mz=se({squaredDifference_:dZe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hZe(e,t){const n=j(e,"x","squeeze","string_or_numeric");return ce(n,Ad(n.shape,t).newShape)}const Kf=se({squeeze_:hZe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pZe(e,t=0){const n=FS(e,"tensors","stack","string_or_numeric");U(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&U(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:t};return ie.runKernel(u$,r,s)}const Di=se({stack_:pZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fZe(e,t=0){const r={x:j(e,"x","step")},s={alpha:t};return ie.runKernel(tv,r,s)}const Ab=se({step_:fZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mZe(e,t,n,r,s=0,a=0,i=0,o=0,l=0){const c={x:j(e,"x","stridedSlice","string_or_numeric")},d={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return ie.runKernel(JP,c,d)}const Fee=se({stridedSlice_:mZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gZe(e){const n={x:j(e,"x","tan","float32")};return ie.runKernel(J1,n)}const Oee=se({tan_:gZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(e,t){Sb(e);const n=Dd(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Fd(e,null,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hx(e,t,n){if(Sb(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Dd(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Fd(e,t,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mee(e,t,n){if(Sb(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=Dd(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Fd(e,t,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yZe(e,t,n){if(Sb(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=Dd(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Fd(e,t,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bZe(e,t,n){if(Sb(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=Dd(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Fd(e,t,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xZe(e,t,n){if(Sb(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=Dd(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,Fd(e,t,r,n)}function Lee(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+` update.rank != ${s+e.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function Lz(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Lee(n,t,e)}function Xf(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let d=s;d<a;++d)i*=n[d];const o=s<1?1:s,l=ve(t.shape)/o,u=[...yt(n.slice(0,s)),1],c=ve(n);return{sliceRank:s,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wZe(e,t,n){const r=j(e,"tensor","tensorScatterupdate"),s=j(t,"indices","tensorScatterupdate","int32"),a=j(n,"updates","tensorScatterupdate");if(Lz(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);const i={tensor:r,indices:s,updates:a},o={};return ie.runKernel(GP,i,o)}const vZe=se({tensorScatterUpdate_:wZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kZe(e,t=1,n=!0){const r=j(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,l]=ie.runKernel(nz,a,i);return{values:o,indices:l}}const Pee=se({topk_:kZe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IZe(e,t=0,n=1,r,s){if(Pi(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new Cz(t,n,r,!0,s),i=Mt(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Pz=se({truncatedNormal_:IZe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SZe(e,t=0){const n=j(e,"x","unique","string_or_numeric");U(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:t},[a,i]=ie.runKernel(sz,r,s);return{values:a,indices:i}}const zee=se({unique_:SZe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CZe(e,t,n){const r=j(e,"x","unsortedSegmentSum"),s=j(t,"segmentIds","unsortedSegmentSum","int32");U(Rg(n),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:s},i={numSegments:n};return ie.runKernel(C$,a,i)}const zz=se({unsortedSegmentSum_:CZe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NZe(e,t=0){const n=j(e,"x","unstack","string_or_numeric");U(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:t};return ie.runKernel(S$,r,s)}const xo=se({unstack_:NZe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ze(e,t){return Iz(e,t,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bee(e,t=!0,n,r){return ie.makeVariable(e,t,n,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bz(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const r=Mt(e,"int32"),s=Mt([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const i=r.indexToLoc(n[a]),o=a*e.length;s.values.set(i,o)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function TZe(e){const t=j(e,"condition","whereAsync","bool"),n=await t.data(),r=Bz(t.shape,n);return e!==t&&t.dispose(),r}const Wee=TZe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function _Ze(e,t,n){const r=j(e,"tensor","boolMask"),s=j(t,"mask","boolMask","bool"),a=n??0,i=s.rank,o=r.shape;U(i>0,()=>"mask cannot be scalar"),oi(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=a;m<a+i;m++)l*=o[m];const u=o.slice(0,a).concat([l],o.slice(a+i)),c=ce(r,u),d=ce(s,[-1]),h=await Wee(d),p=Kf(h,[1]),f=uv(c,p,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f}const EZe=_Ze;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AZe(e,t,n){const r=j(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),U(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{U(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return r.dtype==="complex64"?ge(()=>{let i=M0(r),o=R$(r);return i=ie.runKernel(qm,{x:i},a),o=ie.runKernel(qm,{x:o},a),n&&(o=Hn(o)),nd(i,o)}):ie.runKernel(qm,s,a)}const qt=se({transpose_:AZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RZe(e,t,n,r,s=!0){const a=j(e,"v","movingAverage"),i=j(t,"x","movingAverage"),o=j(n,"decay","movingAverage");TKe(a,i),U(Xt(a.shape,i.shape),()=>"Shape mismatch in v and x");const l=bt(1),u=rt(l,o);let c=le(rt(i,a),u);if(s){U(r!=null,()=>"When using zeroDebias: true, step is required.");const d=j(r,"step","movingAverage");c=ft(c,rt(l,ad(o,d)))}return Ee(a,c)}const DZe=se({movingAverage_:RZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FZe(e,t,n){Pi(n);const r=j(e,"indices","scatterND","int32"),s=j(t,"updates","scatterND");Lz(s,r,n);const a={indices:r,updates:s},i={shape:n};return ie.runKernel(UP,a,i)}const OZe=se({scatterND_:FZe});function MZe(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(!(t.rank===0||t.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LZe(e,t,n,r=0){Pi(n);const s=j(e,"sparseIndices","sparseToDense","int32"),a=j(t,"sparseValues","sparseToDense","string_or_numeric"),i=j(r,"defaultValue","sparseToDense",a.dtype);MZe(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},l={outputShape:n};return ie.runKernel(YP,o,l)}const PZe=se({sparseToDense_:LZe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zZe(e,t){const n=j(t,"indices","gatherND","int32"),s={params:j(e,"x","gatherND","string_or_numeric"),indices:n};return ie.runKernel(SP,s)}const BZe=se({gatherND_:zZe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WZe(e,t){if(t==null)return e.shape.slice();if(Xt(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VZe(e,t,n,r){const s=j(e,"x","dropout");if(U(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),U(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Kn?s.clone():s;const a=WZe(s,n),i=1-t,o=ft(lv(Ee(Eb(a,0,1,"float32",r),i)),i);return le(s,o)}const Vee=se({dropout_:VZe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uee(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Wz(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return ka(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function UZe(e,t,n=1){const r=j(e,"predictions","inTopK"),s=j(t,"targets","inTopK");U(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),U(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),oi(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];U(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);const i=await r.data(),o=await s.data(),[l,u]=[i.length/a,a],c=Is("bool",l);for(let d=0;d<l;d++){const h=d*u,p=i.subarray(h,h+u),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,g)=>g.value-m.value),c[d]=0;for(let m=0;m<n;m++)if(f[m].index===o[d]){c[d]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),qo(c,s.shape,"bool")}const GZe=UZe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HZe(e,t,n,r,s,a="NHWC",i){let o=e;e.rank===3&&(o=ce(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=ce(t,[1,t.shape[0],t.shape[1],t.shape[2]])),U(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),U(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),U(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u=a==="NHWC"?o.shape[3]:o.shape[1],c=a==="NHWC"?l.shape[3]:l.shape[1];U(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),U(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),ca("conv2dDerFilter",s,i);const d={x:o,dy:l},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return ie.runKernel(uP,d,h)}const Vz=se({conv2DBackpropFilter_:HZe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j$(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return le(e,Ab(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function q$(e,t){let n=t;const r=jr(e.shape,t.shape);return r.length>0&&(n=ot(n,r)),ce(n,e.shape)}function K$(e,t,n,r){if(t==="linear")return e;if(t==="relu")return Ql(e);if(t==="elu")return iv(e);if(t==="relu6")return $z(e);if(t==="prelu")return z$(e,n);if(t==="leakyrelu")return D$(e,r);if(t==="sigmoid")return zl(e);throw new Error(`Unknown fused activation ${t}.`)}const X$=(e,t)=>!(e>0)||t==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jZe({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",X$(ie.state.gradientDepth,l)===!1){U(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=sd(e,t,n,r,s,a,i);return o!=null&&(k=Ee(k,o)),K$(k,l,u,c)}const d=j(e,"x","conv2d","float32"),h=j(t,"filter","conv2d","float32");let p=d,f=!1;d.rank===3&&(f=!0,p=ce(d,[1,d.shape[0],d.shape[1],d.shape[2]])),U(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),U(h.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),ca("fused conv2d",r,i);const m=s==="NHWC"?p.shape[3]:p.shape[1];U(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),U(Ns(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const g=cs(p.shape,h.shape,n,a,r,i);let y;o!=null&&(y=j(o,"bias","fused conv2d"),[y]=mr(y,d),s==="NHWC"?Nt(g.outShape,y.shape):(U(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),U(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(u!=null){const k=u.shape;if(U(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)U(k[0]===1||k[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${g.outChannels}).`);else if(k.length===3)try{Nt(k,g.outShape)}catch{const S=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(S)}b=j(u,"prelu weights","fused conv2d")}const x=(k,I)=>{U(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[S,$,N,T]=I,C=j$(k,N,l);U(rd(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const E=fz($.shape,C,S,n,r),M=Vz($,C,S.shape,n,r),F=[E,M];if(T!=null){const z=q$(T,C);F.push(z)}return F},w={x:p,filter:h,bias:y,preluActivationWeights:b},v={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?Lu((I,S,$)=>{let N=ie.runKernel(_S,w,v);return $([S,I,N]),f&&(N=ce(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:x}})(p,h):Lu((I,S,$,N)=>{let T=ie.runKernel(_S,w,v);return N([S,I,T,$]),f&&(T=ce(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:x}})(p,h,y)}const Gee=se({fusedConv2d_:jZe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qZe(e,t,n,r,s,a=[1,1],i){let o=e;e.rank===3&&(o=ce(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=ce(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return ie.runKernel(gP,u,c)}const Hee=se({depthwiseConv2dNativeBackpropFilter_:qZe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KZe(e,t,n,r,s,a=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=ce(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},d=ie.runKernel(yP,u,c);return l?ce(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const jee=se({depthwiseConv2dNativeBackpropInput_:KZe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XZe({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(X$(ie.state.gradientDepth,l)===!1){let v=av(e,t,n,r,s,a,i);return o!=null&&(v=Ee(v,o)),K$(v,l,u,c)}const d=j(e,"x","depthwiseConv2d","float32"),h=j(t,"filter","depthwiseConv2d","float32");let p=d,f=!1;d.rank===3&&(f=!0,p=ce(d,[1,d.shape[0],d.shape[1],d.shape[2]])),U(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),U(h.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),U(p.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),a==null&&(a=[1,1]),U(Ns(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),ca("fused depthwiseConv2d",r,i);const m=cs(p.shape,h.shape,n,a,r,i,!0);let g;o!=null&&(g=j(o,"bias","fused conv2d"),[g]=mr(g,d),Nt(m.outShape,g.shape));let y;u!=null&&(y=j(u,"prelu weights","fused depthwiseConv2d"));const b=(v,k)=>{U(rd(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[I,S,$,N]=k,T=j$(v,$,l),C=jee(S.shape,T,I,n,r,a,i),E=Hee(S,T,I.shape,n,r,a,i);if(N!=null){const M=q$(g,T);return[C,E,M]}return[C,E]},x={x:p,filter:h,bias:g,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?Lu((k,I,S)=>{let $=ie.runKernel(ES,x,w);return S([I,k,$]),f&&($=ce($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:b}})(p,h):Lu((k,I,S,$)=>{let N=ie.runKernel(ES,x,w);return $([I,k,N,S]),f&&(N=ce(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:b}})(p,h,g)}const YZe=se({fusedDepthwiseConv2d_:XZe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZZe({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(X$(ie.state.gradientDepth,a)===!1){let T=Ut(e,t,n,r);return s!=null&&(T=Ee(T,s)),K$(T,a,i,o)}let l=j(e,"a","fused matMul"),u=j(t,"b","fused matMul");[l,u]=mr(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=ve(f),y=ve(m);U(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);const x=Nt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),w=n?ce(l,[g,c,h]):ce(l,[g,h,c]),v=r?ce(u,[y,p,d]):ce(u,[y,d,p]);let k;s!=null&&(k=j(s,"bias","fused matMul"),[k]=mr(k,l),Nt(x,k.shape));let I;i!=null&&(I=j(i,"prelu weights","fused matMul"));const S=(T,C)=>{const[E,M,F,z]=C,H=j$(ce(T,F.shape),F,a);let P,O;if(!n&&!r?(P=Ut(H,M,!1,!0),O=Ut(E,H,!0,!1)):!n&&r?(P=Ut(H,M,!1,!1),O=Ut(H,E,!0,!1)):n&&!r?(P=Ut(M,H,!1,!0),O=Ut(E,H,!1,!1)):(P=Ut(M,H,!0,!0),O=Ut(H,E,!0,!0)),s!=null){const L=q$(z,H);return[P,O,L]}else return[P,O]},$={a:w,b:v,bias:k,preluActivationWeights:I},N={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};return s==null?Lu((C,E,M)=>{const F=ie.runKernel(TS,$,N);return M([C,E,F]),{value:ce(F,x),gradFunc:S}})(w,v):Lu((C,E,M,F)=>{const z=ie.runKernel(TS,$,N);return F([C,E,z,M]),{value:ce(z,x),gradFunc:S}})(w,v,k)}const MR=se({fusedMatMul_:ZZe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JZe=Object.freeze(Object.defineProperty({__proto__:null,conv2d:Gee,depthwiseConv2d:YZe,matMul:MR},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QZe(e){return Wz(e,.54,.46)}const eJe=se({hammingWindow_:QZe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tJe(e){return Wz(e,.5,.5)}const qee=se({hannWindow_:tJe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nJe(e,t,n,r=!1,s=0){let a=0;const i=[];for(;a+t<=e.size;)i.push(jt(e,a,t)),a+=n;if(r)for(;a<e.size;){const o=a+t-e.size,l=$r([jt(e,a,t-o),Tb([o],s)]);i.push(l),a+=n}return i.length===0?Hx([],[0,t]):ce($r(i),[i.length,t])}const Kee=se({frame_:nJe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rJe(e,t,n,r,s=qee){r==null&&(r=Uee(t));const a=Kee(e,t,n),i=le(a,s(t));return H$(i,r)}const sJe=se({stft_:rJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aJe(e,t,n,r,s="bilinear",a=0){const i=j(e,"image","cropAndResize"),o=j(t,"boxes","cropAndResize","float32"),l=j(n,"boxInd","cropAndResize","int32"),u=o.shape[0];U(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),U(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),U(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),U(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),U(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),U(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:i,boxes:o,boxInd:l},d={method:s,extrapolationValue:a,cropSize:r};return ie.runKernel(pP,c,d)}const iJe=se({cropAndResize_:aJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oJe(e){const t=j(e,"image","flipLeftRight","float32");U(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};return ie.runKernel(IP,n,{})}const lJe=se({flipLeftRight_:oJe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uJe(e){const t=j(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];U(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),U(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,ao(t,s)}const cJe=se({grayscaleToRGB_:uJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dJe(e,t,n=0,r=.5){const s=j(e,"image","rotateWithOffset","float32");U(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const a={image:s},i={radians:t,fillValue:n,center:r};return ie.runKernel(az,a,i)}const hJe=se({rotateWithOffset_:dJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rb(e,t,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);const i=e.shape[0];return n=Math.min(n,i),U(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),U(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),U(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),U(t.rank===1,()=>"scores must be a 1D tensor"),U(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),U(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pJe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=j(e,"boxes","nonMaxSuppression","float32"),i=j(t,"scores","nonMaxSuppression","float32"),o=Rb(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return ie.runKernel(DP,{boxes:a,scores:i},l)}const fJe=se({nonMaxSuppression_:pJe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mJe(e,t,n){const r=gJe(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function gJe(e,t,n){return bJe(e,t,n||yJe)}function yJe(e,t){return e>t?1:e<t?-1:0}function bJe(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uz(e,t,n,r,s){return jz(e,t,n,r,s,0)}function Gz(e,t,n,r,s,a){return jz(e,t,n,r,s,0,!1,a,!0)}function Hz(e,t,n,r,s,a){return jz(e,t,n,r,s,a,!0)}function jz(e,t,n,r,s,a,i=!1,o=!1,l=!1){const u=[];for(let g=0;g<t.length;g++)t[g]>s&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(fG);const c=a>0?-.5/a:0,d=[],h=[];for(;d.length<n&&u.length>0;){const g=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:x}=g;if(y<s)break;let w=!1;for(let v=d.length-1;v>=x;--v){const k=xJe(e,b,d[v]);if(k>=r){w=!0;break}if(g.score=g.score*wJe(r,c,k),g.score<=s)break}g.suppressBeginIndex=d.length,w||(g.score===y?(d.push(b),h.push(g.score)):g.score>s&&mJe(u,g,fG))}const p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function xJe(e,t,n){const r=e.subarray(t*4,t*4+4),s=e.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(a,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(p+f-x)}function wJe(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function fG(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function vJe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=j(e,"boxes","nonMaxSuppressionAsync"),i=j(t,"scores","nonMaxSuppressionAsync"),o=Rb(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=Uz(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),ka(d,"int32")}const kJe=vJe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IJe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=j(e,"boxes","nonMaxSuppression"),o=j(t,"scores","nonMaxSuppression"),l=Rb(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},d=ie.runKernel(OP,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}const SJe=se({nonMaxSuppressionWithScore_:IJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function CJe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=j(e,"boxes","nonMaxSuppressionAsync"),o=j(t,"scores","nonMaxSuppressionAsync"),l=Rb(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=Hz(c,d,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ka(h,"int32"),selectedScores:ka(p)}}const NJe=CJe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Je(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=j(e,"boxes","nonMaxSuppression"),o=j(t,"scores","nonMaxSuppression"),l=Rb(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,h={boxes:i,scores:o},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:a},f=ie.runKernel(FP,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}const TJe=se({nonMaxSuppressionPadded_:$Je});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function _Je(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=j(e,"boxes","nonMaxSuppressionAsync"),o=j(t,"scores","nonMaxSuppressionAsync"),l=Rb(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=Gz(h,p,u,c,d,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ka(f,"int32"),validOutputs:bt(m,"int32")}}const EJe=_Je;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AJe(e,t,n=!1,r=!1){const s=j(e,"images","resizeBilinear");U(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),U(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),U(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=ce(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=ie.runKernel(m$,o,l);return i?ce(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const Xee=se({resizeBilinear_:AJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RJe(e,t,n=!1,r=!1){const s=j(e,"images","resizeNearestNeighbor");U(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),U(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),U(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),U(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=ce(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=ie.runKernel(f$,o,l);return i?ce(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const Yee=se({resizeNearestNeighbor_:RJe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DJe(e,t="binary",n=!1,r=.5){const s=j(e,"image","threshold"),a=.2989,i=.587,o=.114,l=s.shape[0]*s.shape[1];let u=le(ka([r]),255),c,d,h,p;if(U(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),U(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),U(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),U(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),s.shape[2]===3){[c,d,h]=Za(s,[1,1,1],-1);const g=le(c,a),y=le(d,i),b=le(h,o);p=Ee(Ee(g,y),b)}else p=e;if(t==="otsu"){const g=ree(Xe(Tz(p),"int32"),qo([]),256);u=FJe(g,l)}const f=n?jf(p,u):ui(p,u);return Xe(le(f,255),"int32")}function FJe(e,t){let n=ka([-1]),r=ka([0]),s=ka([0]),a,i,o,l,u,c;for(let d=0;d<e.size-1;d++){a=jt(e,0,d+1),i=jt(e,d+1),u=ft(ot(a),t),c=ft(ot(i),t);const h=ot(le(a,zg(0,a.size)));o=ft(h,ot(a));const p=Tb(i.shape,a.size),f=Ee(zg(0,i.size),p),m=le(i,f);l=ft(ot(m),ot(i));const g=rt(o,l),y=rt(o,l),b=le(u,c);s=le(le(b,g),y);const x=ui(s,r);r=Fs(x,s,r),n=Fs(x,ka([d]),n)}return n}const OJe=se({threshold_:DJe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MJe(e,t,n="nearest",r="constant",s=0,a){const i=j(e,"image","transform","float32"),o=j(t,"transforms","transform","float32");U(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),U(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),U(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return ie.runKernel(rz,l,u)}const LJe=se({transform_:MJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PJe(e,t,n){const r=j(e,"a","bandPart");U(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,i]=r.shape.slice(-2);let o,l;typeof t=="number"?(U(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),U(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),o=j(t<0?a:t,"numLower","bandPart")):(U(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Fs(O0(t,0),a,op(t,a))),typeof n=="number"?(U(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),U(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=j(n<0?i:n,"numUpper","bandPart")):(U(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Fs(O0(n,0),i,op(n,i)));const u=ce(zg(0,a,1,"int32"),[-1,1]),c=zg(0,i,1,"int32"),d=rt(u,c),h=jl(jf(d,o),Ld(d,Hn(l))),p=Fr([a,i],r.dtype);return ce(Di(xo(ce(r,[-1,a,i])).map(f=>Fs(h,f,p))),s)}const zJe=se({bandPart_:PJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BJe(e){let t;if(Array.isArray(e)){t=!1,U(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=e[0].shape[0];for(let a=1;a<e.length;++a)U(e[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${s})`)}else t=!0,e=Za(e,e.shape[0],0).map(s=>Kf(s,[0]));U(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],r=e;for(let s=0;s<e.length;++s)n.push(ie.tidy(()=>{let a=r[s];if(s>0)for(let i=0;i<s;++i){const o=le(ot(le(n[i],a)),n[i]);a=rt(a,o)}return ft(a,ov(a,"euclidean"))}));return t?Di(n,0):n}const WJe=se({gramSchmidt_:BJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VJe(e,t=!1){if(U(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return mG(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),r=xo(ce(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach(l=>{const[u,c]=mG(l,t);s.push(u),a.push(c)});const i=ce(Di(s,0),e.shape),o=ce(Di(a,0),e.shape);return[i,o]}}function mG(e,t=!1){return ie.tidy(()=>{U(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],r=e.shape[1];let s=xz(n),a=Tu(e);const i=Hx([[1]],[1,1]);let o=Tu(i);const l=n>=r?r:n;for(let u=0;u<l;++u){const c=a,d=o,h=s;[o,a,s]=ie.tidy(()=>{const p=jt(a,[u,u],[n-u,1]),f=ov(p),m=jt(a,[u,u],[1,1]),g=Fs(ui(m,0),Hx([[-1]]),Hx([[1]])),y=rt(m,le(g,f)),b=ft(p,y);b.shape[0]===1?o=Tu(i):o=$r([i,jt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const x=Hn(ft(Ut(g,y),f)),w=jt(a,[u,0],[n-u,r]),v=le(x,o),k=qt(o);if(u===0)a=rt(w,Ut(v,Ut(k,w)));else{const $=rt(w,Ut(v,Ut(k,w)));a=$r([jt(a,[0,0],[u,r]),$],0)}const I=qt(v),S=jt(s,[0,u],[n,s.shape[1]-u]);if(u===0)s=rt(S,Ut(Ut(S,o),I));else{const $=rt(S,Ut(Ut(S,o),I));s=$r([jt(s,[0,0],[n,u]),$],1)}return[o,a,s]}),nt([c,d,h])}return!t&&n>r&&(s=jt(s,[0,0],[n,r]),a=jt(a,[0,0],[r,r])),[s,a]})}const UJe=se({qr_:VJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var va;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(va||(va={}));function GJe(e,t,n=va.SUM_BY_NONZERO_WEIGHTS){const r=j(e,"losses","computeWeightedLoss");let s=null;t!=null&&(s=j(t,"weights","computeWeightedLoss"));const a=s==null?r:le(r,s);if(n===va.NONE)return a;if(n===va.SUM)return ot(a);if(n===va.MEAN){if(s==null)return dr(a);{const i=r.size/s.size,o=ft(ot(a),ot(s));return i>1?ft(o,bt(i)):o}}if(n===va.SUM_BY_NONZERO_WEIGHTS){if(s==null)return ft(ot(a),bt(r.size));{const i=le(s,ki(r.shape)),o=Xe(ot(Pg(i,bt(0))),"float32");return ft(ot(a),o)}}throw Error(`Unknown reduction: ${n}`)}const Yu=se({computeWeightedLoss_:GJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HJe(e,t,n,r=va.SUM_BY_NONZERO_WEIGHTS){const s=j(e,"labels","absoluteDifference"),a=j(t,"predictions","absoluteDifference");let i=null;n!=null&&(i=j(n,"weights","absoluteDifference")),oi(s.shape,a.shape,"Error in absoluteDifference: ");const o=Rr(rt(s,a));return Yu(o,i,r)}const jJe=se({absoluteDifference_:HJe});function qJe(e,t,n,r,s=va.SUM_BY_NONZERO_WEIGHTS){const a=j(e,"labels","cosineDistance"),i=j(t,"predictions","cosineDistance");let o=null;r!=null&&(o=j(r,"weights","cosineDistance")),oi(a.shape,i.shape,"Error in cosineDistance: ");const l=bt(1),u=rt(l,ot(le(a,i),n,!0));return Yu(u,o,s)}const KJe=se({cosineDistance_:qJe});function XJe(e,t,n,r=va.SUM_BY_NONZERO_WEIGHTS){let s=j(e,"labels","hingeLoss");const a=j(t,"predictions","hingeLoss");let i=null;n!=null&&(i=j(n,"weights","hingeLoss")),oi(s.shape,a.shape,"Error in hingeLoss: ");const o=bt(1);s=rt(le(bt(2),s),o);const l=Ql(rt(o,le(s,a)));return Yu(l,i,r)}const YJe=se({hingeLoss_:XJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZJe(e,t,n,r=1,s=va.SUM_BY_NONZERO_WEIGHTS){const a=j(e,"labels","huberLoss"),i=j(t,"predictions","huberLoss");let o=null;n!=null&&(o=j(n,"weights","huberLoss")),oi(a.shape,i.shape,"Error in huberLoss: ");const l=bt(r),u=Rr(rt(i,a)),c=op(u,l),d=rt(u,c),h=Ee(le(bt(.5),En(c)),le(l,d));return Yu(h,o,s)}const JJe=se({huberLoss_:ZJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QJe(e,t,n,r=1e-7,s=va.SUM_BY_NONZERO_WEIGHTS){const a=j(e,"labels","logLoss"),i=j(t,"predictions","logLoss");let o=null;n!=null&&(o=j(n,"weights","logLoss")),oi(a.shape,i.shape,"Error in logLoss: ");const l=bt(1),u=bt(r),c=Hn(le(a,Ai(Ee(i,u)))),d=le(rt(l,a),Ai(Ee(rt(l,i),u))),h=rt(c,d);return Yu(h,o,s)}const eQe=se({logLoss_:QJe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tQe(e,t,n,r=va.SUM_BY_NONZERO_WEIGHTS){const s=j(e,"labels","meanSquaredError"),a=j(t,"predictions","meanSquaredError");let i=null;n!=null&&(i=j(n,"weights","meanSquaredError")),oi(s.shape,a.shape,"Error in meanSquaredError: ");const o=Mz(s,a);return Yu(o,i,r)}const nQe=se({meanSquaredError_:tQe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rQe(e,t){const n=j(e,"labels","sigmoidCrossEntropyWithLogits"),r=j(t,"logits","sigmoidCrossEntropyWithLogits");oi(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Ql(r),a=le(r,n),i=F$(Ei(Hn(Rr(r))));return Ee(rt(s,a),i)}function sQe(e,t,n,r=0,s=va.SUM_BY_NONZERO_WEIGHTS){let a=j(e,"multiClassLabels","sigmoidCrossEntropy");const i=j(t,"logits","sigmoidCrossEntropy");let o=null;if(n!=null&&(o=j(n,"weights","sigmoidCrossEntropy")),oi(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const u=bt(r),c=bt(1),d=bt(.5);a=Ee(le(a,rt(c,u)),le(d,u))}const l=rQe(a,i);return Yu(l,o,s)}const aQe=se({sigmoidCrossEntropy_:sQe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iQe(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Lu((s,a,i)=>{const l=vz(a,[n],!0),u=rt(Xe(a,"float32"),l);i([s,u]);const c=Hn(le(u,s));return{value:ot(c,[n]),gradFunc:(p,f)=>{const[m,g]=f,y=br(p.shape,[n]);return[le(ce(p,y),rt(Xe(m,"float32"),Ei(g))),le(ce(p,y),rt(Ei(g),Xe(m,"float32")))]}}})(e,t)}function oQe(e,t,n,r=0,s=va.SUM_BY_NONZERO_WEIGHTS){let a=j(e,"onehotLabels","softmaxCrossEntropy");const i=j(t,"logits","softmaxCrossEntropy");let o=null;if(n!=null&&(o=j(n,"weights","softmaxCrossEntropy")),oi(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const u=bt(r),c=bt(1),d=bt(a.shape[1]);a=Ee(le(a,rt(c,u)),ft(u,d))}const l=iQe(a,i);return Yu(l,o,s)}const lQe=se({softmaxCrossEntropy_:oQe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uQe(e,t,n,r){const s=j(e,"indices","sparseFillEmptyRows","int32"),a=j(t,"values","sparseFillEmptyRows"),i=j(n,"denseShape","sparseFillEmptyRows","int32"),o=j(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:s,values:a,denseShape:i,defaultValue:o},u=ie.runKernel(jP,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const cQe=se({sparseFillEmptyRows_:uQe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dQe(e,t,n){const r=j(e,"inputIndices","sparseReshape","int32"),s=j(t,"inputShape","sparseReshape","int32"),a=j(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=ie.runKernel(qP,i);return{outputIndices:o[0],outputShape:o[1]}}const hQe=se({sparseReshape_:dQe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pQe(e,t,n){const r=j(e,"data","sparseSegmentMean"),s=j(t,"indices","sparseSegmentMean","int32"),a=j(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return ie.runKernel(KP,i)}const fQe=se({sparseSegmentMean_:pQe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mQe(e,t,n){const r=j(e,"data","sparseSegmentSum"),s=j(t,"indices","sparseSegmentSum","int32"),a=j(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return ie.runKernel(XP,i)}const gQe=se({sparseSegmentSum_:mQe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yQe(e,t,n,r,s,a,i,o){const l=j(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=j(t,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},h=ie.runKernel(QP,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}const bQe=se({stringNGrams_:yQe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xQe(e,t,n=!0){const r=j(e,"input","stringSplit","string"),s=j(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=ie.runKernel(ez,i,a);return{indices:o[0],values:o[1],shape:o[2]}}const wQe=se({stringSplit_:xQe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vQe(e,t){const n=j(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return ie.runKernel(tz,s,r)}const kQe=se({stringToHashBucketFast_:vQe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IQe(e,t,n,r=!0){const s=j(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return ie.runKernel(I$,{x:s},a)}const SQe=se({staticRegexReplace_:IQe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CQe={fft:G$,ifft:P0,rfft:H$,irfft:Oz},NQe={hammingWindow:eJe,hannWindow:qee,frame:Kee,stft:sJe},io={flipLeftRight:lJe,grayscaleToRGB:cJe,resizeNearestNeighbor:Yee,resizeBilinear:Xee,rotateWithOffset:hJe,cropAndResize:iJe,nonMaxSuppression:fJe,nonMaxSuppressionAsync:kJe,nonMaxSuppressionWithScore:SJe,nonMaxSuppressionWithScoreAsync:NJe,nonMaxSuppressionPadded:TJe,nonMaxSuppressionPaddedAsync:EJe,threshold:OJe,transform:LJe},Zee={bandPart:zJe,gramSchmidt:WJe,qr:UJe},$Qe={absoluteDifference:jJe,computeWeightedLoss:Yu,cosineDistance:KJe,hingeLoss:YJe,huberLoss:JJe,logLoss:eQe,meanSquaredError:nQe,sigmoidCrossEntropy:aQe,softmaxCrossEntropy:lQe},TQe={sparseFillEmptyRows:cQe,sparseReshape:hQe,sparseSegmentMean:fQe,sparseSegmentSum:gQe},_Qe={stringNGrams:bQe,stringSplit:wQe,stringToHashBucketFast:kQe,staticRegexReplace:SQe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Db{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class eo{constructor(){this.classNameMap={}}static getMap(){return eo.instance==null&&(eo.instance=new eo),eo.instance}static register(t){eo.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Ae(e){U(e.className!=null,()=>"Class being registered does not have the static className property defined."),U(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),U(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),eo.register(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zd extends Db{minimize(t,n=!1,r){const{value:s,grads:a}=this.computeGradients(t,r);if(r!=null){const i=r.map(o=>({name:o.name,tensor:a[o.name]}));this.applyGradients(i)}else this.applyGradients(a);return nt(a),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return o9e(t,n)}dispose(){this.iterations_!=null&&nt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:bt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(zd,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jee extends zd{static get className(){return"Adadelta"}constructor(t,n,r=null){super(),this.learningRate=t,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=ie.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=ie.registeredVariables[r],i=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:ge(()=>Kt(a).variable(i))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:ge(()=>Kt(a).variable(i))});const o=Array.isArray(t)?t[s].tensor:t[r];if(o==null)return;const l=this.accumulatedGrads[s].variable,u=this.accumulatedUpdates[s].variable;ge(()=>{const c=Ee(le(l,this.rho),le(En(o),1-this.rho)),d=le(ft(Ps(Ee(u,this.epsilon)),Ps(Ee(l,this.epsilon))),o),h=Ee(le(u,this.rho),le(En(d),1-this.rho));l.assign(c),u.assign(h);const p=Ee(le(d,-this.learningRate),a);a.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(nt(this.accumulatedGrads.map(t=>t.variable)),nt(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=t.length/2,r=!1;this.accumulatedGrads=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qee extends zd{static get className(){return"Adagrad"}constructor(t,n=.1){super(),this.learningRate=t,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=ie.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:ge(()=>Tb(a.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(t)?t[s].tensor:t[r];if(i==null)return;const o=this.accumulatedGrads[s].variable;ge(()=>{const l=Ee(o,En(i));o.assign(l);const u=Ee(le(ft(i,Ps(Ee(l,ie.backend.epsilon()))),-this.learningRate),a);a.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&nt(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulatedGrads=t.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ete extends zd{static get className(){return"Adam"}constructor(t,n,r,s=null){super(),this.learningRate=t,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ge(()=>{this.accBeta1=bt(n).variable(),this.accBeta2=bt(r).variable()}),s==null&&(this.epsilon=ie.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);ge(()=>{const r=rt(1,this.accBeta1),s=rt(1,this.accBeta2);n.forEach((a,i)=>{const o=ie.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:ge(()=>Kt(o).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${a}/v`,variable:ge(()=>Kt(o).variable(l))});const u=Array.isArray(t)?t[i].tensor:t[a];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedSecondMoment[i].variable,h=Ee(le(c,this.beta1),le(u,1-this.beta1)),p=Ee(le(d,this.beta2),le(En(u),1-this.beta2)),f=ft(h,r),m=ft(p,s);c.assign(h),d.assign(p);const g=Ee(le(ft(f,Ee(Ps(m),this.epsilon)),-this.learningRate),o);o.assign(g)}),this.accBeta1.assign(le(this.accBeta1,this.beta1)),this.accBeta2.assign(le(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&nt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&nt(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),ge(()=>{this.accBeta1.assign(ad(this.beta1,this.iterations_+1)),this.accBeta2.assign(ad(this.beta2,this.iterations_+1))});const n=t.length/2,r=!1;this.accumulatedFirstMoment=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tte extends zd{static get className(){return"Adamax"}constructor(t,n,r,s=null,a=0){super(),this.learningRate=t,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ge(()=>{this.iteration=bt(0).variable(),this.accBeta1=bt(n).variable()}),s==null&&(this.epsilon=ie.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);ge(()=>{const r=rt(1,this.accBeta1),s=ft(-this.learningRate,Ee(le(this.iteration,this.decay),1));n.forEach((a,i)=>{const o=ie.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:Kt(o).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${a}/v`,variable:Kt(o).variable(l)});const u=Array.isArray(t)?t[i].tensor:t[a];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedWeightedInfNorm[i].variable,h=Ee(le(c,this.beta1),le(u,1-this.beta1)),p=le(d,this.beta2),f=Rr(u),m=Xu(p,f);c.assign(h),d.assign(m);const g=Ee(le(ft(s,r),ft(h,Ee(m,this.epsilon))),o);o.assign(g)}),this.iteration.assign(Ee(this.iteration,1)),this.accBeta1.assign(le(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&nt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&nt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qz extends zd{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=Array.isArray(t)?t[s].tensor:t[r];if(a==null)return;const i=ie.registeredVariables[r];ge(()=>{const o=Ee(le(this.c,a),i);i.assign(o)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=ns(bt(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nte extends qz{static get className(){return"Momentum"}constructor(t,n,r=!1){super(t),this.learningRate=t,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=bt(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=ie.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:ge(()=>Kt(a).variable(!1))});const i=this.accumulations[s].variable,o=Array.isArray(t)?t[s].tensor:t[r];o!=null&&ge(()=>{let l;const u=Ee(le(this.m,i),o);this.useNesterov?l=Ee(le(this.c,Ee(o,le(u,this.m))),a):l=Ee(le(this.c,u),a),i.assign(u),a.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&nt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulations=t.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rte extends zd{static get className(){return"RMSProp"}constructor(t,n=.9,r=0,s=null,a=!1){if(super(),this.learningRate=t,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,s==null&&(this.epsilon=ie.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=ie.registeredVariables[r],i=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:ge(()=>Kt(a).variable(i))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:ge(()=>Kt(a).variable(i))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:ge(()=>Kt(a).variable(i))});const o=Array.isArray(t)?t[s].tensor:t[r];if(o==null)return;const l=this.accumulatedMeanSquares[s].variable,u=this.accumulatedMoments[s].variable;ge(()=>{const c=Ee(le(l,this.decay),le(En(o),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[s].variable,h=Ee(le(d,this.decay),le(o,1-this.decay)),p=ft(le(o,this.learningRate),Ps(rt(c,Ee(En(h),this.epsilon)))),f=Ee(le(u,this.momentum),p);l.assign(c),d.assign(h),u.assign(f);const m=rt(a,f);a.assign(m)}else{const d=Ee(le(l,this.decay),le(En(o),1-this.decay)),h=Ee(le(u,this.momentum),ft(le(o,this.learningRate),Ps(Ee(d,this.epsilon))));l.assign(d),u.assign(h);const p=rt(a,h);a.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&nt(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&nt(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&nt(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2,r=!1;this.accumulatedMeanSquares=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EQe=[Jee,Qee,ete,tte,nte,rte,qz];function AQe(){for(const e of EQe)Ae(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RQe="model",DQe=".json",FQe=".weights.bin";function gG(e){return new Promise(t=>setTimeout(t)).then(e)}class lp{constructor(t){if(!xe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(lp.URL_SCHEME)&&(t=t.slice(lp.URL_SCHEME.length)),(t==null||t.length===0)&&(t=RQe),this.modelJsonFileName=t+DQe,this.weightDataFileName=t+FQe}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s=RQ(t,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=a,await gG(()=>i.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){const o=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;o.download=this.weightDataFileName,o.href=n,await gG(()=>o.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:nv(t)}}}}lp.URL_SCHEME="downloads://";class OQe{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,n)=>{const r=new FileReader;r.onload=s=>{const a=JSON.parse(s.target.result),i=a.modelTopology;if(i==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:i});return}const l=uz(a,u=>this.loadWeights(u));t(l)},r.onerror=s=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(t){const n=[],r=[];for(const i of t)n.push(...i.weights),r.push(...i.paths);const s=this.checkManifestAndWeightFiles(t),a=r.map(i=>this.loadWeightsFile(i,s[i]));return Promise.all(a).then(i=>[n,T$(i)])}loadWeightsFile(t,n){return new Promise((r,s)=>{const a=new FileReader;a.onload=i=>{const o=i.target.result;r(o)},a.onerror=i=>s(`Failed to weights data from file of path '${t}'.`),a.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(t){const n=[],r=this.weightsFiles.map(a=>pG(a.name)),s={};for(const a of t)a.paths.forEach(i=>{const o=pG(i);if(n.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(n.push(o),r.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);s[i]=this.weightsFiles[r.indexOf(o)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const MQe=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(lp.URL_SCHEME)?LQe(e.slice(lp.URL_SCHEME.length)):null;tr.registerSaveRouter(MQe);function LQe(e="model"){return new lp(e)}function PQe(e){return new OQe(e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yG(e,t,n,r){i(e),n=n??0,r=r??1,o(n,r);let s=0;const a=l=>(l.then(u=>{const c=n+ ++s/e.length*(r-n);return t(c),u}),l);function i(l){U(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,u){U(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),U(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),U(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(a))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ste(e,t){t==null&&(t={});const n=t.fetchFunc==null?xe().platform.fetch:t.fetchFunc,r=e.map(d=>n(d,t.requestInit,{isBinary:!0})),s=0,a=.5,o=(t.onProgress==null?await Promise.all(r):await yG(r,t.onProgress,s,a)).map(d=>d.arrayBuffer()),l=.5,u=1;return t.onProgress==null?await Promise.all(o):await yG(o,t.onProgress,l,u)}async function zQe(e,t="",n,r){return ate(i=>ste(i,{requestInit:r}))(e,t,n)}function ate(e){return async(t,n="",r)=>{const s=t.map(()=>!1),a={},i=r!=null?r.map(()=>!1):[],o=[];if(t.forEach((p,f)=>{let m=0;p.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,b=vR[y]*ve(g.shape),x=()=>{s[f]=!0,a[f]==null&&(a[f]=[]),a[f].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};r!=null?r.forEach((w,v)=>{w===g.name&&(x(),i[v]=!0)}):x(),o.push(g.name),m+=b})}),!i.every(p=>p)){const p=r.filter((f,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const l=s.reduce((p,f,m)=>(f&&p.push(m),p),[]),u=[];l.forEach(p=>{t[p].paths.forEach(f=>{const m=n+(n.endsWith("/")?"":"/")+f;u.push(m)})});const c=await e(u),d={};let h=0;return l.forEach(p=>{const f=t[p].paths.length;let m=0;for(let w=0;w<f;w++)m+=c[h+w].byteLength;const g=new ArrayBuffer(m),y=new Uint8Array(g);let b=0;for(let w=0;w<f;w++){const v=new Uint8Array(c[h+w]);y.set(v,b),b+=v.byteLength}a[p].forEach(w=>{const v=g.slice(w.groupOffset,w.groupOffset+w.sizeBytes),k=AQ(v,[w.manifestEntry]);for(const I in k)d[I]=k[I]}),h+=f}),d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BQe="application/octet-stream",WQe="application/json";class Kz{constructor(t,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(U(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=xe().platform.fetch,U(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&U(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],s=RQ(t,r);n.body.append("model.json",new Blob([JSON.stringify(s)],{type:WQe}),"model.json"),t.weightData!=null&&n.body.append("model.weights.bin",new Blob([t.weightData],{type:BQe}),"model.weights.bin");const a=await this.fetch(this.path,n);if(a.ok)return{modelArtifactsInfo:nv(t),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await t.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return uz(n,a=>this.loadWeights(a))}async loadWeights(t){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=VQe(n),a=this.weightPathPrefix||r,i=FQ(t),o=[],l=[];for(const c of t)for(const d of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(d)):o.push(a+d+s);this.weightUrlConverter&&o.push(...await Promise.all(l));const u=await ste(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,T$(u)]}}Kz.URL_SCHEME_REGEX=/^https?:\/\//;function VQe(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}function LR(e){return e.match(Kz.URL_SCHEME_REGEX)!=null}const ite=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>LR(r)):n=LR(e),n)return Xz(e,t)}return null};tr.registerSaveRouter(ite);tr.registerLoadRouter(ite);function Xz(e,t){return new Kz(e,t)}function UQe(e,t){return Xz(e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F_{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class ote{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class GQe{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=n=>Promise.resolve(t.save(n)))}}function HQe(e,t,n,r){const s=arguments;return new GQe(lte(...s))}function lte(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new F_(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new F_({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new F_({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function jQe(e){return new ote(e)}function qQe(e){return new ote(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ute=Object.freeze(Object.defineProperty({__proto__:null,browserFiles:PQe,browserHTTPRequest:UQe,concatenateArrayBuffers:T$,copyModel:rXe,decodeWeights:AQ,encodeWeights:kR,fromMemory:HQe,fromMemorySync:lte,getLoadHandlers:UKe,getModelArtifactsForJSON:uz,getModelArtifactsForJSONSync:DQ,getModelArtifactsInfoForJSON:nv,getSaveHandlers:OQ,getWeightSpecs:FQ,http:Xz,isHTTPScheme:LR,listModels:tXe,loadWeights:zQe,moveModel:sXe,registerLoadRouter:VKe,registerSaveRouter:WKe,removeModel:nXe,weightsLoaderFactory:ate,withSaveHandler:jQe,withSaveHandlerSync:qQe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Kd;function KQe(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)a=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(pR(dR,ie.backendName)!=null){const f={pixels:e},m={numChannels:t};return ie.runKernel(dR,f,m)}const[u,c]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let d;if(i)d=e.getContext("2d").getImageData(0,0,u,c).data;else if(r||n)d=e.data;else if(a||s||o){if(Kd==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Kd=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Kd=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Kd.canvas.width=u,Kd.canvas.height=c,Kd.drawImage(e,0,0,u,c),d=Kd.getImageData(0,0,u,c).data}let h;if(t===4)h=new Int32Array(d);else{const f=u*c;h=new Int32Array(f*t);for(let m=0;m<f;m++)for(let g=0;g<t;++g)h[m*t+g]=d[m*4+g]}return Mee(h,[c,u,t],"int32")}const bG=se({fromPixels_:KQe});function Yz(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(ve(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const o=e.shape,l=s.slice();l.pop();let u=1;for(let d=a;d<n;++d)u*=o[d],l.push(o[d]);const c=[...yt(e.shape).map(d=>d/u),1].slice(0,a);return[l,i,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PR=-2,XQe=-1;function Zz(e,t,n){const r=e.shape.length;U(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),U(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)U(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function YQe(e){const t=[];let n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function Jz(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function cte(e,t,n,r){const s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function dte(e,t,n){return n<=e?n:n-(t-1)}function hte(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function ZQe(e,t,n,r,s,a,i,o,l){const u=e.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){const p=t[0],f=n+1;c=pte(i,p,f,r,e),d=fte(o,p,f,s,e),h=cte(a,p,f,e)}else for(let p=0;p<u;p++)c[p]=gte(i,r,a,e,p,l),d[p]=yte(o,s,a,e,p,l),h[p]=mte(a,p,l);return{begin:c,end:d,strides:h}}function pte(e,t,n,r,s){const a=[...s],i=hte(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const l=dte(t,n,o);let u=r[l];e&1<<l&&(u=0),a[o]=u}return a}function fte(e,t,n,r,s){const a=[...s],i=hte(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const l=dte(t,n,o);let u=r[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),a[o]=u}for(let o=0;o<a.length;o++){const l=s[o];a[o]<0&&(a[o]+=l),a[o]=tp(0,a[o],s[o])}return a}function mte(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function gte(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=tp(0,i,l-1),i}function yte(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),o>0?i=tp(0,i,l):i=tp(-1,i,l-1),i}function Qz(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function eB(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Y$(e,t,n){let r;const s=e.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(i=>{U(i!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((i,o)=>i>=0?i:(U(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,a]}function tB(e,t,n,r,s,a,i,o,l){let u;if(r==null?(u=new Array(t.length),u.fill(1)):u=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let x=0;x<d.dims;x++)c&&1<<x&o&&d.numAddAxisAfterEllipsis++,1<<x&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};JQe(d,h);let p=!0,f=!0,m=!0;const g=[],y=[];for(let x=0;x<e.length;++x){if(h.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);const w=!!(h.shrinkAxisMask&1<<x),v=e[x];if(v===-1){g.push(w?1:-1);continue}const k=[h.beginMask&1<<x,h.endMask&1<<x],I=[h.strides[x]>0?0:-1,h.strides[x]>0?v:v-1];if(w&&h.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&h.strides[x]===1;const S=!!(h.beginMask&1<<x&&h.endMask&1<<x);if(h.beginValid&&h.endValid){if(w){const C=h.begin[x]<0?v+h.begin[x]:h.begin[x];if(h.begin[x]=C,h.end[x]=h.begin[x]+1,C<0||C>=v)throw Error(`slice index ${h.begin[x]} of dimension ${x} out of bounds.`)}else h.begin[x]=xG(h.begin[x],0,h.strides[x],v,k,I),h.end[x]=xG(h.end[x],1,h.strides[x],v,k,I);const T=h.strides[x]===1&&h.begin[x]===0&&h.end[x]===v;p=p&&T,f=f&&(x===0&&h.strides[x]===1||T)}else p=p&&h.strides[x]===1&&S,f=f&&(x===0&&h.strides[x]===1||S);let $,N=!1;if(h.beginValid&&h.endValid?($=h.end[x]-h.begin[x],N=!0):w?($=1,N=!0):S&&v>=0&&(h.strides[x]<0?$=-v:$=v,N=!0),N){let T;$===0||$<0!=h.strides[x]<0?T=0:T=Math.trunc($/h.strides[x])+($%h.strides[x]!==0?1:0),g.push(T)}else g.push(-1)}for(let x=0;x<h.finalShapeGatherIndices.length;++x){const w=h.finalShapeGatherIndices[x];w>=0?y.push(g[w]):w===PR&&y.push(1)}return{finalShapeSparse:y.filter((x,w)=>h.finalShapeGatherIndices[w]!==PR),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function JQe(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(PR),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(XQe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function xG(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const i=e<0?r+e:e;return i<a[0]?a[0]:i>a[1]?a[1]:i}}const QQe=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Zz,computeFlatOffset:eB,computeOutShape:Jz,getNormalizedAxes:ZQe,isSliceContinous:Qz,maskToAxes:YQe,parseSliceParams:Y$,sliceInfo:tB,startForAxis:gte,startIndicesWithElidedDims:pte,stopForAxis:yte,stopIndicesWithElidedDims:fte,stridesForAxis:mte,stridesWithElidedDims:cte},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eet{static sgd(t){return new qz(t)}static momentum(t,n,r=!1){return new nte(t,n,r)}static rmsprop(t,n=.9,r=0,s=null,a=!1){return new rte(t,n,r,s,a)}static adam(t=.001,n=.9,r=.999,s=null){return new ete(t,n,r,s)}static adadelta(t=.001,n=.95,r=null){return new Jee(t,n,r)}static adamax(t=.002,n=.9,r=.999,s=null,a=0){return new tte(t,n,r,s,a)}static adagrad(t,n=.1){return new Qee(t,n)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dm=eet;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tet=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e())();function bte(){return new Promise(e=>tet(()=>e()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nB(e,t){const n=e[0].length;e.forEach((s,a)=>{U(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),U(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=e[0];e.forEach((s,a)=>{for(let i=0;i<n;i++)U(i===t||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function Bl(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Lo;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(Lo||(Lo={}));function xte(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function wte(e){const t={FIRST_DIM_SIZE:Lo.FIRST_DIM_SIZE,VALUE_ROWIDS:Lo.VALUE_ROWIDS,ROW_LENGTHS:Lo.ROW_LENGTHS,ROW_SPLITS:Lo.ROW_SPLITS,ROW_LIMITS:Lo.ROW_LIMITS,ROW_STARTS:Lo.ROW_STARTS},n=[];for(const r of e)if(r in t)n.push(t[r]);else break;return n}function vte(e){return e.length===0?0:e[0]===Lo.FIRST_DIM_SIZE?e.length-1:e.length}function kte(e,t){if(e==null||t==null)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const a=e[s],i=t[s+1];if(a>=0&&i>=0&&a!==1&&a!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${a} but ragged tensor input.flatValues.shape[${s-e.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rB=30;function Z$(e){return e<=rB?e:lR(e,Math.floor(Math.sqrt(e)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sB(e,t,n){const r=n*(typeof e=="number"?e:e[0]),s=t*(typeof e=="number"?e:e[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cv(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const a=t.length;for(let i=0;i<a;++i)s=s.concat([e[i+1]/t[i],t[i]]);s=s.concat(e.slice(a+1))}return s}function dv(e,t,n=!0){const r=[];if(n){r.push(t);for(let s=t+1;s<e;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],a=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?a.push(i):s.push(i);r.push(...s),r.push(0),r.push(...a)}return r}function hv(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function aB(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function iB(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J$=1.7580993408473768,Q$=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oB=.3275911,lB=.254829592,uB=-.284496736,cB=1.421413741,dB=-1.453152027,hB=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pu(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Ite(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Ste(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function Cte(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function pB(e,t){const n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function Nte(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function $te(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function Tte(e,t,n){const r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O_="->",net=/->/g,wG=",",vG="...";function fB(e,t){e=e.replace(/\s/g,"");const n=(e.length-e.replace(net,"").length)/O_.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${O_}").`);const[r,s]=e.split(O_);U(r.indexOf(vG)===-1,()=>`The ellipsis notation ("${vG}") is not supported yet.`);const a=r.split(wG),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<s.length;++h){const p=s[h];if(!a.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);o.indexOf(p)===-1&&o.push(p)}for(let h=0;h<r.length;++h){const p=r[h];o.indexOf(p)===-1&&p!==wG&&o.push(p)}const l=new Array(a.length);for(let h=0;h<i;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let p=0;p<a[h].length;++p)l[h].push(o.indexOf(a[h][p]))}const u=o.length,c=s.length,d=[];for(let h=c;h<u;++h)d.push(h);return{allDims:o,summedDims:d,idDims:l}}function mB(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function gB(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const a=n[s].shape;for(let i=0;i<t[s].length;++i)r[t[s][i]]===void 0?r[t[s][i]]=a[i]:U(r[t[s][i]]===a[i],()=>`Expected dimension ${r[t[s][i]]} at axis ${i} of input shaped ${JSON.stringify(a)}, but got dimension ${a[i]}`)}}function yB(e,t){const n=e,r=[];let s=0;e.length===0&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const a=[];for(let i=0;i<n.length;++i){const o=n[i],l=ret(t,o);for(const u of l)a.indexOf(u)===-1&&(r[i].push(u),a.push(u))}return{path:n,steps:r}}function bB(e){return e.every((t,n)=>t===n)}function ret(e,t){const n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function xB(e,t,n=0){let r=[];if(typeof t=="number")U(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);U(s<=1,()=>"There should be only one negative value in split array.");const a=t.indexOf(-1);if(a!==-1){const i=t.reduce((o,l)=>l>0?o+l:o);t[a]=e.shape[n]-i}U(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _te(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function Ete(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function Ate(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rte(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Dte(e,t){return`size ${e} must be non-negative, not ${t}`}function Fte(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Ote(e,t){const n=ve(e),r=ve(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function Mte(e,t){const n=ve(e),r=ve(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zR(){return"segment ids must be >= 0"}function Lte(){return"segment ids are not increasing"}function Pte(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function zte(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bte(e,t){let n=!1,r;for(e<=rB?(r=e,n=!0):r=lR(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=lR(e,r+1);return r}function Wte(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function wB(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<s;d++)o.push(t.shape[d]);for(let d=n+1;d<a;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}const set=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:wB,computeOutShape:Wte,segOpComputeOptimalWindowSize:Bte},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zu(e){try{return e.map(t=>td(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Vte(e){return e.map(t=>Lc(t))}const aet=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:lB,ERF_A2:uB,ERF_A3:cB,ERF_A4:dB,ERF_A5:hB,ERF_P:oB,PARALLELIZE_THRESHOLD:rB,get RowPartitionType(){return Lo},SELU_SCALE:Q$,SELU_SCALEALPHA:J$,applyActivation:K$,assertAndGetBroadcastShape:Nt,assertAxesAreInnerMostDims:$s,assertParamsConsistent:nB,assignToTypedArray:Nte,axesAreInnerMostDims:bz,calculateShapes:Xf,checkEinsumDimSizes:gB,checkPadOnDimRoundingMode:ca,combineLocations:yee,combineRaggedTensorToTensorShapes:xte,complexWithEvenIndex:Ste,complexWithOddIndex:Cte,computeConv2DInfo:cs,computeConv3DInfo:Od,computeDefaultPad:hz,computeDilation2DInfo:rv,computeOptimalWindowSize:Z$,computeOutAndReduceShapes:ds,computeOutShape:Bl,computePool2DInfo:Co,computePool3DInfo:qu,convertConv2DDataFormat:Ku,decodeEinsumEquation:fB,eitherStridesOrDilationsAreOne:Ns,expandShapeToKeepDim:br,exponent:Tte,exponents:$te,fromStringArrayToUint8:Vte,fromUint8ToStringArray:zu,getAxesPermutation:lr,getBroadcastDims:Lg,getComplexWithIndex:pB,getEinsumComputePath:yB,getEinsumPermutation:mB,getFusedBiasGradient:q$,getFusedDyActivation:j$,getImageCenter:sB,getInnerMostAxes:wr,getPermuted:dv,getRaggedRank:vte,getReductionAxes:jr,getReshaped:cv,getReshapedPermuted:hv,getRowPartitionTypesHelper:wte,getSliceBeginCoords:aB,getSliceSize:iB,getSparseFillEmptyRowsIndicesDenseShapeMismatch:_te,getSparseFillEmptyRowsNegativeIndexErrorMessage:Ete,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Ate,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Fte,getSparseReshapeInputOutputMismatchErrorMessage:Mte,getSparseReshapeInputOutputMultipleErrorMessage:Ote,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Rte,getSparseReshapeNegativeOutputDimErrorMessage:Dte,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:zte,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:zR,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Lte,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Pte,getUndoAxesPermutation:Md,isIdentityPermutation:bB,log:lKe,mergeRealAndImagArrays:Pu,prepareAndValidate:Yz,prepareSplitSize:xB,segment_util:set,shouldFuse:X$,slice_util:QQe,splitRealAndImagArrays:Ite,stridesOrDilationsArePositive:ip,tupleValuesAreOne:rd,upcastType:ni,validateDefaultValueShape:kte,validateInput:Lz,validateUpdateShape:Lee,warn:gi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */AQe();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ute={kernelName:C2,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,Ab(Xe(n,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iet={kernelName:o1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=En(Xe(n,"float32")),s=Ps(rt(bt(1),r));return Hn(ft(e,s))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oet={kernelName:l1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=Ps(rt(En(Xe(n,"float32")),1));return ft(e,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uet={kernelName:$b,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nt(n.shape,r.shape);return{a:()=>{let o=e;const l=jr(n.shape,s);return l.length>0&&(o=ot(o,l)),ce(o,n.shape)},b:()=>{let o=e;const l=jr(r.shape,s);return l.length>0&&(o=ot(o,l)),ce(o,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cet={kernelName:N2,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((r,s)=>{n[s]=()=>e.clone()}),n}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const det={kernelName:$2,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Kt(n)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const het={kernelName:T2,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Kt(n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pet={kernelName:u1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ft(e,Ps(rt(bt(1),En(Xe(n,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fet={kernelName:c1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=Ps(Ee(bt(1),En(Xe(n,"float32"))));return ft(e,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const met={kernelName:p1,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nt(n.shape,r.shape);return{a:()=>{const o=Ee(En(n),En(r));let l=le(e,ft(r,o));const u=jr(n.shape,s);return u.length>0&&(l=ot(l,u)),ce(l,n.shape)},b:()=>{const o=Ee(En(n),En(r));let l=Hn(le(e,ft(n,o)));const u=jr(r.shape,s);return u.length>0&&(l=ot(l,u)),ce(l,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const get={kernelName:d1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ft(e,Ee(En(Xe(n,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yet={kernelName:h1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ft(e,rt(bt(1),En(Xe(n,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bet(e,t,n,r,s,a){const i=j(e,"dy","avgPool3dGrad"),o=j(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;o.rank===4&&(c=!0,l=ce(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=ce(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),U(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),ca("avgPool3dGrad",s,a);const d={dy:l,input:u},h={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=ie.runKernel(aP,d,h);return c?ce(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const xet=se({avgPool3dGrad_:bet});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wet={kernelName:E2,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>xet(e,r,s,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vet(e,t,n,r,s){const a=j(e,"dy","avgPoolGrad"),i=j(t,"input","avgPoolGrad");U(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,l=a,u=!1;i.rank===3&&(u=!0,o=ce(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=ce(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),U(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c={dy:l,input:o},d={filterSize:n,strides:r,pad:s},h=ie.runKernel(sP,c,d);return u?ce(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const ket=se({avgPoolGrad_:vet});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iet={kernelName:_2,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>ket(e,r,s,a,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cet={kernelName:A2,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return!a&&!i?{a:()=>Ut(e,s,!1,!0),b:()=>Ut(r,e,!0,!1)}:!a&&i?{a:()=>Ut(e,s,!1,!1),b:()=>Ut(e,r,!0,!1)}:a&&!i?{a:()=>Ut(s,e,!1,!0),b:()=>Ut(r,e,!1,!1)}:{a:()=>Ut(s,e,!0,!0),b:()=>Ut(e,r,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Net={kernelName:R2,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>P$(e,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $et={kernelName:iKe,gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let l=s.length-1;l>=0;l--)if(s[l]===a[l])i[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>ot(e,o,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tet={kernelName:f1,gradFunc:e=>({x:()=>e.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _et={kernelName:m1,gradFunc:e=>({x:()=>Kt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eet={kernelName:g1,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>Fs(jl(Ld(r,s),jf(r,a)),e,Kt(e))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aet={kernelName:D2,inputsToSave:["x"],gradFunc:Ute.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ret={kernelName:F2,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map(l=>l.shape),{axis:s}=n,a=Bt(s,t[0].shape)[0],i=r.map(l=>l[a]);return Za(e,i,a).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Det={kernelName:O2,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return U(rd(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>fz(r.shape,e,s,i,o,l),filter:()=>Vz(r,e,s.shape,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fet={kernelName:M2,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>sd(e,s,a,i,o,1,l),filter:()=>Vz(e,r,s.shape,a,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oet(e,t,n,r,s){let a=e;e.rank===4&&(a=ce(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=ce(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),U(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),U(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),U(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),U(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),U(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);const o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return ie.runKernel(cP,o,l)}const Met=se({conv3DBackpropFilter_:Oet});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Let={kernelName:L2,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;U(rd(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,o]=t;return{x:()=>cee(i.shape,e,o,s,a),filter:()=>Met(i,e,o.shape,s,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pet={kernelName:y1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(Hn(Rz(Xe(n,"float32"))),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zet={kernelName:b1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(Dz(Xe(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bet={kernelName:P2,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const o=lr([s],r.rank);let l=yz(e,s,a,!i);return o!=null&&(l=qt(l,o)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wet={kernelName:z2,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=r??[1,1];U(rd(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,u]=t;return U(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),U(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),U(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),U(Ns(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),ca("depthwiseConv2d",a,i),{x:()=>jee(l.shape,e,u,s,a,o,i),filter:()=>Hee(l,e,u.shape,s,a,o,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vet={kernelName:B2,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>ie.runKernel(uR,a,n),filter:()=>ie.runKernel(cR,i,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uet={kernelName:w1,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>ie.runKernel(wP,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Get={kernelName:v1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=le(Ei(Hn(En(n))),2/Math.sqrt(Math.PI));return{x:()=>le(e,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Het={kernelName:k1,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jet={kernelName:V2,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>ce(e,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qet={kernelName:I1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,Ei(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ket={kernelName:S1,gradFunc:e=>({x:()=>Kt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xet={kernelName:C1,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nt(n.shape,r.shape);return{a:()=>{const o=ft(e,Xe(r,"float32")),l=jr(n.shape,s);return l.length>0?ce(ot(o,l),n.shape):o},b:()=>{let o=le(e,Xe(n,"float32"));const l=jr(r.shape,s);l.length>0&&(o=ce(ot(o,l),r.shape));const u=En(r);return Hn(ft(o,Xe(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yet={kernelName:U2,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,l=o??bt(1),u=jr(a.shape,s.shape),c=[];if(a.rank===1){for(let w=0;w<s.shape.length-1;++w)c.push(s.shape[w]);c.push(1)}const d=rt(s,a),h=le(e,l),p=_z(Ee(i,bt(r))),f=le(le(le(p,p),p),bt(-.5));return{x:()=>a.rank===1?ce(le(le(e,ao(ce(p,[1,1,1,a.shape[0]]),c)),l),s.shape):ce(le(le(e,p),l),s.shape),mean:()=>{let w=le(le(p,bt(-1)),h);return a.rank===1&&(w=ot(w,u)),ce(w,a.shape)},variance:()=>{let w=le(le(f,d),h);return a.rank===1&&(w=ot(w,u)),ce(w,a.shape)},scale:()=>{const w=le(d,p);let v=le(e,w);return a.rank===1&&(v=ot(v,u)),ce(v,a.shape)},offset:()=>{let w=e;return a.rank===1&&(w=ot(w,u)),ce(w,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zet={kernelName:G2,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a}=n,i=Bt(a,r.shape)[0];return{x:()=>{const l=r.shape,u=s.size,c=l.slice(0,i),d=c.length,h=l.slice(a,l.length).slice(1),p=h.length,f=kG(0,d),m=kG(d+1,d+1+p),g=IG([c,[u],h]),y=ce(e,g),b=ce(s,[u]),x=IG([[d],f,m]),w=qt(y,x);let v=zz(w,b,r.shape[i]);const k=Md(x);return v=qt(v,k),v},indices:()=>s}}};function kG(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function IG(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jet={kernelName:N1,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Kt(n),b:()=>Kt(r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qet={kernelName:$1,gradFunc:e=>({x:()=>Xe(e,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ett={kernelName:T1,gradFunc:e=>({x:()=>Kt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ttt={kernelName:_1,gradFunc:e=>({x:()=>Kt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ntt={kernelName:E1,gradFunc:e=>({x:()=>Kt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rtt={kernelName:j2,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=ui(r,0);return{x:()=>Fs(a,e,le(e,s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const stt={kernelName:R1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ft(e,Ee(n,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const att={kernelName:A1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ft(e,Xe(n,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const itt={kernelName:oKe,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const i=Ei(r);return rt(e,le(ot(e,s,!0),i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ott(e,t,n,r=5,s=1,a=1,i=.5){const o={x:e,y:t,dy:n},l={depthRadius:r,bias:s,alpha:a,beta:i};return ie.runKernel(TP,o,l)}const ltt=se({localResponseNormalizationBackprop_:ott});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const utt={kernelName:J2,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>ltt(r,s,e,a,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gte(e,t,n,r){return t.rank<n.rank&&(t=ce(t,br(t.shape,r))),e.rank<n.rank&&(e=ce(e,br(e.shape,r))),{x:()=>le(e,Xe(sl(n,t),e.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG={kernelName:Q2,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=t[1],o=Bt(s,a.shape),l=Gte(e,i,a,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ctt={kernelName:D1,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>le(e,Xe(Ld(n,r),"float32")),b:()=>le(e,Xe(O0(n,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dtt(e,t,n,r,s,a,i){const o=j(e,"dy","maxPool3dGrad"),l=j(t,"input","maxPool3dGrad"),u=j(n,"output","maxPool3dGrad");let c=o,d=l,h=u,p=!1;l.rank===4&&(p=!0,c=ce(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=ce(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=ce(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),U(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),U(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),U(h.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),ca("maxPool3dGrad",a,i);const f={dy:c,input:d,output:h},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=ie.runKernel(EP,f,m);return p?ce(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const htt=se({maxPool3dGrad_:dtt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ptt={kernelName:t$,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>htt(e,r,s,a,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ftt(e,t,n,r,s,a,i){const o=j(e,"dy","maxPoolGrad"),l=j(t,"input","maxPoolGrad"),u=j(n,"output","maxPoolGrad");U(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),U(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),U(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),ca("maxPoolGrad",a,i);const c={dy:o,input:l,output:u},d={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return ie.runKernel(_P,c,d)}const mtt=se({maxPoolGrad_:ftt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gtt={kernelName:e$,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>mtt(e,r,s,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ytt={kernelName:n$,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=Bt(s,r.shape),o=ds(r.shape,a)[1],l=ve(o);return{x:()=>{const c=r.shape.slice();a.forEach(p=>{c[p]=1});const d=ce(e,c);return ft(le(d,ki(r.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const btt={kernelName:r$,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=Bt(s,a.shape),l=Gte(e,i,a,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xtt={kernelName:F1,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>le(e,Xe(jf(n,r),"float32")),b:()=>le(e,Xe(ui(n,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wtt={kernelName:s$,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>jt(e,a,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vtt={kernelName:O1,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nt(n.shape,r.shape);return{a:()=>{const o=jr(n.shape,s);return o.length>0?ce(ot(e,o),n.shape):e},b:()=>{const o=le(e,Hn(lv(ft(n,r)))),l=jr(r.shape,s);return l.length>0?ce(ot(o,l),r.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ktt={kernelName:M1,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nt(n.shape,r.shape);return{a:()=>{const o=le(e,Xe(r,"float32")),l=jr(n.shape,s);return l.length>0?ce(ot(o,l),n.shape):o},b:()=>{const o=le(e,Xe(n,"float32")),l=jr(r.shape,s);return l.length>0?ce(ot(o,l),r.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Itt={kernelName:a$,gradFunc:e=>({x:()=>Hn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Stt={kernelName:l$,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>Fr(n.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ctt={kernelName:o$,gradFunc:e=>({x:()=>Kt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ntt={kernelName:u$,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return xo(e,r).map(a=>()=>a)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CG={kernelName:c$,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>jt(e,a,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $tt={kernelName:L1,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=Nt(a.shape,i.shape);return{a:()=>{const c=Xe(i,"float32");let d=le(e,le(c,ad(a,rt(c,bt(1)))));const h=jr(a.shape,o);return h.length>0&&(d=ot(d,h)),ce(d,a.shape)},b:()=>{const c=ui(a,0),d=Fs(c,Ai(a),Kt(a));let h=le(e,le(s,d));const p=jr(i.shape,o);return p.length>0&&(h=ot(h,p)),ce(h,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ttt={kernelName:d$,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=ui(n,0);return{x:()=>Fs(s,e,le(e,r)),alpha:()=>{let a=Fs(s,Kt(e),le(e,n));const i=jr(r.shape,e.shape);return i.length>0&&(a=ot(a,i)),ce(a,r.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _tt(e,t,n){const r=e.shape.slice();r[n]=1;const s=ce(t,r),a=LS(e,n,!0,!1),i=LS(e,n,!0,!0),o=le(a,i);return le(s,o)}function Ett(e,t,n){const r=e.shape.length,s=r-n.length,a=lr(n,r);let i=e;a!=null&&(i=qt(e,a));const o=i.shape.slice(),u=o.splice(r-n.length,n.length).reduce((h,p)=>h*p,1);o.push(u);const c=i.reshape(o);let d=_tt(c,t,s);if(d=d.reshape(i.shape),a!=null){const h=Md(a);d=qt(d,h)}return d}const Att={kernelName:h$,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return s==null?a=r.shape.map((i,o)=>o):typeof s=="number"?a=[s]:a=s,{x:()=>Ett(r,e,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rtt={kernelName:x1,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nt(n.shape,r.shape);return{a:()=>{const o=ft(e,Xe(r,"float32")),l=jr(n.shape,s);return l.length>0?ce(ot(o,l),n.shape):o},b:()=>{let o=le(e,Xe(n,"float32"));const l=jr(r.shape,s);l.length>0&&(o=ce(ot(o,l),r.shape));const u=En(r);return Hn(ft(o,Xe(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dtt={kernelName:P1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ft(e,Hn(En(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ftt={kernelName:B1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=le(jf(n,6),Ab(n));return{x:()=>le(e,Xe(r,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ott={kernelName:z1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,Xe(Ab(n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mtt={kernelName:p$,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(e,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ltt={kernelName:m$,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>ie.runKernel(VP,s,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ptt={kernelName:f$,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>ie.runKernel(WP,s,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ztt={kernelName:g$,gradFunc:(e,t,n)=>{const{dims:r}=n,s=Bt(r,e.shape);return{x:()=>bo(e,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Btt={kernelName:W1,gradFunc:e=>({x:()=>Kt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wtt={kernelName:V1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Hn(ft(e,le(ad(n,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vtt={kernelName:y$,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Xe(Kt(n),"float32"),t:()=>le(e,Xe(n,e.dtype)),e:()=>le(e,Xe(O$(n),e.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Utt={kernelName:U1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=ui(n,bt(0)),s=bt(J$),a=bt(Q$),i=le(e,a),o=le(le(e,s),Ei(Xe(n,"float32")));return Fs(r,i,o)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gtt={kernelName:q1,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,le(n,rt(bt(1),n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Htt={kernelName:j1,gradFunc:e=>({x:()=>Kt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jtt={kernelName:G1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(A$(Xe(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qtt={kernelName:H1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(gz(Xe(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ktt={kernelName:b$,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=Y$(r,s,a),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>Pd(e,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xtt={kernelName:k$,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=!0,i=le(e,r);return{logits:()=>rt(i,le(ot(i,[s],a),r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ytt={kernelName:K1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,zl(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NG={kernelName:w$,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>E$(e,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $G={kernelName:v$,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>$r(e,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ztt={kernelName:X1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ft(e,le(Ps(Xe(n,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jtt={kernelName:ZP,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,le(Xe(n,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qtt={kernelName:Y1,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=bt(2);return{a:()=>le(e,le(s,rt(n,r))),b:()=>le(e,le(s,rt(r,n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ent={kernelName:tv,gradFunc:e=>({x:()=>Kt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tnt={kernelName:Z1,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nt(n.shape,r.shape);return{a:()=>{let o=e;const l=jr(n.shape,s);return l.length>0&&(o=ot(o,l)),ce(o,n.shape)},b:()=>{let o=e;const l=jr(r.shape,s);return l.length>0&&(o=ot(o,l)),ce(Hn(o),r.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nnt={kernelName:x$,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;Bt(a,r.shape).forEach(u=>{s[u]=1});const o=ce(e,s),l=le(o,ki(r.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rnt={kernelName:J1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ft(e,En(A$(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const snt={kernelName:Q1,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(rt(bt(1),En(n)),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ant={kernelName:ev,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let i=Kt(r);if(r.rank===1)for(let o=0;o<s[0];++o)i=Ee(i,jt(e,[o*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let o=0;o<s[0];++o)for(let l=0;l<s[1];++l)i=Ee(i,jt(e,[o*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let o=0;o<s[0];++o)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)i=Ee(i,jt(e,[o*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let o=0;o<s[0];++o)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)i=Ee(i,jt(e,[o*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return i}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const int={kernelName:qm,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=Md(s);return{x:()=>qt(e,a)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ont={kernelName:S$,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>Di(e,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lnt={kernelName:C$,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>unt(e,n)}}};function unt(e,t){const n=Xu(t,Kt(t)),r=uv(e,n);let s=Ld(t,bt(0,"int32"));const a=r.rank-s.rank;for(let o=0;o<a;++o)s=xa(s,o+1);s=jl(s,ki(r.shape,"bool"));const i=Kt(r);return Fs(s,r,i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cnt={kernelName:N$,gradFunc:e=>({x:()=>Kt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dnt=[Ute,iet,oet,uet,cet,det,het,pet,fet,met,get,yet,wet,Iet,Cet,Net,$et,Tet,_et,Eet,Aet,Ret,Fet,Det,Let,Pet,zet,Bet,Wet,Vet,Rtt,Uet,Get,Het,jet,qet,Xet,Ket,Yet,Zet,Jet,Qet,ett,ttt,ntt,rtt,stt,att,itt,utt,SG,SG,ctt,ptt,gtt,ytt,btt,xtt,wtt,vtt,ktt,Itt,Stt,Ctt,Ntt,CG,CG,$tt,Ttt,Att,Dtt,Ftt,Ott,Mtt,Ltt,Ptt,ztt,Btt,Wtt,Vtt,Utt,Gtt,Htt,jtt,qtt,Ktt,Xtt,Ytt,NG,NG,$G,$G,Ztt,Qtt,Jtt,ent,tnt,nnt,rnt,snt,ant,int,ont,lnt,cnt];for(const e of dnt)uKe(e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.abs=function(){return this.throwIfDisposed(),Rr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.acos=function(){return this.throwIfDisposed(),HQ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.acosh=function(){return this.throwIfDisposed(),jQ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.add=function(e){return this.throwIfDisposed(),Ee(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.all=function(e,t){return this.throwIfDisposed(),dz(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.any=function(e,t){return this.throwIfDisposed(),MS(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.argMax=function(e){return this.throwIfDisposed(),Og(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.argMin=function(e){return this.throwIfDisposed(),qQ(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.asScalar=function(){return this.throwIfDisposed(),U(this.size===1,()=>"The array must have only 1 element."),ce(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.asType=function(e){return this.throwIfDisposed(),Xe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.as1D=function(){return this.throwIfDisposed(),ce(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.as2D=function(e,t){return this.throwIfDisposed(),ce(this,[e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),ce(this,[e,t,n])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),ce(this,[e,t,n,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),ce(this,[e,t,n,r,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.asin=function(){return this.throwIfDisposed(),KQ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.asinh=function(){return this.throwIfDisposed(),XQ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.atan=function(){return this.throwIfDisposed(),YQ(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.atan2=function(e){return this.throwIfDisposed(),ZQ(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.atanh=function(){return this.throwIfDisposed(),JQ(this)};Ce().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),_$(this,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),E$(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),sv(this,e,t,n,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Ym(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.cast=function(e){return this.throwIfDisposed(),Xe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.ceil=function(){return this.throwIfDisposed(),see(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),ri(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Kn&&(e=[e]),$r([this,...e],t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),pz(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),mz(this,e,t,n,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),sd(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.cos=function(){return this.throwIfDisposed(),A$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.cosh=function(){return this.throwIfDisposed(),gz(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),LS(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),yz(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),hee(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),av(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),pee(this,e,t,n,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.divNoNan=function(e){return this.throwIfDisposed(),fee(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.div=function(e){return this.throwIfDisposed(),ft(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.dot=function(e){return this.throwIfDisposed(),mee(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.elu=function(){return this.throwIfDisposed(),iv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.equal=function(e){return this.throwIfDisposed(),sl(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.erf=function(){return this.throwIfDisposed(),gee(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),xee(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.exp=function(){return this.throwIfDisposed(),Ei(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.expandDims=function(e){return this.throwIfDisposed(),xa(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.expm1=function(){return this.throwIfDisposed(),wee(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.fft=function(){return this.throwIfDisposed(),G$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.flatten=function(){return this.throwIfDisposed(),ce(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.floor=function(){return this.throwIfDisposed(),lv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.floorDiv=function(e){return this.throwIfDisposed(),cz(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.gather=function(e,t,n){return this.throwIfDisposed(),uv(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Ld(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.greater=function(e){return this.throwIfDisposed(),ui(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.ifft=function(){return this.throwIfDisposed(),P0(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.irfft=function(){return this.throwIfDisposed(),Oz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.isFinite=function(){return this.throwIfDisposed(),vee(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.isInf=function(){return this.throwIfDisposed(),kee(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.isNaN=function(){return this.throwIfDisposed(),Iee(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.leakyRelu=function(e){return this.throwIfDisposed(),D$(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.lessEqual=function(e){return this.throwIfDisposed(),jf(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.less=function(e){return this.throwIfDisposed(),O0(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),See(this,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.logSigmoid=function(){return this.throwIfDisposed(),Cee(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.logSoftmax=function(e){return this.throwIfDisposed(),wz(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),vz(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.log=function(){return this.throwIfDisposed(),Ai(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.log1p=function(){return this.throwIfDisposed(),F$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.logicalAnd=function(e){return this.throwIfDisposed(),jl(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.logicalNot=function(){return this.throwIfDisposed(),O$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.logicalOr=function(e){return this.throwIfDisposed(),kz(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.logicalXor=function(e){return this.throwIfDisposed(),Nee(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Ut(this,e,t,n)};Ce().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),M$(this,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.max=function(e,t){return this.throwIfDisposed(),fo(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.maximum=function(e){return this.throwIfDisposed(),Xu(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.mean=function(e,t){return this.throwIfDisposed(),dr(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.min=function(e,t){return this.throwIfDisposed(),F0(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.minimum=function(e){return this.throwIfDisposed(),op(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Tee(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.mod=function(e){return this.throwIfDisposed(),_ee(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.mul=function(e){return this.throwIfDisposed(),le(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.neg=function(){return this.throwIfDisposed(),Hn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.norm=function(e,t,n){return this.throwIfDisposed(),ov(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.notEqual=function(e){return this.throwIfDisposed(),Pg(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Sz(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.onesLike=function(){return this.throwIfDisposed(),Ri(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.pad=function(e,t){return this.throwIfDisposed(),Pd(this,e,t)};Ce().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),Eee(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.pow=function(e){return this.throwIfDisposed(),ad(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.prelu=function(e){return this.throwIfDisposed(),z$(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.prod=function(e,t){return this.throwIfDisposed(),Aee(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.reciprocal=function(){return this.throwIfDisposed(),Ree(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.relu=function(){return this.throwIfDisposed(),Ql(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.relu6=function(){return this.throwIfDisposed(),$z(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.reshapeAs=function(e){return this.throwIfDisposed(),ce(this,e.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.reshape=function(e){return this.throwIfDisposed(),ce(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Xee(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Yee(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.reverse=function(e){return this.throwIfDisposed(),bo(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.rfft=function(){return this.throwIfDisposed(),H$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.round=function(){return this.throwIfDisposed(),Tz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.rsqrt=function(){return this.throwIfDisposed(),_z(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.selu=function(){return this.throwIfDisposed(),Ez(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Az(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.sigmoid=function(){return this.throwIfDisposed(),zl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.sign=function(){return this.throwIfDisposed(),Dee(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.sin=function(){return this.throwIfDisposed(),Rz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.sinh=function(){return this.throwIfDisposed(),Dz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.slice=function(e,t){return this.throwIfDisposed(),jt(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.softmax=function(e){return this.throwIfDisposed(),U$(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.softplus=function(){return this.throwIfDisposed(),_b(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),P$(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.split=function(e,t){return this.throwIfDisposed(),Za(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.sqrt=function(){return this.throwIfDisposed(),Ps(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.square=function(){return this.throwIfDisposed(),En(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Mz(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.squeeze=function(e){return this.throwIfDisposed(),Kf(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Kn?[this,e]:[this,...e];return Di(n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.step=function(e){return this.throwIfDisposed(),Ab(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),Fee(this,e,t,n,r,s,a,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.sub=function(e){return this.throwIfDisposed(),rt(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.sum=function(e,t){return this.throwIfDisposed(),ot(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.tan=function(){return this.throwIfDisposed(),Oee(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.tanh=function(){return this.throwIfDisposed(),Mg(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.tile=function(e){return this.throwIfDisposed(),ao(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.toBool=function(){return this.throwIfDisposed(),Xe(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.toFloat=function(){return this.throwIfDisposed(),Xe(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.toInt=function(){return this.throwIfDisposed(),Xe(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.topk=function(e,t){return this.throwIfDisposed(),Pee(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.transpose=function(e){return this.throwIfDisposed(),qt(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.unique=function(e){return this.throwIfDisposed(),zee(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),zz(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.unstack=function(e){return this.throwIfDisposed(),xo(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.where=function(e,t){return this.throwIfDisposed(),Fs(e,this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ce().prototype.zerosLike=function(){return this.throwIfDisposed(),Kt(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Il extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Il.prototype)}}class oo extends Error{constructor(t){super(t),Object.setPrototypeOf(this,oo.prototype)}}class de extends Error{constructor(t){super(t),Object.setPrototypeOf(this,de.prototype)}}class Dt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Dt.prototype)}}class vB extends Error{constructor(t){super(t),Object.setPrototypeOf(this,vB.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Hte{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let n;return this.cache.has(t)&&(n=this.cache.get(t),this.cache.delete(t),this.cache.set(t,n)),n}put(t,n){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let n=0;n<this.maxEntries-t;n++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function up(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{const n=new Array(t);return n.fill(e),n}}function Sl(e,t){if(!e)throw new vB(t)}function TG(e,t){let n=0;for(const r of e)r===t&&n++;return n}function wa(e){return e.length===1?e[0]:e}function Wn(e){return Array.isArray(e)?e:[e]}function gu(e){const n=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function ch(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}let Ui={};function kB(e){if(e==null)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function BR(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>BR(t));else{const t=Object.keys(e);for(const n of t){const r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:BR(r))}}}function pv(e,t={},n={},r="object",s=!1){if(typeof e=="string"){const a=e;let i;if(a in n)i=n[a];else if(a in Ui)i=Ui[a];else if(i=t[a],i==null)throw new de(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{const a=e;if(a.className==null||a.config==null)throw new de(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in Ui?[o,l]=Ui.className:i in t&&([o,l]=t[i]),o==null)throw new de(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const p of Object.keys(Ui))u[p]=Ui[p];for(const p of Object.keys(n))u[p]=n[p];const c=a.config;c.customObjects=u;const d=Object.assign({},Ui);for(const p of Object.keys(n))Ui[p]=n[p];BR(a.config);const h=l(o,a.config,n,s);return Ui=Object.assign({},d),h}else{const u=Object.assign({},Ui);for(const d of Object.keys(n))Ui[d]=n[d];const c=new o(a.config);return Ui=Object.assign({},u),c}}}function hnt(e,t){return e<t?-1:e>t?1:0}function _k(e,t){return-1*hnt(e,t)}function Pc(e){if(e==null)return e;const t=[];for(const n of e)t.indexOf(n)===-1&&t.push(n);return t}function pnt(e){if(e==null)throw new de(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function Yf(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new de(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function IB(e,t,n=0,r=1/0){return Sl(n>=0),Sl(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(s=>typeof s===t)}function rs(e,t){Array.isArray(e)?(U(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>rs(n,`element ${r+1} of ${t}`))):U(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${jte(e)}.`)}function jte(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>jte(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function fnt(e,t,n){let r=n!=null?n():ya(),s;return(...i)=>{const o=n!=null?n():ya();return o-r<t||(r=o,s=e(...i)),s}}function qte(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let mnt=0;function Kte(){return mnt++}const Ek={};function eT(e=""){return e in Ek||(Ek[e]=0),Ek[e]+=1,e+Ek[e].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const gnt=["channelsFirst","channelsLast"],ynt=["nearest","bilinear"],bnt=["valid","same","causal"],xnt=["max","avg"],wnt=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const hm=new Map;function vr(e){Yf(gnt,"DataFormat",e)}function vnt(e){Yf(ynt,"InterpolationFormat",e)}function zi(e){Yf(bnt,"PaddingMode",e)}function Xte(e){Yf(xnt,"PoolMode",e)}const jx=[],_G="/";function Th(e,t){jx.push(e);try{const n=t();return jx.pop(),n}catch(n){throw jx.pop(),n}}function knt(){return jx.length===0?"":jx.join(_G)+_G}function Yte(e){if(!Jte(e))throw new Error("Not a valid tensor name: '"+e+"'");return knt()+e}function Zte(e){if(!Jte(e))throw new Error("Not a valid tensor name: '"+e+"'");hm.has(e)||hm.set(e,0);const t=hm.get(e);if(hm.set(e,hm.get(e)+1),t>0){const n=`${e}_${t}`;return hm.set(n,1),n}else return e}const Int=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Jte(e){return!!e.match(Int)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Snt(e){return e===parseInt(e.toString(),10)}function zc(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function Bg(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function id(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function al(e,t){if(t<e)throw new de(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let M_;function Lr(){return M_==null&&(M_=hXe().epsilon()),M_}function il(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Wl(e,t){return Xe(e,t)}function fv(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),ce(e,n)}function Cnt(e,t){return ge(()=>{if(e.shape.length!==2)throw new de(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);const n=fv(e,1);return WR(n,[1,t,1])})}function Nnt(e){const t=[zc(e.shape)];return ce(e,t)}function $nt(e){if(e.rank<=1)throw new de(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],zc(e.shape,1)];return ce(e,t)}function _h(e,t,n){return ge(()=>{switch(e.rank){case 1:return W$(e,t,n);case 2:return Fz(e,[t,0],[n,e.shape[1]]);case 3:return V$(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return L0(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return jt(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return jt(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new de(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function L_(e,t,n){return ge(()=>{switch(e.rank){case 1:return W$(e,t,n);case 2:return Fz(e,[0,t],[e.shape[0],n]);case 3:return V$(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return L0(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new de(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Ak(e,t,n,r){return ge(()=>{switch(e.rank){case 1:return W$(e,t,n);case 2:switch(r){case 1:return _h(e,t,n);case 2:return L_(e,t,n);default:throw new de(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return _h(e,t,n);case 2:return V$(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return L_(e,t,n);default:throw new de(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return _h(e,t,n);case 2:return L0(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return L0(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return L_(e,t,n);default:throw new de(`The axis is not within the rank of the tensor ${r}`)}default:throw new de(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function SB(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),$r(e,t)}function EG(e,t){switch(e.rank){case 1:return aee([e,t]);case 2:return iee([e,t],0);case 3:return oee([e,t],0);case 4:return lee([e,t],0);default:throw new de(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function WR(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new de(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return ao(e,t)}function tT(e,t=0,n=1,r,s){return Nz(e,t,n,r,s)}function Vl(e,t,n,r){if(e.rank<2||t.rank<2)throw new Dt(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){const s=e.shape.slice(-1)[0],a=t.shape.slice(-2)[0];if(s!==a)throw new Dt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return MR({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?VR(e.rank,r,il()):null,activation:n});{const s=e.shape.slice(),a=s.pop();e=ce(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},(f,m)=>m===0?t.rank-2:m<=t.rank-2?m-1:m);t=ce(qt(t,c),[l,-1]);const d=[...s,...u];return ce(MR({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?VR(e.rank,r,il()):null,activation:n}),d)}}function Qte(e,t,n){return ge(()=>(Array.isArray(t)?t=ka(t,"int32"):t=Xe(t,"int32"),uv(e,t,n)))}function mv(e){return le(e,e)}function VR(e,t,n){const r=t.shape;if(t.rank!==1&&t.rank!==e)throw new de(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?ce(t,[1,r[0],1,1,1]):ce(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?ce(t,[1,1,1,1,r[0]]):ce(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?ce(t,[1,r[0],1,1]):ce(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?ce(t,[1,1,1,r[0]]):ce(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?ce(t,[1,r[0],1]):ce(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?ce(t,[1,1,r[0]]):ce(t,[1].concat(r))}else if(e<3)return t;throw new de(`Unsupported input rank by biasAdd: ${t.rank}`)}function dl(e,t,n){return ge(()=>(n==null&&(n=il()),vr(n),Ee(e,VR(e.rank,t,n))))}function Tnt(e,t=1){if(t!==1)throw new Dt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return iv(e)}function _nt(e){return ge(()=>ft(e,Ee(Rr(e),1)))}function ene(e,t,n,r){return ge(()=>Vee(e,t,n,r))}function Ent(e){return ge(()=>{const t=Ee(.5,le(.2,e));return ri(t,0,1)})}function gv(e,t,n=!1){return n?e():t()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ant=["fanIn","fanOut","fanAvg"],Rnt=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Dnt(e){Yf(Ant,"FanMode",e)}function Fnt(e){Yf(Rnt,"Distribution",e)}class No extends Db{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class tne extends No{apply(t,n){return Fr(t,n)}}tne.className="Zeros";Ae(tne);class CB extends No{apply(t,n){return ki(t,n)}}CB.className="Ones";Ae(CB);class nne extends No{constructor(t){if(super(),typeof t!="object")throw new de(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new de(`config must have value set but got ${t}`);this.value=t.value}apply(t,n){return ge(()=>le(bt(this.value),ki(t,n)))}getConfig(){return{value:this.value}}}nne.className="Constant";Ae(nne);class rne extends No{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,n){return Eb(t,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}rne.className="RandomUniform";Ae(rne);class sne extends No{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Dt(`randomNormal does not support dType ${n}.`);return tT(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}sne.className="RandomNormal";Ae(sne);class ane extends No{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Dt(`truncatedNormal does not support dType ${n}.`);return Pz(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}ane.className="TruncatedNormal";Ae(ane);class ine extends No{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,n){return ge(()=>{if(t.length!==2||t[0]!==t[1])throw new de("Identity matrix initializer can only be used for 2D square matrices.");return le(this.gain,xz(t[0]))})}getConfig(){return{gain:this.gain}}}ine.className="Identity";Ae(ine);function Ont(e,t="channelsLast"){let n,r;if(vr(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){const s=zc(e,2);n=e[1]*s,r=e[0]*s}else if(t==="channelsLast"){const s=zc(e,0,e.length-2);n=e[e.length-2]*s,r=e[e.length-1]*s}}else{const s=zc(e);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}class si extends No{constructor(t){if(super(),t.scale<0)throw new de(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,Dnt(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,Fnt(this.distribution),this.seed=t.seed}apply(t,n){const r=Ont(t),s=r[0],a=r[1];let i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,s):this.mode==="fanOut"?i/=Math.max(1,a):i/=Math.max(1,(s+a)/2),this.distribution==="normal"){const o=Math.sqrt(i);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Dt(`${this.getClassName()} does not support dType ${n}.`);return Pz(t,0,o,n,this.seed)}else{const o=Math.sqrt(3*i);return Eb(t,-o,o,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}si.className="VarianceScaling";Ae(si);class NB extends si{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return si.className}}NB.className="GlorotUniform";Ae(NB);class $B extends si{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return si.className}}$B.className="GlorotNormal";Ae($B);class TB extends si{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return si.className}}TB.className="HeNormal";Ae(TB);class _B extends si{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return si.className}}_B.className="HeUniform";Ae(_B);class EB extends si{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return si.className}}EB.className="LeCunNormal";Ae(EB);class AB extends si{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return si.className}}AB.className="LeCunUniform";Ae(AB);class one extends No{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,n){return ge(()=>{if(t.length<2)throw new Dt("Shape must be at least 2D.");if(n!=="int32"&&n!=="float32"&&n!==void 0)throw new TypeError(`Unsupported data type ${n}.`);n=n;const r=ve(t.slice(0,-1)),s=t[t.length-1],a=r*s;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const i=[Math.max(s,r),Math.min(s,r)],o=tT(i,0,1,n,this.seed),l=Zee.qr(o,!1);let u=l[0];const d=l[1].flatten().stridedSlice([0],[Math.min(s,r)*Math.min(s,r)],[Math.min(s,r)+1]);return u=le(u,d.sign()),r<s&&(u=u.transpose()),le(bt(this.gain),u.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}one.className="Orthogonal";Ae(one);const AG={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function RG(e,t={}){return pv(e,eo.getMap().classNameMap,t,"initializer")}function ir(e){return kB(e)}function Zn(e){if(typeof e=="string"){const t=e in AG?AG[e]:e;if(t==="GlorotNormal")return new $B;if(t==="GlorotUniform")return new NB;if(t==="HeNormal")return new TB;if(t==="HeUniform")return new _B;if(t==="LeCunNormal")return new EB;if(t==="LeCunUniform")return new AB;{const n={};return n.className=t,n.config={},RG(n)}}else return e instanceof No?e:RG(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function UR(e){return Array.isArray(e)&&Array.isArray(e[0])}function PS(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function vt(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new de(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function rn(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new de(`Expected exactly 1 Shape; got ${e.length}`)}else return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zS(e){let t=0;for(const n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,s)=>r*s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const DG="Variable";class Mnt{constructor(t,n="float32",r=DG,s=!0,a=null){this.dtype=n??"float32",this.shape=t.shape,this.id=Kte(),r=r??DG,this.originalName=Yte(r),this.name=Zte(this.originalName),this.trainable_=s,this.constraint=a,this.val=Bee(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),Lnt(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function Lnt(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function GR(e){return e.map(t=>t.read())}function RB(e){e.forEach(t=>{t[0].write(t[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Pr{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class El{constructor(t,n,r,s,a,i,o){this.dtype=t,this.shape=n,this.sourceLayer=r,this.inputs=s,this.callArgs=a,this.outputTensorIndex=o,this.id=Kte(),i!=null&&(this.originalName=Yte(i),this.name=Zte(this.originalName)),this.rank=n.length}}let Pnt=0;class nT{constructor(t,n){this.callArgs=n,this.id=Pnt++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)r!=null&&r.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const n of this.inboundLayers)n!=null?t.push(n.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let znt=0;class Wt extends Db{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=znt++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=t.name;if(!n){const r=this.getClassName();n=gu(r)+"_"+eT(r)}if(this.name=n,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let r;if(t.batchInputShape!=null)r=t.batchInputShape;else if(t.inputShape!=null){let a=null;t.batchSize!=null&&(a=t.batchSize),r=[a].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;s==null&&(s=t.inputDType),s==null&&(s="float32"),this.dtype=s}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,n){return t.name+"_ib-"+n.toString()}getNodeAtIndex(t,n){if(this.inboundNodes.length===0)throw new oo(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=t)throw new de(`Asked to get ${n} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return wa(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return wa(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Il(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Il(`Layer ${this.name} is not connected, no input to return.`);return wa(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Il(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Il(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return wa(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(n=>n.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Wn(t),this.inputSpec==null||this.inputSpec.length===0)return;const n=Wn(this.inputSpec);if(t.length!==n.length)throw new de(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let r=0;r<t.length;r++){const s=t[r],a=n[r];if(a==null)continue;const i=s.rank;if(a.ndim!=null&&i!==a.ndim)throw new de(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${i}`);if(a.maxNDim!=null&&i>a.maxNDim)throw new de(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${i}`);if(a.minNDim!=null&&i<a.minNDim)throw new de(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${i}.`);if(a.dtype!=null&&s.dtype!==a.dtype)throw new de(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${s.dtype}.`);if(a.axes){const o=s.shape;for(const l in a.axes){const u=Number(l),c=a.axes[l],d=u>=0?o[u]:o[o.length+u];if(c!=null&&[c,null].indexOf(d)===-1)throw new de(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${o}.`)}}if(a.shape!=null)for(let o=0;o<a.shape.length;++o){const l=a.shape[o],u=s.shape[o];if(l!=null&&u!=null&&l!==u)throw new de(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${s.shape}.`)}}}call(t,n){return t}invokeCallHook(t,n){this._callHook!=null&&this._callHook(t,n)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,n){n=n||{},this.assertNotDisposed();const r=Wn(t);let s=!0;for(const i of r)if(!(i instanceof El)){s=!1;break}let a=!0;for(const i of r)if(i instanceof El){a=!1;break}if(s===a)throw new de("Arguments to apply() must be all SymbolicTensors or all Tensors");return Th(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const i=[];for(const o of Wn(t))i.push(o.shape);this.build(wa(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let i=this.call(t,n);const o=Wn(i),l=[];for(let u of o)r.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(i=wa(l),this.activityRegularizer!=null)throw new Dt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{const i=Bnt(t),o=this.computeOutputShape(i);let l;const u=Wnt(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((c,d)=>new El(u,c,this,Wn(t),n,this.name,d)):l=new El(u,o,this,Wn(t),n,this.name),this.addInboundNode(t,l,null,null,i,o,n),this._refCount++,this.activityRegularizer!=null)throw new Dt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&t[s]!=null&&t[s]!==r&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Il(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const n of this.inboundNodes){const r=JSON.stringify(n.outputShapes);t.indexOf(r)===-1&&t.push(r)}if(t.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new Il(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new oo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return zS(this.weights)}build(t){this.built=!0}getWeights(t=!1){return GR(t?this.trainableWeights:this.weights)}setWeights(t){ge(()=>{const n=this.weights;if(n.length!==t.length)throw new de(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${n.length} weights. Provided weights: ${t}...`);if(n.length===0)return;const r=[],s=GR(n);for(let a=0;a<s.length;++a){const i=s[a],o=n[a],l=t[a];if(!Xt(i.shape,l.shape))throw new de(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([o,l])}RB(r)})}addWeight(t,n,r,s,a,i,o,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new de(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=l!=null?l():Zn("zeros"));const u=s.apply(n,r),c=new Mnt(u,r,t,i,o);return u.dispose(),a!=null&&this.addLoss(()=>a.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Wn(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}addInboundNode(t,n,r,s,a,i,o=null){const l=Wn(t);n=Wn(n),r=Wn(r),s=Wn(s),a=PS(a),i=PS(i);const u=[],c=[],d=[];for(const h of l)u.push(h.sourceLayer),c.push(h.nodeIndex),d.push(h.tensorIndex);new nT({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:n,inputMasks:r,outputMasks:s,inputShapes:a,outputShapes:i},o);for(let h=0;h<n.length;h++)n[h].sourceLayer=this,n[h].nodeIndex=this.inboundNodes.length-1,n[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function Bnt(e){e=Wn(e);const t=[];for(const n of e)t.push(n.shape);return wa(t)}function Wnt(e){return"float32"}function lne(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{const r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{const s=[];for(let a=0;a<r.inboundLayers.length;a++){const i=r.inputTensors[a],o=r.inboundLayers[a],l=r.nodeIndices[a],u=lne(i,o,l);for(const c of u)s.indexOf(c)===-1&&s.push(c)}return s}}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class yv extends Wt{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:eT("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new de("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=t.batchInputShape;if(n==null){if(t.inputShape==null)throw new de("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new de("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=t.dtype||"float32";this.batchInputShape=n,this.dtype=r,this.inputSpec=[{shape:n}];const s=new El(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new nT({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(t,n){throw new de(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}yv.className="InputLayer";Ae(yv);function Vnt(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new de("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new yv({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Unt(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return Xe(t,e.dtype)}catch{throw new de(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}class vc{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof vc)for(const n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(const n of t)this.add(n.key,n.value)}}add(t,n,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=Unt(t,n),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new de(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof El){if(this.id2Value[t.id]==null)throw new de(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const n=this.name2Id[t];if(n==null)throw new de(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof El){if(this.id2Value[t.id]==null)throw new de(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const n=this.name2Id[t];if(n==null)throw new de(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&nt(this.id2Mask)}}const BS=new Hte,WS=new Hte;function Gnt(e){BS!=null&&BS.setMaxEntries(e),WS!=null&&WS.setMaxEntries(e)}function Nx(e,t,n,r){const s=n==null?!1:n.training,a=Array.isArray(e),i=a?e:[e],o=i.map(f=>f.name),l=[],u=t.names();for(const f of o)u.indexOf(f)!==-1?l.push(t.getValue(f)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let d=BS.get(c),h;if(d==null){const f=Hnt(i,t);d=f.sorted,h=f.recipientCounts,BS.put(c,d),WS.put(c,h)}h={},s||Object.assign(h,WS.get(c));const p=new vc(t);for(let f=0;f<d.length;++f){if(r!=null){const $=NR().numTensors;$>r.maxNumTensors&&(r.maxNumTensors=$),$<r.minNumTensors&&(r.minNumTensors=$)}const m=d[f],g=m.sourceLayer;if(g instanceof yv)continue;const y=[],b=[],x=[];let w=!1;for(const $ of m.inputs){const N=p.getValue($),T=p.getMask($);y.push(N),b.push(T),T!=null&&(w=!0),s||(h[$.name]--,h[$.name]===0&&!t.hasKey($)&&o.indexOf($.name)===-1&&!N.isDisposed&&$.sourceLayer.stateful!==!0&&x.push(N))}w&&(n=n||{},n.mask=b[0]);const v=Wn(g.apply(y,n));let k=null;g.supportsMasking&&(k=g.computeMask(y,b));const I=qnt(m),S=Array.isArray(I)?I:[I];for(let $=0;$<S.length;++$){p.hasKey(S[$])||p.add(S[$],v[$],Array.isArray(k)?k[0]:k);const N=o.indexOf(S[$].name);N!==-1&&(l[N]=v[$])}s||nt(x)}return p.disposeMasks(),a?l:l[0]}function Hnt(e,t){U(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){const s=FG(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:i,recipientMap:o}=FG(a,t);for(const l of i)s.has(l.name)||(n.push(l),s.add(l.name));for(const l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:jnt(r)}}function jnt(e){const t={};for(const n in e)t[n]=e[n].size;return t}function FG(e,t){const n=new Set,r=[],s={};for(const o of t.names())n.add(o);const a=[],i=[];for(a.push(e);a.length>0;){const o=a[a.length-1];if(n.has(o.name)){a.pop();continue}const l=i[i.length-1]===a.length-1;if(o.inputs.length===0||l)a.pop(),r.push(o),n.add(o.name),l&&i.pop();else{i.push(a.length-1);for(const u of o.inputs)s[u.name]==null&&(s[u.name]=new Set),s[u.name].add(o.name),!n.has(u.name)&&a.push(u)}}return{sorted:r,recipientMap:s}}function qnt(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(const s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Knt=xe();Knt.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Gnt);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function DB(e,t){return ge(()=>Ps(ot(le(e,e),t,!0)))}class bv extends Db{getConfig(){return{}}}class une extends bv{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return ge(()=>{const n=DB(t,this.axis),r=ri(n,0,this.maxValue);return le(t,ft(r,Ee(Lr(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}une.className="MaxNorm";Ae(une);class cne extends bv{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return ge(()=>ft(t,Ee(Lr(),DB(t,this.axis))))}getConfig(){return{axis:this.axis}}}cne.className="UnitNorm";Ae(cne);class dne extends bv{apply(t){return Ql(t)}}dne.className="NonNeg";Ae(dne);class hne extends bv{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return ge(()=>{const n=DB(t,this.axis),r=Ee(le(this.rate,ri(n,this.minValue,this.maxValue)),le(1-this.rate,n));return le(t,ft(r,Ee(Lr(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}hne.className="MinMaxNorm";Ae(hne);const OG={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Gr(e){return kB(e)}function MG(e,t={}){return pv(e,eo.getMap().classNameMap,t,"constraint")}function Hr(e){if(e==null)return null;if(typeof e=="string"){const n={className:e in OG?OG[e]:e,config:{}};return MG(n)}else return e instanceof bv?e:MG(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Xd(e){if(e==null)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if(typeof a!="number"){const i=a;t.push(i.data()),n.push(s),r.push(i)}}if(t.length>0){const s=await Promise.all(t);for(let a=0;a<s.length;++a)e[n[a]]=s[a][0];nt(r)}}function pne(e){if(e!=null)for(const t in e){const n=e[t];typeof n!="number"&&n.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var LG;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(LG||(LG={}));const Xnt=125;class z0{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,n){}async onEpochEnd(t,n){}async onBatchBegin(t,n){}async onBatchEnd(t,n){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class Ynt{constructor(t,n=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=n}append(t){this.callbacks.push(t)}setParams(t){for(const n of this.callbacks)n.setParams(t)}setModel(t){for(const n of this.callbacks)n.setModel(t)}async onEpochBegin(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onEpochBegin(t,n)}async onEpochEnd(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onEpochEnd(t,n)}async onBatchBegin(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onBatchBegin(t,n)}async onBatchEnd(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onBatchEnd(t,n)}async onTrainBegin(t){t==null&&(t={});for(const n of this.callbacks)await n.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const n of this.callbacks)await n.onTrainEnd(t)}}class Znt extends z0{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,n){n==null&&(n={});const r=n.size==null?0:n.size;this.seen+=r;for(const s in n){const a=n[s];if(typeof a=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+a*r;else{let i;s in this.totals?i=this.totals[s]:this.totals[s]=0;const o=ge(()=>Ee(this.totals[s],le(a,r)));this.totals[s]=o,i!=null&&i.dispose()}}}async onEpochEnd(t,n){if(n!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?n[r]=this.totals[r]/this.seen:ge(()=>{const s=le(ft(1,this.seen),this.totals[r]);n[r]=s,this.totals[r].dispose(),ns(n[r])}))}}class Jnt extends z0{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,n){n==null&&(n={}),this.epoch.push(t);for(const r in n)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(n[r])}async syncData(){const t=[],n=[],r=[];for(const a in this.history){const i=this.history[a];for(let o=0;o<i.length;++o)if(typeof i[o]!="number"){const l=i[o];t.push(l.data()),n.push(a),r.push(o)}}const s=await Promise.all(t);for(let a=0;a<s.length;++a)this.history[n[a]][r[a]].dispose(),this.history[n[a]][r[a]]=s[a][0]}}class Qnt extends z0{constructor(t,n){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||bte,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Xnt),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");iR(this.yieldEvery)&&(this.maybeWait=fnt(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,n,r){const s=[];this.yield!=null&&(await Xd(r),s.push(this.yield(t,n,r))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(t,n){this.currentEpoch=t,this.epochBegin!=null&&(await Xd(n),await this.epochBegin(t,n))}async onEpochEnd(t,n){const r=[];this.epochEnd!=null&&(await Xd(n),r.push(this.epochEnd(t,n))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(t,n){this.batchBegin!=null&&(await Xd(n),await this.batchBegin(t,n))}async onBatchEnd(t,n){const r=[];this.batchEnd!=null&&(await Xd(n),r.push(this.batchEnd(t,n))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):iR(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,t,n)),await Promise.all(r)}async onTrainBegin(t){this.trainBegin!=null&&(await Xd(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Xd(t),await this.trainEnd(t))}}function fne(e,t){return e==null&&(e={}),e instanceof z0?[e]:Array.isArray(e)&&e[0]instanceof z0?e:Wn(e).map(r=>new Qnt(r,t))}class Ki{constructor(){}static registerCallbackConstructor(t,n){U(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Ki.checkForDuplicate(n),Ki.constructors[t]==null&&(Ki.constructors[t]=[]),Ki.constructors[t].push(n)}static checkForDuplicate(t){for(const n in Ki.constructors)Ki.constructors[+n].forEach(s=>{if(s===t)throw new de("Duplicate callback constructor.")})}static clear(){Ki.constructors={}}static createCallbacks(t){const n=[];for(const r in Ki.constructors){const s=+r;t>=s&&n.push(...Ki.constructors[s])}return n.map(r=>new r)}}Ki.constructors={};function mne(e,t,n,r,s,a,i,o,l){const u=new Jnt,c=[new Znt,...Ki.createCallbacks(t)];e!=null&&c.push(...e),c.push(u);const d=new Ynt(c);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _u(e,t={},n=!1){return pv(e,eo.getMap().classNameMap,t,"layer",n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function VS(e,t){return ge(()=>{e.dtype!=="float32"&&(e=Xe(e,"float32"));const n=ot(mv(e),t,!0),r=Tb(n.shape,Lr()),s=Ps(Xu(n,r));return ft(e,s)})}function rT(e,t){return ge(()=>dr(mv(rt(t,e)),-1))}function FB(e,t){return ge(()=>dr(Rr(rt(t,e)),-1))}function OB(e,t){return ge(()=>{const n=rt(e,t),r=ri(Rr(e),Lr(),Number.MAX_VALUE),s=Rr(ft(n,r));return le(100,dr(s,-1))})}function ert(e,t){return ge(()=>{const n=ri(t,Lr(),Number.MAX_VALUE),r=Ai(Ee(1,n)),s=ri(e,Lr(),Number.MAX_VALUE),a=Ai(Ee(1,s));return dr(mv(rt(r,a)),-1)})}function trt(e,t){return ge(()=>{const n=Xu(0,rt(1,le(e,t)));return dr(mv(n),-1)})}function nrt(e,t){return ge(()=>{const n=Xu(0,rt(1,le(e,t)));return dr(n,-1)})}function rrt(e,t){return ge(()=>{const n=ot(le(e,t),-1),r=fo(le(rt(1,e),t),-1);return Xu(0,Ee(1,rt(r,n)))})}function srt(e,t){return ge(()=>{const n=Math.log(2),r=rt(t,e),s=rt(Ee(r,_b(le(-2,r))),n);return dr(s,-1)})}function B0(e,t,n=!1){return ge(()=>{if(n)t=U$(t);else{const r=ot(t,t.shape.length-1,!0);t=ft(t,r)}return t=ri(t,Lr(),1-Lr()),Hn(ot(le(Xe(e,"float32"),Ai(t)),t.shape.length-1))})}function US(e,t,n=!1){return ge(()=>{const r=Xe(lv(Nnt(e)),"int32");t=ri(t,Lr(),1-Lr());const s=t.shape,a=ce(Sz(r,s[s.length-1]),s);return B0(a,t,n)})}function art(e,t){if(!Xt(e.shape,t.shape))throw new de(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return ge(()=>{const n=Ql(t),r=Hn(Rr(t));return Ee(rt(n,le(t,e)),F$(Ei(r)))})}function sT(e,t){return ge(()=>{let n;return n=ri(t,Lr(),1-Lr()),n=Ai(ft(n,rt(1,n))),dr(art(e,n),-1)})}function irt(e,t){return ge(()=>{const n=ri(e,Lr(),1),r=ri(t,Lr(),1);return ot(le(e,Ai(ft(n,r))),-1)})}function ort(e,t){return ge(()=>{const n=Ai(Ee(Lr(),t));return dr(rt(t,le(e,n)),-1)})}function gne(e,t){return ge(()=>{const n=VS(e,-1),r=VS(t,-1),s=le(n,r);return Hn(ot(s,-1))})}const GS={meanSquaredError:rT,meanAbsoluteError:FB,meanAbsolutePercentageError:OB,meanSquaredLogarithmicError:ert,squaredHinge:trt,hinge:nrt,categoricalHinge:rrt,logcosh:srt,categoricalCrossentropy:B0,sparseCategoricalCrossentropy:US,binaryCrossentropy:sT,kullbackLeiblerDivergence:irt,poisson:ort,cosineProximity:gne};function P_(e){if(typeof e=="string"){if(e in GS)return GS[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new de(t)}else return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yne(e,t){return ge(()=>{const n=le(.5,Ri(t)),r=Wl(ui(t,n),e.dtype);return dr(sl(e,r),-1)})}function bne(e,t){return ge(()=>Wl(sl(Og(e,-1),Og(t,-1)),"float32"))}function lrt(e,t){return ge(()=>Xe(ot(jl(sl(e,1),sl(t,1))),"float32"))}function urt(e,t){return ge(()=>Xe(ot(jl(sl(e,0),sl(t,1))),"float32"))}function crt(e,t){return ge(()=>{const n=lrt(e,t),r=urt(e,t),s=Ee(n,r);return Xe(Fs(ui(s,0),ft(n,s),0),"float32")})}function drt(e,t){return sT(e,t)}function hrt(e,t){return e.rank===t.rank&&(e=Kf(e,[e.rank-1])),t=Og(t,-1),t.dtype!==e.dtype&&(t=Xe(t,e.dtype)),Xe(sl(e,t),"float32")}const prt=rT,frt=rT,mrt=FB,grt=FB,yrt=OB,brt=OB,xne=B0,xrt=gne,wne=US,HS={binaryAccuracy:yne,categoricalAccuracy:bne,precision:crt,categoricalCrossentropy:xne,sparseCategoricalCrossentropy:wne,mse:prt,MSE:frt,mae:mrt,MAE:grt,mape:yrt,MAPE:brt,cosine:xrt};function wrt(e){if(typeof e=="string"&&e in HS)return HS[e];if(typeof e!="string"&&e!=null)return e;throw new de(`Unknown metric ${e}`)}function Rk(e){if(Sl(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(const n of Object.keys(GS))if(GS[n]===e){t=n;break}if(t!==void 0)return t;for(const n of Object.keys(HS))if(HS[n]===e){t=n;break}return t!==void 0?t:e.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vrt(e){const t={Adagrad:()=>dm.adagrad(.01),Adadelta:()=>dm.adadelta(1,.95,Lr()),Adam:()=>dm.adam(.001,.9,.999,Lr()),Adamax:()=>dm.adamax(.002,.9,.999,Lr(),0),RMSProp:()=>dm.rmsprop(.001,.9,0,Lr()),SGD:()=>dm.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new de(`Unknown Optimizer ${e}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const PG=1*1024*1024;function zG(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!HR(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const r=JSON.stringify(e);r.length>PG&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${PG}.`)}}function HR(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t)if(typeof n!="string"||!HR(e[n]))return!1;return!0}else if(Array.isArray(e)){for(const t of e)if(!HR(t))return!1;return!0}else return!1;else{const t=typeof e;return t==="string"||t==="number"||t==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function krt(e,t,n,r=console.log){const s=Srt(e),a=["Layer (type)","Input Shape","Output shape","Param #"];s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let i;if(!s){a.push("Receives inputs"),i=[];for(const c in e.nodesByDepth)i.push(...e.nodesByDepth[c])}r("_".repeat(t)),jS(a,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)s?Crt(o[c],n,r):Nrt(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=Irt(e),u=zS(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function Irt(e){let t;return e.collectedTrainableWeights!=null?t=zS(e.collectedTrainableWeights):t=zS(e.trainableWeights),t}function Srt(e){let t=!0;const n=[],r=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of e.layers){let a=!1;for(const i of s.inboundNodes)if(r.indexOf(i)!==-1)if(a){t=!1;break}else a=!0;if(!t)break}return t}function jS(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function Crt(e,t,n){let r,s;try{s=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}const a=e.name,i=e.getClassName(),o=[`${a} (${i})`,s,r,e.countParams().toString()];jS(o,t,n)}function Nrt(e,t,n,r){let s,a;try{a=e.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{a="multiple"}try{s=JSON.stringify(e.outputShape)}catch{s="multiple"}const i=[];for(const d of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let h=0;h<d.inboundLayers.length;++h){const p=d.inboundLayers[h].name,f=d.nodeIndices[h],m=d.tensorIndices[h];i.push(`${p}[${f}][${m}]`)}const o=e.name,l=e.getClassName(),u=i.length===0?"":i[0],c=[`${o} (${l})`,a,s,e.countParams().toString(),u];jS(c,t,r);for(let d=1;d<i.length;++d)jS(["","","","",i[d]],t,r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vne(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function jR(e,t){if(e===null)return null;if(typeof e=="string")return ch(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const a=e[s];vne(t,s,a)?n.push(a):n.push(jR(a,t))}return n}else{const n={};for(const r of Object.keys(e)){const s=e[r];if(r==="name"&&typeof s=="string")n[r]=s;else{const a=ch(r);n[a]=jR(s,a)}}return n}}function qR(e,t){if(e==null)return null;if(typeof e=="string")return gu(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const a=e[s];vne(t,s,a)?n.push(a):n.push(qR(a,t))}return n}else{const n={};for(const r of Object.keys(e)){const s=e[r],a=gu(r);(r==="name"||r==="className")&&typeof s=="string"?n[a]=s:n[a]=qR(s,r)}return n}}/** @license See the LICENSE file. */const kne="4.4.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let $rt=class gl extends Wt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=eT(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Pc(this.inputs).length!==this.inputs.length)throw new de(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Pc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const x=b.sourceLayer,w=b.nodeIndex,v=b.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(v)}for(const b of this.inputs){const x=b.sourceLayer,w=b.nodeIndex,v=b.tensorIndex;Sl(w===0,"input layer has >1 nodes"),Sl(v===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(v)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const x=this.inputLayers[b];if(!(x instanceof yv))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const n={},r={},s={},a={},i={},o=[],l=(b,x,w,v,k,I)=>{(v==null||k==null||I==null)&&(v=b.sourceLayer,k=b.nodeIndex,I=b.tensorIndex);const S=v.inboundNodes[k];if(w.indexOf(S)!==-1)throw new oo(`The tensor ${b.name} at layer "${v.name}" is part of a cycle.`);if(x.indexOf(S)!==-1)return;this.containerNodes.add(gl.nodeKey(v,k)),v.id in i||(i[v.id]=Object.keys(i).length),w.indexOf(S)===-1&&w.push(S);const $=S.inboundLayers.length;for(let N=0;N<$;N++){const T=S.inputTensors[N],C=S.inboundLayers[N],E=S.nodeIndices[N],M=S.tensorIndices[N];l(T,x,w,C,E,M)}for(x.push(S);w.indexOf(S)>=0;)w.splice(w.indexOf(S),1);o.push(S)},u=[],c=[];for(const b of this.outputs)l(b,u,c);const d=o.slice().reverse();for(const b of d){r[b.id]=b,b.id in n||(n[b.id]=0);let x=n[b.id];const w=s[b.outboundLayer.id]==null?0:s[b.outboundLayer.id];x=Math.max(x,w),s[b.outboundLayer.id]=x,a[b.outboundLayer.id]=b.outboundLayer,n[b.id]=x;for(let v=0;v<b.inboundLayers.length;v++){const k=b.inboundLayers[v],I=b.nodeIndices[v],S=k.inboundNodes[I],$=n[S.id]==null?0:n[S.id];n[S.id]=Math.max(x+1,$),r[S.id]=S}}const h={};for(const b in n){const x=n[b];x in h||(h[x]=[]),h[x].push(r[b])}const p={};for(const b in s){const x=s[b];x in p||(p[x]=[]),p[x].push(a[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(_k);this.layers=[];for(const b of f){const x=p[b];x.sort((w,v)=>{const k=i[w.id],I=i[v.id];return k<I?-1:k>I?1:0});for(const w of x)w instanceof gl&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=p,f=Object.keys(h).map(b=>parseInt(b,10)).sort(_k);const m=this.inputs.slice(),g=[];for(const b of f)for(const x of h[b]){const w=x.outboundLayer;if(w!=null){for(const v of x.inputTensors)if(m.indexOf(v)===-1)throw new oo(`Graph disconnected: cannot obtain value for tensor ${v} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(const v of x.outputTensors)m.push(v);g.push(w.name)}}this.nodesByDepth=h;const y=this.layers.map(b=>b.name);for(const b of y){const x=y.filter(w=>w===b).length;if(x!==1)throw new oo(`The name "${b}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new nT({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new de("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){const r={};let s=0;for(const i of this.layers)for(const o of i.weights){if(r[o.originalName]!=null)throw new de(`Duplicate weight name: ${o.originalName}`);r[o.originalName]=o,s++}const a=[];for(const i in t){let o=i;if(r[i]==null){const l=i.split("/");o=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(r[o]!=null)a.push([r[o],t[i]]);else if(n)throw new de(`Provided weight data has no target variable: ${i}`);delete r[o]}if(n){const i=[];for(const o in r)i.push(o);if(i.length>0)throw new de(`${i.length} of ${s} weights are not set: ${i}`)}RB(a)}updatedConfig(){const t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${kne}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){const r=qR(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return ge(()=>{t=Wn(t);const r=new vc;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Nx(this.outputs,r,n)})}computeMask(t,n){return ge(()=>{t=Wn(t);let r;return n==null?r=up(null,t.length):r=Wn(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const n=PS(t);if(n.length!==this.inputLayers.length)throw new de(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let o=0;o<n.length;o++){const l=this.inputLayers[o],u=n[o],c=l.name+"_0_0";r[c]=u}const s=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(_k);if(s.length>1)for(const o of s){const l=this.nodesByDepth[o];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(c.id)!==-1)continue;const d=[];for(let m=0;m<u.inboundLayers.length;m++){const g=u.inboundLayers[m],y=u.nodeIndices[m],b=u.tensorIndices[m],x=`${g.name}_${y}_${b}`,w=r[x];d.push(w)}const h=c.computeOutputShape(wa(d)),p=PS(h),f=c.inboundNodes.indexOf(u);for(let m=0;m<p.length;m++){const g=`${c.name}_${f}_${m}`;r[g]=p[m]}}}const a=[],i=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],d=`${l.name}_${u}_${c}`;i.push(d)}for(let o=0;o<i.length;o++){const l=i[o];Sl(l in r),a.push(r[l])}return wa(a)}runInternalGraph(t,n){n==null&&(n=up(null,t.length));const r={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=t[l],d=n[l];r[u.id]=[c,d]}const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(_k);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,h=c.inputTensors,p=c.outputTensors,f=new Array;for(const m of h)m.id in r&&f.push(r[m.id]);if(f.length===h.length){let m={},g,y,b,x;if(c.callArgs!=null&&(m=c.callArgs),f.length===1){const[w,v]=f[0];m.mask==null&&(m.mask=v),b=Wn(d.call(w,m)),x=Wn(d.computeMask(w,v)),g=[w],y=[v]}else g=f.map(w=>w[0]),y=f.map(w=>w[1]),m.mask==null&&(m.mask=y),b=Wn(d.call(g,m)),x=Wn(d.computeMask(g,y));if(d.activityRegularizer)throw new Dt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<p.length;++w){const v=p[w],k=b[w],I=x[w];r[v.id]=[k,I]}}}}const a=[],i=[],o=[];for(const l of this.outputs){Sl(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];o.push(u.shape),a.push(u),i.push(c)}return[a,i,o]}buildNodeConversionMap(t){const n={};let r;for(const s of this.layers){r=s instanceof gl?1:0;for(let a=0;a<s.inboundNodes.length;a++){const i=gl.nodeKey(s,a);this.containerNodes.has(i)&&(n[i]=r,r+=1)}}return n}getLayer(t,n){if(n!=null){if(this.layers.length<=n)throw new de(`Was asked to retrieve layer at index ${n}, but model only has ${this.layers.length} layer(s).`);return this.layers[n]}else if(t==null)throw new de("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===t)return r;throw new de(`No such layer: ${t}`)}calculateLosses(){return ge(()=>{const t=[];for(const n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){const s=gl.nodeKey(n,r);this.containerNodes.has(s)&&t.push(...n.calculateLosses())}return t})}getConfig(){const t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(const i of this.layers){const o=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){const h=i.inboundNodes[d],p=gl.nodeKey(i,d);let f={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const y=h.inboundLayers[g],b=h.nodeIndices[g],x=h.tensorIndices[g],w=gl.nodeKey(y,b);let v=n[w];v==null&&(v=0),m.push([y.name,v,x,f])}u.push(m)}}}const c={};c.name=i.name,c.className=o,c.config=l,c.inboundNodes=u,r.push(c)}t.layers=r;const s=[];for(let i=0;i<this.inputLayers.length;i++){const o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=gl.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const d=this.inputLayersTensorIndices[i];s.push([o.name,c,d])}t.inputLayers=s;const a=[];for(let i=0;i<this.outputLayers.length;i++){const o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=gl.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const d=this.outputLayersTensorIndices[i];a.push([o.name,c,d])}return t.outputLayers=a,t}static fromConfig(t,n,r={},s=!1){const a={},i={};function o(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function l(g,y){const b=[];let x;for(const w of y){const v=w[0],k=w[1],I=w[2];if(x=w[3]==null?{}:w[3],!(v in a)){o(g,y);return}const S=a[v];if(S.inboundNodes.length<=k){o(g,y);return}const $=S.inboundNodes[k];b.push($.outputTensors[I])}b.length>0&&g.apply(wa(b),x)}function u(g){const y=g.name,b=_u(g,n.customObjects!=null?n.customObjects:{});b.setFastWeightInitDuringBuild(s),a[y]=b,g.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new de(`Corrupted configuration, expected array for nodeData: ${w}`);o(b,w)})}const c=n.name,d=n.layers;for(const g of d)u(g);for(;!pnt(i);)for(const g of d){const y=a[g.name];if(y.name in i){const b=i[y.name];delete i[y.name];for(const x of b)l(y,x)}}const h=[],p=[],f=n.inputLayers;for(const g of f){const y=g[0],b=g[1],x=g[2];Sl(y in a);const v=a[y].inboundNodes[b].outputTensors;h.push(v[x])}const m=n.outputLayers;for(const g of m){const y=g[0],b=g[1],x=g[2];Sl(y in a);const v=a[y].inboundNodes[b].outputTensors;p.push(v[x])}return new t({inputs:h,outputs:p,name:c})}get stateful(){if(this._stateful)throw new de("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){ge(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Trt(e,t,n){const r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){const s=[];return t.forEach(a=>{a in e?s.push(e[a]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function Ine(e,t){return Trt(e,t,"classWeight")}async function Sne(e,t,n,r){if(t!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){const s=ge(()=>{if(e.shape.length===1)return Tu(e);if(e.shape.length===2){if(e.shape[1]>1)return Og(e,1);if(e.shape[1]===1)return ce(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await s.data());nt(s);const i=[];return a.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),ka(i,"float32")}else return null}function _rt(e,t){return le(e,t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ert=32;function Cne(e,t){let n,r;const s=t;n=s.xs,r=s.ys,U(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const a=BG("input",e.inputNames,n),i=BG("output",e.outputNames,r),o=a[0].shape[0];U(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),U(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<a.length;l++)U(a[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)U(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:a,ys:i}}function BG(e,t,n){if(n instanceof Kn)return[n];if(Array.isArray(n))return U(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{const r=[];for(const s of t){if(n[s]==null)throw new de(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function Art(e){if(e.length===3)throw new Dt("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function Rrt(e,t,n){const r=n.batchesPerEpoch!=null;if(U(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),U(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),U(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),U(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),U(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=n.validationData!=null;let a,i;if(s)if(WG(n.validationData))U(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const g=Art(n.validationData);a=g.xs,i=g.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;s?u=l.slice().concat(l.map(g=>"val_"+g)):u=l.slice();const c=fne(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:h,history:p}=mne(c,d,n.epochs,null,null,Drt(t,n),null,s,u);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const g={};await h.onEpochBegin(f);let y=0,b=0;for(r||(m=await t.iterator());!r||y<n.batchesPerEpoch;){const x=await m.next();if(r&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){const{xs:w,ys:v}=Cne(e,x.value),k={};k.batch=b,k.size=w[0].shape[0],await h.onBatchBegin(b,k);const I=[];if(n.classWeight!=null){const N=Ine(n.classWeight,e.outputNames);for(let T=0;T<N.length;++T)I.push(await Sne(v[T],null,N[T]))}const S=w.concat(v).concat(I),$=o(S);nt(S);for(let N=0;N<l.length;++N){const T=l[N],C=$[N];k[T]=C,ns(C)}await h.onBatchEnd(b,k),pne(k),b++,y++}if(r?y>=n.batchesPerEpoch:x.done){if(s){let w;WG(n.validationData)?w=Wn(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):w=Wn(e.evaluate(a,i,{batchSize:n.validationBatchSize==null?Ert:n.validationBatchSize,verbose:0}));for(let v=0;v<e.metricsNames.length;++v)g[`val_${e.metricsNames[v]}`]=w[v]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,g),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Drt(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function WG(e){return typeof e.iterator=="function"}function Frt(e){return typeof e.next=="function"}async function Ort(e,t,n){n=n||{};const r=n.batches!=null,s=e.testFunction;let a=[];if(n.verbose>0)throw new Dt("Verbose mode is not implemented yet.");U(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i=Frt(t)?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const u=await i.next();if(a=ge(()=>{if(u.value){const{xs:c,ys:d}=Cne(e,u.value),h=c.concat(d),p=ge(()=>s(h));if(nt(h),l===0)for(let m=0;m<p.length;++m)a.push(bt(0));const f=h[0].shape[0];for(let m=0;m<p.length;++m){const g=p[m],y=a[m];a[m]=ge(()=>Ee(a[m],le(f,g))),l>0&&nt(y)}nt(p),o+=f,++l}return a}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){const c=a[u];a[u]=ft(a[u],o),nt(c)}return wa(a)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function z_(e){U(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function ax(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>_h(r,t,n-t)):_h(e,t,n-t)}function KR(e,t){return ge(()=>e==null?null:Array.isArray(e)?e.map(n=>KR(n,t)):Qte(e,t.dtype==="int32"?t:Xe(t,"int32")))}function B_(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function Nne(e){const t=[];e instanceof Kn&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(r.rank===1)t.push(fv(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Ao(e,t){if(e==null)return;const n=[];if(t instanceof Kn)n.push(t.id);else if(Array.isArray(t))t.forEach(s=>n.push(s.id));else if(t!=null)for(const s in t){const a=t[s];n.push(a.id)}const r=[];if(e instanceof Kn)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(e!=null)for(const s in e){const a=e[s];n.indexOf(a.id)===-1&&r.push(a)}r.forEach(s=>{s.isDisposed||s.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Mrt(e){return e instanceof Kn}function XR(e){return Array.isArray(e)}function VG(e){return!Mrt(e)&&!XR(e)}function UG(e,t,n,r=!0,s=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(XR(e)&&e.length>0)i=!0;else if(VG(e)){for(const o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new de(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let a;if(VG(e)){e=e,a=[];for(const i of t){if(e[i]==null)throw new de(`No data provided for "${i}". Need data for each key in: ${t}`);a.push(e[i])}}else if(XR(e)){if(e=e,e.length!==t.length)throw new de(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new de(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=Nne(a),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new de(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;const u=o.shape[l],c=n[i][l];if(c!=null&&c>=0&&u!==c)throw new de(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function Lrt(e,t,n){const r=Pc(e.map(a=>a.shape[0]));r.sort();const s=Pc(t.map(a=>a.shape[0]));if(s.sort(),r.length>1)throw new de(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>1)throw new de(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(r.length>0&&s.length>0&&!Xt(r,s))throw new de(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function Prt(e,t,n){const r=[rT,sT,B0];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(i!=null){if(i===B0&&a.shape[a.shape.length-1]===1)throw new de(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){const l=a.shape.slice(1),u=o.slice(1);for(let c=0;c<l.length;++c){const d=l[c],h=u[c];if(h!=null&&d!==h)throw new de(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function GG(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new de(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new de(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new de(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;const u=o.shape[l],c=n[i][l];if(c!=null&&c!==u)throw new de(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function zrt(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{const r=[];for(const s of t){let a=n.hasOwnProperty(s)?n[s]:[];Array.isArray(a)||(a=[a]),r.push(a)}return r}}const Brt="layers-model";class Zm extends $rt{constructor(t){super(t),this.isTraining=!1}summary(t,n,r=console.log){if(!this.built)throw new de("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");krt(this,t,n,r)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=vrt(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof zd))throw new de("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const i in t.loss)if(this.outputNames.indexOf(i)===-1)throw new de(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)t.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),n.push(P_(t.loss[i]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new de(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);n=t.loss.map(o=>P_(o))}else{const i=P_(t.loss);this.outputs.forEach(o=>{n.push(i)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const o=this.internalOutputShapes[i],l=this.outputNames[i];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[i])}const r=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Th("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(r.indexOf(i)!==-1)continue;const o=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([o,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const s=zrt(t.metrics,this.outputNames),a=(i,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[i]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,i])};Th("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(r.indexOf(i)!==-1)continue;const o=s[i];(u=>{const c="";let d,h,p;for(const f of u){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){const g=this.internalOutputShapes[i];g[g.length-1]===1||this.lossFunctions[i]===sT?["accuracy","acc"].indexOf(f)!==-1?h=yne:["crossentropy","ce"].indexOf(f)!==-1&&(h=drt):this.lossFunctions[i]===US?["accuracy","acc"].indexOf(f)!==-1?h=hrt:["crossentropy","ce"].indexOf(f)!==-1&&(h=wne):["accuracy","acc"].indexOf(f)!==-1?h=bne:["crossentropy","ce"].indexOf(f)!==-1&&(h=xne);let y;["accuracy","acc"].indexOf(f)!==-1?y="acc":["crossentropy","ce"].indexOf(f)!==-1&&(y="ce"),p=h,d=c+y}else p=wrt(f),d=c+Rk(f);let m;Th(d,()=>{m=p}),a(i,d,m)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,n,r={}){const s=r.batchSize==null?32:r.batchSize;z_(s);const a=!0,i=this.standardizeUserDataXY(t,n,a,s);try{const o=i[0].concat(i[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,o,s,r.verbose,r.steps);return wa(u)}finally{Ao(i[0],t),Ao(i[1],n)}}async evaluateDataset(t,n){return this.makeTestFunction(),Ort(this,t,n)}checkNumSamples(t,n,r,s="steps"){let a;if(r!=null){if(a=null,n!=null)throw new de(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(t!=null)Array.isArray(t)?a=t[0].shape[0]:a=t.shape[0];else throw new de(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return a}execute(t,n){if(Array.isArray(n)&&n.length===0)throw new de("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(n),s=r?n:[n],a=this.retrieveSymbolicTensors(s),i=new vc;if(t instanceof Kn&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new de(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)i.add(this.inputs[l],t[l])}else for(const l of this.inputs){const u=t[l.name];if(u==null)throw new de(`No value is provided for the model's input ${l.name}`);i.add(l,u)}const o=Nx(a,i);return r?o:o[0]}retrieveSymbolicTensors(t){const n=up(null,t.length);let r=t.length;for(const s of this.layers){const a=Array.isArray(s.output)?s.output:[s.output],i=a.map(o=>o.name);for(let o=0;o<t.length;++o){const l=i.indexOf(t[o]);if(l!==-1&&(n[o]=a[l],r--),r===0)break}if(r===0)break}if(r>0){const s=[];throw n.forEach((a,i)=>{a==null&&s.push(t[i])}),new de(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return n}predictLoop(t,n=32,r=!1){return ge(()=>{const s=this.checkNumSamples(t);if(r)throw new Dt("Verbose predictLoop() is not implemented yet.");const a=B_(s,n),i=this.outputs.map(o=>[]);for(let o=0;o<a.length;++o)ge(()=>{const u=a[o][0],c=a[o][1],d=ax(t,u,c),h=[];if(Array.isArray(d))for(let f=0;f<d.length;++f)h.push({key:this.inputs[f],value:d[f]});else h.push({key:this.inputs[0],value:d});const p=new vc(h);return Nx(this.outputs,p)}).forEach((u,c)=>i[c].push(u));return wa(i.map(o=>$r(o,0)))})}predict(t,n={}){const r=Nne(t);GG(r,this.inputNames,this.feedInputShapes,!1);try{const s=n.batchSize==null?32:n.batchSize;return z_(s),this.predictLoop(r,s)}finally{Ao(r,t)}}predictOnBatch(t){GG(t,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,n)}standardizeUserDataXY(t,n,r=!0,s){if(this.optimizer_==null)throw new oo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let i=0;i<this.feedOutputShapes.length;++i){const o=this.feedOutputShapes[i];this.feedLossFns[i]===US?a.push(o.slice(0,o.length-1).concat([1])):a.push(o)}if(t=UG(t,this.feedInputNames,this.feedInputShapes,!1,"input"),n=UG(n,this.feedOutputNames,a,!1,"target"),Lrt(t,n),Prt(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&t[0].shape[0]%s!==0)throw new de(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${t[0].shape[0]} sample(s).`);return[t,n]}async standardizeUserData(t,n,r,s,a=!0,i){const[o,l]=this.standardizeUserDataXY(t,n,a,i);if(r!=null)throw new Error("sample weight is not supported yet.");let u=null;if(s!=null){const c=Ine(s,this.outputNames);u=[];for(let d=0;d<c.length;++d)u.push(await Sne(l[d],null,c[d]))}return[o,l,u]}testLoop(t,n,r,s=0,a){return ge(()=>{const i=this.checkNumSamples(n,r,a,"steps"),o=[];if(s>0)throw new Dt("Verbose mode is not implemented yet.");if(a!=null)throw new Dt("steps mode in testLoop() is not implemented yet");{const l=B_(i,r),u=ka(al(0,i));for(let c=0;c<l.length;++c){const d=l[c][0],h=l[c][1],p=_h(u,d,h-d),f=KR(n,p),m=t(f);if(c===0)for(let g=0;g<m.length;++g)o.push(bt(0));for(let g=0;g<m.length;++g){const y=m[g];o[g]=Ee(o[g],le(h-d,y))}}for(let c=0;c<o.length;++c)o[c]=ft(o[c],i)}return o})}getDedupedMetricsNames(){const t=this.metricsNames,n=[];for(let r=0;r<t.length;++r){const s=t[r];let a=s;if(TG(t,s)>1){const i=TG(t.slice(0,r),s);a+=`_${i}`}n.push(a)}return n}makeTrainFunction(){return t=>{const n=[],r=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],o=()=>{const d=[];for(let m=0;m<this.inputs.length;++m)d.push({key:this.inputs[m],value:r[m]});const h=new vc(d),p=Nx(this.outputs,h,{training:!0});let f;for(let m=0;m<this.lossFunctions.length;++m){const g=this.lossFunctions[m];let y=g(s[m],p[m]);a[m]!=null&&(y=_rt(y,a[m]));const b=dr(y);n.push(b),m===0?f=y:f=Ee(f,y)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=n[m];else{const y=this.metricsTensors[m][0],b=this.metricsTensors[m][1];g=dr(y(s[b],p[b]))}ns(g),i.push(g)}return f=dr(f),this.calculateLosses().forEach(m=>{f=Ee(f,m)}),f},l=this.collectedTrainableWeights.map(d=>d.read()),u=!0;return[this.optimizer_.minimize(o,u,l)].concat(i)}}makeTestFunction(){this.testFunction=t=>ge(()=>{const n=[];let r;const s=t.slice(0,this.inputs.length),a=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let u=0;u<this.inputs.length;++u)i.push({key:this.inputs[u],value:s[u]});const o=new vc(i),l=Nx(this.outputs,o);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],d=dr(c(a[u],l[u]));u===0?r=d:r=Ee(r,d),n.push(r)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],d=this.metricsTensors[u][1],h=dr(c(a[d],l[d]));n.push(h)}return n})}async fit(t,n,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let s,a,i,o,l,u,c,d,h;try{const p=r.batchSize==null?32:r.batchSize;z_(p);const f=!1,m=await this.standardizeUserData(t,n,r.sampleWeight,r.classWeight,f,p);s=m[0],a=m[1],h=m[2];let g=!1,y;if(r.validationData!=null&&r.validationData.length>0){if(g=!0,r.validationData.length===2)l=r.validationData[0],u=r.validationData[1];else throw r.validationData.length===3?new Dt("validationData including sample weights is not supported yet."):new de(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const $=!0,N=await this.standardizeUserData(l,u,null,null,$,p);c=N[0],d=N[1],y=c.concat(d)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){g=!0;const $=Math.floor(s[0].shape[0]*(1-r.validationSplit)),N=s[0].shape[0];c=ax(s,$,N),i=s,s=ax(s,0,$),d=ax(a,$,N),o=a,a=ax(a,0,$),y=c.concat(d)}else r.validationSteps!=null&&(g=!0);const b=s.concat(a).concat(h);this.checkTrainableWeightsConsistency();const x=this.makeTrainFunction(),w=this.getDedupedMetricsNames();let v,k;g?(this.makeTestFunction(),v=this.testFunction,k=w.slice().concat(w.map($=>"val_"+$))):(v=null,y=[],k=w.slice());const I=fne(r.callbacks,r.yieldEvery);return await this.fitLoop(x,b,w,p,r.epochs,r.verbose,I,v,y,r.shuffle,k,r.initialEpoch,null,null)}finally{this.isTraining=!1,Ao(s,t),Ao(a,n),Ao(i,t),Ao(o,n),Ao(c,l),Ao(d,u),h!=null&&nt(h)}}async fitLoop(t,n,r,s,a,i,o,l,u,c,d,h,p,f){s==null&&(s=32),a==null&&(a=1),c==null&&(c=!0),h==null&&(h=0);let m=!1;if(l!=null&&u!=null&&(m=!0),f!=null&&(m=!0,p==null))throw new de("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(n,s,p,"steps_per_epoch");let y;g!=null&&(y=al(0,g)),i==null&&(i=1);const{callbackList:b,history:x}=mne(o,i,a,h,g,p,s,m,d);b.setModel(this),this.history=x,await b.onTrainBegin(),this.stopTraining_=!1;for(let w=h;w<a;++w){await b.onEpochBegin(w);const v={};if(p!=null)throw new Dt("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Dt("batch shuffling is not implemneted yet");c&&q8e(y);const k=ka(y),I=B_(g,s);for(let S=0;S<I.length;++S){const $={};if(await b.onBatchBegin(S,$),ge(()=>{const N=I[S][0],T=I[S][1],C=_h(k,N,T-N);$.batch=S,$.size=T-N;const E=KR(n,C),M=t(E);for(let F=0;F<r.length;++F){const z=r[F],H=M[F];$[z]=H,ns(H)}if(S===I.length-1&&m){const F=this.testLoop(l,u,s);for(let z=0;z<r.length;++z){const H=r[z],P=F[z];ns(P),v["val_"+H]=P}}}),await b.onBatchEnd(S,$),pne($),this.stopTraining_)break}k.dispose()}if(await b.onEpochEnd(w,v),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,n){return Rrt(this,t,n)}async trainOnBatch(t,n){const r=await this.standardizeUserData(t,n),s=r[0],a=r[1],o=this.makeTrainFunction()(s.concat(a)),l=[];for(const u of o){const c=await u.data();l.push(c[0])}return nt(o),Ao(r[0],t),Ao(r[1],n),wa(l)}getNamedWeights(t){const n=[],r=t!=null&&t.trainableOnly,s=r?this.trainableWeights:this.weights,a=this.getWeights(r);for(let i=0;i<s.length;++i)r&&!s[i].trainable||n.push({name:s[i].originalName,tensor:a[i]});return n}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=NR().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=n-NR().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=gu(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(n=>gu(n))}else{const n=Object.keys(this.loss);t={};const r=this.loss;for(const s of n)if(typeof r[s]=="string")t[s]=gu(r[s]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[gu(Rk(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>gu(Rk(t)));{const t={};for(const n in this.metrics)t[n]=gu(Rk(this.metrics[n]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=jR(t.optimizer_config),r=_u(n);let s;if(typeof t.loss=="string")s=ch(t.loss);else if(Array.isArray(t.loss))s=t.loss.map(i=>ch(i));else if(t.loss!=null){s={};for(const i in t.loss)s[i]=ch(t.loss[i])}let a;if(Array.isArray(t.metrics))a=t.metrics.map(i=>ch(i));else if(t.metrics!=null){a={};for(const i in t.metrics)a[i]=ch(t.metrics[i])}this.compile({loss:s,metrics:a,optimizer:r})}async save(t,n){if(typeof t=="string"){const u=OQ(t);if(u.length===0)throw new de(`Cannot find any save handlers for URL '${t}'`);if(u.length>1)throw new de(`Found more than one (${u.length}) save handlers for URL '${t}'`);t=u[0]}if(t.save==null)throw new de("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await kR(this.getNamedWeights(n)),s=!1,a=null,o={modelTopology:this.toJSON(a,s),format:Brt,generatedBy:`TensorFlow.js tfjs-layers v${kne}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:d}=await kR(await this.optimizer.getWeights(),u);r.specs.push(...d),r.data=T$([r.data,c])}return this.userDefinedMetadata!=null&&(zG(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=r.data,o.weightSpecs=r.specs,t.save(o)}setUserDefinedMetadata(t){zG(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Zm.className="Model";Ae(Zm);class $ne extends Zm{}$ne.className="Functional";Ae($ne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class W0 extends Zm{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:eT("sequential_"),t.layers!=null)for(const n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new de(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const n=t instanceof W0||t instanceof Zm;let r;if(n){if(r=t,r.outputs.length!==1)throw new de("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new de("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new de("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=Vnt({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(s)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new de(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new de("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=lne(this.outputs[0])}this.inboundNodes=[],new nT({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:up(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=t.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(rn(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Zm({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,r=console.log){this.built||this.build(),super.summary(t,n,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,r={}){if(!this.built)throw new oo("The model needs to be compiled before being used.");return this.model.evaluate(t,n,r)}async evaluateDataset(t,n){if(!this.built)throw new oo("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,r={}){if(!this.built)throw new oo("The model needs to be compiled before being used.");return this.model.fit(t,n,r)}async fitDataset(t,n){if(!this.built)throw new oo("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,r={},s=!1){let a,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new de("Legacy serialization format not supported yet.");a=n}else U(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,i=n;const o=new t(i);if(!(o instanceof W0))throw new Dt(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of a){const c=_u(l,void 0,s);s&&c.setFastWeightInitDuringBuild(!0),o.add(c)}return o}set stopTraining(t){if(this.model==null)throw new de("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new de("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const n of this.layers){const r={};r.className=n.getClassName(),r.config=n.getConfig(),t.push(r)}return{name:this.name,layers:t}}}W0.className="Sequential";Ae(W0);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Fa=class extends Db{getConfig(){return{}}};class Tne extends Fa{apply(t,n=1){return Tnt(t,n)}}Tne.className="elu";Ae(Tne);class _ne extends Fa{apply(t){return Ez(t)}}_ne.className="selu";Ae(_ne);class Ene extends Fa{apply(t){return Ql(t)}}Ene.className="relu";Ae(Ene);class Ane extends Fa{apply(t){return ge(()=>op(6,Ql(t)))}}Ane.className="relu6";Ae(Ane);class Rne extends Fa{apply(t){return t}}Rne.className="linear";Ae(Rne);class Dne extends Fa{apply(t){return zl(t)}}Dne.className="sigmoid";Ae(Dne);class Fne extends Fa{apply(t){return Ent(t)}}Fne.className="hardSigmoid";Ae(Fne);class One extends Fa{apply(t){return _b(t)}}One.className="softplus";Ae(One);class Mne extends Fa{apply(t){return _nt(t)}}Mne.className="softsign";Ae(Mne);class Lne extends Fa{apply(t){return Mg(t)}}Lne.className="tanh";Ae(Lne);let MB=class extends Fa{apply(t,n=-1){return U$(t,n)}};MB.className="softmax";Ae(MB);class Pne extends Fa{apply(t,n=-1){return wz(t,n)}}Pne.className="logSoftmax";Ae(Pne);class zne extends Fa{apply(t,n=1){return ge(()=>le(zl(le(t,n)),t))}}zne.className="swish";Ae(zne);class Bne extends Fa{apply(t){return ge(()=>le(t,Mg(_b(t))))}}Bne.className="mish";Ae(Bne);function od(e){return e.getClassName()}function W_(e,t={}){return pv(e,eo.getMap().classNameMap,t,"activation")}function ld(e){if(e==null){const t={};return t.className="linear",t.config={},W_(t)}if(typeof e=="string"){const t={};return t.className=e,t.config={},W_(t)}else return e instanceof Fa?e:W_(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Wrt(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}class Wne extends Db{}class Vne extends Wne{constructor(t){super(),Wrt(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return ge(()=>{let n=Fr([1]);return this.hasL1&&(n=Ee(n,ot(le(this.l1,Rr(t))))),this.hasL2&&(n=Ee(n,ot(le(this.l2,mv(t))))),ce(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,n){return new t({l1:n.l1,l2:n.l2})}}Vne.className="L1L2";Ae(Vne);const HG={l1l2:"L1L2"};function An(e){return kB(e)}function jG(e,t={}){return pv(e,eo.getMap().classNameMap,t,"regularizer")}function Qn(e){if(e==null)return null;if(typeof e=="string"){const n={className:e in HG?HG[e]:e,config:{}};return jG(n)}else return e instanceof Wne?e:jG(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Une extends Wt{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,n){t=vt(t);let r=Ql(t);return this.maxValue!=null&&(r=ri(r,0,this.maxValue)),r}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},n=super.getConfig();return Object.assign(t,n),t}}Une.className="ReLU";Ae(Une);class Gne extends Wt{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const r=vt(t);return D$(r,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}}Gne.className="LeakyReLU";Ae(Gne);class Hne extends Wt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Zn(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Qn(t.alphaRegularizer),this.alphaConstraint=Hr(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new de(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=rn(t);const n=t.slice(1);if(this.sharedAxes!=null)for(const s of this.sharedAxes)n[s-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let s=1;s<t.length;++s)r[s]=t[s];this.inputSpec=[new Pr({ndim:t.length,axes:r})],this.built=!0}call(t,n){return t=vt(t),z$(t,this.alpha.read())}getConfig(){const t={alphaInitializer:ir(this.alphaInitializer),alphaRegularizer:An(this.alphaRegularizer),alphaConstraint:Gr(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(t,n),t}}Hne.className="PReLU";Ae(Hne);let jne=class extends Wt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Dt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const r=vt(t);return iv(r)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}};jne.className="ELU";Ae(jne);class qne extends Wt{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,n){const r=vt(t);return le(r,Xe(ui(r,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},n=super.getConfig();return Object.assign(t,n),t}}qne.className="ThresholdedReLU";Ae(qne);class Kne extends Wt{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new MB().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,n){const r=vt(t);return this.softmax(r,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}Kne.className="Softmax";Ae(Kne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Jm(e,t,n){if(typeof e=="number")return up(e,t);if(e.length!==t)throw new de(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const s=e[r];if(!Snt(s))throw new de(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function Ko(e,t,n,r,s=1){if(e==null)return e;const a=t+(t-1)*(s-1);let i;return n==="same"?i=e:i=e-a+1,Math.floor((i+r-1)/r)}function Cl(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+id([n-t,0]);else if(r==="same")e=e*t;else throw new de(`Unsupport padding mode: ${r}.`);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function LB(e,t){return ge(()=>(vr(t),t==="channelsFirst"?qt(e,[0,2,3,1]):e))}function Xne(e,t){return ge(()=>(vr(t),t==="channelsFirst"?qt(e,[0,2,3,4,1]):e))}function Vrt(e,t,n,r=1,s="valid",a,i=1){return ge(()=>{if(a==null&&(a=il()),vr(a),e.shape.length!==3)throw new de(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new de(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new de(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(a==="channelsFirst"&&(e=qt(e,[0,2,1])),s==="causal")throw new Dt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=pz(e,t,r,s==="same"?"same":"valid","NWC",i);return n!=null&&(o=dl(o,n)),o})}function qG(e,t,n,r=[1,1],s="valid",a,i,o=null){return ge(()=>{if(a==null&&(a=il()),vr(a),e.rank!==3&&e.rank!==4)throw new de(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new de(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=LB(e,a);if(s==="causal")throw new Dt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Gee({x:l,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),a==="channelsFirst"&&(l=qt(l,[0,3,1,2])),l})}function Urt(e,t,n,r=[1,1,1],s="valid",a,i){return ge(()=>{if(a==null&&(a=il()),vr(a),e.rank!==4&&e.rank!==5)throw new de(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new de(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=Xne(e,a);if(s==="causal")throw new Dt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=uee(o,t,r,s==="same"?"same":"valid","NDHWC",i),n!=null&&(o=dl(o,n)),a==="channelsFirst"&&(o=qt(o,[0,4,1,2,3])),o})}class aT extends Wt{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",aT.verifyArgs(n),this.rank=t,rs(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Dt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Jm(n.kernelSize,t,"kernelSize"),this.strides=Jm(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,zi(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,vr(this.dataFormat),this.activation=ld(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=Zn(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Hr(n.biasConstraint),this.biasRegularizer=Qn(n.biasRegularizer),this.activityRegularizer=Qn(n.activityRegularizer),this.dilationRate=Jm(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new de(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new de(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new de(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Sl("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!IB(t.kernelSize,"number",1,3))throw new de(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:od(this.activation),useBias:this.useBias,biasInitializer:ir(this.biasInitializer),biasRegularizer:An(this.biasRegularizer),activityRegularizer:An(this.activityRegularizer),biasConstraint:Gr(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}class Fb extends aT{constructor(t,n){super(t,n),this.kernel=null,Fb.verifyArgs(n),this.filters=n.filters,rs(this.filters,"filters"),this.kernelInitializer=Zn(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Hr(n.kernelConstraint),this.kernelRegularizer=Qn(n.kernelRegularizer)}build(t){t=rn(t);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new de(`The channel dimension of the input should be defined. Found ${t[n]}`);const r=t[n],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return ge(()=>{t=vt(t);let r;const s=this.bias==null?null:this.bias.read(),a=qte(this.activation.getClassName());if(a!=null&&this.rank===2)r=qG(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)r=Vrt(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=qG(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=Urt(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Dt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=rn(t);const n=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<r.length;++a){const i=Ko(r[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);n.push(i)}let s=[t[0]];return this.dataFormat==="channelsLast"?(s=s.concat(n),s.push(this.filters)):(s.push(this.filters),s=s.concat(n)),s}getConfig(){const t={filters:this.filters,kernelInitializer:ir(this.kernelInitializer),kernelRegularizer:An(this.kernelRegularizer),kernelConstraint:Gr(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new de(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class xv extends Fb{constructor(t){super(2,t),xv.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!IB(t.kernelSize,"number",1,2))throw new de(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}xv.className="Conv2D";Ae(xv);class wv extends Fb{constructor(t){super(3,t),wv.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new de(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}wv.className="Conv3D";Ae(wv);class Yne extends xv{constructor(t){if(super(t),this.inputSpec=[new Pr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new de(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=rn(t),t.length!==4)throw new de("Input should have rank 4; Received input shape: "+JSON.stringify(t));const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new de("The channel dimension of the inputs should be defined. Found `None`.");const r=t[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Pr({ndim:4,axes:{[n]:r}})],this.built=!0}call(t,n){return ge(()=>{let r=vt(t);if(r.shape.length!==4)throw new de(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,a=s[0];let i,o;this.dataFormat==="channelsFirst"?(i=2,o=3):(i=1,o=2);const l=s[i],u=s[o],c=this.kernelSize[0],d=this.kernelSize[1],h=this.strides[0],p=this.strides[1],f=Cl(l,h,c,this.padding),m=Cl(u,p,d,this.padding),g=[a,f,m,this.filters];this.dataFormat!=="channelsLast"&&(r=qt(r,[0,2,3,1]));let y=mz(r,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=qt(y,[0,3,1,2])),this.bias!=null&&(y=dl(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(t){t=rn(t);const n=t.slice();let r,s,a;this.dataFormat==="channelsFirst"?(r=1,s=2,a=3):(r=3,s=1,a=2);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return n[r]=this.filters,n[s]=Cl(n[s],l,i,this.padding),n[a]=Cl(n[a],u,o,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}Yne.className="Conv2DTranspose";Ae(Yne);class Zne extends wv{constructor(t){if(super(t),this.inputSpec=[new Pr({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new de(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=rn(t),t.length!==5)throw new de("Input should have rank 5; Received input shape: "+JSON.stringify(t));const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new de("The channel dimension of the inputs should be defined. Found `None`.");const r=t[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Pr({ndim:5,axes:{[n]:r}})],this.built=!0}call(t,n){return ge(()=>{let r=vt(t);if(r.shape.length!==5)throw new de(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,a=s[0];let i,o,l;this.dataFormat==="channelsFirst"?(l=2,i=3,o=4):(l=1,i=2,o=3);const u=s[l],c=s[i],d=s[o],h=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],b=Cl(u,m,h,this.padding),x=Cl(c,g,p,this.padding),w=Cl(d,y,f,this.padding),v=[a,b,x,w,this.filters];this.dataFormat!=="channelsLast"&&(r=qt(r,[0,2,3,4,1]));let k=dee(r,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(k=qt(k,[0,4,1,2,3])),this.bias!==null&&(k=dl(k,this.bias.read(),this.dataFormat)),this.activation!==null&&(k=this.activation.apply(k)),k})}computeOutputShape(t){t=rn(t);const n=t.slice();let r,s,a,i;this.dataFormat==="channelsFirst"?(r=1,s=2,a=3,i=4):(r=4,s=1,a=2,i=3);const o=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],d=this.strides[1],h=this.strides[2];return n[r]=this.filters,n[s]=Cl(n[s],c,o,this.padding),n[a]=Cl(n[a],d,l,this.padding),n[i]=Cl(n[i],h,u,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}Zne.className="Conv3DTranspose";Ae(Zne);class Jne extends Fb{constructor(t,n){if(super(t,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new de("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new de("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new de(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=Zn(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Qn(n.depthwiseRegularizer),this.depthwiseConstraint=Hr(n.depthwiseConstraint),this.pointwiseInitializer=Zn(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Qn(n.pointwiseRegularizer),this.pointwiseConstraint=Hr(n.pointwiseConstraint)}build(t){if(t=rn(t),t.length<this.rank+2)throw new de(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null||t[n]<0)throw new de(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[n])}`);const r=t[n],s=this.kernelSize.concat([r,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(r*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new Pr({ndim:this.rank+2,axes:{[n]:r}})],this.built=!0}call(t,n){return ge(()=>{t=vt(t);let r;if(this.rank===1)throw new Dt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=qt(t,[0,2,3,1])),r=Az(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=dl(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=qt(r,[0,3,1,2])),r})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=ir(this.depthwiseInitializer),t.pointwiseInitializer=ir(this.pointwiseInitializer),t.depthwiseRegularizer=An(this.depthwiseRegularizer),t.pointwiseRegularizer=An(this.pointwiseRegularizer),t.depthwiseConstraint=Gr(this.depthwiseConstraint),t.pointwiseConstraint=Gr(this.pointwiseConstraint),t}}Jne.className="SeparableConv";class Qne extends Jne{constructor(t){super(2,t)}}Qne.className="SeparableConv2D";Ae(Qne);class iT extends Fb{constructor(t){super(1,t),iT.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!IB(t.kernelSize,"number",1,1))throw new de(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}iT.className="Conv1D";Ae(iT);class ere extends Wt{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,n){return ge(()=>{if(t=vt(t),this.dataFormat==="channelsLast"){const r=Ak(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Ak(r,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=Ak(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Ak(r,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}ere.className="Cropping2D";Ae(ere);class tre extends Wt{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,vr(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,vnt(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const n=t[2]==null?null:this.size[0]*t[2],r=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],n,r]}else{const n=t[1]==null?null:this.size[0]*t[1],r=t[2]==null?null:this.size[1]*t[2];return[t[0],n,r,t[3]]}}call(t,n){return ge(()=>{let r=vt(t);const s=r.shape;if(this.dataFormat==="channelsFirst"){r=qt(r,[0,2,3,1]);const a=this.size[0]*s[2],i=this.size[1]*s[3],o=this.interpolation==="nearest"?io.resizeNearestNeighbor(r,[a,i]):io.resizeBilinear(r,[a,i]);return qt(o,[0,3,1,2])}else{const a=this.size[0]*s[1],i=this.size[1]*s[2];return this.interpolation==="nearest"?io.resizeNearestNeighbor(r,[a,i]):io.resizeBilinear(r,[a,i])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(t,n),t}}tre.className="UpSampling2D";Ae(tre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Grt(e,t,n=[1,1],r="valid",s,a){return ge(()=>{s==null&&(s=il()),vr(s);let i=LB(e,s);if(e.rank!==4)throw new de(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new de(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=av(i,t,n,r==="same"?"same":"valid","NHWC",a),s==="channelsFirst"&&(i=qt(i,[0,3,1,2])),i})}class nre extends aT{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Zn(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Hr(t.depthwiseConstraint),this.depthwiseRegularizer=Qn(t.depthwiseRegularizer)}build(t){if(t=rn(t),t.length<4)throw new de(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(t[n]==null||t[n]<0)throw new de(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[n]}).`);const r=t[n],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return ge(()=>{t=vt(t);let r=Grt(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=dl(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(t){t=rn(t);const n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,a=Ko(n,this.kernelSize[0],this.padding,this.strides[0]),i=Ko(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],s,a,i]:[t[0],a,i,s]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=ir(this.depthwiseInitializer),t.depthwiseRegularizer=An(this.depthwiseRegularizer),t.depthwiseConstraint=Gr(this.depthwiseRegularizer),t}}nre.className="DepthwiseConv2D";Ae(nre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function rre(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new de("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(a){return a==null||Array.isArray(a)?a:[a]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function sre(e,t,n,r=!1,s,a,i=!1,o=!1){return ge(()=>{const l=t.shape.length;if(l<3)throw new de(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(al(2,l));if(t=qt(t,u),a!=null)throw new Dt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=Xe(Xe(s,"bool"),"float32"),s.rank===l-1&&(s=xa(s,-1)),s=qt(s,u)),r&&(t=bo(t,0),s!=null&&(s=bo(s,0)));const c=[];let d,h=n;const p=t.shape[0],f=xo(t);let m;s!=null&&(m=xo(s));for(let y=0;y<p;++y){const b=f[y],x=ge(()=>e(b,h));if(s==null)d=x[0],h=x[1];else{const w=ge(()=>{const v=m[y],k=rt(Ri(v),v),I=Ee(le(x[0],v),le(h[0],k)),S=h.map(($,N)=>Ee(le(x[1][N],v),le($,k)));return{output:I,newStates:S}});d=w.output,h=w.newStates}o&&c.push(d)}let g;return o&&(g=Di(c,1)),[d,g,h]})}class Bd extends Wt{constructor(t){super(t);let n;if(t.cell==null)throw new de("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new BB({cells:t.cell}):n=t.cell,n.stateSize==null)throw new de("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Pr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return al(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){UR(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const r=n[0];let s;if(this.returnSequences?s=[t[0],t[1],r]:s=[t[0],r],this.returnState){const a=[];for(const i of n)a.push([t[0],i]);return[s].concat(a)}else return s}computeMask(t,n){return ge(()=>{Array.isArray(n)&&(n=n[0]);const r=this.returnSequences?n:null;if(this.returnState){const s=this.states.map(a=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<t;++r)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Dt("Constants support is not implemented in RNN yet.");UR(t)&&(t=t[0]),t=t;const n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new Pr({shape:[n,null,...r]});const s=[t[0]].concat(t.slice(2));this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!Xt(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new de(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new Pr({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){ge(()=>{if(!this.stateful)throw new Il("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new de("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Fr([r,s])):this.states_=[Fr([r,this.cell.stateSize])];else if(t==null)nt(this.states_),this.keptStates!=null&&(nt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Fr([r,s])):this.states_[0]=Fr([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new de(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):nt(this.states_);for(let s=0;s<this.states_.length;++s){const a=t[s],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,o=[r,i];if(!Xt(a.shape,o))throw new de(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[s]=a}}this.states_=this.states_.map(s=>ns(s.clone()))})}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});const a=rre(t,r,s,this.numConstants);t=a.inputs,r=a.initialState,s=a.constants;let i=[],o=[];if(r!=null){n.initialState=r,i=i.concat(r),this.stateSpec=[];for(const u of r)this.stateSpec.push(new Pr({shape:u.shape}));o=o.concat(this.stateSpec)}if(s!=null&&(n.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof El){const u=[t].concat(i),c=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=c;const h=super.apply(u,n);return this.inputSpec=d,h}else return super.apply(t,n)}call(t,n){return ge(()=>{const r=n==null?null:n.mask,s=n==null?null:n.training;let a=n==null?null:n.initialState;t=vt(t),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(t));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new de(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:s},u=sre((f,m)=>{const g=this.cell.call([f].concat(m),o);return[g[0],g.slice(1)]},t,a,this.goBackwards,r,null,this.unroll,this.returnSequences),c=u[0],d=u[1],h=u[2];this.stateful&&this.resetStates(h,s);const p=this.returnSequences?d:c;return this.returnState?[p].concat(h):p})}getInitialState(t){return ge(()=>{let n=Fr(t.shape);return n=ot(n,[1,2]),n=fv(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?WR(n,[1,r]):n):this.cell.stateSize>1?[WR(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===Bd.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(t,n,r={}){const s=n.cell,a=_u(s,r);return new t(Object.assign(n,{cell:a}))}}Bd.className="RNN";Ae(Bd);class oT extends Wt{}class PB extends oT{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,rs(this.units,"units"),this.activation=ld(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Zn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Qn(t.kernelRegularizer),this.recurrentRegularizer=Qn(t.recurrentRegularizer),this.biasRegularizer=Qn(t.biasRegularizer),this.kernelConstraint=Hr(t.kernelConstraint),this.recurrentConstraint=Hr(t.recurrentConstraint),this.biasConstraint=Hr(t.biasConstraint),this.dropout=Bg([1,id([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Bg([1,id([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=rn(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return ge(()=>{if(t=t,t.length!==2)throw new de(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let r=t[1];t=t[0];const s=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ud({ones:()=>Ri(t),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ud({ones:()=>Ri(r),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let a;const i=this.dropoutMask,o=this.recurrentDropoutMask;i!=null?a=Vl(le(t,i),this.kernel.read()):a=Vl(t,this.kernel.read()),this.bias!=null&&(a=dl(a,this.bias.read())),o!=null&&(r=le(r,o));let l=Ee(a,Vl(r,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:od(this.activation),useBias:this.useBias,kernelInitializer:ir(this.kernelInitializer),recurrentInitializer:ir(this.recurrentInitializer),biasInitializer:ir(this.biasInitializer),kernelRegularizer:An(this.kernelRegularizer),recurrentRegularizer:An(this.recurrentRegularizer),biasRegularizer:An(this.biasRegularizer),activityRegularizer:An(this.activityRegularizer),kernelConstraint:Gr(this.kernelConstraint),recurrentConstraint:Gr(this.recurrentConstraint),biasConstraint:Gr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),n)}}PB.className="SimpleRNNCell";Ae(PB);class are extends Bd{constructor(t){t.cell=new PB(t),super(t)}call(t,n){return ge(()=>{this.cell.dropoutMask!=null&&(nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return new t(n)}}are.className="SimpleRNN";Ae(are);class zB extends oT{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new de("GRUCell does not support reset_after parameter set to true.");this.units=t.units,rs(this.units,"units"),this.activation=ld(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ld(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Zn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Qn(t.kernelRegularizer),this.recurrentRegularizer=Qn(t.recurrentRegularizer),this.biasRegularizer=Qn(t.biasRegularizer),this.kernelConstraint=Hr(t.kernelConstraint),this.recurrentConstraint=Hr(t.recurrentConstraint),this.biasConstraint=Hr(t.biasConstraint),this.dropout=Bg([1,id([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Bg([1,id([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=rn(t);const n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return ge(()=>{if(t=t,t.length!==2)throw new de(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const r=n.training==null?!1:n.training;let s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ud({ones:()=>Ri(t),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ud({ones:()=>Ri(s),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u;0<this.dropout&&this.dropout<1&&(t=le(t,a[0]));let c=Vl(t,this.kernel.read());this.useBias&&(c=dl(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=le(s,i[0]));const d=this.recurrentKernel.read(),[h,p]=Za(d,[2*this.units,this.units],d.rank-1),f=Vl(s,h),[m,g,y]=Za(c,3,c.rank-1),[b,x]=Za(f,2,f.rank-1);o=this.recurrentActivation.apply(Ee(m,b)),l=this.recurrentActivation.apply(Ee(g,x));const w=Vl(le(l,s),p);u=this.activation.apply(Ee(y,w));const v=Ee(le(o,s),le(Ee(1,Hn(o)),u));return[v,v]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:od(this.activation),recurrentActivation:od(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ir(this.kernelInitializer),recurrentInitializer:ir(this.recurrentInitializer),biasInitializer:ir(this.biasInitializer),kernelRegularizer:An(this.kernelRegularizer),recurrentRegularizer:An(this.recurrentRegularizer),biasRegularizer:An(this.biasRegularizer),activityRegularizer:An(this.activityRegularizer),kernelConstraint:Gr(this.kernelConstraint),recurrentConstraint:Gr(this.recurrentConstraint),biasConstraint:Gr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),n)}}zB.className="GRUCell";Ae(zB);class ire extends Bd{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new zB(t),super(t)}call(t,n){return ge(()=>{this.cell.dropoutMask!=null&&(nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}}ire.className="GRU";Ae(ire);class lT extends oT{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,rs(this.units,"units"),this.activation=ld(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ld(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Zn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Qn(t.kernelRegularizer),this.recurrentRegularizer=Qn(t.recurrentRegularizer),this.biasRegularizer=Qn(t.biasRegularizer),this.kernelConstraint=Hr(t.kernelConstraint),this.recurrentConstraint=Hr(t.recurrentConstraint),this.biasConstraint=Hr(t.biasConstraint),this.dropout=Bg([1,id([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Bg([1,id([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var n;t=rn(t);const r=t[t.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){const a=this.biasInitializer,i=this.units;s=new(n=class extends No{apply(l,u){const c=a.apply([i]),d=new CB().apply([i]),h=a.apply([i*2]);return EG(EG(c,d),h)}},n.className="CustomInit",n)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,n){return ge(()=>{const r=n.training==null?!1:n.training;if(t=t,t.length!==3)throw new de(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=t[1];const a=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ud({ones:()=>Ri(t),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ud({ones:()=>Ri(s),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let l,u,c,d;0<this.dropout&&this.dropout<1&&(t=le(t,i[0]));let h=Vl(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=le(s,o[0])),h=Ee(h,Vl(s,this.recurrentKernel.read())),this.useBias&&(h=dl(h,this.bias.read()));const[p,f,m,g]=Za(h,4,h.rank-1);l=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(f),c=Ee(le(u,a),le(l,this.activation.apply(m))),d=this.recurrentActivation.apply(g);const y=le(d,this.activation.apply(c));return[y,y,c]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:od(this.activation),recurrentActivation:od(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ir(this.kernelInitializer),recurrentInitializer:ir(this.recurrentInitializer),biasInitializer:ir(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:An(this.kernelRegularizer),recurrentRegularizer:An(this.recurrentRegularizer),biasRegularizer:An(this.biasRegularizer),activityRegularizer:An(this.activityRegularizer),kernelConstraint:Gr(this.kernelConstraint),recurrentConstraint:Gr(this.recurrentConstraint),biasConstraint:Gr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),n)}}lT.className="LSTMCell";Ae(lT);class ore extends Bd{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new lT(t),super(t)}call(t,n){return ge(()=>{this.cell.dropoutMask!=null&&(nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}}ore.className="LSTM";Ae(ore);class BB extends oT{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?t.push(...n.stateSize):t.push(n.stateSize);return t}call(t,n){return ge(()=>{t=t;let r=t.slice(1);const s=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?s.push(r.splice(0,o.stateSize.length)):s.push(r.splice(0,1));s.reverse();const a=[];let i;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];r=s[o],o===0?i=[t[0]].concat(r):i=[i[0]].concat(r),i=l.call(i,n),a.push(i.slice(1))}r=[];for(const o of a.slice().reverse())r.push(...o);return[i[0]].concat(r)})}build(t){UR(t)&&(t=t[0]),t=t;let n;this.cells.forEach((r,s)=>{Th(`RNNCell_${s}`,()=>{r.build(t),Array.isArray(r.stateSize)?n=r.stateSize[0]:n=r.stateSize,t=[t[0],n]})}),this.built=!0}getConfig(){const t=super.getConfig(),n=a=>({className:a.getClassName(),config:a.getConfig()}),s={cells:this.cells.map(n)};return Object.assign(Object.assign({},t),s)}static fromConfig(t,n,r={}){const s=[];for(const a of n.cells)s.push(_u(a,r));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const n of this.cells)t.push(...n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.cells)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const r of this.cells)n.push(...r.trainableWeights);return n.concat(t)}return t}getWeights(){const t=[];for(const n of this.cells)t.push(...n.weights);return GR(t)}setWeights(t){const n=[];for(const r of this.cells){const s=r.weights.length,a=t.splice(s);for(let i=0;i<r.weights.length;++i)n.push([r.weights[i],a[i]])}RB(n)}}BB.className="StackedRNNCells";Ae(BB);function ud(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>a!=null?a(t(),n):ene(t(),n),o=()=>gv(i,t,r);return!s||s<=1?ns(o().clone()):Array(s).fill(void 0).map(o).map(u=>ns(u.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Hrt=globalThis&&globalThis.__rest||function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n};class lre extends Bd{constructor(t){if(t.unroll)throw new Dt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Dt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new Pr({ndim:5})]}call(t,n){return ge(()=>{if(this.cell.dropoutMask!=null&&(nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new de("ConvRNN2D cell does not support constants");const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}computeOutputShape(t){let n=this.computeSingleOutputShape(t);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([t[0],...n.slice(-3)])]),n}getInitialState(t){return ge(()=>{const{stateSize:n}=this.cell,r=t.shape,s=this.computeSingleOutputShape(r),a=[s[0],...s.slice(2)],i=Fr(a);return Array.isArray(n)?Array(n.length).fill(i):[i]})}resetStates(t,n=!1){ge(()=>{if(!this.stateful)throw new Il("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),a=[s[0],...s.slice(2)];if(r[0]==null)throw new de("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Fr(a)):this.states_=[Fr(a)];else if(t==null)nt(this.states_),this.keptStates!=null&&(nt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Fr(a)):this.states_[0]=Fr(a);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new de(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n?this.keptStates.push(this.states_.slice()):nt(this.states_);for(let o=0;o<this.states_.length;++o){const l=t[o],u=a;if(!Xt(l.shape,u))throw new de(`State ${o} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[o]=l}}this.states_=this.states_.map(o=>ns(o.clone()))})}computeSingleOutputShape(t){const{dataFormat:n,filters:r,kernelSize:s,padding:a,strides:i,dilationRate:o}=this.cell,l=n==="channelsFirst",u=t[l?3:2],c=t[l?4:3],d=Ko(u,s[0],a,i[0],o[0]),h=Ko(c,s[1],a,i[1],o[1]);return[...t.slice(0,2),...l?[r,d,h]:[d,h,r]]}}lre.className="ConvRNN2D";class WB extends lT{constructor(t){const{filters:n,kernelSize:r,strides:s,padding:a,dataFormat:i,dilationRate:o}=t;super(Object.assign(Object.assign({},t),{units:n})),this.filters=n,rs(this.filters,"filters"),this.kernelSize=Jm(r,2,"kernelSize"),this.kernelSize.forEach(l=>rs(l,"kernelSize")),this.strides=Jm(s||1,2,"strides"),this.strides.forEach(l=>rs(l,"strides")),this.padding=a||"valid",zi(this.padding),this.dataFormat=i||"channelsLast",vr(this.dataFormat),this.dilationRate=Jm(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>rs(l,"dilationRate"))}build(t){var n;t=rn(t);const r=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[r]==null)throw new de(`The channel dimension of the input should be defined. Found ${t[r]}`);const s=t[r],a=4,i=this.kernelSize.concat([s,this.filters*a]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(n=class extends No{apply(h,p){const f=u.apply([c]),m=ki([c]),g=u.apply([c*2]);return SB([f,m,g])}},n.className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,n){return ge(()=>{if(t.length!==3)throw new de(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const r=n.training||!1,s=t[0],a=t[1],i=t[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ud({ones:()=>Ri(s),rate:this.dropout,training:r,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(L,V,q)=>!V||!V[q]?L:le(V[q],L);let c=u(s,l,0),d=u(s,l,1),h=u(s,l,2),p=u(s,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ud({ones:()=>Ri(a),rate:this.recurrentDropout,training:r,count:o,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let m=u(a,f,0),g=u(a,f,1),y=u(a,f,2),b=u(a,f,3);const x=3,[w,v,k,I]=Za(this.kernel.read(),o,x),[S,$,N,T]=this.useBias?Za(this.bias.read(),o):[null,null,null,null];c=this.inputConv(c,w,S,this.padding),d=this.inputConv(d,v,$,this.padding),h=this.inputConv(h,k,N,this.padding),p=this.inputConv(p,I,T,this.padding);const[C,E,M,F]=Za(this.recurrentKernel.read(),o,x);m=this.recurrentConv(m,C),g=this.recurrentConv(g,E),y=this.recurrentConv(y,M),b=this.recurrentConv(b,F);const z=this.recurrentActivation.apply(Ee(c,m)),H=this.recurrentActivation.apply(Ee(d,g)),P=Ee(le(H,i),le(z,this.activation.apply(Ee(h,y)))),O=le(this.recurrentActivation.apply(Ee(p,b)),this.activation.apply(P));return[O,O,P]})}getConfig(){const t=super.getConfig(),n=Hrt(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(t,n,r,s){const a=sd(t,n,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?dl(a,r,this.dataFormat):a}recurrentConv(t,n){return sd(t,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}WB.className="ConvLSTM2DCell";Ae(WB);class ure extends lre{constructor(t){const n=new WB(t);super(Object.assign(Object.assign({},t),{cell:n}))}static fromConfig(t,n){return new t(n)}}ure.className="ConvLSTM2D";Ae(ure);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class VB extends Wt{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const n=t.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?n[s]:this.noiseShape[s]);return r}call(t,n){return ge(()=>{this.invokeCallHook(t,n);const r=vt(t);if(0<this.rate&&this.rate<1){const s=n.training==null?!1:n.training,a=this.getNoiseShape(r);return gv(()=>ene(r,this.rate,a,this.seed),()=>r,s)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(t,n),t}dispose(){return super.dispose()}}VB.className="Dropout";Ae(VB);class cre extends VB{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const n=t.shape;return[n[0],1,n[2]]}}cre.className="SpatialDropout1D";Ae(cre);class dre extends Wt{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let n=null;t.batchSize!=null&&(n=t.batchSize),this.batchInputShape=[n,t.inputDim]}this.units=t.units,rs(this.units,"units"),this.activation=ld(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=Zn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Zn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Hr(t.kernelConstraint),this.biasConstraint=Hr(t.biasConstraint),this.kernelRegularizer=Qn(t.kernelRegularizer),this.biasRegularizer=Qn(t.biasRegularizer),this.activityRegularizer=Qn(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=rn(t);const n=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(t){t=rn(t);const n=t.slice();return n[n.length-1]=this.units,n}call(t,n){return ge(()=>{this.invokeCallHook(t,n);const r=vt(t),s=qte(this.activation.getClassName());let a;return s!=null?a=Vl(r,this.kernel.read(),s,this.bias?this.bias.read():null):(a=Vl(r,this.kernel.read()),this.bias!=null&&(a=dl(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){const t={units:this.units,activation:od(this.activation),useBias:this.useBias,kernelInitializer:ir(this.kernelInitializer),biasInitializer:ir(this.biasInitializer),kernelRegularizer:An(this.kernelRegularizer),biasRegularizer:An(this.biasRegularizer),activityRegularizer:An(this.activityRegularizer),kernelConstraint:Gr(this.kernelConstraint),biasConstraint:Gr(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}dre.className="Dense";Ae(dre);class hre extends Wt{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=rn(t);for(const n of t.slice(1))if(n==null)throw new de(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],zc(t,1)]}call(t,n){return ge(()=>{this.invokeCallHook(t,n);let r=vt(t);if(this.dataFormat==="channelsFirst"&&r.rank>1){const s=[0];for(let a=2;a<r.rank;++a)s.push(a);s.push(1),r=qt(r,s)}return $nt(r)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(t,n),t}}hre.className="Flatten";Ae(hre);class pre extends Wt{constructor(t){super(t),this.supportsMasking=!0,this.activation=ld(t.activation)}call(t,n){return ge(()=>{this.invokeCallHook(t,n);const r=vt(t);return this.activation.apply(r)})}getConfig(){const t={activation:od(this.activation)},n=super.getConfig();return Object.assign(t,n),t}}pre.className="Activation";Ae(pre);class fre extends Wt{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,n){return ge(()=>(t=vt(t),Cnt(t,this.n)))}getConfig(){const t={n:this.n},n=super.getConfig();return Object.assign(t,n),t}}fre.className="RepeatVector";Ae(fre);class mre extends Wt{constructor(t){super(t),this.targetShape=t.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,n){const r="Total size of new array must be unchanged.",s=n.slice();let a=1,i=null;for(let l=0;l<s.length;++l){const u=s[l];if(this.isUnknown(u))if(i===null)i=l;else throw new de("Can only specifiy one unknown dimension.");else a*=u}const o=zc(t);if(i!==null){if(a===0||o%a!==0)throw new de(r);s[i]=o/a}else if(o!==a)throw new de(r);return s}computeOutputShape(t){let n=!1;for(let r=0;r<t.length;++r)if(this.isUnknown(t[r])){n=!0;break}return n?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,n){return ge(()=>{this.invokeCallHook(t,n);const r=vt(t),s=r.shape,a=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return ce(r,a)})}getConfig(){const t={targetShape:this.targetShape},n=super.getConfig();return Object.assign(t,n),t}}mre.className="Reshape";Ae(mre);class gre extends Wt{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const n=al(1,t.dims.length+1);if(!Xt(t.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Pr({ndim:this.dims.length+1})]}computeOutputShape(t){t=rn(t);const n=t.slice();return this.dims.forEach((r,s)=>{n[s+1]=t[r]}),n}call(t,n){return qt(vt(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},n=super.getConfig();return Object.assign(t,n),t}}gre.className="Permute";Ae(gre);class yre extends Wt{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,t),n}computeMask(t,n){const r=vt(t),s=-1;return MS(Pg(r,this.maskValue),s)}call(t,n){return ge(()=>{this.invokeCallHook(t,n);const r=vt(t),s=-1,a=!0,i=MS(Pg(r,this.maskValue),s,a);return le(r,Xe(i,r.dtype))})}}yre.className="Masking";Ae(yre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class bre extends Wt{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let n=null;t.batchSize!=null&&(n=t.batchSize),t.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(Wn(t.inputLength))}this.inputDim=t.inputDim,rs(this.inputDim,"inputDim"),this.outputDim=t.outputDim,rs(this.outputDim,"outputDim"),this.embeddingsInitializer=Zn(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Qn(t.embeddingsRegularizer),this.activityRegularizer=Qn(t.activityRegularizer),this.embeddingsConstraint=Hr(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,n){return ge(()=>this.maskZero?(t=vt(t),Pg(t,Kt(t))):null)}computeOutputShape(t){if(t=rn(t),this.inputLength==null)return[...t,this.outputDim];const n=Wn(this.inputLength);if(n.length!==t.length-1)throw new de(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let r=0;for(let s=0;s<n.length;++s){const a=n[s],i=t[s+1];if(a!=null&&i!=null&&a!==i)throw new de(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);a==null&&(n[r]=i),r++}}return[t[0],...n,this.outputDim]}call(t,n){return ge(()=>{this.invokeCallHook(t,n);let r=vt(t);r.dtype!=="int32"&&(r=Wl(r,"int32"));const s=Qte(this.embeddings.read(),ce(r,[r.size]));return ce(s,rn(this.computeOutputShape(r.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ir(this.embeddingsInitializer),embeddingsRegularizer:An(this.embeddingsRegularizer),activityRegularizer:An(this.activityRegularizer),embeddingsConstraint:Gr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(t,n),t}}bre.className="Embedding";Ae(bre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Zf extends Wt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Dt}computeElementwiseOpOutputShape(t,n){if(t==null||n==null)return null;if(t.length<n.length)return this.computeElementwiseOpOutputShape(n,t);if(n.length===0)return t;const r=t.slice(0,t.length-n.length);for(let s=0;s<n.length;++s){const a=t[t.length-n.length+s],i=n[s];if(a==null||i==null||a<0||i<0)r.push(null);else if(a===1)r.push(i);else if(i===1)r.push(a);else{if(a!==i)throw new de("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(n));r.push(a)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[rn(t)]),t=t,t.length<2)throw new de(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let n=[];for(const a of t)a!=null&&a[0]!==null&&n.push(a[0]);if(n=Pc(n),n.length>1)throw new de(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=t[0]==null?null:t[0].slice(1);for(let a=1;a<t.length;++a){const i=t[a]==null?null:t[a].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}const s=t.map(a=>a.length);t.indexOf(null)===-1&&Pc(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,n){return ge(()=>{if(t=t,this.reshapeRequired){const r=[],s=t.map(a=>a.rank);if(s.indexOf(null)===-1){const a=id(s);for(let i of t){const o=i.rank;for(let l=0;l<a-o;++l)i=fv(i,1);r.push(i)}return this.mergeFunction(r)}else{let a=!1;for(const l of t){const u=l.rank;if(u==null){const c=l.shape,d=c[0],h=c.slice(1).concat([d]);let p=ce(l,[d].concat(zc(c.slice(1))));p=qt(p,[1,0]),p=ce(p,h),r.push(p),a=!0}else if(u>1){const c=al(1,u).concat([0]);r.push(qt(l,c)),a=!0}else r.push(l)}let i=this.mergeFunction(r);const o=i.rank;if(a){if(o==null){const l=i.shape,u=l.length,c=l[u-1],d=[c].concat(l.slice(0,l.length-1));i=ce(qt(ce(i,[-1,c]),[1,0]),d)}else if(o>1){const l=[o-1].concat(al(0,o-1));i=qt(i,l)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let n;t[0]==null?n=null:n=t[0].slice(1);for(let s=1;s<t.length;++s){const a=t[s]==null?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let r=[];for(const s of t)s!=null&&s[0]!==null&&r.push(s[0]);return r=Pc(r),r.length===1?n=r.concat(n):n=[null].concat(n),n}computeMask(t,n){return ge(()=>{if(n==null)return null;if(!Array.isArray(n))throw new de("`mask` should be an Array");if(!Array.isArray(t))throw new de("`inputs` should be an Array");if(n.length!==t.length)throw new de(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${n.length})`);if(n.every(s=>s==null))return null;n=n.map(s=>s==null?s:xa(s,0));let r=n[0];for(let s=1;s<n.length-1;++s)r=jl(r,n[s]);return r})}}class xre extends Zf{constructor(t){super(t)}mergeFunction(t){return ge(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=Ee(n,t[r]);return n})}}xre.className="Add";Ae(xre);class wre extends Zf{constructor(t){super(t)}mergeFunction(t){return ge(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=le(n,t[r]);return n})}}wre.className="Multiply";Ae(wre);class vre extends Zf{constructor(t){super(t)}mergeFunction(t){return ge(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=Ee(n,t[r]);return le(1/t.length,n)})}}vre.className="Average";Ae(vre);class kre extends Zf{constructor(t){super(t)}mergeFunction(t){return ge(()=>{let n=t[0];for(let r=1;r<t.length;++r)n=Xu(n,t[r]);return n})}}kre.className="Maximum";Ae(kre);class Ire extends Zf{constructor(t){super(t)}mergeFunction(t){return ge(()=>{let n=t[0];for(let r=1;r<t.length;++r)n=op(n,t[r]);return n})}}Ire.className="Minimum";Ae(Ire);class Sre extends Zf{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new de("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let n=!0;for(const s of t)if(s!=null){n=!1;break}if(n)return;const r=[];for(let s=0;s<t.length;++s){const a=t[s].slice();a.splice(this.axis,1);let i=!1;for(const o of r)if(Xt(o,a)){i=!0;break}i||r.push(a)}if(r.length>1)throw new de("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return ge(()=>SB(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new de("A `Concatenate` layer should be called on a list of inputs.");const n=t,r=n[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(const a of n.slice(1)){if(r[s]==null||a[s]==null){r[s]=null;break}r[s]+=a[s]}return r}computeMask(t,n){if(n==null)return null;if(!Array.isArray(n))throw new de("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new de("`inputs` should be an array for Concatenate");if(n.length!==t.length)throw new de(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${t.length})`);return ge(()=>{let r=!0;if(n.forEach(i=>{if(i!=null){r=!1;return}}),r)return null;const s=[];for(let i=0;i<t.length;++i)n[i]==null?s.push(Xe(Ri(t[i]),"bool")):n[i].rank<t[i].rank?s.push(xa(n[i],-1)):s.push(n[i]);const a=$r(s,this.axis);return dz(a,-1,!1)})}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}Sre.className="Concatenate";Ae(Sre);function ix(e,t){for(;e<0;)e+=t;return e}function jrt(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Dt("batchDot is not implemented for tensors of 4D or higher rank yet");if(U(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),U(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new Dt("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;n==null&&(n=[r-1,s-2]);const a=n;return ge(()=>{let i;if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);t=ce(t,t.shape.concat(l))}else if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);e=ce(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)a[0]===a[1]?o=ot(le(e,t),a[0]):o=ot(le(qt(e,[1,0]),t),a[1]);else{const l=a[0]!==e.shape.length-1,u=a[1]===t.shape.length-1;o=Ut(e,t,l,u)}if(i>0){let l;r>s?l=r+s-3:l=r-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);o=Kf(o,u)}return o.shape.length===1&&(o=xa(o,1)),o})}class Cre extends Zf{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){U(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0],r=t[1];if(n.length>3||r.length>3)throw new Dt("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(n,r);if(n[s[0]]!==r[s[1]])throw new de(`Dimension incompatibility: ${n[s[0]]} !== ${r[s[1]]}`)}mergeFunction(t){if(t.length!==2)throw new de(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let n=t[0],r=t[1],s;return Array.isArray(this.axes)?s=this.axes.map((a,i)=>ix(a,t[i].shape.length)):s=[ix(this.axes,n.shape.length),ix(this.axes,r.shape.length)],this.normalize&&(n=VS(n,s[0]),r=VS(r,s[1])),jrt(n,r,s)}interpretAxes(t,n){let r;return Array.isArray(this.axes)?r=this.axes:r=[ix(this.axes,t.length),ix(this.axes,n.length)],r}computeOutputShape(t){U(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0].slice(),r=t[1].slice();if(n.length>3||r.length>3)throw new Dt("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(n,r);n.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);const a=n.concat(r);return a.length===1&&a.push(1),a}computeMask(t,n){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(t,n),t}}Cre.className="Dot";Ae(Cre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Nre extends Wt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,t),n}call(t,n){return ge(()=>{this.invokeCallHook(t,n);const r=vt(t);return gv(()=>Ee(tT(r.shape,0,this.stddev),r),()=>r,n.training||!1)})}}Nre.className="GaussianNoise";Ae(Nre);class $re extends Wt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return ge(()=>{this.invokeCallHook(t,n);const r=vt(t);return this.rate>0&&this.rate<1?gv(()=>{const a=Math.sqrt(this.rate/(1-this.rate));return le(r,tT(r.shape,1,a))},()=>r,n.training||!1):r})}}$re.className="GaussianDropout";Ae($re);class Tre extends Wt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||vt(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return ge(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(t);return gv(()=>{const a=vt(t),i=1.6732632423543772,o=1.0507009873554805,l=-i*o;let u=Ld(Eb(r),this.rate);u=Wl(u,"float32");const c=((1-this.rate)*(1+this.rate*l**2))**-.5,d=-c*l*this.rate,h=Ee(le(a,u),le(Ee(u,-1),l));return Ee(le(h,c),d)},()=>vt(t),n.training||!1)}return t})}}Tre.className="AlphaDropout";Ae(Tre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function V0(e,t,n,r,s,a=.001){let i;if(e.rank===2)i=eee(e,t,n,r,s,a);else if(e.rank===3)i=tee(e,t,n,r,s,a);else if(e.rank===4)i=nee(e,t,n,r,s,a);else throw new Dt(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function qrt(e,t,n,r,s=.001){return ge(()=>{const a=L$(e,r),i=a.mean,o=a.variance;return[V0(e,i,o,n,t,s),i,o]})}function Krt(e,t,n,r,s=.001){return ge(()=>{const a=L$(e,r),i=a.mean,o=a.variance,l=[];for(const f of al(0,e.rank))r.indexOf(f)!==-1?l.push(1):l.push(e.shape[f]);const u=ce(i,l),c=ce(o,l),d=t==null?null:ce(t,l),h=n==null?null:ce(n,l);return[V0(e,u,c,h,d,s),i,o]})}function Xrt(e,t,n,r,s=.001){return Xt(r.slice().sort(),al(0,e.rank-1))?qrt(e,t,n,r,s):Krt(e,t,n,r,s)}class _re extends Wt{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Zn(t.betaInitializer||"zeros"),this.gammaInitializer=Zn(t.gammaInitializer||"ones"),this.movingMeanInitializer=Zn(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Zn(t.movingVarianceInitializer||"ones"),this.betaConstraint=Hr(t.betaConstraint),this.gammaConstraint=Hr(t.gammaConstraint),this.betaRegularizer=Qn(t.betaRegularizer),this.gammaRegularizer=Qn(t.gammaRegularizer)}build(t){t=rn(t);const n=this.axis>=0?this.axis:this.axis+t.length,r=t[n];if(r==null)throw new de(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new Pr({ndim:t.length,axes:{[n]:r}})];const s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,n){return ge(()=>{const r=n.training==null?!1:n.training,s=vt(t),a=s.shape,i=a.length,o=al(0,i),l=this.axis>=0?this.axis:this.axis+i;o.splice(l,1);const u=up(1,i);u[l]=a[l];const c=o.slice();c.sort();const d=!Xt(c,al(0,i).slice(0,i-1)),h=()=>{if(d){const b=ce(this.movingMean.read(),u),x=ce(this.movingVariance.read(),u),w=this.center?ce(this.beta.read(),u):null,v=this.scale?ce(this.gamma.read(),u):null;return V0(s,b,x,w,v,this.epsilon)}else return V0(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return h();const[p,f,m]=Xrt(s,this.gamma.read(),this.beta.read(),o,this.epsilon),g=(b,x,w)=>{ge(()=>{const v=1-w,k=b.read(),I=le(rt(k,x),v);b.write(rt(k,I))})};return(()=>{g(this.movingMean,f,this.momentum),g(this.movingVariance,m,this.momentum)})(),p})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ir(this.betaInitializer),gammaInitializer:ir(this.gammaInitializer),movingMeanInitializer:ir(this.movingMeanInitializer),movingVarianceInitializer:ir(this.movingVarianceInitializer),betaRegularizer:An(this.betaRegularizer),gammaRegularizer:An(this.gammaRegularizer),betaConstraint:Gr(this.betaConstraint),gammaConstraint:Gr(this.gammaConstraint)},n=super.getConfig();return Object.assign(t,n),t}}_re.className="BatchNormalization";Ae(_re);class Ere extends Wt{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Zn(t.betaInitializer||"zeros"),this.gammaInitializer=Zn(t.gammaInitializer||"ones"),this.betaRegularizer=Qn(t.betaRegularizer),this.gammaRegularizer=Qn(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=rn(t);const n=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=n);for(const a of this.axis)if(a<0||a>=n)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==Pc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(a=>t[a]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(t,n){const r=vt(t),s=r.shape,a=s.length;return ge(()=>{let{mean:o,variance:l}=L$(r,this.axis,!0);const u=up(1,a);for(const m of this.axis)u[m]=s[m];const c=m=>m!=null&&m.shape.length!==a?ce(m,u):m;let d=this.scale?c(this.gamma.read()):null,h=this.center?c(this.beta.read()):null;const p=[],f=[];for(let m=0;m<a;++m)this.axis.indexOf(m)!==-1?(p.push(s[m]),f.push(1)):(p.push(1),f.push(s[m]));return o=ao(o,p),l=ao(l,p),d!=null&&(d=ao(d,f)),h!=null&&(h=ao(h,f)),V0(r,o,l,h,d,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ir(this.betaInitializer),gammaInitializer:ir(this.gammaInitializer),betaRegularizer:An(this.betaRegularizer),gammaRegularizer:An(this.gammaRegularizer)},n=super.getConfig();return Object.assign(t,n),t}}Ere.className="LayerNormalization";Ae(Ere);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Yrt(e,t,n){return ge(()=>{if(e.rank!==4)throw new de(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new de("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=il()),n!=="channelsLast"&&n!=="channelsFirst")throw new de(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],Pd(e,r)})}class Are extends Wt{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?il():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new de(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let n,r;if(typeof t.padding[0]=="number")n=[t.padding[0],t.padding[0]],r=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new de(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(n=t.padding[0],t.padding[1].length!==2)throw new de(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);r=t.padding[1]}this.padding=[n,r]}this.inputSpec=[new Pr({ndim:4})]}computeOutputShape(t){t=rn(t);let n,r;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?n=t[2]+this.padding[0][0]+this.padding[0][1]:n=null,t[3]!=null&&t[3]>=0?r=t[3]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],t[1],n,r]):(t[1]!=null&&t[1]>=0?n=t[1]+this.padding[0][0]+this.padding[0][1]:n=null,t[2]!=null&&t[2]>=0?r=t[2]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],n,r,t[3]])}call(t,n){return ge(()=>Yrt(vt(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}Are.className="ZeroPadding2D";Ae(Are);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function uT(e,t,n,r,s,a){return ge(()=>{vr(s),Xte(a),zi(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=il()),a==null&&(a="max"),e=LB(e,s);let i;const o=r==="same"?"same":"valid";return a==="max"?i=M$(e,t,n,o):i=_$(e,t,n,o),s==="channelsFirst"&&(i=qt(i,[0,3,1,2])),i})}function Rre(e,t,n,r,s,a){return ge(()=>{vr(s),Xte(a),zi(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=il()),a==null&&(a="max"),e=Xne(e,s);let i;const o=r==="same"?"same":"valid";return a==="max"?i=$ee(e,t,n,o):i=QQ(e,t,n,o),s==="channelsFirst"&&(i=qt(i,[0,4,1,2,3])),i})}class Dre extends Wt{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new de(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(rs(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new de(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);rs(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,zi(this.padding),this.inputSpec=[new Pr({ndim:3})]}computeOutputShape(t){t=rn(t);const n=Ko(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],n,t[2]]}call(t,n){return ge(()=>{this.invokeCallHook(t,n),t=fv(vt(t),2);const r=this.poolingFunction(vt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Kf(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(t,n),t}}class Fre extends Dre{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return vr(a),zi(s),uT(t,n,r,s,a,"max")}}Fre.className="MaxPooling1D";Ae(Fre);class Ore extends Dre{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return vr(a),zi(s),uT(t,n,r,s,a,"avg")}}Ore.className="AveragePooling1D";Ae(Ore);class Mre extends Wt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new de(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];rs(this.poolSize,"poolSize"),rs(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,vr(this.dataFormat),zi(this.padding),this.inputSpec=[new Pr({ndim:4})]}computeOutputShape(t){t=rn(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2];return n=Ko(n,this.poolSize[0],this.padding,this.strides[0]),r=Ko(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,r]:[t[0],n,r,t[3]]}call(t,n){return ge(()=>(this.invokeCallHook(t,n),this.poolingFunction(vt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class Lre extends Mre{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return vr(a),zi(s),uT(t,n,r,s,a,"max")}}Lre.className="MaxPooling2D";Ae(Lre);class Pre extends Mre{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return vr(a),zi(s),uT(t,n,r,s,a,"avg")}}Pre.className="AveragePooling2D";Ae(Pre);class zre extends Wt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new de(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];rs(this.poolSize,"poolSize"),rs(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,vr(this.dataFormat),zi(this.padding),this.inputSpec=[new Pr({ndim:5})]}computeOutputShape(t){t=rn(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[4]:t[3];return n=Ko(n,this.poolSize[0],this.padding,this.strides[0]),r=Ko(r,this.poolSize[1],this.padding,this.strides[1]),s=Ko(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,r,s]:[t[0],n,r,s,t[4]]}call(t,n){return ge(()=>(this.invokeCallHook(t,n),this.poolingFunction(vt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class Bre extends zre{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return vr(a),zi(s),Rre(t,n,r,s,a,"max")}}Bre.className="MaxPooling3D";Ae(Bre);class Wre extends zre{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return vr(a),zi(s),Rre(t,n,r,s,a,"avg")}}Wre.className="AveragePooling3D";Ae(Wre);class Vre extends Wt{constructor(t){super(t),this.inputSpec=[new Pr({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,n){throw new Dt}}class Ure extends Vre{constructor(t){super(t||{})}call(t,n){return ge(()=>{const r=vt(t);return dr(r,1)})}}Ure.className="GlobalAveragePooling1D";Ae(Ure);class Gre extends Vre{constructor(t){super(t||{})}call(t,n){return ge(()=>{const r=vt(t);return fo(r,1)})}}Gre.className="GlobalMaxPooling1D";Ae(Gre);class Hre extends Wt{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,vr(this.dataFormat),this.inputSpec=[new Pr({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,n){throw new Dt}getConfig(){const t={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class jre extends Hre{call(t,n){return ge(()=>{const r=vt(t);return this.dataFormat==="channelsLast"?dr(r,[1,2]):dr(r,[2,3])})}}jre.className="GlobalAveragePooling2D";Ae(jre);class qre extends Hre{call(t,n){return ge(()=>{const r=vt(t);return this.dataFormat==="channelsLast"?fo(r,[1,2]):fo(r,[2,3])})}}qre.className="GlobalMaxPooling2D";Ae(qre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Kre extends Wt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(t,n),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,n,r={}){const s=n.layer,a=_u(s,r);delete n.layer;const i={layer:a};return Object.assign(i,n),new t(i)}}class Xre extends Kre{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=rn(t),t.length<3)throw new de(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=rn(t);const n=[t[0]].concat(t.slice(2)),r=this.layer.computeOutputShape(n),s=t[1];return[r[0],s].concat(r.slice(1))}call(t,n){return ge(()=>(t=vt(t),sre((i,o)=>[vt(this.layer.call(i,n)),[]],t,[],!1,null,null,!1,!0)[1]))}}Xre.className="TimeDistributed";Ae(Xre);function Zrt(e){Yf(wnt,"BidirectionalMergeMode",e)}const Jrt="concat";class Yre extends Kre{constructor(t){super(t);const n=t.layer.getConfig(),r={};r.className=t.layer.getClassName(),r.config=n,this.forwardLayer=_u(r),n.goBackwards=n.goBackwards!==!0;const s={};if(s.className=t.layer.getClassName(),s.config=n,this.backwardLayer=_u(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?Jrt:t.mergeMode,Zrt(this.mergeMode),t.weights)throw new Dt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const n=t.length,r=Math.floor(n/2);this.forwardLayer.setWeights(t.slice(0,r)),this.backwardLayer.setWeights(t.slice(r))}computeOutputShape(t){let n=this.forwardLayer.computeOutputShape(t);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let r,s,a;return this.returnState&&(a=n.slice(1)),r=n[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,s=[r]):this.mergeMode==null?s=[r,r.slice()]:s=[r],this.returnState?this.mergeMode==null?s.concat(a).concat(a.slice()):[r].concat(a).concat(a.slice()):wa(s)}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});const a=rre(t,r,s,this.numConstants);if(t=a.inputs,r=a.initialState,s=a.constants,Array.isArray(t)&&(r=t.slice(1),t=t[0]),(r==null||r.length===0)&&s==null)return super.apply(t,n);const i=[],o=[];if(r!=null){const u=r.length;if(u%2>0)throw new de("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,i.push(...r);const c=r.map(d=>new Pr({shape:d.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),o.push(...c)}if(s!=null)throw new Dt("Support for constants in Bidirectional layers is not implemented yet.");const l=i[0]instanceof El;for(const u of i)if(u instanceof El!==l)throw new de("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[t].concat(i),c=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=c;const h=super.apply(u,n);return this.inputSpec=d,h}else return super.apply(t,n)}call(t,n){return ge(()=>{const r=n.initialState;let s,a;if(r==null)s=this.forwardLayer.call(t,n),a=this.backwardLayer.call(t,n);else{const l=r.slice(0,r.length/2),u=r.slice(r.length/2);s=this.forwardLayer.call(t,Object.assign(n,{initialState:l})),a=this.backwardLayer.call(t,Object.assign(n,{initialState:u}))}let i;this.returnState&&(Array.isArray(s)&&(i=s.slice(1).concat(a.slice(1))),s=s[0],a=a[0]),this.returnSequences&&(a=bo(a,1));let o;return this.mergeMode==="concat"?o=SB([s,a]):this.mergeMode==="sum"?o=Ee(s,a):this.mergeMode==="ave"?o=le(.5,Ee(s,a)):this.mergeMode==="mul"?o=le(s,a):this.mergeMode==null&&(o=[s,a]),this.returnState?this.mergeMode==null?o.concat(i):[o].concat(i):o})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Th(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Th(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,n){Array.isArray(n)&&(n=n[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[n,n]:r=n:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const a=this.forwardLayer.states.map(i=>null);return Array.isArray(r)?r.concat(a).concat(a):[r].concat(a).concat(a)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(t,n),t}static fromConfig(t,n){const r=_u(n.layer);if(delete n.layer,n.numConstants!=null)throw new Dt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=n;return s.layer=r,new t(s)}}Yre.className="Bidirectional";Ae(Yre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Zre extends Wt{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return ge(()=>(t=vt(t),t.dtype!=="float32"&&(t=Wl(t,"float32")),Ee(le(t,this.scale),this.offset)))}}Zre.className="Rescaling";Ae(Zre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:Qrt,cropAndResize:est}=io;class Jre extends Wt{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,n,r,s,a,i,o,l){return ge(()=>{let u,c=!1;const d=n/i,h=r/o,p=(s+n)/i,f=(a+r)/o,m=[d,h,p,f],g=[];t.rank===3?(c=!0,u=Di([t])):u=t;for(let v=0;v<u.shape[0];v++)g.push(m);const y=qo(g,[g.length,4]),b=zg(0,g.length,1,"int32"),w=est(u,y,b,[s,a],"nearest");return Wl(c?vt(xo(w)):w,l)})}upsize(t,n,r,s){return ge(()=>{const a=Qrt(t,[n,r]);return Wl(a,s)})}call(t,n){return ge(()=>{const r=vt(t),s=r.dtype,a=r.shape,i=a[a.length-3],o=a[a.length-2];let l=0;i!==this.height&&(l=Math.floor((i-this.height)/2));let u=0;return o!==this.width&&(u=Math.floor((o-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(r,l,u,this.height,this.width,i,o,s):this.upsize(t,this.height,this.width,s)})}getConfig(){const t={height:this.height,width:this.width},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=rn(t);const n=t.length-3,r=t.length-2;return t[n]=this.height,t[r]=this.width,t}}Jre.className="CenterCrop";Ae(Jre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tst(e,t,n,r){let s=vt(e);if(s.dtype!=="int32"&&(s=Wl(s,"int32")),t==="int")return s;const a=s.shape;if(s.rank===0&&(s=xa(s,-1)),t==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=xa(s,-1)),s.rank>2)throw new de(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t),o=s;let l;if(typeof r<"u"&&t==="count"?l=TR(o,r,n,i):l=TR(o,[],n,i),t!=="tfIdf")return l;if(r)return le(l,r);throw new de("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Qre extends Wt{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){return t=rn(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,n){return ge(()=>{t=vt(t),t.dtype!=="int32"&&(t=Wl(t,"int32"));let r;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new de(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);r=vt(n.countWeights)}const s=fo(t),a=F0(t),i=ui(this.numTokens,s).bufferSync().get(0),o=Ld(a,0).bufferSync().get(0);if(!(i&&o))throw new de(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return tst(t,this.outputMode,this.numTokens,r)})}}Qre.className="CategoryEncoding";Ae(Qre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const nst=["bilinear","nearest"],KG=new Set(nst);class ese extends Wt{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(KG.has(t.interpolation))this.interpolation=t.interpolation;else throw new de(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){t=rn(t);const n=t[2];return[this.height,this.width,n]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return ge(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return io.resizeBilinear(t,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return io.resizeNearestNeighbor(t,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...KG]} are supported`)})}}ese.className="Resizing";Ae(ese);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class tse{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}tse.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class nse extends Wt{constructor(t){super(t),this.randomGenerator=new tse(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(t,n),t}}nse.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const rst=["bilinear","nearest"],XG=new Set(rst);class rse extends nse{constructor(t){super(t);const{factor:n,interpolation:r="bilinear"}=t;if(this.factor=n,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new de(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new de(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new de(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(XG.has(r))this.interpolation=r;else throw new de(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=rn(t);const n=t[2];return[this.imgHeight,-1,n]}call(t,n){return ge(()=>{const r=vt(t);this.imgHeight=r.shape[r.shape.length-3];const s=r.shape[r.shape.length-2];this.widthFactor=Eb([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*s;a=Math.round(a);const i=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return io.resizeBilinear(t,i);case"nearest":return io.resizeNearestNeighbor(t,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...XG]} are supported`)}})}}rse.className="RandomWidth";Ae(rse);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sst=xe();sst.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ji;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(ji||(ji={}));var YG;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(YG||(YG={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ast={};function sse(e){return ast[e]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R(e,t,n,r,s){const a=t.inputParams[e];if(a&&a.inputIndexStart!==void 0){const o=a.inputIndexStart,l=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?o+1:a.inputIndexEnd,u=o<0?t.inputNames.length+o:o;if(a.type==="tensor")return bs(t.inputNames[u],n,r,s);if(a.type==="tensors"){const h=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((f,m)=>{var g;return((g=h[m])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(f=>bs(f,n,r,s))}const c=bs(t.inputNames[u],n,r,s),d=c.dataSync();return a.type==="number"?d[0]:po(c.shape,d)}const i=t.attrParams[e];return i&&i.value}function bs(e,t,n,r){const[s,a]=za(e,n);if(r!=null){const o=r.getHashTableHandleByName(s);if(o!=null)return o}const i=n.currentContextIds.find(o=>!!t[qS(s,o)]);return i!==void 0?t[qS(s,i)][a]:void 0}function ZG(e,t,n){return t[qS(e,n.currentContextId)]}function yu(e,t){const[n,r,s]=za(e,t);return[qS(n,t&&t.currentContextId),r,s]}function qS(e,t){return t?`${e}-${t}`:e}function za(e,t){if(e==="")return["",0,void 0];const n=t!=null&&t.parseNodeNameCache!=null;if(n){const a=t.parseNodeNameCache.get(e);if(a!=null)return a}const r=e.split(":");let s;if(r.length===1)s=[e,0,void 0];else{const a=r[0],i=r.length===3?r[1]:void 0,o=Number(r[r.length-1]);s=[a,o,i]}return n&&t.parseNodeNameCache.set(e,s),s}function yI(e,t,n){let r=R("pad",e,t,n);if(r==="explicit"){r=R("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function bu(e){return e.kept?e:Tu(e)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ist=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ost=Object.freeze(Object.defineProperty({__proto__:null,json:ist},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lst=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ust=Object.freeze(Object.defineProperty({__proto__:null,json:lst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cst=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],dst=Object.freeze(Object.defineProperty({__proto__:null,json:cst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hst=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],pst=Object.freeze(Object.defineProperty({__proto__:null,json:hst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fst=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],mst=Object.freeze(Object.defineProperty({__proto__:null,json:fst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gst=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],yst=Object.freeze(Object.defineProperty({__proto__:null,json:gst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bst=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],xst=Object.freeze(Object.defineProperty({__proto__:null,json:bst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wst=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],vst=Object.freeze(Object.defineProperty({__proto__:null,json:wst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kst=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Ist=Object.freeze(Object.defineProperty({__proto__:null,json:kst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sst=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Cst=Object.freeze(Object.defineProperty({__proto__:null,json:Sst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nst=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],$st=Object.freeze(Object.defineProperty({__proto__:null,json:Nst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tst=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],_st=Object.freeze(Object.defineProperty({__proto__:null,json:Tst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Est=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Ast=Object.freeze(Object.defineProperty({__proto__:null,json:Est},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rst=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Dst=Object.freeze(Object.defineProperty({__proto__:null,json:Rst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fst=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Ost=Object.freeze(Object.defineProperty({__proto__:null,json:Fst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mst=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Lst=Object.freeze(Object.defineProperty({__proto__:null,json:Mst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pst=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],zst=Object.freeze(Object.defineProperty({__proto__:null,json:Pst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bst=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Wst=Object.freeze(Object.defineProperty({__proto__:null,json:Bst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vst=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Ust=Object.freeze(Object.defineProperty({__proto__:null,json:Vst},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JG{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[ost,ust,dst,pst,mst,yst,xst,vst,Ist,Cst,$st,_st,Ast,Dst,Ost,Lst,zst,Wst,Ust],n=[].concat(...t.map(r=>r.json));this.opMappers=n.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(t,n={}){const r=t.node,s=[],a=[],i=[],o=r.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):g.op==="Const"?a.push(m[g.name]):(g.input==null||g.input.length===0)&&i.push(m[g.name]),m),{});let l=[];const u=[];let c={},d={};n!=null&&(c=this.mapSignatureEntries(n.inputs),d=this.mapSignatureEntries(n.outputs));const h=Object.keys(o);h.forEach(m=>{const g=o[m];g.inputNames.forEach((y,b)=>{const[x,,w]=yu(y),v=o[x];if(v.outputs!=null){const k=v.outputs.indexOf(w);if(k!==-1){const I=`${x}:${k}`;g.inputNames[b]=I}}g.inputs.push(v),v.children.push(g)})}),Object.keys(d).length===0?h.forEach(m=>{const g=o[m];g.children.length===0&&u.push(g)}):Object.keys(d).forEach(m=>{const[g]=yu(m),y=o[g];y!=null&&(y.signatureKey=d[m],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{const[g]=yu(m),y=o[g];y&&(y.signatureKey=c[m],l.push(y))}):l=s;let p={};t.library!=null&&t.library.function!=null&&(p=t.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const f={nodes:o,inputs:l,outputs:u,weights:a,placeholders:s,signature:n,functions:p};return i.length>0&&(f.initNodes=i),f}mapSignatureEntries(t){return Object.keys(t||{}).reduce((n,r)=>(n[t[r].name]=r,n),{})}mapNode(t){const n=sse(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});const r={name:t.name,op:t.op,category:n.category,inputNames:(t.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((s,a)=>(s[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},s),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((s,a)=>{const i=a.type;let o;switch(a.type){case"string":o=YR(t.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=YR(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":o=rD(t.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=rD(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":o=JR(t.attr,a.tfName,a.defaultValue||0),o===void 0&&a.tfDeprecatedName&&(o=JR(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":o=nD(t.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=nD(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":o=ZR(t.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=ZR(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":o=aD(t.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=aD(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":o=tD(t.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=tD(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":o=sD(t.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=sD(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":o=QR(t.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=QR(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":o=eD(t.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=eD(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":o=QG(t.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=QG(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${t.op}`)}return s[a.name]={value:o,type:i},s},{})),r}mapFunction(t){const n=t.nodeDef,r=[],s=[];let a={};n!=null&&(a=n.reduce((d,h)=>(d[h.name]=this.mapNode(h),h.op==="Const"&&s.push(d[h.name]),d),{}));const i=[],o=[];t.signature.inputArg.forEach(d=>{const[h]=yu(d.name),p={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:UB(d.type),type:"dtype"}},children:[]};p.signatureKey=d.name,i.push(p),a[h]=p}),Object.keys(a).forEach(d=>{const h=a[d];h.inputNames.forEach((p,f)=>{const[m,,g]=yu(p),y=a[m];if(y.outputs!=null){const b=y.outputs.indexOf(g);if(b!==-1){const x=`${m}:${b}`;h.inputNames[f]=x}}h.inputs.push(y),y.children.push(h)})});const u=t.ret;t.signature.outputArg.forEach(d=>{const[h,p]=yu(u[d.name]),f=a[h];f!=null&&(f.defaultOutput=p,o.push(f))});const c=this.mapArgsToSignature(t);return{nodes:a,inputs:i,outputs:o,weights:s,placeholders:r,signature:c}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:t.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,t.ret),n),{})}}mapArgToTensorInfo(t,n){let r=t.name;return n!=null&&(r=n[r]),{name:r,dtype:t.type}}}function Gst(e){const t=xe().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function ase(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):Gst(e);return t?n:n.toLowerCase()}function YR(e,t,n,r=!1){const s=e[t];return s!=null?ase(s.s,r):n}function ZR(e,t,n){const r=e[t];return r?r.b:n}function JR(e,t,n){const r=e[t]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function UB(e){switch(typeof e=="string"&&(e=ji[e]),e){case ji.DT_FLOAT:case ji.DT_HALF:return"float32";case ji.DT_INT32:case ji.DT_INT64:case ji.DT_INT8:case ji.DT_UINT8:return"int32";case ji.DT_BOOL:return"bool";case ji.DT_DOUBLE:return"float32";case ji.DT_STRING:return"string";default:return null}}function QG(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function QR(e,t,n){const r=e[t];return r&&r.type?UB(r.type):n}function eD(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map(s=>UB(s)):n}function ise(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function tD(e,t,n){const r=e[t];return r&&r.shape?ise(r.shape):n}function nD(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function rD(e,t,n,r=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map(a=>ase(a,r)):n}function sD(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>ise(s)):n}function aD(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hst{constructor(t,n,r){this.node=t,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(s=>this.getInput(s)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((s,a)=>(s[a]=this.getAttr(a),s),{}))}getInput(t){return bs(t,this.tensorMap,this.context)}getAttr(t,n){const r=this.node.rawAttrs[t];if(r.tensor!=null)return bs(t,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return JR(this.node.rawAttrs,t,n);if(r.s!=null)return YR(this.node.rawAttrs,t,n);if(r.b!=null)return ZR(this.node.rawAttrs,t,n);if(r.shape!=null)return tD(this.node.rawAttrs,t,n);if(r.type!=null)return QR(this.node.rawAttrs,t,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return nD(this.node.rawAttrs,t,n);if(r.list.s!=null)return rD(this.node.rawAttrs,t,n);if(r.list.shape!=null)return sD(this.node.rawAttrs,t,n);if(r.list.b!=null)return aD(this.node.rawAttrs,t,n);if(r.list.type!=null)return eD(this.node.rawAttrs,t,n)}return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ts=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:EQ,abs:Rr,acos:HQ,acosh:jQ,add:Ee,addN:vXe,all:dz,any:MS,argMax:Og,argMin:qQ,asin:KQ,asinh:XQ,atan:YQ,atan2:ZQ,atanh:JQ,avgPool:_$,avgPool3d:QQ,basicLSTMCell:GXe,batchNorm:sv,batchNorm2d:eee,batchNorm3d:tee,batchNorm4d:nee,batchToSpaceND:E$,bincount:ree,booleanMaskAsync:EZe,broadcastArgs:QXe,broadcastTo:Ym,buffer:Mt,cast:Xe,ceil:see,clipByValue:ri,clone:Tu,complex:nd,concat:$r,concat1d:aee,concat2d:iee,concat3d:oee,concat4d:lee,conv1d:pz,conv2d:sd,conv2dTranspose:mz,conv3d:uee,conv3dTranspose:dee,cos:A$,cosh:gz,cosineWindow:Wz,cumprod:LS,cumsum:yz,denseBincount:TR,depthToSpace:hee,depthwiseConv2d:av,diag:k7e,dilation2d:pee,div:ft,divNoNan:fee,dot:mee,dropout:Vee,einsum:E7e,elu:iv,enclosingPowerOfTwo:Uee,equal:sl,erf:gee,euclideanNorm:xee,exp:Ei,expandDims:xa,expm1:wee,eye:xz,fft:G$,fill:Tb,floor:lv,floorDiv:cz,fused:JZe,gather:uv,gatherND:BZe,greater:ui,greaterEqual:Ld,ifft:P0,imag:R$,image:io,inTopKAsync:GZe,irfft:Oz,isFinite:vee,isInf:kee,isNaN:Iee,leakyRelu:D$,less:O0,lessEqual:jf,linalg:Zee,linspace:r9e,localResponseNormalization:See,log:Ai,log1p:F$,logSigmoid:Cee,logSoftmax:wz,logSumExp:vz,logicalAnd:jl,logicalNot:O$,logicalOr:kz,logicalXor:Nee,losses:$Qe,lowerBound:x9e,matMul:Ut,max:fo,maxPool:M$,maxPool3d:$ee,maxPoolWithArgmax:I9e,maximum:Xu,mean:dr,meshgrid:N9e,min:F0,minimum:op,mirrorPad:Tee,mod:_ee,moments:L$,movingAverage:DZe,mul:le,multiRNNCell:R9e,multinomial:F9e,neg:Hn,norm:ov,notEqual:Pg,oneHot:Sz,ones:ki,onesLike:Ri,op:se,outerProduct:z9e,pad:Pd,pad1d:V9e,pad2d:G9e,pad3d:j9e,pad4d:K9e,pool:Eee,pow:ad,prelu:z$,print:UQ,prod:Aee,raggedGather:nYe,raggedRange:sYe,raggedTensorToTensor:iYe,rand:lYe,randomGamma:TYe,randomNormal:Nz,randomStandardNormal:AYe,randomUniform:Eb,range:zg,real:M0,reciprocal:Ree,relu:Ql,relu6:$z,reshape:ce,reverse:bo,reverse1d:zYe,reverse2d:WYe,reverse3d:UYe,reverse4d:HYe,rfft:H$,round:Tz,rsqrt:_z,scalar:bt,scatterND:OZe,searchSorted:Iz,selu:Ez,separableConv2d:Az,setdiff1dAsync:ZYe,sigmoid:zl,sign:Dee,signal:NQe,sin:Rz,sinh:Dz,slice:jt,slice1d:W$,slice2d:Fz,slice3d:V$,slice4d:L0,softmax:U$,softplus:_b,spaceToBatchND:P$,sparse:TQe,sparseToDense:PZe,spectral:CQe,split:Za,sqrt:Ps,square:En,squaredDifference:Mz,squeeze:Kf,stack:Di,step:Ab,stridedSlice:Fee,string:_Qe,sub:rt,sum:ot,tan:Oee,tanh:Mg,tensor:qo,tensor1d:ka,tensor2d:Hx,tensor3d:Mee,tensor4d:yZe,tensor5d:bZe,tensor6d:xZe,tensorScatterUpdate:vZe,tile:ao,topk:Pee,transpose:qt,truncatedNormal:Pz,unique:zee,unsortedSegmentSum:zz,unstack:xo,upperBound:$Ze,variable:Bee,where:Fs,whereAsync:Wee,zeros:Fr,zerosLike:Kt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jst=(e,t,n,r=Ts)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(R("a",e,t,n),R("b",e,t,n))];case"AddN":return[r.addN(R("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(R("a",e,t,n),R("b",e,t,n))];case"Mul":return[r.mul(R("a",e,t,n),R("b",e,t,n))];case"RealDiv":case"Div":return[r.div(R("a",e,t,n),R("b",e,t,n))];case"DivNoNan":return[r.divNoNan(R("a",e,t,n),R("b",e,t,n))];case"FloorDiv":return[r.floorDiv(R("a",e,t,n),R("b",e,t,n))];case"Sub":return[r.sub(R("a",e,t,n),R("b",e,t,n))];case"Minimum":return[r.minimum(R("a",e,t,n),R("b",e,t,n))];case"Maximum":return[r.maximum(R("a",e,t,n),R("b",e,t,n))];case"Pow":return[r.pow(R("a",e,t,n),R("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(R("a",e,t,n),R("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qst=(e,t,n,r=Ts)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(R("x",e,t,n))];case"Acos":return[r.acos(R("x",e,t,n))];case"Acosh":return[r.acosh(R("x",e,t,n))];case"Asin":return[r.asin(R("x",e,t,n))];case"Asinh":return[r.asinh(R("x",e,t,n))];case"Atan":return[r.atan(R("x",e,t,n))];case"Atan2":return[r.atan2(R("x",e,t,n),R("y",e,t,n))];case"Atanh":return[r.atanh(R("x",e,t,n))];case"Ceil":return[r.ceil(R("x",e,t,n))];case"Complex":return[r.complex(R("real",e,t,n),R("imag",e,t,n))];case"Cos":return[r.cos(R("x",e,t,n))];case"Cosh":return[r.cosh(R("x",e,t,n))];case"Elu":return[r.elu(R("x",e,t,n))];case"Erf":return[r.erf(R("x",e,t,n))];case"Exp":return[r.exp(R("x",e,t,n))];case"Expm1":return[r.expm1(R("x",e,t,n))];case"Floor":return[r.floor(R("x",e,t,n))];case"Log":return[r.log(R("x",e,t,n))];case"Log1p":return[r.log1p(R("x",e,t,n))];case"Imag":return[r.imag(R("x",e,t,n))];case"Neg":return[r.neg(R("x",e,t,n))];case"Reciprocal":return[r.reciprocal(R("x",e,t,n))];case"Real":return[r.real(R("x",e,t,n))];case"Relu":return[r.relu(R("x",e,t,n))];case"Round":return[r.round(R("x",e,t,n))];case"Selu":return[r.selu(R("x",e,t,n))];case"Sigmoid":return[r.sigmoid(R("x",e,t,n))];case"Sin":return[r.sin(R("x",e,t,n))];case"Sign":return[r.sign(R("x",e,t,n))];case"Sinh":return[r.sinh(R("x",e,t,n))];case"Softplus":return[r.softplus(R("x",e,t,n))];case"Sqrt":return[r.sqrt(R("x",e,t,n))];case"Square":return[r.square(R("x",e,t,n))];case"Tanh":return[r.tanh(R("x",e,t,n))];case"Tan":return[r.tan(R("x",e,t,n))];case"ClipByValue":return[r.clipByValue(R("x",e,t,n),R("clipValueMin",e,t,n),R("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(R("x",e,t,n))];case"Rsqrt":return[r.rsqrt(bs(e.inputNames[0],t,n))];case"Prod":return[r.prod(R("x",e,t,n),R("axes",e,t,n))];case"LeakyRelu":return[r.leakyRelu(R("x",e,t,n),R("alpha",e,t,n))];case"Prelu":return[r.prelu(R("x",e,t,n),R("alpha",e,t,n))];case"IsNan":return[r.isNaN(bs(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(bs(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(bs(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zi(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){U(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){const s=e[r],a=t[r];U(s<0||a<0||s===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function eH(e){return!(typeof e=="number"||e.some(t=>t<0))}function ox(e,t,n){let r=iD(e,n);const s=!eH(r);if(s&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(a=>{r=iD(a.shape,r)}),!eH(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function iD(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kst{constructor(t,n,r,s,a,i,o){this.name=t,this.dtype=n,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=a,this.dynamicSize=i,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=bt(0),ns(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const n=this.tensors[t];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(t){return t.map(n=>this.read(n))}write(t,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[t]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),Zi(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=n,ns(n),r.written=!0,this.tensors[t]=r}writeMany(t,n){if(t.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${n.length}.`);t.forEach((r,s)=>this.write(r,n[s]))}gather(t,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(t)t=t.slice(0,this.size());else{t=[];for(let s=0;s<this.size();s++)t.push(s)}if(t.length===0)return qo([],[0].concat(this.elementShape));const r=this.readMany(t);return Zi(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Di(r,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return qo([],[0].concat(this.elementShape));const n=[];for(let s=0;s<this.size();s++)n.push(s);const r=this.readMany(n);return Zi(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),$r(r,0)}scatter(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,xo(n,0))}split(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let r=0;const s=t.map(l=>(r+=l,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const a=r===0?0:n.size/r,i=[];ge(()=>{n=ce(n,[1,r,a]);for(let l=0;l<t.length;++l){const c=[0,l===0?0:s[l-1],0],d=[1,t[l],a];i[l]=ce(jt(n,c,d),this.elementShape)}return i});const o=[];for(let l=0;l<t.length;l++)o[l]=l;this.writeMany(o,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cp{get id(){return this.idTensor.id}constructor(t,n,r,s=-1){this.tensors=t,this.elementShape=n,this.elementDtype=r,t!=null&&t.forEach(a=>{if(r!==a.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${a.dtype}`);Zi(n,a.shape,"TensorList shape mismatch: "),ns(a)}),this.idTensor=bt(0),this.maxNumElements=s,ns(this.idTensor)}copy(){return new cp([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Zi(t,this.elementShape,"TensorList shape mismatch: ");const s=ox(this.elementShape,this.tensors,t);return ge(()=>{const a=this.tensors.map(i=>ce(i,s));return Di(a,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=ox(this.elementShape,this.tensors,t),s=this.tensors.pop();return s.kept=!1,Zi(s.shape,t,"TensorList shape mismatch: "),ce(s,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Zi(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ns(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const n=new cp([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)n.tensors[r]=this.tensors[r];return n}getItem(t,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Zi(this.tensors[t].shape,n,"TensorList shape mismatch: ");const s=ox(this.elementShape,this.tensors,n);return ce(this.tensors[t],s)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Zi(this.elementShape,n.shape,"TensorList shape mismatch: "),ns(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Zi(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());const s=ox(this.elementShape,this.tensors,r);return t.length===0?qo([],[0].concat(s)):ge(()=>{const a=t.map(i=>ce(this.tensors[i],s));return Di(a,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Zi(this.elementShape,n,"TensorList shape mismatch: ");const r=ox(this.elementShape,this.tensors,n);return this.size()===0?qo([],[0].concat(r)):ge(()=>{const s=this.tensors.map(a=>ce(a,r));return $r(s,0)})}}function Xst(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);const s=e.shape.slice(1);Zi(s,t,"TensorList shape mismatch: ");const a=xo(e);return new cp(a,t,r)}function Yst(e,t,n,r){return new cp([],e,t,r)}function Zst(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new cp([],n,e.dtype,r),i=xo(e,0);return t.forEach((o,l)=>{a.setItem(o,i[l])}),a}function Jst(e,t,n){let r=0;const s=t.map(c=>(r+=c,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);const a=e.shape.slice(1),i=iD(a,n),o=r===0?0:e.size/r,l=ge(()=>{const c=[];e=ce(e,[1,r,o]);for(let d=0;d<t.length;++d){const p=[0,d===0?0:s[d-1],0],f=[1,t[d],o];c[d]=ce(jt(e,p,f),i)}return e.dispose(),c}),u=new cp([],n,e.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qst=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=R("thenBranch",e,t,n),s=R("elseBranch",e,t,n),a=R("cond",e,t,n),i=R("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=R("body",e,t,n),s=R("cond",e,t,n),a=R("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map(c=>c.id);let l=await i[0].data();i.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let u=a;for(;l[0];){const c=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const d=u.map(p=>p.id);c.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()});const h=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await h[0].data(),h.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()})}return u}case"LoopCond":{const r=R("pred",e,t,n);return[bu(r)]}case"Switch":{const r=R("pred",e,t,n);let s=R("data",e,t,n);return s.kept||(s=bu(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find(s=>bs(s,t,n)!==void 0);if(r){const s=bs(r,t,n);return[bu(s)]}return}case"Enter":{const r=R("frameName",e,t,n),s=R("tensor",e,t,n);return n.enterFrame(r),[bu(s)]}case"Exit":{const r=R("tensor",e,t,n);return n.exitFrame(),[bu(r)]}case"NextIteration":{const r=R("tensor",e,t,n);return n.nextIteration(),[bu(r)]}case"TensorArrayV3":{const r=R("size",e,t,n),s=R("dtype",e,t,n),a=R("elementShape",e,t,n),i=R("dynamicSize",e,t,n),o=R("clearAfterRead",e,t,n),l=R("identicalElementShapes",e,t,n),u=R("name",e,t,n),c=new Kst(u,s,r,a,l,i,o);return n.addTensorArray(c),[c.idTensor,bt(1)]}case"TensorArrayWriteV3":{const r=R("tensorArrayId",e,t,n),s=R("index",e,t,n),a=R("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=R("tensorArrayId",e,t,n),s=R("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=R("tensorArrayId",e,t,n),s=R("indices",e,t,n),a=R("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=R("tensorArrayId",e,t,n),s=R("indices",e,t,n),a=R("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=R("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=R("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=R("tensorArrayId",e,t,n),s=R("tensor",e,t,n),a=R("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=R("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return[bt(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=R("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=R("tensorListId",e,t,n),s=R("index",e,t,n),a=R("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=R("tensorListId",e,t,n),s=R("index",e,t,n),a=R("elementShape",e,t,n),i=R("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=R("indices",e,t,n),s=R("tensor",e,t,n),a=R("elementShape",e,t,n),i=R("numElements",e,t,n),o=Zst(s,r,a,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=R("elementShape",e,t,n),s=R("elementDType",e,t,n);let a;e.op==="TensorListReserve"?a="numElements":a="maxNumElements";const i=R(a,e,t,n),o=e.op==="TensorListReserve"?-1:i,l=Yst(r,s,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const r=R("tensorListId",e,t,n),s=R("indices",e,t,n),a=R("elementShape",e,t,n),i=R("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{const r=R("tensorListId",e,t,n),s=R("elementShape",e,t,n),a=R("elementDType",e,t,n),i=R("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{const r=R("tensor",e,t,n),s=R("elementShape",e,t,n),a=R("elementDType",e,t,n),i=Xst(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=R("tensorListId",e,t,n),s=n.getTensorList(r.id),a=R("dtype",e,t,n),i=R("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=R("tensorListId",e,t,n),s=R("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=R("tensorListId",e,t,n),s=R("elementShape",e,t,n),a=R("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=R("tensor",e,t,n),s=R("elementShape",e,t,n),a=R("lengths",e,t,n),i=Jst(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{const r=R("tensorListId",e,t,n),s=n.getTensorList(r.id);return[bt(s.size(),"int32")]}case"TensorListResize":{const r=R("tensorListId",e,t,n),s=R("size",e,t,n),i=n.getTensorList(r.id).resize(s);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tH(e,t,n){const[r,s]=R("fusedOps",e,t,n),a=r==="biasadd",i=!a,o=s==="prelu",l=r==="fusedbatchnorm",u=R("numArgs",e,t,n);if(a){if(o&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=R("strides",e,t,n),d=yI(e,t,n),h=R("dataFormat",e,t,n).toUpperCase(),p=R("dilations",e,t,n);let[f,m]=R("args",e,t,n);i&&(m=f,f=void 0);const g=R("leakyreluAlpha",e,t,n);return{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:g}}const eat=(e,t,n,r=Ts)=>{switch(e.op){case"Conv1D":{const s=R("stride",e,t,n),a=R("pad",e,t,n),i=R("dataFormat",e,t,n).toUpperCase(),o=R("dilation",e,t,n);return[r.conv1d(R("x",e,t,n),R("filter",e,t,n),s,a,i,o)]}case"Conv2D":{const s=R("strides",e,t,n),a=yI(e,t,n),i=R("dataFormat",e,t,n).toUpperCase(),o=R("dilations",e,t,n);return[r.conv2d(R("x",e,t,n),R("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=tH(e,t,n);return[r.fused.conv2d({x:R("x",e,t,n),filter:R("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=tH(e,t,n);return[r.fused.depthwiseConv2d({x:R("x",e,t,n),filter:R("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=R("outputShape",e,t,n),a=R("strides",e,t,n),i=yI(e,t,n);return[r.conv2dTranspose(R("x",e,t,n),R("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=R("strides",e,t,n),a=yI(e,t,n),i=R("dilations",e,t,n),o=R("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(R("input",e,t,n),R("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("dataFormat",e,t,n).toUpperCase(),o=R("dilations",e,t,n);return[r.conv3d(R("x",e,t,n),R("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("kernelSize",e,t,n);return[r.avgPool(R("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("kernelSize",e,t,n);return[r.maxPool(R("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("kernelSize",e,t,n),o=R("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(R("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[l,u]}case"AvgPool3D":{const s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("kernelSize",e,t,n);return[r.avgPool3d(R("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("kernelSize",e,t,n);return[r.maxPool3d(R("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("dilations",e,t,n),o=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(R("x",e,t,n),R("filter",e,t,n),[o,l],a,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tat=(e,t,n,r=Ts)=>{switch(e.op){case"Fill":{const s=R("shape",e,t,n),a=R("dtype",e,t,n),i=R("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{const s=R("start",e,t,n),a=R("stop",e,t,n),i=R("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{const s=R("logits",e,t,n),a=R("numSamples",e,t,n),i=R("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{const s=R("indices",e,t,n),a=R("depth",e,t,n),i=R("onValue",e,t,n),o=R("offValue",e,t,n),l=R("dtype",e,t,n);return[r.oneHot(s,a,i,o,l)]}case"Ones":return[r.ones(R("shape",e,t,n),R("dtype",e,t,n))];case"OnesLike":return[r.onesLike(R("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(R("shape",e,t,n),R("dtype",e,t,n),R("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(R("shape",e,t,n),R("minval",e,t,n),R("maxval",e,t,n),R("dtype",e,t,n))];case"Range":{const s=R("start",e,t,n),a=R("stop",e,t,n),i=R("step",e,t,n);return[r.range(s,a,i,R("dtype",e,t,n))]}case"TruncatedNormal":{const s=R("shape",e,t,n),a=R("mean",e,t,n),i=R("stdDev",e,t,n),o=R("seed",e,t,n);return[r.truncatedNormal(s,a,i,R("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(R("shape",e,t,n),R("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(R("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V_(e,t,n){const r=R("boxes",e,t,n),s=R("scores",e,t,n),a=R("maxOutputSize",e,t,n),i=R("iouThreshold",e,t,n),o=R("scoreThreshold",e,t,n),l=R("softNmsSigma",e,t,n);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}const nat=async(e,t,n,r,s=Ts)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=V_(e,t,n),d=await s.image.nonMaxSuppressionWithScoreAsync(a,i,o,l,u,c);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=V_(e,t,n),c=R("padToMaxOutputSize",e,t,n),d=await s.image.nonMaxSuppressionPaddedAsync(a,i,o,l,u,c);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=V_(e,t,n);return[await s.image.nonMaxSuppressionAsync(a,i,o,l,u)]}case"Where":{const a=s.cast(R("condition",e,t,n),"bool"),i=[await s.whereAsync(a)];return a.dispose(),i}case"ListDiff":return s.setdiff1dAsync(R("x",e,t,n),R("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rat=(e,t,n,r=Ts)=>{switch(e.op){case"LowerBound":{const s=R("sortedSequence",e,t,n),a=R("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=R("x",e,t,n),a=R("k",e,t,n),i=R("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{const s=R("sortedSequence",e,t,n),a=R("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{const s=R("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=R("x",e,t,n),a=R("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sat=(e,t,n,r=Ts)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=R("default",e,t,n);return[bs(e.name,t,n)||s];case"Placeholder":return[bs(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=R("x",e,t,n);return[bu(c)]}case"IdentityN":return R("x",e,t,n).map(c=>bu(c));case"Snapshot":const a=R("x",e,t,n);return[bu(a)];case"Shape":return[r.tensor1d(R("x",e,t,n).shape,"int32")];case"ShapeN":return R("x",e,t,n).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(R("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(R("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=R("x",e,t,n),o=R("data",e,t,n),l=R("message",e,t,n),u=R("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aat{get id(){return this.handle.id}constructor(t,n){this.keyDType=t,this.valueDType=n,this.handle=bt(0),this.tensorMap=new Map,ns(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return bt(this.size(),"int32")}async import(t,n){this.checkKeyAndValueTensor(t,n);const r=await t.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),ge(()=>{const s=xo(n),a=r.length,i=s.length;U(a===i,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${i} elements.`);for(let o=0;o<a;o++){const l=r[o],u=s[o];ns(u),this.tensorMap.set(l,u)}return this.handle})}async find(t,n){this.checkKeyAndValueTensor(t,n);const r=await t.data();return ge(()=>{const s=[];for(let a=0;a<r.length;a++){const i=r[a],o=this.findWithDefault(i,n);s.push(o)}return Di(s)})}findWithDefault(t,n){const r=this.tensorMap.get(t);return r??n}checkKeyAndValueTensor(t,n){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iat=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(e.name);if(s!=null)return[s];{const a=R("keyDType",e,t,n),i=R("valueDType",e,t,n),o=new aat(a,i);return r.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=R("tableHandle",e,t,n,r),a=R("keys",e,t,n),i=R("values",e,t,n);return[await r.getHashTableById(s.id).import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=R("tableHandle",e,t,n,r),a=R("keys",e,t,n),i=R("defaultValue",e,t,n);return[await r.getHashTableById(s.id).find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=R("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oat=(e,t,n,r=Ts)=>{switch(e.op){case"ResizeBilinear":{const s=R("images",e,t,n),a=R("size",e,t,n),i=R("alignCorners",e,t,n),o=R("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const s=R("images",e,t,n),a=R("size",e,t,n),i=R("alignCorners",e,t,n),o=R("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{const s=R("image",e,t,n),a=R("boxes",e,t,n),i=R("boxInd",e,t,n),o=R("cropSize",e,t,n),l=R("method",e,t,n),u=R("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,l,u)]}case"ImageProjectiveTransformV3":{const s=R("images",e,t,n),a=R("transforms",e,t,n),i=R("outputShape",e,t,n),o=R("fillValue",e,t,n),l=R("interpolation",e,t,n),u=R("fillMode",e,t,n);return[r.image.transform(s,a,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lat=(e,t,n,r=Ts)=>{switch(e.op){case"Equal":return[r.equal(R("a",e,t,n),R("b",e,t,n))];case"NotEqual":return[r.notEqual(R("a",e,t,n),R("b",e,t,n))];case"Greater":return[r.greater(R("a",e,t,n),R("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(R("a",e,t,n),R("b",e,t,n))];case"Less":return[r.less(R("a",e,t,n),R("b",e,t,n))];case"LessEqual":return[r.lessEqual(R("a",e,t,n),R("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(R("a",e,t,n),R("b",e,t,n))];case"LogicalNot":return[r.logicalNot(R("a",e,t,n))];case"LogicalOr":return[r.logicalOr(R("a",e,t,n),R("b",e,t,n))];case"Select":case"SelectV2":return[r.where(R("condition",e,t,n),R("a",e,t,n),R("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uat=(e,t,n,r=Ts)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(R("a",e,t,n),R("b",e,t,n),R("transposeA",e,t,n),R("transposeB",e,t,n))];case"Einsum":return[r.einsum(R("equation",e,t,n),...R("tensors",e,t,n))];case"Transpose":return[r.transpose(R("x",e,t,n),R("perm",e,t,n))];case"_FusedMatMul":const[s,a]=R("fusedOps",e,t,n),i=s==="biasadd",o=a==="prelu",l=R("numArgs",e,t,n),u=R("leakyreluAlpha",e,t,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=R("args",e,t,n);return[r.fused.matMul({a:R("a",e,t,n),b:R("b",e,t,n),transposeA:R("transposeA",e,t,n),transposeB:R("transposeB",e,t,n),bias:c,activation:a,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(R("a",e,t,n),R("numLower",e,t,n),R("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cat=(e,t,n,r=Ts)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(R("x",e,t,n),R("axis",e,t,n),R("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(R("x",e,t,n),R("mean",e,t,n),R("variance",e,t,n),R("offset",e,t,n),R("scale",e,t,n),R("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(R("x",e,t,n),R("mean",e,t,n),R("variance",e,t,n),R("offset",e,t,n),R("scale",e,t,n),R("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(R("x",e,t,n),R("radius",e,t,n),R("bias",e,t,n),R("alpha",e,t,n),R("beta",e,t,n))];case"Softmax":return[r.softmax(R("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(R("x",e,t,n))];case"SparseToDense":return[r.sparseToDense(R("sparseIndices",e,t,n),R("outputShape",e,t,n),R("sparseValues",e,t,n),R("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dat=(e,t,n,r=Ts)=>{switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(R("paramsNestedSplits",e,t,n),R("paramsDenseValues",e,t,n),R("indices",e,t,n),R("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(R("starts",e,t,n),R("limits",e,t,n),R("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(R("shape",e,t,n),R("values",e,t,n),R("defaultValue",e,t,n),R("rowPartitionTensors",e,t,n),R("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hat=(e,t,n,r=Ts)=>{switch(e.op){case"Max":{const o=R("axis",e,t,n),l=R("keepDims",e,t,n);return[r.max(R("x",e,t,n),o,l)]}case"Mean":{const o=R("axis",e,t,n),l=R("keepDims",e,t,n);return[r.mean(R("x",e,t,n),o,l)]}case"Min":{const o=R("axis",e,t,n),l=R("keepDims",e,t,n);return[r.min(R("x",e,t,n),o,l)]}case"Sum":{const o=R("axis",e,t,n),l=R("keepDims",e,t,n);return[r.sum(R("x",e,t,n),o,l)]}case"All":{const o=R("axis",e,t,n),l=R("keepDims",e,t,n);return[r.all(R("x",e,t,n),o,l)]}case"Any":{const o=R("axis",e,t,n),l=R("keepDims",e,t,n);return[r.any(R("x",e,t,n),o,l)]}case"ArgMax":{const o=R("axis",e,t,n);return[r.argMax(R("x",e,t,n),o)]}case"ArgMin":{const o=R("axis",e,t,n);return[r.argMin(R("x",e,t,n),o)]}case"Prod":{const o=R("axis",e,t,n),l=R("keepDims",e,t,n);return[r.prod(R("x",e,t,n),o,l)]}case"Cumprod":{const o=R("axis",e,t,n),l=R("exclusive",e,t,n),u=R("reverse",e,t,n);return[r.cumprod(R("x",e,t,n),o,l,u)]}case"Cumsum":{const o=R("axis",e,t,n),l=R("exclusive",e,t,n),u=R("reverse",e,t,n);return[r.cumsum(R("x",e,t,n),o,l,u)]}case"Bincount":const s=R("x",e,t,n),a=R("weights",e,t,n),i=R("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{const o=R("x",e,t,n),l=R("weights",e,t,n),u=R("size",e,t,n),c=R("binaryOutput",e,t,n);return[r.denseBincount(o,l,u,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pat=(e,t,n,r=Ts)=>{switch(e.op){case"ConcatV2":case"Concat":{const s=R("n",e,t,n),a=R("axis",e,t,n);let i=R("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{const s=R("x",e,t,n),a=R("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=R("axis",e,t,n),a=R("batchDims",e,t,n),i=R("x",e,t,n),o=R("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{const s=R("dims",e,t,n),a=[];for(let o=0;o<s.length;o++)s[o]&&a.push(o);const i=R("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{const s=R("axis",e,t,n),a=R("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{const s=R("begin",e,t,n),a=R("size",e,t,n);return[r.slice(R("x",e,t,n),s,a)]}case"StridedSlice":{const s=R("begin",e,t,n),a=R("end",e,t,n),i=R("strides",e,t,n),o=R("beginMask",e,t,n),l=R("endMask",e,t,n),u=R("ellipsisMask",e,t,n),c=R("newAxisMask",e,t,n),d=R("shrinkAxisMask",e,t,n),h=R("x",e,t,n);return[r.stridedSlice(h,s,a,i,o,l,u,c,d)]}case"Pack":return ge(()=>{const s=R("axis",e,t,n),a=R("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,l=a.map(u=>{const c=Xt(u.shape,i);if(!c&&!Xt(r.squeeze(u).shape,o))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,i)});return[r.stack(l,s)]});case"Unpack":{const s=R("axis",e,t,n),a=R("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{const s=R("reps",e,t,n);return[r.tile(R("x",e,t,n),s)]}case"Split":case"SplitV":{const s=R("axis",e,t,n),a=R("numOrSizeSplits",e,t,n),i=R("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{const s=R("indices",e,t,n),a=R("values",e,t,n),i=R("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{const s=R("x",e,t,n),a=R("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=R("sparseIndices",e,t,n),a=R("outputShape",e,t,n),i=R("sparseValues",e,t,n),o=R("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=R("indices",e,t,n),a=R("values",e,t,n),i=R("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fat=(e,t,n,r=Ts)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(R("indices",e,t,n),R("values",e,t,n),R("denseShape",e,t,n),R("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(R("inputIndices",e,t,n),R("inputShape",e,t,n),R("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(R("data",e,t,n),R("indices",e,t,n),R("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(R("data",e,t,n),R("indices",e,t,n),R("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mat=(e,t,n,r=Ts)=>{switch(e.op){case"FFT":return[r.fft(R("x",e,t,n))];case"IFFT":return[r.ifft(R("x",e,t,n))];case"RFFT":return[r.rfft(R("x",e,t,n))];case"IRFFT":return[r.irfft(R("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gat=(e,t,n,r=Ts)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(R("input",e,t,n),R("pattern",e,t,n),R("rewrite",e,t,n),R("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(R("data",e,t,n),R("dataSplits",e,t,n),R("separator",e,t,n),R("nGramWidths",e,t,n),R("leftPad",e,t,n),R("rightPad",e,t,n),R("padWidth",e,t,n),R("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:i}=r.string.stringSplit(R("input",e,t,n),R("delimiter",e,t,n),R("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(R("input",e,t,n),R("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yat=(e,t,n,r=Ts)=>{switch(e.op){case"Cast":return[r.cast(R("x",e,t,n),R("dtype",e,t,n))];case"ExpandDims":{const s=R("axis",e,t,n);return[r.expandDims(R("x",e,t,n),s)]}case"Squeeze":{const s=R("axis",e,t,n);return[r.squeeze(R("x",e,t,n),s)]}case"Reshape":return[r.reshape(R("x",e,t,n),R("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(R("x",e,t,n),R("padding",e,t,n),R("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(R("x",e,t,n),R("padding",e,t,n),R("constantValue",e,t,n))];case"SpaceToBatchND":{const s=R("blockShape",e,t,n),a=R("paddings",e,t,n);return[r.spaceToBatchND(R("x",e,t,n),s,a)]}case"BatchToSpaceND":{const s=R("blockShape",e,t,n),a=R("crops",e,t,n);return[r.batchToSpaceND(R("x",e,t,n),s,a)]}case"DepthToSpace":{const s=R("blockSize",e,t,n),a=R("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(R("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(R("x",e,t,n),R("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(R("s0",e,t,n),R("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nH(e,t,n,r,s=ge){const a=((i,o,l)=>{switch(i.category){case"arithmetic":return s(()=>jst(i,o,l));case"basic_math":return s(()=>qst(i,o,l));case"control":return Qst(i,o,l);case"convolution":return s(()=>eat(i,o,l));case"creation":return s(()=>tat(i,o,l));case"dynamic":return nat(i,o,l);case"evaluation":return s(()=>rat(i,o,l));case"image":return s(()=>oat(i,o,l));case"graph":return s(()=>sat(i,o,l));case"logical":return s(()=>lat(i,o,l));case"matrices":return s(()=>uat(i,o,l));case"normalization":return s(()=>cat(i,o,l));case"ragged":return s(()=>dat(i,o,l));case"reduction":return s(()=>hat(i,o,l));case"slice_join":return s(()=>pat(i,o,l));case"sparse":return s(()=>fat(i,o,l));case"spectral":return s(()=>mat(i,o,l));case"string":return s(()=>gat(i,o,l));case"transformation":return s(()=>yat(i,o,l));case"hash_table":return iat(i,o,l,r);case"custom":const u=sse(i.op);if(u&&u.customExecutor)return u.customExecutor(new Hst(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return np(a)?a.then(i=>[].concat(i)):[].concat(a)}class rH{constructor(t={},n={},r={},s={},a){this.weightMap=t,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,n){return{id:t,frameName:n,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let n=0;n<this.contexts.length-1;n++){const r=this.contexts.slice(0,this.contexts.length-n);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(t);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(t)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sH(e,t,n,r){const s=new Set,a=[];let i=null,o=null;const l=new Set,u=new Set(Object.keys(e).map(h=>za(h)[0]));r=r||[];const c=new Set(r.map(h=>za(h.name)[0])),d=[...t];for(;d.length>0;){const h=d.pop();if((dh(h)||Cat(h)||Nat(h))&&i==null&&(i=h,o=i.children.map(p=>p.name).filter(p=>s.has(p))),s.add(h.name),n[h.name]==null&&!u.has(h.name)&&!c.has(h.name)){if(h.inputs.length===0){a.push(h.name);continue}h.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),d.push(p))})}}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}function bat(e,t){const{usedNodes:n,inputs:r}=t,s=Object.keys(r).map(g=>za(g)[0]).map(g=>e.nodes[g]),a=e.initNodes||[],i=g=>n.has(typeof g=="string"?g:g.name);function o(g){return[...new Map(g.map(y=>[y.name,y])).values()]}const l=o([...s,...e.weights,...a]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map(g=>[g.name,g])),d={};for(const g of u){d[g.name]=d[g.name]||0;for(const y of g.children)i(y)||(d[y.name]=Number.POSITIVE_INFINITY),d[y.name]=(d[y.name]||0)+1}const h=Object.entries(d).filter(([,g])=>g===0).map(([g])=>g),p=[...h];for(;h.length>0;){const g=h.pop(),y=c.get(g);for(const b of y.children.filter(i))--d[b.name]===0&&(p.push(b.name),h.push(b.name))}const f=p.map(g=>c.get(g)),m=xat(f,l);return wat(m,l),m}function xat(e,t){const n=new Map(e.map(i=>[i.name,i])),r=t.map(i=>i.name),s=new Set(r);for(;r.length>0;){const i=r.pop(),o=n.get(i);for(const l of o.children)!n.has(l.name)||s.has(l.name)||(s.add(l.name),r.push(l.name))}return e.filter(i=>s.has(i.name))}class Dk extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}function wat(e,t){const n=new Map(e.map((o,l)=>[o.name,l])),r=new Set(t.map(o=>o.name)),s=o=>r.has(typeof o=="string"?o:o.name),a=new Set(e.map(o=>o.name)),i=o=>a.has(typeof o=="string"?o:o.name);for(const o of e){for(const l of o.children.filter(i)){if(!n.has(l.name))throw new Dk(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new Dk(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!s(o))for(const l of o.inputs){if(!n.has(l.name))throw new Dk(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new Dk(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function vat(e){const t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,r=e.map((o,l)=>dh(o)?n:l),s=o=>{const l=r[t.get(o.name)];return l??-1},a=e.map((o,l)=>o.children.map(s).reduce((u,c)=>Math.max(u,c),r[l])),i=new Map;for(let o=0;o<e.length;++o){const l=a[o];if(l===n)continue;const u=e[o],c=e[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u)}return i}const kat=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Iat=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Sat=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function dh(e){return kat.has(e.op)}function Cat(e){return Iat.has(e.op)}function Nat(e){return Sat.has(e.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KS{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const n=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new KS(t.functions[r],this)})}getCompilationKey(t,n){const r=t.map(a=>a.name).sort(),s=n.map(a=>a.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(t,n){const r=sH(t,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:a,syncInputs:i}=r;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const u=n.map(d=>d.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${s}]`)}const o=bat(this.graph,r),l=vat(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;const n=t.clone();return ns(n),n}cloneTensorList(t){return t?t.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);const r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);const s=r.map(h=>this.graph.nodes[za(h)[0]]),a=n.map(h=>za(h)[0]),i=new Set(a);let o=a.map(h=>this.graph.nodes[h]);o.length===0&&(o=this._outputs);const l=this.getCompilationKey(s,o);let u=this.compiledMap.get(l);u==null&&(u=this.compile(t,o),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=xe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const c={},d={};return ge(()=>{const h=new rH(this.weightMap,c,d,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(y=>{const[b,x]=za(y,h),w=[];w[x]=t[y],p[b]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(w))});const f=this.getFrozenTensorIds(p),{orderedNodes:m,nodeLiveUntilMap:g}=u;for(const y of m){if(p[y.name])continue;const b=nH(y,p,h,this._resourceManager);if(np(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);p[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,p,h,f,i,g.get(y.name))}return this.parent==null&&h.dispose(f),n.map(y=>bs(y,p,h))})}getFrozenTensorIds(t){const n=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(t,n,r,s,a,i,o){if(!(dh(n)||i.has(t))){for(const l of r[t])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(const l of n.inputs){if(dh(l))continue;const u=ZG(l.name,r,s);if(u!=null)for(const c of u){if(!c||c.kept||a.has(c.id))continue;const d=o[c.id];d===1?(c.dispose(),delete o[c.id]):d!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,r,s,a,i){function o(l){return dh(l)||a.has(l.name)}if(!(dh(t)||i==null))for(const l of i){if(o(l))continue;const u=ZG(l.name,n,r);for(const c of u)!c||c.kept||s.has(c.id)||c.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,r=!1,s={},a={}){this.disposeIntermediateTensors(),r||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=xe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const i=new rH(this.weightMap,s,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(t,i,n,r),l=n.map(h=>bs(h,o,i)),u=l.map(h=>h.id),c=Object.keys(t).map(h=>t[h].id),d=new Set([...u,...c,...this.weightIds]);return Object.values(o).forEach(h=>{h.forEach(p=>{p&&!p.isDisposed&&!d.has(p.id)&&p.dispose()})}),this.parent==null&&i.dispose(d),l}async executeFunctionAsync(t,n,r){const s=t.reduce((a,i,o)=>(a[this.inputs[o].name]=i,a),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(t,n,r,s){const a=Object.keys(t),i=a.map(w=>this.graph.nodes[za(w)[0]]),o=r.map(w=>za(w)[0]),l=new Set(o);let u=o.map(w=>this.graph.nodes[w]);u.length===0&&(u=this._outputs);const{usedNodes:c,missingInputs:d,dynamicNode:h,syncInputs:p}=sH(t,u,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:n.currentContext})),m=Object.assign({},this.weightMap);Object.keys(t).forEach(w=>{const[v,k]=za(w),I=[];I[k]=t[w],m[v]=I});const g={},y=this.getFrozenTensorIds(m),b={};for(;f.length>0;){const w=this.processStack(i,f,n,m,b,y,l,g,c);await Promise.all(w)}h==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const x=u.filter(w=>!dh(w)&&!bs(w.name,m,n)).map(w=>w.name);if(x.length>0){let w="";throw h!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${a}]. Consider providing the following inputs: [${d}]. ${w}`)}return m}processStack(t,n,r,s,a,i,o,l,u){const c=[];for(;n.length>0;){const d=n.pop();r.currentContext=d.contexts;let h="";if(d.node.op==="Enter"&&R("isConstant",d.node,s,r)&&([h]=yu(d.node.name,r)),s[d.node.name]==null){const p=nH(d.node,s,r,this._resourceManager);h||([h]=yu(d.node.name,r));const f=r.currentContext;np(p)?c.push(p.then(m=>(s[h]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(m)),r.currentContext=f,this.checkTensorForDisposal(h,d.node,s,r,i,o,l),this.processChildNodes(d.node,n,r,s,a,u),m))):(s[h]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(p)),this.checkTensorForDisposal(h,d.node,s,r,i,o,l),this.processChildNodes(d.node,n,r,s,a,u))}else this.processChildNodes(d.node,n,r,s,a,u)}return c}processChildNodes(t,n,r,s,a,i){t.children.forEach(o=>{const[l]=yu(o.name,r);a[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(u=>!!bs(u,s,r))&&(a[l]=!0,n.push({contexts:r.currentContext,node:o})):o.inputNames.every(u=>!!bs(u,s,r))&&(a[l]=!0,n.push({contexts:r.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{const r=t[n],[s]=za(n),a=this.graph.nodes[s];if(a.attrParams.shape&&a.attrParams.shape.value){const i=a.attrParams.shape.value,o=i.length===r.shape.length&&r.shape.every((l,u)=>i[u]===-1||i[u]===l);U(o,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&U(r.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var n,r;const s={};for(const a in t){const i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[a];i!=null?s[i.name]=t[a]:s[a]=t[a]}return s}checkInputs(t){const n=Object.keys(t).filter(r=>{const[s]=za(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var r,s;const a=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[n];return a!=null?a.name:n},{})}checkOutputs(t){t.forEach(n=>{const[r]=za(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}}class $at{constructor(t={},n={}){this.hashTableNameToHandle=t,this.hashTableMap=n}addHashTable(t,n){this.hashTableNameToHandle[t]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tat="?tfjs-format=file",_at="model.json";class Eat{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,n={},r=ute){this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=r,n==null&&(this.loadOptions={}),this.resourceManager=new $at}findIOHandler(){const t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const n=this.io.getLoadHandlers(t,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[t]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return np(t)?t.then(n=>this.loadSync(n)):this.loadSync(t)}loadSync(t){this.artifacts=t;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new KS(JG.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){const a=JG.Instance.transformGraph(t.modelInitializer);this.initializer=new KS(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,n){if(typeof t=="string"){const r=this.io.getSaveHandlers(t);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${t}'`);t=r[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const n=t instanceof Kn?[t]:t,r={};return n.forEach((s,a)=>r[this.structuredOutputKeys[a]]=s),r}return t}predict(t,n){const r=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(t,n){const r=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(t){var n;if(!(t instanceof Kn)&&!Array.isArray(t)){const a=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(a!=null)for(const i in a){const o=a[i];o.resourceId!=null&&(t[i]=this.resourceIdToCapturedInput[o.resourceId])}return t}t=Array.isArray(t)?t:[t];const r=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${t.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((a,i)=>{var o,l,u;const c=(u=(l=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||l===void 0?void 0:l[i])===null||u===void 0?void 0:u.resourceId;return c!=null?a[i]=this.resourceIdToCapturedInput[c]:a[i]=t[s++],a},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,r=Object.keys(n);for(let s=0;s<r.length;s++){const a=r[s],i=n[a];this.resourceIdToCapturedInput[i.resourceId]=t[s]}}}execute(t,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const r=this.executor.execute(t,n);return r.length>1?r:r[0]}async executeAsync(t,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const r=await this.executor.executeAsync(t,n);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((n,r)=>(n[r]=[t[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&nt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function aH(e,t={},n=ute){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=Aat(e));const r=new Eat(e,t,n);return await r.load(),r}function Aat(e){return e.endsWith("/")||(e=e+"/"),`${e}${_at}${Tat}`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var iH;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(iH||(iH={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ut(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&U(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rat=Bz;class cT extends JL{nextDataId(){return cT.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new aQ(this,xl())}write(t,n,r){this.firstUse&&(this.firstUse=!1,xe().get("IS_NODE")&&gi(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:r,refCount:1}),s}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&i1(r[0])){const a=r.map(i=>Lc(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return{dataId:s,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){const n=this.data.get(t);n.refCount--}}move(t,n,r,s,a){this.data.set(t,{values:n,dtype:s,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:n,complexTensorInfos:r}=this.data.get(t);if(n==="complex64"){const s=this.readSync(r.real.dataId),a=this.readSync(r.imag.dataId);return Pu(s,a)}return Q8e(this.data.get(t).values,n)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const r=n.map(s=>td(s));return Mt(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Mt(t.shape,t.dtype,n)}makeOutput(t,n,r){return xl().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const n=ya();return t(),{kernelMs:ya()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){ut([t],"where");const n=this.readSync(t.dataId);return Rat(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}cT.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ose(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const Dat=e=>{const{x:t}=e.inputs,n=e.backend;ut(t,"abs");let r=new Float32Array(ve(t.shape));const s=n.data.get(t.dataId).values;return r=ose(s),n.makeOutput(r,t.shape,t.dtype)},Fat={kernelName:C2,backendName:"cpu",kernelFunc:Dat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ar(e){return(t,n,r,s,a)=>{const i=Nt(t,n),o=i.length,l=yt(i),u=ve(i),c=Is(a,u),d=t.length,h=n.length,p=yt(t),f=yt(n),m=Lg(t,i),g=Lg(n,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=e(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){const b=Nb(y,o,l),x=b.slice(-d);m.forEach(I=>x[I]=0);const w=Pl(x,d,p),v=b.slice(-h);g.forEach(I=>v[I]=0);const k=Pl(v,h,f);c[y]=e(r[w],s[k])}return[c,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Va(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const Oat={kernelName:lP,backendName:"cpu",kernelFunc:Va};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XS(e,t,n="float32"){if(n==="complex64"){const s=XS(e,t,"float32"),a=XS(e,t,"float32");return Va({inputs:{real:s,imag:a},backend:e})}const r=Ls(ve(t),n);return e.makeTensorInfo(t,n,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ql(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Mat={kernelName:$1,backendName:"cpu",kernelFunc:ql};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dp(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const Lat={kernelName:BP,backendName:"cpu",kernelFunc:dp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lse(e,t,n,r){if(r==="int32"){const s=Int32Array.from(e);return[t,"int32",s]}if(r==="bool"){const s=Hf([0],n),[a,i]=Ar((o,l)=>o!==l?1:0)(t,[],e,s,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function cd(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return ql({inputs:{x:s},backend:n});const c=XS(n,s.shape,s.dtype),d=cd({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),h=Va({inputs:{real:d,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),h}if(s.dtype==="complex64"){const c=dp({inputs:{input:s},backend:n}),d=cd({inputs:{x:c},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(c),d}if(!oQ(s.dtype,a)){const c=ql({inputs:{x:s},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,l,u]=lse(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}const Pat={kernelName:f1,backendName:"cpu",kernelFunc:cd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hs(e,t,n,r){return n==null?({inputs:s,backend:a})=>{const{a:i,b:o}=s,l=a;ut([i,o],e);const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d=i.dtype==="string"?zu(u):u,h=i.dtype==="string"?zu(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:({inputs:s,backend:a})=>{const{a:i,b:o}=s,l=a;if(i.dtype==="complex64"||o.dtype==="complex64"){const u=cd({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),d=c.complexTensorInfos.real,h=c.complexTensorInfos.imag,p=l.data.get(d.dataId).values,f=l.data.get(h.dataId).values,m=cd({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,x=l.data.get(y.dataId).values,w=l.data.get(b.dataId).values,[v,k,I]=n(i.shape,o.shape,p,f,x,w),S=l.makeTensorInfo(I,"float32",v),$=l.makeTensorInfo(I,"float32",k),N=Va({inputs:{real:S,imag:$},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(S),l.disposeIntermediateTensorInfo($),N}else{const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d=r||i.dtype,[h,p]=t(i.shape,o.shape,u,c,d);return l.makeTensorInfo(p,d,h)}}}function GB(e){return(t,n,r,s,a,i)=>{const o=Nt(t,n),l=ve(o),u=o.length,c=yt(o),d=Is("float32",l),h=Is("float32",l),p=Lg(t,o),f=Lg(n,o),m=Pu(r,s),g=Pu(a,i),y=t.length,b=yt(t),x=n.length,w=yt(n);if(p.length+f.length===0)for(let v=0;v<d.length;v++){const k=v%m.length,I=v%g.length,S=e(m[k*2],m[k*2+1],g[I*2],g[I*2+1]);d[v]=S.real,h[v]=S.imag}else for(let v=0;v<d.length;v++){const k=Nb(v,u,c),I=k.slice(-y);p.forEach(C=>I[C]=0);const S=Pl(I,y,b),$=k.slice(-x);f.forEach(C=>$[C]=0);const N=Pl($,x,w),T=e(m[S*2],m[S*2+1],g[N*2],g[N*2+1]);d[v]=T.real,h[v]=T.imag}return[d,h,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const use=Ar((e,t)=>e+t),zat=GB((e,t,n,r)=>({real:e+n,imag:t+r})),Wg=hs($b,use,zat),Bat={kernelName:$b,backendName:"cpu",kernelFunc:Wg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HB(e,t,n,r,s){const a=ve(r),i=Ls(s,n);for(let o=0;o<e.length;o++){const l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(a>0?i[l]+=t[o]:i[l]+=1)}return i}function cse(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=Mt([s,n],t.dtype);for(let o=0;o<s;o++)for(let l=0;l<a;l++){const u=e.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(r?i.set(1,o,u):t.size>0?i.set(i.get(o,u)+t.get(o,l),o,u):i.set(i.get(o,u)+1,o,u))}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eu(e){return(t,n,r)=>{const s=yr(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xn(e,t,n){const r=eu(t);return Wd(e,r,n)}function Wd(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;ut(i,e);const o=a,l=o.data.get(i.dataId).values;let u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=zu(l)}else u=l;const c=n||i.dtype,d=t(u,c,s);return o.makeTensorInfo(i.shape,c,d)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dse=eu(e=>Math.ceil(e)),Wat=Wd(m1,dse),Vat={kernelName:m1,backendName:"cpu",kernelFunc:Wat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hse(e,t,n,r){const s=yr(n,ve(t));if(r&&n!=="string"){let a=0;e.forEach(i=>{const o=ve(i.shape);s.set(i.vals,a),a+=o})}else{let a=0;e.forEach(i=>{const o=n==="string"?zu(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*t[1]+a;for(let d=0;d<i.shape[1];++d)s[c+d]=o[l++]}a+=i.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pse=Ar((e,t)=>e===t?1:0),fse=hs(W2,pse,null,"bool"),Uat={kernelName:W2,backendName:"cpu",kernelFunc:fse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mse=eu(e=>Math.exp(e)),gse=Wd(k1,mse,"float32"),Gat={kernelName:k1,backendName:"cpu",kernelFunc:gse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yse=eu(e=>Math.expm1(e)),Hat=Wd(I1,yse),jat={kernelName:I1,backendName:"cpu",kernelFunc:Hat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bse=eu(e=>Math.floor(e)),qat=Wd(S1,bse),Kat={kernelName:S1,backendName:"cpu",kernelFunc:qat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xse=Ar((e,t)=>Math.floor(e/t)),Xat=hs(C1,xse,null,"int32"),Yat={kernelName:C1,backendName:"cpu",kernelFunc:Xat};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wse(e,t,n,r,s,a,i,o,l){const u=Mt([r,a],n);for(let c=0;c<r;c++){const d=[];let h=0;for(let p=0;p<s;p++){const f=e[c*s+p];h+=f*i[p],d.push(f)}if(h<0||h>=l/a)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let p=0;p<a;p++)u.values[c*a+p]=t.get(...t.indexToLoc(h*a+p))}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vse(e,t,n){const r=Mt(n,e.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),o=i[0],l=i[2],u=t.locToIndex([o,l]);i[2]=t.values[u];const c=e.locToIndex(i);0<=c&&c<e.values.length&&(r.values[s]=e.values[c])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kse=Ar((e,t)=>e>t?1:0),Zat=hs(H2,kse,null,"bool"),Jat={kernelName:H2,backendName:"cpu",kernelFunc:Zat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ise=Ar((e,t)=>e>=t?1:0),Qat=hs(N1,Ise,null,"bool"),eit={kernelName:N1,backendName:"cpu",kernelFunc:Qat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sse=Ar((e,t)=>e<t?1:0),tit=hs(q2,Sse,null,"bool"),nit={kernelName:q2,backendName:"cpu",kernelFunc:tit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cse=Ar((e,t)=>e<=t?1:0),rit=hs(K2,Cse,null,"bool"),sit={kernelName:K2,backendName:"cpu",kernelFunc:rit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nse(e,t,n){const r=(t-e)/(n-1),s=Ls(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $se=eu(e=>Math.log(e)),ait=Wd(A1,$se),iit={kernelName:A1,backendName:"cpu",kernelFunc:ait};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tse(e,t,n,r){const s=Is(r,ve(n));for(let a=0;a<s.length;++a){const i=a*t;let o=e[i];for(let l=0;l<t;++l){const u=e[i+l];(Number.isNaN(u)||u>o)&&(o=u)}s[a]=o}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _se=Ar((e,t)=>Math.max(e,t)),oit=hs(D1,_se),lit={kernelName:D1,backendName:"cpu",kernelFunc:oit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ese=Ar((e,t)=>Math.min(e,t)),uit=hs(F1,Ese),cit={kernelName:F1,backendName:"cpu",kernelFunc:uit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jB=Ar((e,t)=>e*t),dit=GB((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),dT=hs(M1,jB,dit),hit={kernelName:M1,backendName:"cpu",kernelFunc:dT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ase(e,t,n){const r=Rd(-1,n);return jB([],t,r,e,n)}function pit(e){const{inputs:t,backend:n}=e,{x:r}=t;ut(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=Ase(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}const fit={kernelName:a$,backendName:"cpu",kernelFunc:pit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rse=Ar((e,t)=>e!==t?1:0),mit=hs(i$,Rse,null,"bool"),git={kernelName:i$,backendName:"cpu",kernelFunc:mit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qB(e,t,n,r,s){const a=t.length,i=ve(t),o=yt(t),l=yt(s),u=Is(n,ve(s));for(let c=0;c<i;++c){const d=Nb(c,a,o),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[r[f]];const p=Pl(h,a,l);u[p]=e[c]}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ea(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;ut(s,"transpose");const i=s.shape.length,o=new Array(i);for(let d=0;d<o.length;d++)o[d]=s.shape[a[d]];const l=r.data.get(s.dataId).values,u=qB(l,s.shape,s.dtype,a,o);return{dataId:r.write(u,o,s.dtype),shape:o,dtype:s.dtype}}const yit={kernelName:qm,backendName:"cpu",kernelFunc:Ea};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dse(e,t,n,r){const[s,a]=ds(e,r),i=ni(t,"int32"),o=Ls(ve(s),i),l=ve(a);for(let u=0;u<o.length;++u){const c=u*l;let d=1;for(let h=0;h<l;++h)d*=n[c+h];o[u]=d}return{outVals:o,outShape:s,outDtype:i}}function bit(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;ut(s,"prod");const o=s.shape.length,l=Bt(a,s.shape),u=lr(l,o);let c=l,d=s;const h=[];u!=null&&(d=Ea({inputs:{x:s},backend:n,attrs:{perm:u}}),h.push(d),c=wr(c.length,o));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=Dse(d.shape,d.dtype,p,c);let y=m;return i&&(y=br(m,l)),h.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(y,g,f)}const xit={kernelName:h$,backendName:"cpu",kernelFunc:bit};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wit(e,t,n){e.forEach((r,s)=>{if(r<0||r>=n){const a=Nb(s,t.length,yt(t)).join(",");throw new Error(`indices[${a}] = ${r} is not in [0, ${n})`)}})}function vit(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let a=1;a<r.length;++a)if(r[a-1]>r[a])throw new Error("Ragged splits must be sorted in ascending order")}}function kit(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);vit(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const c=t[u+1];for(let d=1;d<l+1;++d)o[u].push(d*c)}for(let u=0;u<e.length;++u){let c=e[u],d=e[u]+1;for(let h=0;h<n.length;++h){const p=n[h],f=h+t.length-1;if(f>=0){const m=o[f],g=m[m.length-1]-p[c];for(let y=c;y<d;++y)o[f].push(p[y+1]+g)}c=p[c],d=p[d]}d!==c&&(s.push([c,d]),a+=d-c)}return{outSplits:o,valueSlices:s,numValues:a}}function Iit(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n].length,s=yr("int32",r);t.push(s),e[n].forEach((a,i)=>s[i]=a)}return t}function oH(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function Sit(e,t,n,r,s,a){const i=oH(t,2)[1],o=oH(a,2)[1];let l=0;for(const u of n)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)s[l*o+d]=e[c*i+d];++l}}function Cit(e,t,n,r,s){const a=t.slice();a[0]=s;const i=yr(n,ve(a)),o=e.length,l=o===0?0:o/t[0];return Sit(e,t,r,l,i,a),[i,a]}function Fse(e,t,n,r,s,a,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const l=t[0][0]-1;if(wit(a,i,l),r.length===0)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:c,valueSlices:d,numValues:h}=kit(a,i,e,u),p=Iit(c),f=Cit(n,r,s,d,h);return[p,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lH=2147483647;function Ose(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=t.length===0,l=s.length===0,u=i.length===0,c=[];o||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");const d=c.length===0?1:c[0],h=yr("int32",d+1);h[0]=0;for(let g=0;g<d;++g){const y=o?e[0]:e[g],b=l?r[0]:r[g],x=u?a[0]:a[g];if(x===0)throw new Error("Requires delta != 0");let w;if(x>0&&b<y||x<0&&b>y)w=0;else if(w=Math.ceil(Math.abs((b-y)/x)),w>lH)throw new Error(`Requires ((limit - start) / delta) <= ${lH}`);h[g+1]=h[g]+w}const p=h[d],f=yr(n,p);let m=0;for(let g=0;g<d;++g){const y=h[g+1]-h[g];let b=o?e[0]:e[g];const x=u?a[0]:a[g];for(let w=0;w<y;++w)f[m++]=b,b+=x}return[h,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Gi=Lo;class YS{constructor(t,n,r,s,a,i,o,l,u,c){this.shape=t,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=wte(c),this.raggedRank=vte(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Gi.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Gi.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Gi.VALUE_ROWIDS:return YS.getMaxWidthValueRowID(n);case Gi.ROW_SPLITS:return YS.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Gi[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const n=t.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){const a=t[s+1]-t[s];a>r&&(r=a)}return r}static getMaxWidthValueRowID(t){const n=t.length;if(n===0)return 0;let r=0,s=t[0],a=0;for(let i=1;i<n;++i){const o=t[i];o!==s&&(s=o,a=Math.max(i-r,a),r=i)}return Math.max(n-r,a)}tensorShapeFromTensor(t,n,r=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return cH(t,r)}calculateOutputSize(t){const n=this.valuesShape,r=this.defaultValueShape;kte(r,n);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=xte(this.raggedRank,s,n);i[0]<0&&(i[0]=t);for(let o=1;o<=this.raggedRank;++o)i[o]<0&&(i[o]=this.getMaxWidth(o));return i}calculateFirstParentOutputIndex(t,n,r){const s=Math.min(t,r),a=[];let i=0;for(let o=0;o<s;++o,i+=n)a.push(i);for(let o=s;o<t;++o)a.push(-1);return U(a.length===t,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(t,n,r,s){const a=t.length,i=[];for(let o=0;o<a-1;++o){const l=t[o+1]-t[o];let u=Math.min(s,l),c=n[o];c===-1&&(u=0);for(let d=0;d<u;++d)i.push(c),c+=r;for(let d=0;d<l-u;++d)i.push(-1)}if(a>0&&i.length!==t[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,r,s){const a=t.length,i=[];if(a===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];i.push(u);for(let c=1;c<a;++c){const d=t[c];if(d===l)u>=0&&(++o,o<s?u+=r:u=-1);else{if(o=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);u=n[d]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,r,s){const a=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Gi.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,r,s);case Gi.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,r,s);default:throw new Error(`Unsupported partition type: ${Gi[i]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case Gi.FIRST_DIM_SIZE:return t[0];case Gi.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Gi.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Gi[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),r=this.calculateOutputSize(n),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const a=cH(r,!1),i=yr(this.valuesDType,ve(a));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(n,s[0],r[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,s[u],r[u]);this.setOutput(this.raggedRank,l,i,a)}return[a,i]}setOutput(t,n,r,s){if(r.length===0)return;const a=this.values,i=r;let o=s.slice();o=o.slice(t+1);const l=ve(o),u=n.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const f=this.defaultValueShape;ge(()=>{const m=ce(c,f);c=Ym(m,o).dataSync()})}let d=0,h=0,p=0;for(let f=0;f<=u;++f){let m=f<u?n[f]:-1;if(m===p){++p;continue}if(h<p){const g=a.subarray(d*l),y=i.subarray(h*l),b=(p-h)*l;uH(y,g,b)}if(f>=u){const g=r.length;m=Math.floor(g/l)}if(m>p)if(this.defaultValue.length===1)i.subarray(p*l,m*l).fill(this.defaultValue[0]),p=m;else for(;m>p;){const g=i.slice(p*l);uH(g,c,l),++p}m<0?(d=f+1,h=p):(d=f,h=p,p=h+1)}}}function uH(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function cH(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function Mse(e,t,n,r,s,a,i,o,l,u){return new YS(e,t,n,r,s,a,i,o,l,u).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lse(e,t,n,r){const s=e===t,a=e<t&&n<0,i=t<e&&n>1;if(s||a||i)return Ls(0,r);const o=Math.abs(Math.ceil((t-e)/n)),l=Ls(o,r);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pse=eu(e=>1/Math.sqrt(e)),Nit=Wd(V1,Pse),$it={kernelName:V1,backendName:"cpu",kernelFunc:Nit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vh(e,t,n,r,s,a,i,o,l,u){const c=[r/s,s],d=e.values,h=t.values;if(r===0)return Mt(n,t.dtype);const p=l instanceof Ur?l:Mt(c,t.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<a;f++){const m=[];let g=0;for(let y=0;y<i;y++){const b=d[f*i+y];m.push(b),g+=b*o[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let y=0;y<s;y++)u?p.values[g*s+y]+=h[f*s+y]:p.values[g*s+y]=t.rank===0?h[0]:h[f*s+y]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tit=eu(e=>1/(1+Math.exp(-e))),zse=xn(q1,e=>1/(1+Math.exp(-e))),_it={kernelName:q1,backendName:"cpu",kernelFunc:zse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bse(e,t,n,r,s){const a=Qz(r,t,n),i=ve(n),o=yt(r);if(a){const d=eB(t,o);return s==="string"?e.slice(d,d+i):e.subarray(d,d+i)}const l=s==="string"?zu(e):e,u=Mt(r,s,l),c=Mt(n,s);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),p=h.map((f,m)=>f+t[m]);c.set(u.get(...p),...h)}return s==="string"?Vte(c.values):c.values}function hp(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;ut(s,"slice");const[o,l]=Y$(s,a,i);Zz(s,o,l);const u=n.data.get(s.dataId).values,c=Bse(u,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,c)}const Eit={kernelName:b$,backendName:"cpu",kernelFunc:hp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wse(e,t,n,r,s,a,i){const o=t[0],l=a[0],u=new Array(l),c=new Array(o),d=t[1];if(l===0){if(o!==0)throw new Error(_te(o));const g=yr(n,0),y=yr(s,0);return[g,[0,d],y,u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<o;++g){const y=e[g*d];if(y<0)throw new Error(Ete(g,y));if(y>=l)throw new Error(Ate(g,y,l));++f[y],h=h&&y>=p,p=y}let m=!0;for(let g=0;g<l;++g){const y=f[g]===0;u[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const g=e,y=r;for(let b=0;b<o;++b)c[b]=b;return[g,[o,d],y,u,c]}else{const g=f[l-1],y=yr(n,g*d),b=yr(s,g),x=new Array(l).fill(0);for(let w=0;w<o;++w){const v=e[w*d],k=x[v],I=(v===0?0:f[v-1])+k;x[v]++;for(let S=0;S<d;++S)y[I*d+S]=e[w*d+S];b[I]=r[w],c[w]=I}for(let w=0;w<l;++w)if(x[w]===0){const k=w===0?0:f[w-1];y[k*d+0]=w;for(let I=1;I<d;++I)y[k*d+I]=0;b[k]=i}return[y,[g,d],b,u,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vse(e,t,n,r,s){const a=ve(r),i=t[0],o=s.length,l=[];let u=1,c=-1;for(let g=0;g<o;++g){const y=s[g];if(y===-1){if(c!==-1)throw new Error(Rte(c,g));c=g,l.push(1)}else{if(y<0)throw new Error(Dte(g,y));u*=y,l.push(y)}}if(c!==-1){if(u<=0)throw new Error(Fte());const g=Math.trunc(a/u);if(u*g!==a)throw new Error(Ote(r,l));l[c]=g}if(ve(l)!==a)throw new Error(Mte(r,l));const h=r.length,p=[];if(h>0){p[h-1]=1;for(let g=h-2;g>=0;--g)p[g]=p[g+1]*r[g+1]}const f=[];if(o>0){f[o-1]=1;for(let g=o-2;g>=0;--g)f[g]=f[g+1]*l[g+1]}const m=yr(n,i*o);for(let g=0;g<i;++g){let y=0;for(let b=0;b<h;++b)y+=e[g*h+b]*p[b];for(let b=0;b<o;++b)m[g*o+b]=Math.trunc(y/f[b]),y%=f[b]}return[m,[i,o],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KB(e,t,n,r,s,a=!1,i=0){const o=r.length,l=[t[0],e.length/t[0]],u=l[1],d=o>0?s[o-1]+1:0;if(d<0)throw new Error(zR());const h=t.slice();h[0]=d;const p=h.reduce((x,w)=>x*w,1),f=yr(n,p);if(o===0)return d>0&&f.fill(i),[f,h];if(d<=0)throw new Error(zR());let m=0,g=1,y=0,b=s[m];for(;;){let x=0;if(g<o){if(x=s[g],b===x){++g;continue}if(b>=x)throw new Error(Lte())}if(b<0||b>=d)throw new Error(Pte(b,d));b>y&&f.fill(i,y*u,b*u);for(let w=m;w<g;++w){const v=r[w];if(v<0||v>=l[0])throw new Error(zte(w,r[w],l[0]));for(let k=0;k<u;k++)f[b*u+k]+=e[v*u+k]}if(a)for(let w=0;w<u;w++)f[b*u+w]/=g-m;if(m=g,++g,y=b+1,b=x,g>o)break}return y<d&&f.fill(i,y*u,d*u),[f,h]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ait=eu(e=>Math.sqrt(e)),Rit=xn(X1,e=>Math.sqrt(e)),Dit={kernelName:X1,backendName:"cpu",kernelFunc:Rit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Use=Ar((e,t)=>{const n=e-t;return n*n}),Fit=hs(Y1,Use),Oit={kernelName:Y1,backendName:"cpu",kernelFunc:Fit};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gse=eu((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)}),Mit=Wd(I$,Gse),Lit={kernelName:I$,backendName:"cpu",kernelFunc:Mit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hse(e,t,n,r){const s=Mt(e,t.dtype);for(let a=0;a<s.size;a++){const i=s.indexToLoc(a),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+r[l];s.set(t.get(...o),...i)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pit{constructor(t,n,r,s,a,i){this.separator=Lc(t),this.nGramWidths=n,this.leftPad=Lc(r),this.rightPad=Lc(s),this.padWidth=a,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){const r=this.getPadWidth(n);return Math.max(0,t+2*r-n+1)}createNGrams(t,n,r,s,a,i){for(let o=0;o<a;++o){const l=this.getPadWidth(i),u=Math.max(0,l-o),c=Math.max(0,l-(a-(o+1))),d=i-(u+c),h=n+(u>0?0:o-l);let p=0;p+=u*this.leftPad.length;for(let b=0;b<d;++b)p+=t[h+b].length;p+=c*this.rightPad.length;const f=u+c+d-1;p+=f*this.separator.length,r[s+o]=new Uint8Array(p);const m=r[s+o];let g=0;const y=b=>b.forEach(x=>m[g++]=x);for(let b=0;b<u;++b)y(this.leftPad),y(this.separator);for(let b=0;b<d-1;++b)y(t[h+b]),y(this.separator);if(d>0){y(t[h+d-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,n){const r=t.length,s=n.length;if(s>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<s;++u){let c=n[u]>=l;if(c=c&&n[u]<=r,!c)throw new Error(`Invalid split value ${n[u]}, must be in [${l}, ${r}]`);l=n[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const a=s-1,i=yr("int32",s);if(r===0||s===0){const l=new Array(r);for(let u=0;u<=a;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=a;++l){const u=n[l]-n[l-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(u,d)}),this.preserveShort&&u>0&&c===0&&(c=1),i[l]=i[l-1]+c}const o=new Array(i[a]);for(let l=0;l<a;++l){const u=n[l];let c=i[l];if(this.nGramWidths.forEach(d=>{const h=n[l+1]-n[l],p=this.getNumNGrams(h,d);this.createNGrams(t,u,o,c,p,d),c+=p}),this.preserveShort&&c===i[l]){const d=n[l+1]-n[l];if(d===0)continue;const h=d+2*this.padWidth,p=1;this.createNGrams(t,u,o,c,p,h)}}return[o,i]}}function jse(e,t,n,r,s,a,i,o){return new Pit(n,r,s,a,i,o).compute(e,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zit(e,t,n,r){if(!e.length)return;if(t.length===0){for(let a=0;a<e.length;++a)r.push(e.subarray(a,a+1));return}if(t.length===1){const a=t[0];let i=e.indexOf(a);for(;i!==-1;){const o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(a)}(!n||e.length!==0)&&r.push(e);return}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||t.indexOf(e[a])!==-1){const i=e.subarray(s,a);(!n||i.length!==0)&&r.push(i),s=a+1}}function qse(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let h=0;h<r;++h){const p=s.length;zit(e[h],t,n,s);const f=s.length-p;o[h]=f,a+=f,i=Math.max(i,f)}const l=yr("int32",a*2),u=new Array(a),c=[r,i];let d=0;for(let h=0;h<r;++h)for(let p=0;p<o[h];++p)l[d*2]=h,l[d*2+1]=p,u[d]=s[d],++d;return[l,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kse(e,t){const n=yr("int32",e.length);for(let r=0;r<e.length;++r)n[r]=gKe(e[r]).modulo(t).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xse=Ar((e,t)=>e-t),Bit=GB((e,t,n,r)=>({real:e-n,imag:t-r})),XB=hs(Z1,Xse,Bit),Wit={kernelName:Z1,backendName:"cpu",kernelFunc:XB};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yse(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=Mt(n,e.dtype);for(let s=0;s<r.values.length;++s){const a=r.indexToLoc(s),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=a[l]%e.shape[l];const o=e.locToIndex(i);r.values[s]=e.values[o]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $x=(e,t)=>{const n=t.value-e.value;return n===0?e.index-t.index:n};function Zse(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const o=r-n+1,l=t-n+1,u=Math.log(o),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(o-c)/o)*Math.sign(l-o/2),h=Math.max(n,Math.floor(t-l*c/o+d)),p=Math.min(r,Math.floor(t+(o-l)*c/o+d));Zse(e,t,h,p)}const s=e[t];let a=n,i=r;for(ym(e,n,t),$x(e[r],s)>0&&ym(e,n,r);a<i;){for(ym(e,a,i),a++,i--;$x(e[a],s)<0;)a=a+1;for(;$x(e[i],s)>0;)i=i-1}$x(e[n],s)===0?ym(e,n,i):(i=i+1,ym(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function Jse(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],l=Is(n,i*r),u=Is("int32",i*r);for(let d=0;d<i;d++){const h=d*o,p=e.subarray(h,h+o);let f=new Array(p.length);p.forEach((b,x)=>f[x]={value:b,index:x}),r<f.length&&(Zse(f,r),f=f.slice(0,r)),s&&f.sort($x);const m=d*r,g=l.subarray(m,m+r),y=u.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=f[b].value,y[b]=f[b].index}const c=t.slice();return c[c.length-1]=r,[Mt(c,n,l),Mt(c,"int32",u)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qse(e,t,n,r){const s=Bt(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];const i=new Map,o=new Int32Array(n[s]),l=new Ur(a,r,e),u=[],c=a[0]===1&&a[2]===1;for(let f=0;f<n[s];f++){let m;if(c)m=e[f].toString();else{const y=[];for(let b=0;b<a[0];b++)for(let x=0;x<a[2];x++)y.push(l.get(b,f,x));m=y.join(",")}const g=i.get(m);if(g!=null)o[f]=g;else{const y=i.size;i.set(m,y),o[f]=y,u.push(f)}}const d=a.slice();d[1]=i.size;const h=new Ur(d,r);u.forEach((f,m)=>{for(let g=0;g<a[0];g++)for(let y=0;y<a[2];y++)h.set(l.get(g,f,y),g,m,y)});const p=n.slice();return p[s]=d[1],{outputValues:h.values,outputShape:p,indices:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vit=Object.freeze(Object.defineProperty({__proto__:null,addImpl:use,bincountImpl:HB,bincountReduceImpl:cse,castImpl:lse,ceilImpl:dse,concatImpl:hse,equalImpl:pse,expImpl:mse,expm1Impl:yse,floorDivImpl:xse,floorImpl:bse,gatherNdImpl:wse,gatherV2Impl:vse,greaterEqualImpl:Ise,greaterImpl:kse,lessEqualImpl:Cse,lessImpl:Sse,linSpaceImpl:Nse,logImpl:$se,maxImpl:Tse,maximumImpl:_se,minimumImpl:Ese,multiplyImpl:jB,negImpl:Ase,notEqualImpl:Rse,prodImpl:Dse,raggedGatherImpl:Fse,raggedRangeImpl:Ose,raggedTensorToTensorImpl:Mse,rangeImpl:Lse,rsqrtImpl:Pse,scatterImpl:vh,sigmoidImpl:Tit,simpleAbsImpl:ose,sliceImpl:Bse,sparseFillEmptyRowsImpl:Wse,sparseReshapeImpl:Vse,sparseSegmentReductionImpl:KB,sqrtImpl:Ait,squaredDifferenceImpl:Use,staticRegexReplaceImpl:Gse,stridedSliceImpl:Hse,stringNGramsImpl:jse,stringSplitImpl:qse,stringToHashBucketFastImpl:Kse,subImpl:Xse,tileImpl:Yse,topKImpl:Jse,transposeImpl:qB,uniqueImpl:Qse},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */GQ("cpu",()=>new cT,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eae=xn(w1,e=>e>=0?e:Math.exp(e)-1),Uit={kernelName:w1,backendName:"cpu",kernelFunc:eae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tae(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;ut([s],"leakyRelu");const i=ve(s.shape),o=n.data.get(s.dataId).values,l=Is("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?a*o[u]:o[u];return n.makeTensorInfo(s.shape,"float32",l)}const Git={kernelName:j2,backendName:"cpu",kernelFunc:tae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hit=Ar((e,t)=>e<0?t*e:e);function nae(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;ut([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=Hit(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}const jit={kernelName:d$,backendName:"cpu",kernelFunc:nae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rae=xn(z1,e=>Math.max(0,e)),qit={kernelName:z1,backendName:"cpu",kernelFunc:rae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sae=xn(B1,e=>Math.min(Math.max(0,e),6)),Kit={kernelName:B1,backendName:"cpu",kernelFunc:sae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZS(e,t,n,r,s){if(n==="linear")return ql({inputs:{x:t},backend:e});if(n==="relu")return rae({inputs:{x:t},backend:e});if(n==="elu")return eae({inputs:{x:t},backend:e});if(n==="relu6")return sae({inputs:{x:t},backend:e});if(n==="prelu")return nae({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return tae({inputs:{x:t},backend:e,attrs:{alpha:s}});if(n==="sigmoid")return zse({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pn(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=ve(s.shape),o=iQ(a,i),l=ve(o);U(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,d=u.complexTensorInfos.imag;c.shape=o,d.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const Xit={kernelName:p$,backendName:"cpu",kernelFunc:Pn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aae(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;ut([s,a],"matMul");const l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=o?a.shape[u-1]:a.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=ve(f),y=ve(m),x=Nt(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);U(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const w=i?[g,c,h]:[g,h,c],v=o?[y,p,d]:[y,d,p],k=Pn({inputs:{x:s},backend:n,attrs:{shape:w}}),I=Pn({inputs:{x:a},backend:n,attrs:{shape:v}}),S=i?k.shape[1]:k.shape[2],$=i?k.shape[2]:k.shape[1],N=o?I.shape[1]:I.shape[2],T=Math.max(g,y),C=n.data.get(k.dataId).values,E=n.data.get(I.dataId).values,M=yt(k.shape),F=yt(I.shape),[z,H,P]=i?[M[0],1,M[1]]:[M[0],M[1],1],[O,L,V]=o?[1,F[1],F[0]]:[F[1],1,F[0]],q=$*N,B=Mt([T,$,N],k.dtype),X=B.values,ee=n.blockSize;for(let Z=0;Z<T;Z++){const fe=Z%g,Q=Z%y;for(let be=0;be<$;be+=ee){const we=Math.min(be+ee,$);for(let Ne=0;Ne<N;Ne+=ee){const $e=Math.min(Ne+ee,N);for(let je=0;je<S;je+=ee){const He=Math.min(je+ee,S);for(let Re=be;Re<we;Re++)for(let Fe=Ne;Fe<$e;Fe++){let Pe=0;for(let Je=je;Je<He;Je++){const pn=C[fe*z+Re*H+Je*P],ct=E[Je*O+Fe*L+Q*V];Pe+=pn*ct}X[Z*q+(Re*N+Fe)]+=Pe}}}}}return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(I),n.makeTensorInfo(x,B.dtype,B.values)}const Yit={kernelName:A2,backendName:"cpu",kernelFunc:aae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zit(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=aae({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=Wg({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=ZS(n,h,c,o,d),m.push(h),h=f);for(const y of m)n.disposeIntermediateTensorInfo(y);return h}const Jit={kernelName:TS,backendName:"cpu",kernelFunc:Zit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qit=xn(o1,e=>Math.acos(e)),eot={kernelName:o1,backendName:"cpu",kernelFunc:Qit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tot=xn(l1,e=>Math.acosh(e)),not={kernelName:l1,backendName:"cpu",kernelFunc:tot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rot(e){const{inputs:t,backend:n}=e,r=t;ut(t,"addN");const s=r.map(o=>n.data.get(o.dataId).values),a=Mt(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){const l=s[o];for(let u=0;u<i.length;u++)i[u]+=l[u]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}const sot={kernelName:N2,backendName:"cpu",kernelFunc:rot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;ut(s,"all");const o=Bt(a,s.shape);let l=o;const u=lr(l,s.shape.length);let c=s;u!=null&&(c=Ea({inputs:{x:s},backend:n,attrs:{perm:u}}),l=wr(l.length,s.shape.length)),$s("all",l,c.shape.length);const[d,h]=ds(c.shape,l),p=ve(h),f=Ls(ve(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let x=m[b];for(let w=0;w<p;++w){const v=m[b+w];x=x&&v}f[y]=x}u!=null&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const y=br(d,o),b=Pn({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}const iot={kernelName:nP,backendName:"cpu",kernelFunc:aot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;ut(s,"any");const o=Bt(a,s.shape);let l=o;const u=lr(l,s.shape.length);let c=s;u!=null&&(c=Ea({inputs:{x:s},backend:n,attrs:{perm:u}}),l=wr(l.length,s.shape.length)),$s("any",l,c.shape.length);const[d,h]=ds(c.shape,l),p=ve(h),f=Ls(ve(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let x=m[b];for(let w=0;w<p;++w){const v=m[b+w];x=x||v}f[y]=x}u!=null&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const y=br(d,o),b=Pn({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}const lot={kernelName:rP,backendName:"cpu",kernelFunc:oot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;ut(s,"argMax");let i=Bt(a,s.shape);const o=lr(i,s.shape.length);let l=s;const u=[];o!=null&&(l=Ea({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=wr(i.length,l.shape.length)),i=[i[0]],$s("argMax",i,l.shape.length);const[c,d]=ds(l.shape,i),h=ve(c),p=Ls(h,"int32"),f=ve(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let b=m[y],x=0;for(let w=0;w<f;++w){const v=m[y+w];v>b&&(b=v,x=w)}p[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",p)}const cot={kernelName:$2,backendName:"cpu",kernelFunc:uot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;ut(s,"argMin");let i=Bt(a,s.shape);const o=lr(i,s.shape.length);let l=s;const u=[];o!=null&&(l=Ea({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=wr(i.length,l.shape.length)),i=[i[0]],$s("argMin",i,l.shape.length);const[c,d]=ds(l.shape,i),h=ve(c),p=Ls(h,"int32"),f=ve(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let b=m[y],x=0;for(let w=0;w<f;++w){const v=m[y+w];v<b&&(b=v,x=w)}p[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",p)}const hot={kernelName:T2,backendName:"cpu",kernelFunc:dot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pot=xn(u1,e=>Math.asin(e)),fot={kernelName:u1,backendName:"cpu",kernelFunc:pot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mot=xn(c1,e=>Math.asinh(e)),got={kernelName:c1,backendName:"cpu",kernelFunc:mot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yot=xn(d1,e=>Math.atan(e)),bot={kernelName:d1,backendName:"cpu",kernelFunc:yot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xot=Ar((e,t)=>Math.atan2(e,t)),wot=hs(p1,xot),vot={kernelName:p1,backendName:"cpu",kernelFunc:wot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kot=xn(h1,e=>Math.atanh(e)),Iot={kernelName:h1,backendName:"cpu",kernelFunc:kot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YB(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,f=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Mt(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let w=0;w<s.batchSize;++w){const v=w*y,k=w*r[0];for(let I=0;I<s.inChannels;++I)for(let S=0;S<s.outHeight;++S){const $=S*i-h,N=Math.max(0,$),T=Math.min(s.inHeight,c+$),C=v+S*b;for(let E=0;E<s.outWidth;++E){const M=E*o-p,F=Math.max(0,M),z=Math.min(s.inWidth,d+M);let H=f,P=0,O=0;for(let V=N;V<T;V+=l){const q=k+V*r[1];for(let B=F;B<z;B+=u){const X=q+B*r[2],ee=e[X+I];a==="max"&&ee>H?H=ee:a==="avg"&&(P+=ee,O++)}if(isNaN(H))break}const L=C+E*x+I;g[L]=a==="avg"?P/O:H}}}return m}function iae(e,t,n,r,s=!1,a=!1){const i=Mt(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Mt(t,n,e);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const x=b*o-p;let w=x;for(;w<0;)w+=u;const v=Math.min(r.inHeight,d+x);for(let k=0;k<r.outWidth;++k){const I=k*l-f;let S=I;for(;S<0;)S+=c;const $=Math.min(r.inWidth,h+I);let N=Number.NEGATIVE_INFINITY,T=-1;for(let C=w;C<v;C+=u){const E=C-x;for(let M=S;M<$;M+=c){const F=M-I,z=m.get(g,C,M,y);z>N&&(N=z,s?T=a?((g*r.inHeight+C)*r.inWidth+M)*r.inChannels+y:(C*r.inWidth+M)*r.inChannels+y:T=E*h+F)}}i.set(T,g,b,k,y)}}return i}function oae(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Mt(s.outShape,n),w=x.values,v=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],I=s.outShape[3]*s.outShape[4],S=s.outShape[4];for(let $=0;$<s.batchSize;++$){const N=$*v,T=$*r[0];for(let C=0;C<s.inChannels;++C)for(let E=0;E<s.outDepth;++E){const M=E*i-m;let F=M;for(;F<0;)F+=u;const z=Math.min(s.inDepth,h+M),H=N+E*k;for(let P=0;P<s.outHeight;++P){const O=P*o-g;let L=O;for(;L<0;)L+=c;const V=Math.min(s.inHeight,p+O),q=H+P*I;for(let B=0;B<s.outWidth;++B){const X=B*l-y;let ee=X;for(;ee<0;)ee+=d;const Z=Math.min(s.inWidth,f+X),fe=q+B*S;let Q=b,be=0,we=0;for(let $e=F;$e<z;$e+=u){const je=T+$e*r[1];for(let He=L;He<V;He+=c){const Re=je+He*r[2];for(let Fe=ee;Fe<Z;Fe+=d){const Pe=Re+Fe*r[3],Je=e[Pe+C];if(a==="max"&&Je>Q?Q=Je:a==="avg"&&(be+=Je,we++),isNaN(Q))break}if(isNaN(Q))break}if(isNaN(Q))break}const Ne=fe+C;w[Ne]=a==="avg"?be/Math.max(we,1):Q}}}}return x}function Sot(e,t){const n=Mt(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-h;let x=b;for(;x<0;)x+=i;const w=Math.min(t.inDepth,u+b);for(let v=0;v<t.outHeight;++v){const k=v*s-p;let I=k;for(;I<0;)I+=o;const S=Math.min(t.inHeight,c+k);for(let $=0;$<t.outWidth;++$){const N=$*a-f;let T=N;for(;T<0;)T+=l;const C=Math.min(t.inWidth,d+N);let E=Number.NEGATIVE_INFINITY,M=-1;for(let F=x;F<w;F+=i){const z=F-b;for(let H=I;H<S;H+=o){const P=H-k;for(let O=T;O<C;O+=l){const L=O-N,V=e.get(m,F,H,O,g);V>=E&&(E=V,M=z*c*d+P*c+L)}}}n.set(M,m,y,v,$,g)}}}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;ut(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;U(Ns(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Co(s.shape,a,i,u,o,l);let d;if(c.filterWidth===1&&c.filterHeight===1&&Xt(c.inShape,c.outShape))d=ql({inputs:{x:s},backend:n});else{const h=n.data.get(s.dataId).values,p=yt(s.shape),f=YB(h,s.shape,s.dtype,p,c,"avg");d=n.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}const Not={kernelName:_2,backendName:"cpu",kernelFunc:Cot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;ut(s,"avgPool3d");const c=qu(s.shape,a,i,1,o,l,u),d=n.data.get(s.dataId).values,h=oae(d,s.shape,s.dtype,yt(s.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}const Tot={kernelName:E2,backendName:"cpu",kernelFunc:$ot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ot(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;ut([s,a],"avgPool3DGrad");const c=qu(a.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,x=c.dilationWidth,w=c.effectiveFilterDepth,v=c.effectiveFilterHeight,k=c.effectiveFilterWidth,I=w-1-c.padInfo.front,S=k-1-c.padInfo.left,$=v-1-c.padInfo.top,N=Mt(a.shape,"float32"),T=1/(f*m*g),C=n.bufferSync(s);for(let E=0;E<c.batchSize;++E)for(let M=0;M<c.inChannels;++M)for(let F=0;F<c.inDepth;++F)for(let z=0;z<c.inHeight;++z)for(let H=0;H<c.inWidth;++H){const P=F-I,O=z-$,L=H-S;let V=0;for(let q=0;q<w;q+=y){const B=(P+q)/d;if(!(B<0||B>=c.outDepth||Math.floor(B)!==B))for(let X=0;X<v;X+=b){const ee=(O+X)/h;if(!(ee<0||ee>=c.outHeight||Math.floor(ee)!==ee))for(let Z=0;Z<k;Z+=x){const fe=(L+Z)/p;if(fe<0||fe>=c.outWidth||Math.floor(fe)!==fe)continue;const Q=C.get(E,B,ee,fe,M);V+=Q}}}N.set(V*T,E,F,z,H,M)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}const Eot={kernelName:aP,backendName:"cpu",kernelFunc:_ot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aot(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;ut([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=Co(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,x=b-1-c.padInfo.left,w=y-1-c.padInfo.top,v=Mt(i.shape,"float32"),k=1/(p*f),I=n.data.get(s.dataId).values,S=Mt(s.shape,"float32",I);for(let $=0;$<c.batchSize;++$)for(let N=0;N<c.inChannels;++N)for(let T=0;T<c.inHeight;++T)for(let C=0;C<c.inWidth;++C){const E=T-w,M=C-x;let F=0;for(let z=0;z<y;z+=m){const H=(E+z)/d;if(!(H<0||H>=c.outHeight||Math.floor(H)!==H))for(let P=0;P<b;P+=g){const O=(M+P)/h;if(O<0||O>=c.outWidth||Math.floor(O)!==O)continue;const L=S.get($,H,O,N);F+=L}}v.set(F*k,$,T,C,N)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const Rot={kernelName:sP,backendName:"cpu",kernelFunc:Aot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;U(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ut([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);const c=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,x=d.length;let w=0,v=0,k=0,I=0;for(let S=0;S<c.length;++S)m[S]=f[w++]+(c[S]-d[v++])*p[k++]/Math.sqrt(h[I++]+u),w>=g&&(w=0),v>=x&&(v=0),k>=y&&(k=0),I>=b&&(I=0);return n.makeTensorInfo(s.shape,s.dtype,m)}const Fot={kernelName:U2,backendName:"cpu",kernelFunc:Dot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;ut([s],"batchToSpaceND");const o=a.reduce((y,b)=>y*b),l=cv(s.shape,a,o),u=dv(l.length,a.length),c=hv(s.shape,a,o),d=aB(i,a.length),h=iB(c,i,a.length),p=Pn({inputs:{x:s},backend:n,attrs:{shape:l}}),f=Ea({inputs:{x:p},backend:n,attrs:{perm:u}}),m=Pn({inputs:{x:f},backend:n,attrs:{shape:c}}),g=hp({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const Mot={kernelName:R2,backendName:"cpu",kernelFunc:Oot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=HB(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}const Pot={kernelName:iP,backendName:"cpu",kernelFunc:Lot};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zot(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=Nt(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Bot={kernelName:oP,backendName:"cpu",kernelFunc:zot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wot=xn(g1,(e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),Vot={kernelName:g1,backendName:"cpu",kernelFunc:Wot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uot=e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(ve(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const c=o[u],d=l[u];r[u]=Math.hypot(c,d)}return n.makeOutput(r,t.shape,"float32")},Got={kernelName:D2,backendName:"cpu",kernelFunc:Uot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vg(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const Hot={kernelName:NP,backendName:"cpu",kernelFunc:Vg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ug(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Bt(s,t[0].shape)[0],i=t.map(m=>m.shape);nB(i,a);let o=Bl(t.map(m=>m.shape),a);if(ve(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter(m=>ve(m.shape)>0);if(l.length===1)return ql({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){const m=l.map(w=>dp({inputs:{input:w},backend:n})),g=l.map(w=>Vg({inputs:{input:w},backend:n})),y=Ug({inputs:m,backend:n,attrs:{axis:a}}),b=Ug({inputs:g,backend:n,attrs:{axis:a}}),x=Va({inputs:{real:y,imag:b},backend:n});return m.forEach(w=>n.disposeIntermediateTensorInfo(w)),g.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),x}const u=l.map(m=>{const y=[-1,ve(m.shape.slice(a))];return Pn({inputs:{x:m},backend:n,attrs:{shape:y}})}),c=u.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=Bl(u.map(m=>m.shape),1);const d=u[0].shape[0]===1,h=hse(c,o,t[0].dtype,d),p=Bl(l.map(m=>m.shape),a),f=n.makeTensorInfo(p,t[0].dtype,h);return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const jot={kernelName:F2,backendName:"cpu",kernelFunc:Ug};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lae(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;ut([s,a],"conv2d");const d=Ku(l),h=cs(s.shape,a.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,x=h.dataFormat==="channelsLast",w=new Ur(h.outShape,s.dtype),v=yt(s.shape),k=yt(a.shape),I=v[0],S=x?v[1]:v[2],$=x?v[2]:1,N=x?1:v[1],T=w.strides[0],C=x?w.strides[1]:w.strides[2],E=x?w.strides[2]:1,M=x?1:w.strides[1],F=n.data.get(s.dataId).values,z=n.data.get(a.dataId).values,H=w.values;for(let P=0;P<h.batchSize;++P){const O=P*I,L=P*T;for(let V=0;V<h.outHeight;++V){const q=L+V*C,B=V*h.strideHeight-b;for(let X=0;X<p;++X){const ee=B+X*m;if(ee<0||ee>=h.inHeight)continue;const Z=X*k[0],fe=O+ee*S;for(let Q=0;Q<h.outWidth;++Q){const be=q+Q*E,we=Q*h.strideWidth-y;for(let Ne=0;Ne<f;++Ne){const $e=we+Ne*g;if($e<0||$e>=h.inWidth)continue;const je=Z+Ne*k[1],He=fe+$e*$;let Re=je;for(let Fe=0;Fe<h.inChannels;++Fe){const Pe=F[He+Fe*N];for(let Je=0;Je<h.outChannels;++Je)H[be+Je*M]+=Pe*z[Re+Je];Re+=h.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,H)}const qot={kernelName:O2,backendName:"cpu",kernelFunc:lae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;ut([s,a],"conv2dBackpropFilter");const d=Ku(l),h=cs(s.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y=h.dataFormat==="channelsLast",b=new Ur(h.filterShape,"float32"),x=h.padInfo.left,w=h.padInfo.top,v=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,I=new Ur(s.shape,s.dtype,v),S=new Ur(a.shape,a.dtype,k);for(let $=0;$<m;++$){const N=Math.max(0,Math.ceil((w-$)/p)),T=Math.min(h.outHeight,(h.inHeight+w-$)/p);for(let C=0;C<g;++C){const E=Math.max(0,Math.ceil((x-C)/f)),M=Math.min(h.outWidth,(h.inWidth+x-C)/f);for(let F=0;F<h.inChannels;++F)for(let z=0;z<h.outChannels;++z){let H=0;for(let P=0;P<h.batchSize;++P)for(let O=N;O<T;++O){const L=$+O*p-w;for(let V=E;V<M;++V){const q=C+V*f-x;y?H+=I.get(P,L,q,F)*S.get(P,O,V,z):H+=I.get(P,F,L,q)*S.get(P,z,O,V)}}b.set(H,$,C,F,z)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const Xot={kernelName:uP,backendName:"cpu",kernelFunc:Kot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yot(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;ut([s,a],"conv2dBackpropInput");const d=yt(a.shape),h=yt(s.shape);let p=Ku(u);const f=cs(i,a.shape,o,1,l,c,!1,p),m=new Ur(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[x,w,v]=d,{batchSize:k,filterHeight:I,filterWidth:S,inChannels:$,inHeight:N,inWidth:T,outChannels:C,outHeight:E,outWidth:M,strideHeight:F,strideWidth:z}=f;p=f.dataFormat;const H=I-1-f.padInfo.top,P=S-1-f.padInfo.left,O=p==="channelsLast",L=m.strides[0],V=O?m.strides[1]:m.strides[2],q=O?m.strides[2]:1,B=O?1:m.strides[1],X=h[0],ee=O?h[1]:h[2],Z=O?h[2]:1,fe=O?1:h[1];for(let Q=0;Q<k;++Q)for(let be=0;be<$;++be)for(let we=0;we<N;++we){const Ne=we-H,$e=Math.max(0,Math.ceil(Ne/F)),je=Math.min(E,(I+Ne)/F);for(let He=0;He<T;++He){const Re=He-P,Fe=Math.max(0,Math.ceil(Re/z)),Pe=Math.min(M,(S+Re)/z);let Je=0;for(let ct=$e;ct<je;++ct){const an=ct*F-Ne;for(let Lt=Fe;Lt<Pe;++Lt){const Gt=Lt*z-Re,Qe=X*Q+ee*ct+Z*Lt,It=x*(I-1-an)+w*(S-1-Gt)+v*be;for(let mn=0;mn<C;++mn){const en=y[Qe+fe*mn],on=b[It+mn];Je+=en*on}}}const pn=L*Q+V*we+q*He+B*be;g[pn]=Je}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const Zot={kernelName:M2,backendName:"cpu",kernelFunc:Yot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;ut([s,a],"conv3d");const u=Od(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,x=g.top,w=new Ur(u.outShape,s.dtype),v=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,I=w.values,S=yt(s.shape),$=yt(a.shape);for(let N=0;N<u.batchSize;++N){const T=N*S[0],C=N*w.strides[0];for(let E=0;E<u.outDepth;++E){const M=C+E*w.strides[1],F=E*u.strideDepth-y;for(let z=0;z<c;++z){const H=F+z*p;if(H<0||H>=u.inDepth)continue;const P=z*$[0],O=T+H*S[1];for(let L=0;L<u.outHeight;++L){const V=M+L*w.strides[2],q=L*u.strideHeight-x;for(let B=0;B<d;++B){const X=q+B*f;if(X<0||X>=u.inHeight)continue;const ee=P+B*$[1],Z=O+X*S[2];for(let fe=0;fe<u.outWidth;++fe){const Q=V+fe*u.outChannels,be=fe*u.strideWidth-b;for(let we=0;we<h;++we){const Ne=be+we*m;if(Ne<0||Ne>=u.inWidth)continue;const $e=ee+we*$[2],je=Z+Ne*u.inChannels;let He=$e;for(let Re=0;Re<u.inChannels;++Re){const Fe=v[je+Re];for(let Pe=0;Pe<u.outChannels;++Pe)I[Q+Pe]+=Fe*k[He+Pe];He+=u.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const Qot={kernelName:L2,backendName:"cpu",kernelFunc:Jot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function elt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;ut([s,a],"conv3dBackpropFilterV2");const u=yt(s.shape),c=yt(a.shape),d=Od(s.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new Ur(d.filterShape,"float32"),x=b.values,[w,v,k,I]=b.strides,S=n.data.get(a.dataId).values,[$,N,T,C]=c,E=n.data.get(s.dataId).values,[M,F,z,H]=u,P=d.padInfo.front,O=d.padInfo.left,L=d.padInfo.top;for(let V=0;V<m;++V){const q=Math.max(0,Math.ceil((P-V)/h)),B=Math.min(d.outDepth,(d.inDepth+P-V)/h),X=V*w;for(let ee=0;ee<g;++ee){const Z=Math.max(0,Math.ceil((L-ee)/p)),fe=Math.min(d.outHeight,(d.inHeight+L-ee)/p),Q=ee*v+X;for(let be=0;be<y;++be){const we=Math.max(0,Math.ceil((O-be)/f)),Ne=Math.min(d.outWidth,(d.inWidth+O-be)/f),$e=be*k+Q;for(let je=0;je<d.inChannels;++je){const He=je*I+$e;for(let Re=0;Re<d.outChannels;++Re){let Fe=0;for(let Pe=0;Pe<d.batchSize;++Pe){const Je=Pe*M,pn=Pe*$;for(let ct=q;ct<B;++ct){const Lt=(V+ct*h-P)*F+Je,Gt=ct*N+pn;for(let Qe=Z;Qe<fe;++Qe){const mn=(ee+Qe*p-L)*z+Lt,en=Qe*T+Gt;for(let on=we;on<Ne;++on){const Bi=(be+on*f-O)*H+mn,ha=on*C+en;Fe+=E[Bi+je]*S[ha+Re]}}}}x[He+Re]=Fe}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const tlt={kernelName:cP,backendName:"cpu",kernelFunc:elt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nlt(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;ut([s],"conv3dBackpropInputV2");const u=yt(s.shape),c=yt(a.shape),d=Od(l,a.shape,o,1,i),h=new Ur(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(s.dataId).values,[x,w,v,k]=u,I=n.data.get(a.dataId).values,[S,$,N,T]=c,{batchSize:C,filterDepth:E,filterHeight:M,filterWidth:F,inChannels:z,inDepth:H,inHeight:P,inWidth:O,outChannels:L,outDepth:V,outHeight:q,outWidth:B,strideDepth:X,strideHeight:ee,strideWidth:Z}=d,fe=E-1-d.padInfo.front,Q=M-1-d.padInfo.top,be=F-1-d.padInfo.left;for(let we=0;we<C;++we)for(let Ne=0;Ne<z;++Ne)for(let $e=0;$e<H;++$e){const je=$e-fe,He=Math.max(0,Math.ceil(je/X)),Re=Math.min(V,(E+je)/X);for(let Fe=0;Fe<P;++Fe){const Pe=Fe-Q,Je=Math.max(0,Math.ceil(Pe/ee)),pn=Math.min(q,(M+Pe)/ee);for(let ct=0;ct<O;++ct){const an=ct-be,Lt=Math.max(0,Math.ceil(an/Z)),Gt=Math.min(B,(F+an)/Z);let Qe=0;for(let It=He;It<Re;++It){const mn=It*X-je;for(let en=Je;en<pn;++en){const on=en*ee-Pe;for(let Ws=Lt;Ws<Gt;++Ws){const Bi=Ws*Z-an,ha=x*we+w*It+v*en+k*Ws,tu=S*(E-1-mn)+$*(M-1-on)+N*(F-1-Bi)+T*Ne;for(let Es=0;Es<L;++Es){const To=b[ha+Es],De=I[tu+Es];Qe+=To*De}}}}p[f*we+m*$e+g*Fe+y*ct+Ne]=Qe}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}const rlt={kernelName:dP,backendName:"cpu",kernelFunc:nlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const slt=xn(y1,e=>Math.cos(e)),alt={kernelName:y1,backendName:"cpu",kernelFunc:slt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ilt=xn(b1,e=>Math.cosh(e)),olt={kernelName:b1,backendName:"cpu",kernelFunc:ilt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function llt(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=s.shape,f=a.shape[0],[m,g]=o,y=Mt([f,m,g,p],"float32"),b=n.data.get(a.dataId).values,x=n.data.get(i.dataId).values,w=n.data.get(s.dataId).values,v=yt(s.shape),k=yt(y.shape);for(let I=0;I<f;I++){const S=I*4,$=b[S],N=b[S+1],T=b[S+2],C=b[S+3],E=x[I];if(E>=c)continue;const M=m>1?(T-$)*(d-1)/(m-1):0,F=g>1?(C-N)*(h-1)/(g-1):0;for(let z=0;z<m;z++){const H=m>1?$*(d-1)+z*M:.5*($+T)*(d-1);if(H<0||H>d-1){for(let P=0;P<g;P++)for(let O=0;O<p;O++){const L=O+P*k[2]+z*k[1]+I*k[0];y.values[L]=u}continue}if(l==="bilinear"){const P=Math.floor(H),O=Math.ceil(H),L=H-P;for(let V=0;V<g;V++){const q=g>1?N*(h-1)+V*F:.5*(N+C)*(h-1);if(q<0||q>h-1){for(let Z=0;Z<p;Z++){const fe=Z+V*k[2]+z*k[1]+I*k[0];y.values[fe]=u}continue}const B=Math.floor(q),X=Math.ceil(q),ee=q-B;for(let Z=0;Z<p;Z++){let fe=Z+B*v[2]+P*v[1]+E*v[0];const Q=w[fe];fe=Z+X*v[2]+P*v[1]+E*v[0];const be=w[fe];fe=Z+B*v[2]+O*v[1]+E*v[0];const we=w[fe];fe=Z+X*v[2]+O*v[1]+E*v[0];const Ne=w[fe],$e=Q+(be-Q)*ee,je=we+(Ne-we)*ee;fe=Z+V*k[2]+z*k[1]+I*k[0],y.values[fe]=$e+(je-$e)*L}}}else for(let P=0;P<g;++P){const O=g>1?N*(h-1)+P*F:.5*(N+C)*(h-1);if(O<0||O>h-1){for(let q=0;q<p;q++){const B=q+P*k[2]+z*k[1]+I*k[0];y.values[B]=u}continue}const L=Math.round(O),V=Math.round(H);for(let q=0;q<p;q++){const B=q+L*v[2]+V*v[1]+E*v[0],X=q+P*k[2]+z*k[1]+I*k[0];y.values[X]=w[B]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const ult={kernelName:pP,backendName:"cpu",kernelFunc:llt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function clt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;ut(s,"cumprod");const l=lr([a],s.shape.length);let u=s;l!=null&&(u=Ea({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=wr(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=ni(u.dtype,"int32"),h=eP(ve(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const x=m(y,b);if(b===0)h[x]=i?1:p[x];else{const w=m(y,b-1);h[x]=i?p[w]*h[w]:p[x]*h[w]}}const g=n.makeTensorInfo(u.shape,d,h);if(l!=null){const y=Md(l),b=Ea({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),b}return g}const dlt={kernelName:hP,backendName:"cpu",kernelFunc:clt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hlt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;ut(s,"cumsum");const l=lr([a],s.shape.length);let u=s;l!=null&&(u=Ea({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=wr(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=ni(u.dtype,"int32"),h=Ls(ve(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const x=m(y,b);if(b===0)h[x]=i?0:p[x];else{const w=m(y,b-1);h[x]=i?p[w]+h[w]:p[x]+h[w]}}const g=n.makeTensorInfo(u.shape,d,h);if(l!=null){const y=Md(l),b=Ea({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),b}return g}const plt={kernelName:P2,backendName:"cpu",kernelFunc:hlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function flt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){const l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=HB(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){const l=n.bufferSync(s),u=n.bufferSync(a),c=cse(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const mlt={kernelName:fP,backendName:"cpu",kernelFunc:flt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function glt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;U(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*a,h=u*a,p=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*d*h*p);let g=0;for(let y=0;y<o;++y)for(let b=0;b<d;++b){const x=Math.floor(b/a),w=b%a;for(let v=0;v<h;++v){const k=Math.floor(v/a),I=v%a,S=(w*a+I)*p;for(let $=0;$<p;++$){const T=$+S+c*(k+u*(x+l*y));m[g++]=f[T]}}}return n.makeTensorInfo([o,d,h,p],s.dtype,m)}const ylt={kernelName:mP,backendName:"cpu",kernelFunc:glt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uae(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;ut([s,a],"depthwiseConv2DNative");const c=yt(s.shape),d=yt(a.shape);let h=l;h==null&&(h=[1,1]),U(Ns(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const p=cs(s.shape,a.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,x=b.left,w=b.top,v=p.outChannels/p.inChannels,k=new Ur(p.outShape,s.dtype),I=n.data.get(s.dataId).values,S=n.data.get(a.dataId).values,$=k.values;for(let N=0;N<p.batchSize;++N){const T=N*c[0],C=N*k.strides[0];for(let E=0;E<p.outHeight;++E){const M=C+E*k.strides[1],F=E*p.strideHeight-w;for(let z=0;z<f;++z){const H=F+z*g;if(H<0||H>=p.inHeight)continue;const P=z*d[0],O=T+H*c[1];for(let L=0;L<p.outWidth;++L){const V=M+L*k.strides[2],q=L*p.strideWidth-x;for(let B=0;B<m;++B){const X=q+B*y;if(X<0||X>=p.inWidth)continue;const ee=P+B*d[1],Z=O+X*p.inChannels;let fe=V,Q=ee;for(let be=0;be<p.inChannels;++be){const we=I[Z+be];for(let Ne=0;Ne<v;++Ne)$[fe+Ne]+=we*S[Q+Ne];fe+=v,Q+=v}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const blt={kernelName:z2,backendName:"cpu",kernelFunc:uae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xlt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;ut([s,a],"depthwiseConv2dNativeBackpropFilter");const d=cs(s.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new Ur(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,x=d.outChannels/d.inChannels,w=n.data.get(s.dataId).values,v=new Ur(s.shape,s.dtype,w),k=n.data.get(a.dataId).values,I=new Ur(a.shape,a.dtype,k);for(let S=0;S<f;++S){const $=Math.max(0,Math.ceil((b-S)/h)),N=Math.min(d.outHeight,(d.inHeight+b-S)/h);for(let T=0;T<m;++T){const C=Math.max(0,Math.ceil((y-T)/p)),E=Math.min(d.outWidth,(d.inWidth+y-T)/p);for(let M=0;M<d.outChannels;++M){const F=Math.trunc(M/x),z=M%x;let H=0;for(let P=0;P<d.batchSize;++P)for(let O=$;O<N;++O){const L=S+O*h-b;for(let V=C;V<E;++V){const q=T+V*p-y;H+=v.get(P,L,q,F)*I.get(P,O,V,M)}}g.set(H,S,T,F,z)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const wlt={kernelName:gP,backendName:"cpu",kernelFunc:xlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vlt(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;ut([s,a],"depthwiseConv2DNativeBackpropInput");const d=yt(s.shape),h=yt(a.shape),p=cs(c,a.shape,i,o,l,u,!0),f=new Ur(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(s.dataId).values,[w,v,k]=d,I=n.data.get(a.dataId).values,[S,$,N]=h,{batchSize:T,filterHeight:C,filterWidth:E,inChannels:M,inHeight:F,inWidth:z,outChannels:H,outHeight:P,outWidth:O,strideHeight:L,strideWidth:V}=p,q=C-1-p.padInfo.top,B=E-1-p.padInfo.left,X=H/M;for(let ee=0;ee<T;++ee)for(let Z=0;Z<M;++Z)for(let fe=0;fe<F;++fe){const Q=fe-q,be=Math.max(0,Math.ceil(Q/L)),we=Math.min(P,(C+Q)/L);for(let Ne=0;Ne<z;++Ne){const $e=Ne-B,je=Math.max(0,Math.ceil($e/V)),He=Math.min(O,(E+$e)/V);let Re=0;for(let Fe=be;Fe<we;++Fe){const Pe=Fe*L-Q;for(let Je=je;Je<He;++Je){const pn=Je*V-$e,ct=w*ee+v*Fe+k*Je,an=S*(C-1-Pe)+$*(E-1-pn)+N*Z;for(let Lt=0;Lt<X;++Lt){const Gt=Z*X+Lt,Qe=x[ct+Gt],It=I[an+Lt];Re+=Qe*It}}}m[g*ee+y*fe+b*Ne+Z]=Re}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}const klt={kernelName:yP,backendName:"cpu",kernelFunc:vlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ilt(e){const{inputs:t,backend:n}=e,{x:r}=t,s=ve(r.shape),a=n.data.get(r.dataId).values,i=Mt([s,s],r.dtype),o=i.values;for(let u=0;u<a.length;u++)o[u*s+u]=a[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}const Slt={kernelName:bP,backendName:"cpu",kernelFunc:Ilt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Clt={kernelName:B2,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:w,strideWidth:v,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:$,outShape:N}=rv(r.shape,s.shape,a,i,"NHWC",o),T=ve(N),C=N.length,E=yr(r.dtype,T);for(let F=0;F<p;++F)for(let z=0;z<y;++z){const H=z*w-x.top;for(let P=0;P<b;++P){const O=P*v-x.left;for(let L=0;L<g;++L){let V=Number.MIN_SAFE_INTEGER;for(let B=0;B<k;++B){const X=H+B*S;if(X>=0&&X<f)for(let ee=0;ee<I;++ee){const Z=O+ee*$;if(Z>=0&&Z<m){const fe=Pl([F,X,Z,L],c,yt(r.shape)),Q=Pl([B,ee,L],h,yt(s.shape)),be=u[fe]+d[Q];be>V&&(V=be)}}}const q=Pl([F,z,P,L],C,yt(N));E[q]=V}}}return{dataId:l.write(Hf(E,r.dtype),N,r.dtype),shape:N,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nlt={kernelName:cR,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=po(r.shape,u.data.get(r.dataId).values),d=po(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:$}=rv(r.shape,s.shape,i,o,"NHWC",l);U(a.rank===$.length,()=>`Error in ${cR}, dy must have the same rank as output ${$.length}, but got ${a.rank}`);const N=po($,u.data.get(a.dataId).values),T=uQ(s.shape,s.dtype);for(let E=0;E<h;++E)for(let M=0;M<g;++M){const F=M*x-b.top;for(let z=0;z<y;++z){const H=z*w-b.left;for(let P=0;P<m;++P){let O=Number.MIN_SAFE_INTEGER,L=0,V=0;for(let q=0;q<v;++q){const B=F+q*I;if(B>=0&&B<p)for(let X=0;X<k;++X){const ee=H+X*S;if(ee>=0&&ee<f){const Z=c[E][B][ee][P]+d[q][X][P];Z>O&&(O=Z,L=q,V=X)}}}T[L][V][P]+=N[E][M][z][P]}}}return{dataId:u.write(Hf(T,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $lt={kernelName:uR,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=po(r.shape,u.data.get(r.dataId).values),d=po(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:$}=rv(r.shape,s.shape,i,o,"NHWC",l);U(a.rank===$.length,()=>`Error in ${uR}, dy must have the same rank as output ${$.length}, but got ${a.rank}`);const N=po($,u.data.get(a.dataId).values),T=uQ(r.shape,r.dtype);for(let E=0;E<h;++E)for(let M=0;M<g;++M){const F=M*x-b.top;for(let z=0;z<y;++z){const H=z*w-b.left;for(let P=0;P<m;++P){let O=Number.MIN_SAFE_INTEGER,L=F<0?0:F,V=H<0?0:H;for(let q=0;q<v;++q){const B=F+q*I;if(B>=0&&B<p)for(let X=0;X<k;++X){const ee=H+X*S;if(ee>=0&&ee<f){const Z=c[E][B][ee][P]+d[q][X][P];Z>O&&(O=Z,L=B,V=ee)}}}T[E][L][V][P]+=N[E][M][z][P]}}}return{dataId:u.write(Hf(T,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vv(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;ut(s,"sum");let o;s.dtype==="bool"?o=cd({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):o=ql({inputs:{x:s},backend:n});const l=o.shape.length,u=Bt(a,o.shape),c=lr(u,l);let d=u,h=o;c!=null&&(h=Ea({inputs:{x:o},backend:n,attrs:{perm:c}}),d=wr(d.length,l)),$s("sum",d,h.shape.length);const[p,f]=ds(h.shape,d),m=ni(h.dtype,"int32");let g=XS(n,p,m);const y=ve(f),b=n.data.get(g.dataId).values,x=n.data.get(h.dataId).values;for(let w=0;w<b.length;++w){const v=w*y;let k=0;for(let I=0;I<y;++I)k+=x[v+I];b[w]=k}if(i){const w=br(g.shape,u),v=g;g=Pn({inputs:{x:g},backend:n,attrs:{shape:w}}),n.disposeIntermediateTensorInfo(v)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(h),g}const Tlt={kernelName:x$,backendName:"cpu",kernelFunc:vv};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _lt(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=fB(s,a.length);gB(i.length,l,a);const{path:u,steps:c}=yB(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:b}=mB(p,l[g]);let x;bB(y)?x=a[g]:(x=Ea({inputs:{x:a[g]},backend:n,attrs:{perm:y}}),f.push(x));const w=x.shape.slice();for(let v=0;v<b.length;++v)w.splice(b[v],0,1);Xt(x.shape,w)||(x=Pn({inputs:{x},backend:n,attrs:{shape:w}}),f.push(x)),h===null?h=x:(h=dT({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=vv({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}const Elt={kernelName:xP,backendName:"cpu",kernelFunc:_lt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Alt(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;ut([r,s],"eluGrad");const a=new Float32Array(ve(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];u>=0?a[l]=o[l]:a[l]=o[l]*(u+1)}return n.makeTensorInfo(s.shape,"float32",a)}const Rlt={kernelName:wP,backendName:"cpu",kernelFunc:Alt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dlt=oB,Flt=lB,Olt=uB,Mlt=cB,Llt=dB,Plt=hB,zlt=xn(v1,e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+Dlt*n);return t*(1-((((Plt*r+Llt)*r+Mlt)*r+Olt)*r+Flt)*r*Math.exp(-n*n))}),Blt={kernelName:v1,backendName:"cpu",kernelFunc:zlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JS(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(U(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),Pn({inputs:{x:s},backend:n,attrs:{shape:o}})}const Wlt={kernelName:V2,backendName:"cpu",kernelFunc:JS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vlt=Ar((e,t)=>e/t),ZB=hs(x1,Vlt),oD={kernelName:x1,backendName:"cpu",kernelFunc:ZB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cae(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=ve(u),d=Is("float32",c),h=Is("float32",c);for(let g=0;g<s;g++){const y=hp({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),b=hp({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,a]}}),x=Va({inputs:{real:y,imag:b},backend:n}),{real:w,imag:v}=Ult(x,t,n),k=Pu(w,v);for(let I=0;I<a;I++){const S=pB(k,I);d[g*a+I]=S.real,h[g*a+I]=S.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x)}const p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=Va({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function Ult(e,t,n){const r=ve(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(Glt(r)){const o=lD(a,i,r,t,n),l=[e.shape[0],e.shape[1]];if(t){const u=n.makeTensorInfo(l,"float32",o.real),c=n.makeTensorInfo(l,"float32",o.imag),d=n.makeTensorInfo([],"float32",Rd(r,"float32")),h=ql({inputs:{x:d},backend:n}),p=oD.kernelFunc({inputs:{a:u,b:d},backend:n}),f=oD.kernelFunc({inputs:{a:c,b:h},backend:n}),m=n.data.get(p.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return o}else{const o=Pu(a,i),l=Hlt(o,r,t);return Ite(l)}}function Glt(e){return(e&e-1)===0}function lD(e,t,n,r,s){if(n===1)return{real:e,imag:t};const a=Pu(e,t),i=n/2,o=Ste(a),l=o.real,u=o.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),p=Va({inputs:{real:d,imag:h},backend:s}),f=Cte(a),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),x=s.makeTensorInfo(y,"float32",g),w=Va({inputs:{real:b,imag:x},backend:s}),v=lD(l,u,i,r,s),k=v.real,I=v.imag,S=[k.length],$=s.makeTensorInfo(S,"float32",k),N=s.makeTensorInfo(S,"float32",I),T=Va({inputs:{real:$,imag:N},backend:s}),C=lD(m,g,i,r,s),E=C.real,M=C.imag,F=[E.length],z=s.makeTensorInfo(F,"float32",E),H=s.makeTensorInfo(F,"float32",M),P=Va({inputs:{real:z,imag:H},backend:s}),O=$te(n,r),L=[O.real.length],V=s.makeTensorInfo(L,"float32",O.real),q=s.makeTensorInfo(L,"float32",O.imag),B=Va({inputs:{real:V,imag:q},backend:s}),X=dT({inputs:{a:B,b:P},backend:s}),ee=Wg({inputs:{a:T,b:X},backend:s}),Z=XB({inputs:{a:T,b:X},backend:s}),fe=dp({inputs:{input:ee},backend:s}),Q=dp({inputs:{input:Z},backend:s}),be=Vg({inputs:{input:ee},backend:s}),we=Vg({inputs:{input:Z},backend:s}),Ne=Ug({inputs:[fe,Q],backend:s,attrs:{axis:0}}),$e=Ug({inputs:[be,we],backend:s,attrs:{axis:0}}),je=s.data.get(Ne.dataId).values,He=s.data.get($e.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(X),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(Z),s.disposeIntermediateTensorInfo(fe),s.disposeIntermediateTensorInfo(be),s.disposeIntermediateTensorInfo(Q),s.disposeIntermediateTensorInfo(we),s.disposeIntermediateTensorInfo(Ne),s.disposeIntermediateTensorInfo($e),{real:je,imag:He}}function Hlt(e,t,n){const r=new Float32Array(t*2);for(let s=0;s<t;s++){let a=0,i=0;for(let o=0;o<t;o++){const l=Tte(s*o,t,n),u=pB(e,o);a+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}n&&(a/=t,i/=t),Nte(r,a,i,s)}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jlt(e){const{inputs:t,backend:n}=e,{input:r}=t,s=ve(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=Pn({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=cae(o,!1,n),u=Pn({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}const qlt={kernelName:vP,backendName:"cpu",kernelFunc:jlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JB(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||Cb(s),o=yr(i,ve(r));return Xlt(o,s,i),t.makeTensorInfo(r,i,o)}const Klt={kernelName:kP,backendName:"cpu",kernelFunc:JB};function Xlt(e,t,n){e.fill(t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ylt={kernelName:IP,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,s=n,a=Is(r.dtype,ve(r.shape)),[i,o,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let h=0;h<i;h++){const p=h*l*o*u;for(let f=0;f<o;f++){const m=f*(l*u);for(let g=0;g<l;g++){const y=g*u;for(let b=0;b<u;b++){const x=Math.round(l-g-1),w=p+m+y+b;let v=c[w];if(x>=0&&x<l){const k=x*u,I=p+m+k+b;v=c[I]}a[w]=v}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zlt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=lae({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const y=Pn({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=Wg({inputs:{a:m,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else m=Wg({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(p){const g=m;if(c==="NCHW"&&p==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const y=Pn({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=ZS(n,m,p,y,f),n.disposeIntermediateTensorInfo(y)}else m=ZS(n,m,p,o,f);n.disposeIntermediateTensorInfo(g)}return m}const Jlt={kernelName:_S,backendName:"cpu",kernelFunc:Zlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qlt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=uae({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;m=Wg({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(p){const g=m;m=ZS(n,m,p,o,f),n.disposeIntermediateTensorInfo(g)}return m}const eut={kernelName:ES,backendName:"cpu",kernelFunc:Qlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tut(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=ve(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,d]=Yz(r,s);if(u===0)return n.makeTensorInfo(l,r.dtype,[]);const h=n.data.get(s.dataId).values,p=n.bufferSync(r),f=wse(h,p,r.dtype,u,o,c,d,r.shape,a);return n.makeTensorInfo(l,r.dtype,f.values)}const nut={kernelName:SP,backendName:"cpu",kernelFunc:tut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rut(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;ut([s,a],"gatherV2");const l=Bt(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let w=0;w<u.length;++w){const v=u[w];U(v<=c-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${c-1}]`)}let d=o;o==null&&(d=0);const h=ve(a.shape),p=wB(s,a,l,d),f=Pn({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Pn({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=n.bufferSync(f),x=vse(b,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,x.dtype,x.values)}const sut={kernelName:G2,backendName:"cpu",kernelFunc:rut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aut(e){const{inputs:t,backend:n}=e,{input:r}=t,s=ve(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=Pn({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=cae(o,!0,n),u=Pn({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}const iut={kernelName:CP,backendName:"cpu",kernelFunc:aut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const out=xn(T1,e=>Number.isFinite(e)?1:0,"bool"),lut={kernelName:T1,backendName:"cpu",kernelFunc:out};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uut=xn(_1,e=>Math.abs(e)===1/0?1:0,"bool"),cut={kernelName:_1,backendName:"cpu",kernelFunc:uut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dut=xn(E1,e=>Number.isNaN(e)?1:0,"bool"),hut={kernelName:E1,backendName:"cpu",kernelFunc:dut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function put(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=Nse(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}const fut={kernelName:$P,backendName:"cpu",kernelFunc:put};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mut=xn(R1,e=>Math.log1p(e)),gut={kernelName:R1,backendName:"cpu",kernelFunc:mut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yut=Ar((e,t)=>e&&t),but=hs(X2,yut,null,"bool"),xut={kernelName:X2,backendName:"cpu",kernelFunc:but};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wut=xn(Y2,e=>e?0:1,"bool"),vut={kernelName:Y2,backendName:"cpu",kernelFunc:wut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kut=Ar((e,t)=>e||t),Iut=hs(Z2,kut,null,"bool"),Sut={kernelName:Z2,backendName:"cpu",kernelFunc:Iut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cut(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;ut(s,"LRN");const u=s.shape[3],c=u-1,d=n.data.get(s.dataId).values,h=ve(s.shape),p=new Float32Array(h);function f(m){const g=m%u;let y=m-g+Math.max(0,g-a);const b=m-g+Math.min(g+a,c);let x=0;for(;y<=b;y++){const w=d[y];x+=w*w}return x}for(let m=0;m<h;m++){const g=f(m),y=d[m]*Math.pow(i+o*g,-l);p[m]=y}return n.makeTensorInfo(s.shape,s.dtype,p)}const Nut={kernelName:J2,backendName:"cpu",kernelFunc:Cut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ut(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;ut(i,"LRNGrad");const d=ve(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const x=b%h,w=b-x+Math.max(0,x-o),v=b-x+Math.min(h,x+o+1);let k=0;for(let I=w;I<v;I++)k+=Math.pow(f[I],2);k=u*k+l;for(let I=w;I<v;I++){let S=-2*u*c*f[I]*m[b]/k;b===I&&(S+=Math.pow(k,-c)),S*=p[b],g[I]+=S}}return n.makeTensorInfo(i.shape,s.dtype,g)}const Tut={kernelName:TP,backendName:"cpu",kernelFunc:$ut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dae(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let l=s.shape;const u=l.length,c=Bt(a,l);let d=c;const h=lr(d,u);let p=o.data.get(s.dataId).values;if(h!=null){const w=new Array(u);for(let v=0;v<w.length;v++)w[v]=l[h[v]];p=qB(p,l,s.dtype,h,w),d=wr(d.length,u),l=w}ut(s,"max"),$s("max",d,u);const[f,m]=ds(l,d),g=ve(m),y=Tse(p,g,f,s.dtype),b=o.write(y,f,s.dtype);let x=f;return i&&(x=br(f,c)),{dataId:b,shape:x,dtype:s.dtype}}const _ut={kernelName:Q2,backendName:"cpu",kernelFunc:dae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eut(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;ut(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;U(Ns(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Co(s.shape,a,i,u,o,l);let d;if(c.filterWidth===1&&c.filterHeight===1&&Xt(c.inShape,c.outShape))d=ql({inputs:{x:s},backend:n});else{const h=n.data.get(s.dataId).values,p=yt(s.shape),f=YB(h,s.shape,s.dtype,p,c,"max");d=n.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}const Aut={kernelName:e$,backendName:"cpu",kernelFunc:Eut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rut(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;ut(s,"maxPool3d");const c=qu(s.shape,a,i,1,o,l,u),d=n.data.get(s.dataId).values,h=oae(d,s.shape,s.dtype,yt(s.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}const Dut={kernelName:t$,backendName:"cpu",kernelFunc:Rut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fut(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;ut([s,a],"maxPool3DGrad");const c=qu(a.shape,i,o,1,l,u),d=n.bufferSync(a),h=Sot(d,c),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,v=c.effectiveFilterWidth,k=x-1-c.padInfo.front,I=v-1-c.padInfo.left,S=w-1-c.padInfo.top,$=Mt(a.shape,"float32"),N=n.bufferSync(s);for(let T=0;T<c.batchSize;++T)for(let C=0;C<c.inChannels;++C)for(let E=0;E<c.inDepth;++E)for(let M=0;M<c.inHeight;++M)for(let F=0;F<c.inWidth;++F){const z=E-k,H=M-S,P=F-I;let O=0;for(let L=0;L<x;L+=g){const V=(z+L)/p;if(!(V<0||V>=c.outDepth||Math.floor(V)!==V))for(let q=0;q<w;q+=y){const B=(H+q)/f;if(!(B<0||B>=c.outHeight||Math.floor(B)!==B))for(let X=0;X<v;X+=b){const ee=(P+X)/m;if(ee<0||ee>=c.outWidth||Math.floor(ee)!==ee)continue;const Z=x*w*v-1-h.get(T,V,B,ee,C),fe=L*w*v+q*v+X,Q=Z===fe?1:0;if(Q===0)continue;const be=N.get(T,V,B,ee,C);O+=be*Q}}}$.set(O,T,E,M,F,C)}return n.makeTensorInfo($.shape,$.dtype,$.values)}const Out={kernelName:EP,backendName:"cpu",kernelFunc:Fut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mut(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;ut([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Co(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=Mt(h.outShape,o.dtype,iae(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,x=h.effectiveFilterHeight,w=h.effectiveFilterWidth,v=w-1-h.padInfo.left,k=x-1-h.padInfo.top,I=Mt(o.shape,"float32"),S=n.data.get(s.dataId).values,$=Mt(s.shape,"float32",S);for(let N=0;N<h.batchSize;++N)for(let T=0;T<h.inChannels;++T)for(let C=0;C<h.inHeight;++C)for(let E=0;E<h.inWidth;++E){const M=C-k,F=E-v;let z=0;for(let H=0;H<x;H+=y){const P=(M+H)/m;if(!(P<0||P>=h.outHeight||Math.floor(P)!==P))for(let O=0;O<w;O+=b){const L=(F+O)/g;if(L<0||L>=h.outWidth||Math.floor(L)!==L)continue;const V=x*w-1-f.get(N,P,L,T),q=H*w+O,B=V===q?1:0;if(B===0)continue;const X=$.get(N,P,L,T);z+=X*B}}I.set(z,N,C,E,T)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}const Lut={kernelName:_P,backendName:"cpu",kernelFunc:Mut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Put(e,t,n,r,s){const a=yt(t),i=YB(e,t,n,a,s,"max"),o=iae(e,t,n,s,!0,r);return[i.values,o.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zut={kernelName:AP,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;ut(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=Co(r.shape,s,a,[1,1],i),[d,h]=Put(u,r.shape,r.dtype,o,c),p=l.write(d,c.outShape,r.dtype),f=l.write(h,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function But(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=Bt(a,s.shape),u=ds(s.shape,o)[1],c=ve(u),d=[],h=n.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const p=cd({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});d.push(p);const f=ZB({inputs:{a:p,b:h},backend:n});d.push(f);const m=vv({inputs:{x:f},backend:n,attrs:{axis:a,keepDims:i}});return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const Wut={kernelName:n$,backendName:"cpu",kernelFunc:But};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vut(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;ut(s,"min");const o=Bt(a,s.shape);let l=o;const u=lr(l,s.shape.length);let c=s;u!=null&&(c=Ea({inputs:{x:s},backend:n,attrs:{perm:u}}),l=wr(l.length,s.shape.length)),$s("min",l,c.shape.length);const[d,h]=ds(c.shape,l),p=ve(h),f=Ls(ve(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let x=m[b];for(let w=0;w<p;++w){const v=m[b+w];(Number.isNaN(v)||v<x)&&(x=v)}f[y]=x}u!=null&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const y=br(d,o),b=Pn({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}const Uut={kernelName:r$,backendName:"cpu",kernelFunc:Vut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gut(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;ut(s,"mirrorPad");const o=a.map((x,w)=>x[0]+s.shape[w]+x[1]),l=a.map(x=>x[0]),u=a.map((x,w)=>x[0]+s.shape[w]),c=i==="reflect"?0:1,d=n.data.get(s.dataId).values,h=s.shape.length,p=yt(s.shape),f=ve(o),m=o.length,g=yt(o),y=Is(s.dtype,f);for(let x=0;x<f;x++){let w=Nb(x,m,g);for(let k=0;k<m;k++)w[k]<l[k]?w[k]=l[k]*2-w[k]-c:w[k]>=u[k]&&(w[k]=(u[k]-1)*2-w[k]+c);w=w.map((k,I)=>k-l[I]);const v=Pl(w,h,p);y[x]=d[v]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}const Hut={kernelName:s$,backendName:"cpu",kernelFunc:Gut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jut=Ar((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),qut=hs(O1,jut),Kut={kernelName:O1,backendName:"cpu",kernelFunc:qut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hae(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Bt([o],s.shape),u=dae({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=br(u.shape,l),d=Pn({inputs:{x:u},backend:n,attrs:{shape:c}}),h=XB({inputs:{a:s,b:d},backend:n}),p=gse({inputs:{x:h},backend:n}),f=vv({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=Pn({inputs:{x:f},backend:n,attrs:{shape:c}}),g=ZB({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const Xut={kernelName:k$,backendName:"cpu",kernelFunc:hae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yut(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;ut(s,"multinomial");const l=o?s:hae({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,a],p=Ls(ve(h),"int32");for(let f=0;f<u;++f){const m=f*c,g=new Float32Array(c-1);g[0]=d[m];for(let x=1;x<g.length;++x)g[x]=g[x-1]+d[m+x];const y=B$.alea(i.toString()),b=f*a;for(let x=0;x<a;++x){const w=y();p[b+x]=g.length;for(let v=0;v<g.length;v++)if(w<g[v]){p[b+x]=v;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}const Zut={kernelName:RP,backendName:"cpu",kernelFunc:Yut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jut=Uz;function Qut(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;ut(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d}=Jut(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const ect={kernelName:DP,backendName:"cpu",kernelFunc:Qut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tct=Gz;function nct(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;ut(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:h,validOutputs:p}=tct(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const rct={kernelName:FP,backendName:"cpu",kernelFunc:nct};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sct=Hz;function act(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;ut(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=sct(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const ict={kernelName:OP,backendName:"cpu",kernelFunc:act};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oct(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r;ut(s,"oneHot");const u=ve(s.shape),c=new Float32Array(u*i);c.fill(l);const d=n.data.get(s.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}const lct={kernelName:l$,backendName:"cpu",kernelFunc:oct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QS(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const s=dp({inputs:{input:r},backend:n}),a=QS({inputs:{x:s},backend:n}),i=Vg({inputs:{input:r},backend:n}),o=QS({inputs:{x:i},backend:n}),l=Va({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return JB({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const uct={kernelName:N$,backendName:"cpu",kernelFunc:QS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pae(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const s=dp({inputs:{input:r},backend:n}),a=pae({inputs:{x:s},backend:n}),i=Vg({inputs:{input:r},backend:n}),o=QS({inputs:{x:i},backend:n}),l=Va({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return JB({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const cct={kernelName:o$,backendName:"cpu",kernelFunc:pae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fae(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return JS({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(c=>{oi(a,c.shape,"All tensors passed to stack must have matching shapes"),U(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=t.map(c=>{const d=JS({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=Ug({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const dct={kernelName:u$,backendName:"cpu",kernelFunc:fae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hct(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;ut(s,"pad");const o=a.map((b,x)=>b[0]+s.shape[x]+b[1]),l=a.map(b=>b[0]),u=n.data.get(s.dataId).values,c=ve(s.shape),d=s.shape.length,h=yt(s.shape),p=ve(o),f=o.length,m=yt(o),g=Is(s.dtype,p);i!==0&&g.fill(i);for(let b=0;b<c;b++){const w=Nb(b,d,h).map((k,I)=>k+l[I]),v=Pl(w,f,m);g[v]=u[b]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}const mae={kernelName:c$,backendName:"cpu",kernelFunc:hct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pct=Ar((e,t)=>Math.pow(e,t)),fct=hs(L1,pct),mct={kernelName:L1,backendName:"cpu",kernelFunc:fct};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gct(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,o=s.map(g=>n.data.get(g.dataId).values),l=s.map(g=>g.shape),u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,[d,h,p]=Fse(o,l,u,a.shape,a.dtype,c,i.shape),f=d.map(g=>n.makeTensorInfo([g.length],"int32",g)),m=n.makeTensorInfo(p,a.dtype,h);return f.concat([m])}const yct={kernelName:MP,backendName:"cpu",kernelFunc:gct};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bct(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=Ose(i,r.shape,r.dtype,o,s.shape,l,a.shape),d=n.makeTensorInfo([u.length],"int32",u),h=n.makeTensorInfo([c.length],r.dtype,c);return[d,h]}const xct={kernelName:LP,backendName:"cpu",kernelFunc:bct};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wct(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=o.map(g=>n.data.get(g.dataId).values),p=o.map(g=>g.shape),[f,m]=Mse(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}const vct={kernelName:PP,backendName:"cpu",kernelFunc:wct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kct(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=Lse(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}const Ict={kernelName:zP,backendName:"cpu",kernelFunc:kct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sct=xn(P1,e=>1/e),Cct={kernelName:P1,backendName:"cpu",kernelFunc:Sct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nct(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;ut(s,"resizeBilinear");const l=yt(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(ve([d,u,c,f])),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c];let x=0;const w=y[0]/b[0],v=y[1]/b[1];for(let k=0;k<d;k++)for(let I=0;I<u;I++){let S;i?S=w*(I+.5)-.5:S=w*I;const $=Math.max(0,Math.floor(S)),N=S-$,T=Math.min(h-1,Math.ceil(S)),C=k*l[0]+$*l[1],E=k*l[0]+T*l[1];for(let M=0;M<c;M++){let F;i?F=v*(M+.5)-.5:F=v*M;const z=Math.max(0,Math.floor(F)),H=F-z,P=Math.min(p-1,Math.ceil(F)),O=C+z*l[2],L=E+z*l[2],V=C+P*l[2],q=E+P*l[2];for(let B=0;B<f;B++){const X=m[O+B],ee=m[L+B],Z=m[V+B],fe=m[q+B],Q=X+(Z-X)*H,be=ee+(fe-ee)*H,we=Q+(be-Q)*N;g[x++]=we}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}const $ct={kernelName:m$,backendName:"cpu",kernelFunc:Nct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tct(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;ut([a,s],"resizeBilinearGrad");const o=yt(s.shape),[l,u,c,d]=s.shape,[,h,p]=a.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(a.dataId).values;let w=0;for(let v=0;v<l;v++){const k=v*o[0];for(let I=0;I<h;I++){const S=I*y,$=Math.floor(S),N=Math.min(Math.ceil(S),u-1),T=k+$*o[1],C=k+N*o[1],E=S-$,M=1-E;for(let F=0;F<p;F++){const z=F*b,H=Math.floor(z),P=Math.min(Math.ceil(z),c-1),O=z-H,L=1-O,V=T+H*o[2],q=T+P*o[2],B=C+H*o[2],X=C+P*o[2],ee=M*L,Z=M*O,fe=E*L,Q=E*O;for(let be=0;be<d;be++){const we=x[w++];f[V+be]+=we*ee,f[q+be]+=we*Z,f[B+be]+=we*fe,f[X+be]+=we*Q}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}const _ct={kernelName:VP,backendName:"cpu",kernelFunc:Tct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ect(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;ut(s,"resizeNearestNeighbor");const l=yt(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(d*u*c*f),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],x=y[0]/b[0],w=y[1]/b[1];let v=0;for(let k=0;k<d;k++){const I=k*l[0];for(let S=0;S<u;S++){const $=i?x*(S+.5):x*S;let N=Math.min(h-1,a?Math.round($):Math.floor($));i&&(N=Math.max(0,N));const T=I+N*l[1];for(let C=0;C<c;C++){const E=i?w*(C+.5):w*C;let M=Math.min(p-1,a?Math.round(E):Math.floor(E));i&&(M=Math.max(0,M));const F=T+M*l[2];for(let z=0;z<f;z++){const H=m[F+z];g[v++]=H}}}}return n.makeTensorInfo([d,u,c,f],s.dtype,g)}const Act={kernelName:f$,backendName:"cpu",kernelFunc:Ect};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rct(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;ut([a,s],"resizeNearestNeighborGrad");const o=yt(s.shape),l=yt(a.shape),[u,c,d,h]=s.shape,[,p,f]=a.shape,m=new Float32Array(u*c*d*h),g=n.data.get(a.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=y[0]/b[0],w=y[1]/b[1],v=1/x,k=1/w,I=Math.ceil(v)*2+2,S=Math.ceil(k)*2+2;for(let $=0;$<u;$++){const N=$*o[0];for(let T=0;T<c;T++){const C=N+T*o[1],E=Math.floor(T*v),M=Math.floor(E-I/2);for(let F=0;F<d;F++){const z=C+F*o[2],H=Math.floor(F*k),P=Math.floor(H-S/2);for(let O=0;O<h;O++){let L=0;for(let V=0;V<I;V++){const q=V+M;if(q<0||q>=p)continue;const B=N+q*l[1],X=q*x,ee=Math.min(c-1,i?Math.round(X):Math.floor(X));if(T===ee)for(let Z=0;Z<S;Z++){const fe=Z+P;if(fe<0||fe>=f)continue;const Q=B+fe*l[2],be=fe*w,we=Math.min(d-1,i?Math.round(be):Math.floor(be));F===we&&(L+=g[Q+O])}}m[z+O]=L}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}const Dct={kernelName:WP,backendName:"cpu",kernelFunc:Rct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fct(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;ut(s,"reverse");const i=s.shape.length,o=Bt(a,s.shape);if(i===0)return ql({inputs:{x:s},backend:n});const l=new Ur(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),h=d.slice();o.forEach(p=>h[p]=s.shape[p]-1-h[p]),l.set(u.get(...h),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}const Oct={kernelName:g$,backendName:"cpu",kernelFunc:Fct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mct={kernelName:az,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=Is(r.dtype,ve(r.shape)),[u,c,d,h]=r.shape,[p,f]=sB(i,c,d),m=255,g=Math.sin(s),y=Math.cos(s),b=o.data.get(r.dataId).values;for(let w=0;w<u;w++){const v=w*d*c*h;for(let k=0;k<c;k++){const I=k*(d*h);for(let S=0;S<d;S++){const $=S*h;for(let N=0;N<h;N++){const T=[u,k,S,N],C=T[2],E=T[1];let M=(C-p)*y-(E-f)*g,F=(C-p)*g+(E-f)*y;M=Math.round(M+p),F=Math.round(F+f);let z=a;if(typeof a!="number"&&(N===3?z=m:z=a[N]),M>=0&&M<d&&F>=0&&F<c){const P=F*(d*h),O=M*h,L=v+P+O+N;z=b[L]}const H=v+I+$+N;l[H]=z}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lct=xn(W1,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),Pct={kernelName:W1,backendName:"cpu",kernelFunc:Lct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zct(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Xf(a,s,i),h=!0,p=n.bufferSync(s),f=n.bufferSync(a),m=vh(p,f,i,d,u,l,o,c,0,h);return n.makeTensorInfo(i,m.dtype,m.values)}const Bct={kernelName:UP,backendName:"cpu",kernelFunc:zct};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wct(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function Vct(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}function Uct(e,t,n,r,s,a){const i=yr("int32",n*s);for(let o=0;o<n;++o){const l=e.slice(o*r,(o+1)*r),u=o*s;for(let c=0;c<s;++c)i[u+c]=a==="left"?Wct(l,t[c+u]):Vct(l,t[c+u])}return i}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gct(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=Uct(o,l,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",u)}const Hct={kernelName:HP,backendName:"cpu",kernelFunc:Gct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jct(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;ut([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=ni(s.dtype,a.dtype),d=Ls(ve(s.shape),c);let h=0;const p=i===0||i>1||s.shape.length===1?1:ve(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<p;m++)o[f]===1?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(s.shape,c,d)}const qct={kernelName:y$,backendName:"cpu",kernelFunc:jct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kct=J$,Xct=Q$,Yct=xn(U1,e=>e>=0?Xct*e:Kct*(Math.exp(e)-1)),Zct={kernelName:U1,backendName:"cpu",kernelFunc:Yct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jct=xn(j1,e=>e<0?-1:e>0?1:0),Qct={kernelName:j1,backendName:"cpu",kernelFunc:Jct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const edt=xn(G1,e=>Math.sin(e)),tdt={kernelName:G1,backendName:"cpu",kernelFunc:edt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ndt=xn(H1,e=>Math.sinh(e)),rdt={kernelName:H1,backendName:"cpu",kernelFunc:ndt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sdt=11920928955078125e-23,dH=Math.log(sdt)+2,adt=xn(K1,e=>{const t=e>-dH,n=e<dH,r=Math.exp(e);let s;return n?s=r:t?s=e:s=Math.log(1+r),s}),idt={kernelName:K1,backendName:"cpu",kernelFunc:adt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function odt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;ut([s],"spaceToBatchND");const o=ve(a),l=[[0,0]];l.push(...i);for(let k=1+a.length;k<s.shape.length;++k)l.push([0,0]);const u=mae.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=cv(u.shape,a,o,!1),d=dv(c.length,a.length,!1),h=hv(u.shape,a,o,!1),m=Pn({inputs:{x:u},backend:n,attrs:{shape:c}}),b=Ea({inputs:{x:m},backend:n,attrs:{perm:d}}),v=Pn({inputs:{x:b},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),v}const ldt={kernelName:w$,backendName:"cpu",kernelFunc:odt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function udt(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=Wse(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const cdt={kernelName:jP,backendName:"cpu",kernelFunc:udt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ddt(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,d]=Vse(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const hdt={kernelName:qP,backendName:"cpu",kernelFunc:ddt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pdt(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=KB(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}const fdt={kernelName:KP,backendName:"cpu",kernelFunc:pdt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mdt(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=KB(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}const gdt={kernelName:XP,backendName:"cpu",kernelFunc:mdt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ydt(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Xf(a,s,o),p=!1,f=n.bufferSync(s);let m;switch(a.dtype){case"bool":{const g=n.bufferSync(a),y=Boolean(n.data.get(i.dataId).values[0]);m=vh(f,g,o,h,c,u,l,d,y,p);break}case"float32":{const g=n.bufferSync(a),y=n.data.get(i.dataId).values[0];m=vh(f,g,o,h,c,u,l,d,y,p);break}case"int32":{const g=n.bufferSync(a),y=n.data.get(i.dataId).values[0];m=vh(f,g,o,h,c,u,l,d,y,p);break}case"string":{const g=n.bufferSync(a),y=td(n.data.get(i.dataId).values[0]);m=vh(f,g,o,h,c,u,l,d,y,p);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}const bdt={kernelName:YP,backendName:"cpu",kernelFunc:ydt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xdt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Bt(i,s.shape)[0],l=xB(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{const h=[...c];h[o]=d;const p=hp({inputs:{x:s},backend:n,attrs:{begin:u,size:h}});return u[o]+=d,p})}const wdt={kernelName:v$,backendName:"cpu",kernelFunc:xdt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vdt={kernelName:ZP,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;ut(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let o=0;o<s.length;++o){const l=s[o];a[o]=l*l}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kdt=xn(tv,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),Idt={kernelName:tv,backendName:"cpu",kernelFunc:kdt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sdt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;ut(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=tB(s.shape,a,i,o,l,u,c,d,h);let v;if(m)v=Pn({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const k=Jz(b,x,w),I=hp({inputs:{x:s},backend:n,attrs:{begin:b,size:k}});v=Pn({inputs:{x:I},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(I)}else{const k=n.bufferSync(s),I=Hse(p,k,w,b);v=n.makeTensorInfo(f,I.dtype,I.values)}return v}const Cdt={kernelName:JP,backendName:"cpu",kernelFunc:Sdt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ndt(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=jse(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}const $dt={kernelName:QP,backendName:"cpu",kernelFunc:Ndt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tdt(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=qse(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const _dt={kernelName:ez,backendName:"cpu",kernelFunc:Tdt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Edt(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.data.get(a.dataId).values,o=Kse(i,s);return n.makeTensorInfo(a.shape,"int32",o)}const Adt={kernelName:tz,backendName:"cpu",kernelFunc:Edt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rdt=xn(J1,e=>Math.tan(e)),Ddt={kernelName:J1,backendName:"cpu",kernelFunc:Rdt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fdt=xn(Q1,e=>Math.tanh(e)),Odt={kernelName:Q1,backendName:"cpu",kernelFunc:Fdt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mdt(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=Xf(a,s,r.shape),d=!1,h=n.bufferSync(s),p=n.bufferSync(a),f=n.bufferSync(r),m=vh(h,p,r.shape,c,l,o,i,u,f,d);return n.makeTensorInfo(r.shape,m.dtype,m.values)}const Ldt={kernelName:GP,backendName:"cpu",kernelFunc:Mdt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pdt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;ut(s,"tile");const i=Yse(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const zdt={kernelName:ev,backendName:"cpu",kernelFunc:Pdt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bdt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;ut(s,"topk");const o=n.data.get(s.dataId).values,[l,u]=Jse(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}const Wdt={kernelName:nz,backendName:"cpu",kernelFunc:Bdt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vdt(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=s.shape,[f,m]=u??[d,h],g=[c,f,m,p],y=yt(s.shape),b=y[0],x=y[1],w=y[2],v=yt(g),k=v[0],I=v[1],S=v[2],$=Is(s.dtype,ve(g));$.fill(l);const N=r.data.get(s.dataId).values,T=r.data.get(a.dataId).values;for(let E=0;E<c;++E){const M=a.shape[0]===1?T:T.subarray(E*8,E*8+8);for(let F=0;F<f;++F)for(let z=0;z<m;++z)for(let H=0;H<p;++H){let P;const O=M[6]*z+M[7]*F+1;if(O===0)continue;const L=(M[0]*z+M[1]*F+M[2])/O,V=(M[3]*z+M[4]*F+M[5])/O,q=hH(L,h,o),B=hH(V,d,o);switch(i){case"nearest":P=Kdt(N,d,h,b,x,w,E,B,q,H,l);break;case"bilinear":P=Xdt(N,d,h,b,x,w,E,B,q,H,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const X=E*k+F*I+z*S+H;$[X]=P}return r.makeTensorInfo(g,s.dtype,$)}return{dataId:r.write($,g,s.dtype),shape:s.shape,dtype:s.dtype}}const Udt={kernelName:rz,backendName:"cpu",kernelFunc:Vdt};function hH(e,t,n){switch(n){case"reflect":return Gdt(e,t);case"wrap":return Hdt(e,t);case"nearest":return qdt(e,t);case"constant":default:return jdt(e)}}function Gdt(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{const r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return tp(0,n,t-1)}function Hdt(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{const r=t-1;n-=t*Math.trunc(n/r)}return tp(0,n,t-1)}function jdt(e,t){return e}function qdt(e,t){return tp(0,e,t-1)}function Tx(e,t,n,r,s,a,i,o,l,u,c){const d=i*r+o*s+l*a+u;return 0<=o&&o<t&&0<=l&&l<n?e[d]:c}function Kdt(e,t,n,r,s,a,i,o,l,u,c){const d=Math.round(o),h=Math.round(l);return Tx(e,t,n,r,s,a,i,d,h,u,c)}function Xdt(e,t,n,r,s,a,i,o,l,u,c){const d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1,m=(f-l)*Tx(e,t,n,r,s,a,i,d,h,u,c)+(l-h)*Tx(e,t,n,r,s,a,i,d,f,u,c),g=(f-l)*Tx(e,t,n,r,s,a,i,p,h,u,c)+(l-h)*Tx(e,t,n,r,s,a,i,p,f,u,c);return(p-o)*m+(o-d)*g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ydt(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;ut(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=Qse(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}const Zdt={kernelName:sz,backendName:"cpu",kernelFunc:Ydt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jdt(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==a&&(l[u++]=s.shape[p]);const c=new Array(i).fill(0),d=s.shape.slice();d[a]=1;const h=new Array(o);for(let p=0;p<h.length;p++){c[a]=p;const f=hp({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});h[p]=Pn({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return h}const Qdt={kernelName:S$,backendName:"cpu",kernelFunc:Jdt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eht(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;ut(s,"unsortedSegmentSum");const o=s.shape.length,l=a.shape.length,u=[],c=[],d=o-l;let h=a;for(let f=0;f<d;++f){const m=JS({inputs:{input:h},backend:n,attrs:{dim:f+1}});h=m,c.push(m)}for(let f=0;f<i;++f){const m=Rd(f,"int32"),g=n.makeTensorInfo([],"int32",m),y=fse({inputs:{a:g,b:h},backend:n}),b=cd({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),x=dT({inputs:{a:b,b:s},backend:n}),w=vv({inputs:{x},backend:n,attrs:{axis:0,keepDims:!1}});u.push(w),c.push(g),c.push(y),c.push(b),c.push(x),c.push(w)}const p=fae({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}const tht={kernelName:C$,backendName:"cpu",kernelFunc:eht};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nht=[Jit,Fat,eot,not,Bat,sot,iot,lot,cot,hot,fot,got,bot,vot,Iot,Not,Tot,Eot,Rot,Yit,Fot,Mot,Pot,Bot,Pat,Vat,Vot,Oat,Got,jot,qot,Xot,Zot,Qot,tlt,rlt,alt,olt,ult,dlt,plt,mlt,ylt,blt,wlt,klt,Slt,Clt,Nlt,$lt,Elt,Uit,Rlt,Uat,Blt,Gat,Wlt,jat,qlt,Klt,Ylt,Kat,Yat,Jlt,eut,nut,sut,Jat,eit,Mat,iut,Hot,lut,cut,hut,Git,nit,sit,fut,iit,gut,xut,vut,Sut,Nut,Tut,_ut,lit,Aut,Dut,Out,Lut,zut,Wut,Uut,cit,Hut,Kut,Zut,hit,fit,ect,rct,ict,git,lct,cct,dct,mae,mct,jit,xit,yct,xct,vct,Ict,Lat,oD,Cct,qit,Kit,Xit,$ct,_ct,Act,Dct,Oct,Mct,Pct,$it,Bct,Hct,qct,Zct,_it,Qct,tdt,rdt,Eit,Xut,idt,ldt,cdt,hdt,fdt,gdt,bdt,wdt,Dit,vdt,Oit,Lit,Idt,Cdt,$dt,_dt,Adt,Wit,Tlt,Ddt,Odt,Ldt,zdt,Wdt,Udt,yit,Zdt,Qdt,tht,uct];for(const e of nht)hQ(e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hh={},Fk={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function rht(e,t){hh[e]=t}function ol(e,t){if(!(e in hh)||t!=null){const r=aht(e,t);if(r!==null)hh[e]=r;else return console.log("Could not get context for WebGL version",e),null}const n=hh[e];return n==null||n.isContextLost()?(delete hh[e],ol(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),hh[e])}function sht(e){if(!xe().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function aht(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=t??sht(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete hh[e]},!1),xe().getBool("SOFTWARE_WEBGL_ENABLED")&&(Fk.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",Fk)||n.getContext("experimental-webgl",Fk):n.getContext("webgl2",Fk)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var U0;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(U0||(U0={}));var Ii;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(Ii||(Ii={}));var xs;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(xs||(xs={}));function kv(e,t){return[t,e]}function iht(e,t){return e*t}function Ok(e){const t=ve(e),n=Math.ceil(t/4);return aR(n)}function Ob(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function oht(e,t){const[n,r]=Ob(e,t);return n*r*4}function QB(e,t){const n=e;let r,s,a,i,o,l,u,c,d,h;return xe().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=t!=null?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ze(e,t){const n=t();return xe().getBool("DEBUG")&&lht(e),n}function lht(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+hht(e,t))}const uht=596e-10,cht=65504;function dht(e){return!!(xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||uht<Math.abs(e)&&Math.abs(e)<cht)}function hht(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Mk(e,t){return Zu(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function pht(e,t){const n=Zu(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ze(e,()=>e.shaderSource(n,t)),Ze(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function fht(e,t){const n=Zu(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ze(e,()=>e.shaderSource(n,t)),Ze(e,()=>e.compileShader(n)),xe().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw gae(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const mht=/ERROR: [0-9]+:([0-9]+):/g;function gae(e,t){const n=mht.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}const r=+n[1],s=e.split(`
`),a=s.length.toString().length+2,i=s.map((d,h)=>jm((h+1).toString(),a)+d);let o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${jm(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function ght(e){return Zu(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function yht(e,t){if(Ze(e,()=>e.linkProgram(t)),!xe().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function U_(e,t){if(Ze(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function bht(e,t){const n=Zu(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Ze(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),Ze(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function xht(e,t){const n=Zu(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Ze(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),Ze(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function wht(e){return Zu(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function vht(e,t){const n=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){const r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function kht(e){return Zu(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function pH(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return o===-1?!1:(Ze(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),Ze(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i)),Ze(e,()=>e.enableVertexAttribArray(o)),!0)}function Iht(e,t,n){Tht(e,n),Ze(e,()=>e.activeTexture(e.TEXTURE0+n)),Ze(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function Sht(e,t,n){return Zu(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function Cht(e,t,n){return e.getUniformLocation(t,n)}function Nht(e,t,n,r){Ze(e,()=>Iht(e,t,r)),Ze(e,()=>e.uniform1i(n,r))}function G_(e,t,n){Ze(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),Ze(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function fH(e,t){Ze(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),Ze(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Lk(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+$ht(e,t))}function $ht(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Zu(e,t,n){const r=Ze(e,()=>t());if(r==null)throw new Error(n);return r}function Tht(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){const s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Gg(e,t=2){return ve(e.slice(0,e.length-t))}function Hg(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Pk(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Gg(e),...Hg(e)]),t}function _ht(e,t=!1){let n=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=xe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&xe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,l)=>l>=e.length-2?QL(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=Ad(e).newShape);let s=ve(e),a=null;e.length<=1&&s<=n?a=[1,s]:e.length===2&&e[0]<=n&&e[1]<=n?a=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=a!=null&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(a==null||i)if(t){const o=Gg(e);let l=2,u=2;e.length&&([l,u]=Hg(e)),s=o*(l/2)*(u/2),a=aR(s).map(c=>c*2)}else a=aR(s);return a}function zk(e){return e%2===0}function eC(e,t){if(e=e.slice(-2),t=t.slice(-2),Xt(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r||zk(n)&&zk(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&zk(e[0])&&zk(t[0])}let H_,j_;function Eht(e){if(H_==null){const t=ol(e);H_=t.getParameter(t.MAX_TEXTURE_SIZE)}return H_}function Aht(e){if(j_==null){const t=ol(e);j_=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,j_)}function Rht(e){if(e===0)return 0;let t;const n=ol(e);return lo(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:lo(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function lo(e,t){return e.getExtension(t)!=null}function mH(e){try{if(ol(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Dht(e){if(e===0)return!1;const t=ol(e);if(e===1){if(!lo(t,"OES_texture_float"))return!1}else if(!lo(t,"EXT_color_buffer_float"))return!1;return uD(t)}function Fht(e){if(e===0)return!1;const t=ol(e);if(e===1){if(!lo(t,"OES_texture_float")||!lo(t,"WEBGL_color_buffer_float"))return!1}else{if(lo(t,"EXT_color_buffer_float"))return uD(t);const r="EXT_color_buffer_half_float";if(lo(t,r)){const s=t.getExtension(r);return Oht(t,s)}return!1}return uD(t)}function uD(e){const t=QB(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);const r=1,s=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,s,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),i}function Oht(e,t){const n=QB(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const s=1,a=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,a,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}function Mht(e){return e!==2?!1:ol(e).fenceSync!=null}function Iv(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&U(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ht=xe();ht.registerFlag("HAS_WEBGL",()=>ht.getNumber("WEBGL_VERSION")>0);ht.registerFlag("WEBGL_VERSION",()=>mH(2)?2:mH(1)?1:0);ht.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ht.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ht.get("WEBGL_VERSION")===2);ht.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ht.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ht.registerFlag("WEBGL_PACK",()=>ht.getBool("HAS_WEBGL"));ht.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_CLIP",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_REDUCE",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_LAZILY_UNPACK",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_CONV_IM2COL",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Eht(ht.getNumber("WEBGL_VERSION")));ht.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Aht(ht.getNumber("WEBGL_VERSION")));ht.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=ht.getNumber("WEBGL_VERSION");return e===0?0:Rht(e)});ht.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ht.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!$Q());ht.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Dht(ht.getNumber("WEBGL_VERSION")));ht.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ht.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ht.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ht.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Fht(ht.getNumber("WEBGL_VERSION")));ht.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Mht(ht.getNumber("WEBGL_VERSION")));ht.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ht.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ht.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});ht.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>$Q()?1:-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});ht.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ht.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ht.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ht.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ht.registerFlag("WEBGL_EXP_CONV",()=>!1);ht.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ht.getBool("IS_TEST"));ht.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ht.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ht.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ht.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function da(){let e,t,n,r,s,a,i,o,l,u;return xe().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=xe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jf(e,t,n="index"){const r=yt(t);return r.map((s,a)=>{const i=`int ${e[a]} = ${n} / ${s}`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${s}`:`index -= ${e[a]} * ${s}`;return`${i}; ${o};`}).join("")}function hT(e,t,n="index"){const r=yt(t);return r.map((s,a)=>{const i=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${i}; ${o};`}).join("")}function Lht(e,t){const n=e.length,r=e.map(a=>`${t}[${a}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function Pht(e,t,n="index"){const r=e.map((a,i)=>i),s=Lht(r,t);return s.map((a,i)=>{const o=`int ${e[i]} = ${n} / ${s[i]}`,l=i===s.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${s[i]}`:`index -= ${e[i]} * ${s[i]}`;return`${o}; ${l};`}).join("")}function e4(e){const t=yt(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function t4(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const yae=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:bae}=aet;function zht(e,t,n){const r=[];if(e.forEach(p=>{const f=ve(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?r.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(r.push(`uniform sampler2D ${p.name};`),r.push(`uniform int offset${p.name};`)),n.enableShapeUniforms){const{uniformShape:m}=n4(n.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${p.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${p.name}Shape;`);break}r.push(`uniform ivec2 ${p.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(p=>{r.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const s=r.join(`
`),a=e.map(p=>Bht(p,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=da(),l=Uht(o);let u,c,d=jht(o);return t.isPacked?(u=Wht(t.logicalShape,i,n.enableShapeUniforms),c=Hht(o)):(u=Vht(t.logicalShape,i,n.enableShapeUniforms),c=Ght(o)),n.packedInputs&&(d+=Yht),[d,l,c,s,u,a,n.userCode].join(`
`)}function Mb(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return lpt(e,t);case 1:return cpt(e,t);case 2:return hpt(e,t);case 3:return fpt(e,t);case 4:return gpt(e,t);case 5:return ypt(e);case 6:return bpt(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function xae(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return opt(e);case 1:return upt(e,t);case 2:return dpt(e,t);case 3:return ppt(e,t);default:return mpt(e,t)}}function Bht(e,t,n=!1,r){let s="";n?s+=xae(e,r):s+=Mb(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;return a.length<=i.length&&(n?s+=xpt(e,t):s+=wpt(e,t)),s}function Wht(e,t,n){switch(e.length){case 0:return wae();case 1:return Zht(e,t,n);case 2:return apt(e,t,n);case 3:return Qht(e,t,n);default:return tpt(e,t,n)}}function Vht(e,t,n){switch(e.length){case 0:return wae();case 1:return Jht(e,t,n);case 2:return ipt(e,t,n);case 3:return ept(e,t,n);case 4:return npt(e,t,n);case 5:return rpt(e,t);case 6:return spt(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function Uht(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function Ght(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function Hht(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function jht(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${qht}
    ${Kht}
    ${Xht}
  `}const qht=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Kht=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Xht=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Yht=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function wae(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Zht(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function Jht(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function Qht(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function ept(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${hT(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;const r=Jf(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function tpt(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+o,l=`b${u}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${e.length}(${l});
    }
  `}function npt(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${hT(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Jf(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function rpt(e,t){const n=Jf(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function spt(e,t){const n=Jf(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function apt(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Xt(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function ipt(e,t,n){return Xt(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Qf(e){return`offset${e}`}function opt(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=da();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function lpt(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(s===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=Qf(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[o,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function upt(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=da();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function cpt(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Lb(e)}
      }
    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(i===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=Qf(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function dpt(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],l=da();if(a!=null&&Xt(n,a))return t?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function hpt(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(a!=null&&Xt(n,a)){if(t)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const h=a[0],p=a[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:i,keptDims:o}=Ad(n),l=i;if(l.length<n.length){const h=Pb(e,l),p=["row","col"];return`
      ${Mb(h,t)}
      float ${s}(int row, int col) {
        return ${s}(${zb(p,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Lb(e)}
      }
    `;const u=a[0],c=a[1],d=Qf(r);return c===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function ppt(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){const h=n.slice(1),p=[1,2],f=Pb(e,h),m=["b","row","col"];return`
        ${xae(f,t)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${zb(m,p)});
        }
      `}const o=da();if(t)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${d}, ${c}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function fpt(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=Ad(n),u=o;if(u.length<n.length){const m=Pb(e,u),g=["row","col","depth"];return`
        ${Mb(m,t)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${zb(g,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${i}, 1)));
        ${Lb(e)}
      }
    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===a&&p==null)return t?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(h===i&&p==null)return t?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;const f=Qf(r);return t?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${h}, index);
        return sampleTexture(${r}, uv);
      }
  `}function mpt(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=da();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(a[i-1]/2);let h=d*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=a[i-m-1],f=`b${m} * ${h} + `+f;return`
    vec4 ${r}(${p}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${s.texture2D}(${n}, uv);
    }
  `}function gpt(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=Ad(n);if(l.length<n.length){const b=Pb(e,l),x=["row","col","depth","depth2"];return`
      ${Mb(b,t)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${zb(x,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${a}, 1)));
        ${Lb(e)}
      }
    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(p===a&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;const y=Qf(r);return t?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function ypt(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=Ad(t);if(l.length<t.length){const m=Pb(e,l),g=["row","col","depth","depth2","depth3"];return`
      ${Mb(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${zb(g,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${a}, ${s})) +
          depth3;
        ${Lb(e)}
      }
    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;const f=Qf(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${a} +
          depth2 * ${s} + depth3 + ${f};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function bpt(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=Ad(t);if(s.length<t.length){const g=Pb(e,s),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Mb(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${zb(y,a)});
      }
    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Lb(e)}
      }
    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const m=Qf(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Lb(e){const t=e.name,n=ve(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function xpt(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=bae(e.shapeInfo.logicalShape,t.logicalShape),l=Nn(i),u=i-a;let c;const d=["x","y","z","w","u","v"];a===0?c="":i<2&&o.length>=1?c="coords = 0;":c=o.map(b=>`coords.${d[b+u]} = 0;`).join(`
`);let h="";i<2&&a>0?h="coords":h=e.shapeInfo.logicalShape.map((b,x)=>`coords.${d[x+u]}`).join(", ");let p="return outputValue;";const m=ve(e.shapeInfo.logicalShape)===1,y=ve(t.logicalShape)===1;if(a===1&&!m&&!y)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(o.length){const b=a-2,x=a-1;o.indexOf(b)>-1&&o.indexOf(x)>-1?p="return vec4(outputValue.x);":o.indexOf(b)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(x)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${h});
      ${p}
    }
  `}function wpt(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&Xt(i,a))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const u=Nn(l),c=bae(e.shapeInfo.logicalShape,t.logicalShape),d=l-o;let h;const p=["x","y","z","w","u","v"];o===0?h="":l<2&&c.length>=1?h="coords = 0;":h=c.map(m=>`coords.${p[m+d]} = 0;`).join(`
`);let f="";return l<2&&o>0?f="coords":f=e.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+d]}`).join(", "),`
    float ${s}() {
      ${u} coords = getOutputCoords();
      ${h}
      return get${r}(${f});
    }
  `}function Nn(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function n4(e,t,n){const{newShape:r,keptDims:s}=Ad(t),a=t.length,i=e&&a===3&&t[0]===1,o=i?t.slice(1):r,l=!e&&a>1&&!Xt(t,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:s}}function Pb(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function zb(e,t){return t.map(n=>e[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vpt(e,t,n,r){const s=n.map((c,d)=>{const h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),a=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=zht(s,i,t),l=fht(e.gl,o),u=e.createProgram(l);return xe().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},vae(e,t,u))}function vae(e,t,n){const r=[],s=[];let a,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),xe().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const d of t.variableNames){const h={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(h.shape=e.getUniformLocation(n,`${d}Shape`,c),h.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),r.push(h)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const d of t.customUniforms)s.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function gH(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{const s=n.logicalShape,a=t[r],i=a.shape;if(!Xt(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&a.isUniform)return;const o=n.texShape,l=a.isUniform?null:a.texData.texShape;if(!Xt(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function kpt(e,t,n,r,s){t.program.enableShapeUniforms||(gH(t.inShapeInfos,n),gH([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),xe().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const u=n[l],{uniform:c,offset:d,shape:h,texShape:p}=t.variablesLocations[l];if(h){const{uniformShape:f}=n4(t.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:e.gl.uniform1iv(h,new Int32Array(f));break;case 2:e.gl.uniform2iv(h,new Int32Array(f));break;case 3:e.gl.uniform3iv(h,new Int32Array(f));break;case 4:e.gl.uniform4iv(h,new Int32Array(f));break}}if(p&&e.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(ve(u.shape)<2)e.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),e.gl.uniform1fv(c,f)}continue}u.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){const l=yt(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let l=0;l<t.program.customUniforms.length;++l){const u=t.program.customUniforms[l],c=t.customUniformLocations[l],d=s[l];if(u.type==="float")e.gl.uniform1fv(c,d);else if(u.type==="vec2")e.gl.uniform2fv(c,d);else if(u.type==="vec3")e.gl.uniform3fv(c,d);else if(u.type==="vec4")e.gl.uniform4fv(c,d);else if(u.type==="int")e.gl.uniform1iv(c,d);else if(u.type==="ivec2")e.gl.uniform2iv(c,d);else if(u.type==="ivec3")e.gl.uniform3iv(c,d);else if(u.type==="ivec4")e.gl.uniform4iv(c,d);else throw Error(`uniform type ${u.type} is not supported yet.`)}e.executeProgram()}function Ipt(e,t,n){let r="";t.concat(n).forEach(i=>{const o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=n4(e.packedInputs,i.shape,l);let h="",p="",f="";if(c.length===1&&e.packedInputs){const v=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${v[0]>1}_${v[1]>1}`}else if(c.length===2&&!e.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){const v=yt(c);f=`${v[0]===l[1]}_${v[v.length-1]===l[1]}`}const m=i.shape.length,g=c.length===2&&Xt(i.shape,l),y=ve(i.shape)===1,b=Lg(i.shape,n.shape),x=!e.packedInputs&&m===n.shape.length&&Xt(l,n.texData.texShape),w=e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${x}_${u?d:""}_${c.length}_${y}_${b}_${g}_${h}_${p}_${f}_${w}_${o}`}else{const l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${o}`}});const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${xe().getNumber("WEBGL_VERSION")}`,a}function Bs(e){return xe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Spt{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=U0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=da();this.outputShape=t,this.enableShapeUniforms=Bs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?hT(["r","c","d"],t):Jf(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cpt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=U0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=da();this.outputShape=t,this.enableShapeUniforms=Bs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?hT(["r","c","d"],t):Jf(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Npt{constructor(t){this.variableNames=["A"],this.outTexUsage=Ii.DOWNLOAD;const n=da();this.outputShape=t,this.userCode=`
      ${yae}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $pt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Ii.DOWNLOAD;const n=da();this.outputShape=t,this.userCode=`
      ${yae}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tpt={R:0,G:1,B:2,A:3};class yH{constructor(t,n=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=da();this.outputShape=t,this.enableShapeUniforms=Bs(this.outputShape.length);let a="result";n&&(a="floor(result * 255. + 0.5)");let i="";for(let o=0;o<r.length;o++){const l=r[o];i+=`
          if(offset == ${o}) {
            result = values[${Tpt[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?t4():e4(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${i}
        }
        ${s.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _pt{constructor(t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=da();this.outputShape=t,this.enableShapeUniforms=Bs(this.outputShape.length);let s="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let o=0;o<=1;o++){const l=i*2+o;s+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?t4():e4(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${a};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ept(e){const t=da(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return pht(e,n)}function Apt(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return bht(e,t)}function Rpt(e){const t=new Uint16Array([0,1,2,2,1,3]);return xht(e,t)}function Sv(e,t,n,r,s,a){vht(t,n);const i=wht(e),o=e.TEXTURE_2D;return Ze(e,()=>e.bindTexture(o,i)),Ze(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),Ze(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),Ze(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),Ze(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),xe().getNumber("WEBGL_VERSION")===1?Ze(e,()=>e.texImage2D(o,0,r,t,n,0,s,a,null)):Ze(e,()=>e.texStorage2D(o,1,r,t,n)),Ze(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function kae(e){return e.internalFormatFloat}function Dpt(e,t,n,r){const[s,a]=kv(t,n);return Sv(e,s,a,kae(r),r.textureFormatFloat,e.FLOAT)}function Iae(e){return e.internalFormatHalfFloat}function Fpt(e,t,n,r){const[s,a]=kv(t,n);return Sv(e,s,a,Iae(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function Sae(e){return e.downloadTextureFormat}function Opt(e,t,n,r){const[s,a]=kv(t,n);return Sv(e,s,a,Sae(r),e.RGBA,e.UNSIGNED_BYTE)}function Cae(e){return e.internalFormatPackedFloat}function Mpt(e,t,n,r){const[s,a]=Ob(t,n);return Sv(e,s,a,Cae(r),e.RGBA,e.FLOAT)}function Nae(e){return e.internalFormatPackedHalfFloat}function Lpt(e,t,n,r){const[s,a]=Ob(t,n);return Sv(e,s,a,Nae(r),e.RGBA,r.textureTypeHalfFloat)}function Ppt(e,t,n){return Ze(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),pH(e,t,"clipSpacePos",n,3,20,0)&&pH(e,t,"uv",n,2,20,12)}function zpt(e,t,n,r,s,a){Ze(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),xe().getNumber("WEBGL_VERSION")===2?Ze(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):Ze(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),Ze(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function Bpt(e,t,n){Ze(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?xe().getNumber("WEBGL_VERSION")===2?Ze(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):Ze(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):xe().getNumber("WEBGL_VERSION")===2?Ze(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):Ze(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),Ze(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function Wpt(e,t,n,r){const s=e.createBuffer();Ze(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));const o=4*4*t*n;return Ze(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ)),Ze(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),Ze(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function Vpt(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function Upt(e,t,n,r){const[s,a]=kv(t,n),i=4,o=new Uint8Array(iht(t*n,i));return Ze(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function Gpt(e,t,n,r,s,a,i,o){const l=e,u=new Float32Array(oht(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function Hpt(e,t,n){const r=new Float32Array(t*n*4);return Ze(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q_{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=xe().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,rht(n,t)):this.gl=ol(n),t=this.gl,xe().getNumber("WEBGL_VERSION")===2){const a=t;this.createVertexArray=()=>Ze(a,()=>a.createVertexArray()),this.bindVertexArray=i=>Ze(a,()=>a.bindVertexArray(i)),this.deleteVertexArray=i=>Ze(a,()=>a.deleteVertexArray(i)),this.getVertexArray=()=>Ze(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(t!=null){const a=t.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ze(t,()=>a.createVertexArrayOES()),this.bindVertexArray=i=>Ze(t,()=>a.bindVertexArrayOES(i)),this.deleteVertexArray=i=>Ze(t,()=>a.deleteVertexArrayOES(i)),this.getVertexArray=()=>Ze(t,()=>t.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),xe().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Mk(this.gl,a),lo(this.gl,i))this.textureHalfFloatExtension=Mk(this.gl,i);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),lo(this.gl,s))this.colorBufferHalfFloatExtension=Mk(this.gl,s);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",lo(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(lo(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Apt(this.gl),this.indexBuffer=Rpt(this.gl),this.framebuffer=kht(this.gl),this.textureConfig=QB(this.gl,this.textureHalfFloatExtension)}get debug(){return xe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;Ze(t,()=>t.finish()),Ze(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Ze(t,()=>t.deleteFramebuffer(this.framebuffer)),Ze(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Ze(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Ze(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,n){return this.throwIfDisposed(),Dpt(this.gl,t,n,this.textureConfig)}createFloat16MatrixTexture(t,n){return this.throwIfDisposed(),Fpt(this.gl,t,n,this.textureConfig)}createUnsignedBytesMatrixTexture(t,n){return this.throwIfDisposed(),Opt(this.gl,t,n,this.textureConfig)}uploadPixelDataToTexture(t,n){this.throwIfDisposed(),Bpt(this.gl,t,n)}uploadDenseMatrixToTexture(t,n,r,s){this.throwIfDisposed(),zpt(this.gl,t,n,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,n){return this.throwIfDisposed(),Lpt(this.gl,t,n,this.textureConfig)}createPackedMatrixTexture(t,n){return this.throwIfDisposed(),Mpt(this.gl,t,n,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(fH(this.gl,this.framebuffer),this.outputTexture=null),Ze(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,n,r){return this.downloadMatrixDriver(t,()=>Upt(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,n,r,s,a,i){return Gpt(this.gl,t,n,r,s,a,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,n){return Vpt(this.gl,t,n)}createBufferFromTexture(t,n,r){this.bindTextureToFrameBuffer(t);const s=Wpt(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let n,r;if(xe().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,a=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const i=s.clientWaitSync(a,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},n=a}else xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(t,n,r){return this.downloadMatrixDriver(t,()=>Hpt(this.gl,n,r))}createProgram(t){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=Ept(n));const r=ght(n);Ze(n,()=>n.attachShader(r,this.vertexShader)),Ze(n,()=>n.attachShader(r,t)),yht(n,r);let s;return s=Object.assign(r,{vao:this.createVertexArray()}),this.bindVertexArray(s.vao),Ze(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(Ppt(n,s,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&U_(n,s),this.setProgram(s),s}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(Ze(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&U_(this.gl,this.program)),Ze(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,n,r=!0){return this.throwIfDisposed(),r?Sht(this.gl,t,n):Cht(this.gl,t,n)}getAttributeLocation(t,n){return this.throwIfDisposed(),Ze(this.gl,()=>this.gl.getAttribLocation(t,n))}getUniformLocationNoThrow(t,n){return this.throwIfDisposed(),this.gl.getUniformLocation(t,n)}setInputMatrixTexture(t,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),Nht(this.gl,t,n,r)}setOutputMatrixTexture(t,n,r){this.setOutputMatrixTextureDriver(t,r,n)}setOutputPackedMatrixTexture(t,n,r){this.throwIfDisposed();const[s,a]=Ob(n,r);this.setOutputMatrixTextureDriver(t,s,a)}setOutputMatrixWriteRegion(t,n,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,n)}setOutputPackedMatrixWriteRegion(t,n,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&U_(this.gl,this.program),Lk(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ze(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ze(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Mk(this.gl,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),a=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,a),a}const t=this.getQueryTimerExtensionWebGL1(),n=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,n),n}endQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await JU(()=>this.disposed||this.isQueryAvailable(t,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,n){if(n===0)return!0;if(n===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),a=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(n=>{this.addItemToPoll(()=>t.isFencePassed(),()=>n())})}pollItems(){const t=jpt(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=t;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,n){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in xe().platform&&(r=xe().platform.setTimeoutCustom.bind(xe().platform)),JU(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),G_(this.gl,t,this.framebuffer),this.debug&&Lk(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(G_(this.gl,this.outputTexture,this.framebuffer),this.debug&&Lk(this.gl)):fH(this.gl,this.framebuffer)}downloadMatrixDriver(t,n){this.bindTextureToFrameBuffer(t);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,n,r){this.throwIfDisposed();const s=this.gl;G_(s,t,this.framebuffer),this.debug&&Lk(s),this.outputTexture=t,Ze(s,()=>s.viewport(0,0,n,r)),Ze(s,()=>s.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(t,n,r,s){this.throwIfDisposed(),Ze(this.gl,()=>this.gl.scissor(t,n,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function jpt(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:qpt,bincountImpl:$ae,bincountReduceImpl:Kpt,castImpl:Xpt,ceilImpl:Ypt,concatImpl:Zpt,equalImpl:Jpt,expImpl:Qpt,expm1Impl:eft,floorImpl:tft,gatherNdImpl:nft,gatherV2Impl:rft,greaterImpl:sft,greaterEqualImpl:aft,lessImpl:ift,lessEqualImpl:oft,linSpaceImpl:lft,logImpl:uft,maxImpl:cft,maximumImpl:dft,minimumImpl:hft,multiplyImpl:pft,negImpl:fft,notEqualImpl:mft,prodImpl:gft,raggedGatherImpl:yft,raggedRangeImpl:bft,raggedTensorToTensorImpl:xft,rangeImpl:wft,rsqrtImpl:vft,scatterImpl:kft,sigmoidImpl:Ift,simpleAbsImpl:Tae,sliceImpl:Sft,sparseFillEmptyRowsImpl:Cft,sparseReshapeImpl:Nft,sparseSegmentReductionImpl:_ae,sqrtImpl:$ft,staticRegexReplaceImpl:Tft,stridedSliceImpl:_ft,stringNGramsImpl:Eft,stringSplitImpl:Aft,stringToHashBucketFastImpl:Rft,subImpl:Dft,tileImpl:Fft,topKImpl:Oft,transposeImpl:r4,uniqueImpl:Mft}=Vit;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eae(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Zs(e,t){return t===1?[e]:Eae(e,t)}function Lft(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pft{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Bs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=Zs("rc",this.rank),r=Nn(this.rank),s=this.getOutOfBoundsCondition(n),a=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let a=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)a=`${t[t.length-1-i]},`+a;n.push(a)}return n}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let r=this.rank-2;r<this.rank;r++)n+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(n+="||");return n}getSetup(t){if(this.rank===1)return"";const n=t.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(t){const n=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Aae{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Bs(this.outputShape.length);let r="";for(let s=0;s<4;s++){let a="thisRC = rc;";s%2===1&&(a+="thisRC.z += 1;"),s>1&&(a+="thisRC.y += 1;"),r+=`
        ${a}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${zft(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?t4():e4(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${r}

        setOutput(result);
      }
    `}}function zft(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Pht(["r","c","d"],"inputShape"):Jf(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bft{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,n,r){const s=xH(n,r),a=wH(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const i=bH(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[a].pop();return this.usedTextures[a].push(l),l}let o;return s===xs.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===xs.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===xs.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===xs.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===xs.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),o}releaseTexture(t,n,r,s){if(this.freeTextures==null)return;const a=xH(r,s),i=wH(n,a,s);i in this.freeTextures||(this.freeTextures[i]=[]);const o=bH(n,a,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=xe().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const u=this.usedTextures[i],c=u&&u.indexOf(t);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Wft(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function bH(e,t,n,r,s){const a=Vft(t,r);let i;if(s){const[l,u]=Ob(e[0],e[1]);i=l*u}else{const[l,u]=kv(e[0],e[1]);i=l*u}const o=Wft(n,a);return i*o}function Vft(e,t){switch(e){case xs.PACKED_2X2_FLOAT32:return Cae(t);case xs.PACKED_2X2_FLOAT16:return Nae(t);case xs.UNPACKED_FLOAT32:return kae(t);case xs.UNPACKED_FLOAT16:return Iae(t);case xs.PACKED_4X1_UNSIGNED_BYTE:return Sae(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function Uft(e){return xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?xs.PACKED_2X2_FLOAT32:xs.UNPACKED_FLOAT32:e?xs.PACKED_2X2_FLOAT16:xs.UNPACKED_FLOAT16}function xH(e,t){if(e===Ii.UPLOAD)return xs.PACKED_2X2_FLOAT32;if(e===Ii.RENDER||e==null)return Uft(t);if(e===Ii.DOWNLOAD||e===Ii.PIXELS)return xs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function wH(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Al{constructor(t,n){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Bs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const $o="if (isnan(x)) return x;",Gft="return x;",vH="return abs(x);",Hft="return (x >= 0.0) ? x : (exp(x) - 1.0);",jft=$o+`
  return (x < 0.0) ? 0.0 : x;
`,qft=$o+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,uc="return x;",Kft="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xft="return x;",Yft=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Zft=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Jft=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Qft="return 1.0 / (1.0 + exp(-1.0 * x));";class kc{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Bs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class emt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Bs(this.outputShape.length);const n=t.length,r=Zs("rc",n),s=Nn(n),a=Lft(n,r),i=r.slice(-2),o=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tmt=Bz,nmt=1e-7,rmt=1e-4,Bk={};function smt(e){return e in Bk||(Bk[e]={}),Bk[e]}const amt=xe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),imt=600;function omt(){return xe().global.screen==null?1024:xe().global.screen.height*xe().global.screen.width*window.devicePixelRatio*imt/1024/1024}class pT extends JL{nextDataId(){return pT.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!xe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof q_)n=t;else{const r=ol(xe().getNumber("WEBGL_VERSION"),t);n=new q_(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=ol(xe().getNumber("WEBGL_VERSION"));n=new q_(r),this.binaryCache=smt(xe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Bft(this.gpgpu),this.numMBBeforeWarning=omt(),this.texData=new aQ(this,xl())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,r,s,a,i){const o=this.makeTensorInfo(n,r),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[s,a]},l.texShape=[s,a];const u=Pk(n),c=new yH(u,!1,i),d=this.runWebGLProgram(c,[o],r,[[s,a]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(t,n,r){if((xe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||xe().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:t,usage:Ii.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){const n=this.texData.get(t);n.refCount--}}move(t,n,r,s,a){if(xe().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:s,values:n,usage:Ii.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const n=this.texData.get(t),{values:r,dtype:s,complexTensorInfos:a,slice:i,shape:o,isPacked:l}=n;if(i!=null){let h;l?h=new kc(o,uc):h=new Al(o,uc);const p=this.runWebGLProgram(h,[{dataId:t,shape:o,dtype:s}],s),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(r!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return r;const u=this.activeTimers!=null;let c;u&&(c=ya());let d;if(s==="complex64"){const h=this.readSync(a.real.dataId),p=this.readSync(a.imag.dataId);d=Pu(h,p)}else d=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=ya()-c),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){const f=this.pendingRead.get(t);return new Promise(m=>f.push(m))}const n=this.texData.get(t),{values:r,shape:s,slice:a,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(a!=null){let f;l?f=new kc(s,uc):f=new Al(s,uc);const m=this.runWebGLProgram(f,[{dataId:t,shape:s,dtype:i}],i),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(t);if(xe().getBool("DEBUG")&&!xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&xe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(i!=="complex64"&&xe().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);const f=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(f.texture.texture,...Ok(s))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(i==="complex64"){const f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),m=f[0],g=f[1];d=Pu(m,g)}else if(u==null)d=this.getValuesFromTexture(t);else{const f=ve(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(u,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const f=this.gpgpu.gl;Ze(f,()=>f.deleteBuffer(u))}const h=this.convertAndCacheOnCPU(t,d),p=this.pendingRead.get(t);return this.pendingRead.delete(t),p.forEach(f=>f(h)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&xl().removeDataId(t,this),this.pendingDeletes--),h}readToGPU(t,n={}){const r=this.texData.get(t),{values:s,shape:a,slice:i,dtype:o,isPacked:l,texture:u}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let p;l?p=new kc(a,uc):p=new Al(a,uc);const f=this.runWebGLProgram(p,[{dataId:t,shape:a,dtype:o}],o),m=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),m}if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(t,n.customTexShape),d=xl().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const r=n.map(s=>td(s));return Mt(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Mt(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){const r=t[n];if(!dht(r))throw xe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:n,dtype:r,isPacked:s}=this.texData.get(t),a=ve(n);if(xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const h=this.decode(t),p=this.texData.get(h.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...Ok(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(h),f}const i=xe().getBool("WEBGL_PACK")&&s===!0,o=i?Pk(n):n,l=i?new $pt(o):new Npt(o),u=this.runWebGLProgram(l,[{shape:o,dtype:r,dataId:t}],"float32"),c=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,t();const a=rp(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=rp(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(a);o.kernelMs=K8e(l),o.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ya(),endMs:null}}endTimer(t){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=ya(),t)}async getQueryTime(t){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:n,dtype:r,texShape:s,usage:a,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,a,i)));const c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=amt){return xe().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&ve(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){gi("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=t.dataSync();return tmt(t.shape,n)}packedUnaryOp(t,n,r){const s=new kc(t.shape,n),a=this.compileAndRun(s,[t],r);return xl().makeTensorFromTensorInfo(a)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const s=Tae(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,s)}if(xe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,vH,t.dtype);const n=new Al(t.shape,vH),r=this.compileAndRun(n,[t]);return xl().makeTensorFromTensorInfo(r)}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&i1(r[0])){const a=r.map(i=>Lc(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:n}}makeOutput(t,n,r){return xl().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,r),this)}unpackTensor(t){const n=new emt(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){const n=new Pft(t.shape),r=!0;return this.runWebGLProgram(n,[t],t.dtype,null,r)}packedReshape(t,n){const r=[Gg(t.shape),...Hg(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},a=[Gg(n),...Hg(n)],i=new Aae(a,r),o=!0,l=[r],u=this.runWebGLProgram(i,[s],t.dtype,l,o);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(t,n){const r=this.texData.get(t),{isPacked:s,shape:a,dtype:i}=r;if(n!=null){const h=ve(a),p=n[0]*n[1]*4;U(h<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=Pk(a);let l;s?l=new Cpt(o):l=new Spt(o);const u=!0,c=[n??Ok(o)],d=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,c,u,n);return{dtype:i,shape:a,dataId:d.dataId}}runWebGLProgram(t,n,r,s,a=!1,i){const o=this.makeTensorInfo(t.outputShape,r),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===U0.DENSE){const y=i??Ok(t.outputShape);l.texShape=y.map(b=>b*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),ve(o.shape)===0)return l.values=Is(o.dtype,0),o;const u=[],c=n.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!t.packedInputs&&ve(y.shape)<=xe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!t.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),u.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!eC(b.shape,y.shape)){const x=y,w=y.shape;y.shape=b.shape,y=this.packedReshape(y,w),u.push(y),b=this.texData.get(y.dataId),x.shape=w}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(o.dataId);const d={shape:o.shape,texData:l,isUniform:!1},h=Ipt(t,c,d),p=this.getAndSaveBinary(h,()=>vpt(this.gpgpu,t,c,d)),f=this.activeTimers!=null;let m;f&&(m=this.startTimer()),xe().get("ENGINE_COMPILE_ONLY")||kpt(this.gpgpu,p,c,d,s),u.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(m=this.endTimer(m),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(m)}));const g=xe().get("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=ya();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!xe().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&a===!1){const y=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),y}return o}compileAndRun(t,n,r,s,a=!1){return r=r||n[0].dtype,this.runWebGLProgram(t,n,r,s,a)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(xe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ge(()=>{if(!xe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=xe().getBool("DEBUG");xe().set("DEBUG",!1);const n=this.abs(bt(1e-8)).dataSync()[0];if(xe().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?nmt:rmt}uploadToGPU(t){const n=this.texData.get(t),{shape:r,dtype:s,values:a,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;const u=this.activeTimers!=null;let c;u&&(c=ya());let d=n.texShape;if(d==null&&(d=_ht(r,l),n.texShape=d),a!=null){const h=Pk(r);let p,f=d[1],m=d[0];const g=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(l||!g)&&([f,m]=Ob(d[0],d[1])),l?p=new _pt(h,g):p=new yH(h,g);const y=g?[m,f]:d,b=this.makeTensorInfo(y,s),x=this.texData.get(b.dataId);g?x.usage=Ii.PIXELS:x.usage=Ii.UPLOAD,x.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),f,m,a);const w=[[m,f]],v=!0,k=this.runWebGLProgram(p,[b],s,w,v),I=this.texData.get(k.dataId);n.texShape=I.texShape,n.isPacked=I.isPacked,n.usage=I.usage,xe().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(n.texture=I.texture,n.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo(b),u&&(this.uploadWaitMs+=ya()-c)}else{const h=this.acquireTexture(d,o,s,l);n.texture=h}}convertAndCacheOnCPU(t,n){const r=this.texData.get(t),{dtype:s}=r;return n!=null&&(r.values=lmt(n,s)),r.values}acquireTexture(t,n,r,s){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,s)}computeBytes(t,n){return t[0]*t[1]*$S(n)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(a){throw a}});t.push(r)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await bte(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(gae(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){const{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=vae(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=r,t.infLoc=s,t.nanLoc=a,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,r){t.channels=t.channels||"RGBA";const{texture:s,height:a,width:i,channels:o}=t,l=xl().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(s,n,r,a,i,o);return xl().makeTensorFromDataId(u,n,r,l)}}pT.nextDataId=0;function lmt(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){const n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */TQ()&&GQ("webgl",()=>new pT,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s4=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class jg{constructor(t,n,r){this.variableNames=["A","B"],this.outputShape=Nt(n,r),this.enableShapeUniforms=Bs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const em=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Cv{constructor(t,n,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Nt(n,r);const a=this.outputShape.length;this.enableShapeUniforms=Bs(a);let i="";if(s)if(a===0||ve(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Nn(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Zs("coords",a);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ai(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const umt={kernelName:$1,backendName:"webgl",kernelFunc:ai};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vd(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=ai({inputs:{x:r},backend:n}),l=ai({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const cmt={kernelName:lP,backendName:"webgl",kernelFunc:Vd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rae="return (a < 0.) ? b * a : a;",Dae=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function dmt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",Rd(a,"float32")),o=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Cv(Dae,s.shape,i.shape):new jg(Rae,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}const hmt={kernelName:j2,backendName:"webgl",kernelFunc:dmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fae="return (a < 0.) ? b * a : a;",Oae=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function pmt(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Cv(Oae,r.shape,s.shape):new jg(Fae,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}const fmt={kernelName:d$,backendName:"webgl",kernelFunc:pmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bb="if (isnan(x)) return x;";function Qt({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,o=a,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){const d=o.texData.get(i.dataId),h=n(d.values,l);return o.makeTensorInfo(i.shape,l,h)}const u=xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let c;return u?c=new kc(i.shape,t):c=new Al(i.shape,e),o.runWebGLProgram(c,[i],l)}}function _s({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{const{a:l,b:u}=i,c=o;if(r&&l.dtype==="complex64"){const f=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(x=>{const[w,v]=x,k={dataId:w.dataId,dtype:w.dtype,shape:l.shape},I={dataId:v.dataId,dtype:v.dtype,shape:u.shape},S=new jg(e,l.shape,u.shape);return c.runWebGLProgram(S,[k,I],ni(w.dtype,v.dtype))}),b=Vd({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}const d=a||ni(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&s!=null){const f=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,g=l.dtype==="string"?zu(f):f,y=l.dtype==="string"?zu(m):m,[b,x]=s(l.shape,u.shape,g,y,d),w=c.makeTensorInfo(x,d),v=c.texData.get(w.dataId);return v.values=b,w}const h=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let p;return h?p=new Cv(t,l.shape,u.shape,n):p=new jg(e,l.shape,u.shape),c.runWebGLProgram(p,[l,u],d)}}function G0(e,t=!1){if(e==="linear")return t?Xft:Gft;if(e==="relu")return t?Zft:jft;if(e==="elu")return t?Yft:Hft;if(e==="relu6")return t?Jft:qft;if(e==="prelu")return t?Oae:Fae;if(e==="leakyrelu")return t?Dae:Rae;if(e==="sigmoid")return t?Qft:Kft;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mae{constructor(t,n,r,s=!1,a=!1,i=!1,o=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Bs(this.outputShape.length);const c=s?t[1]:t[2],d=Math.ceil(c/2),h=s?"i * 2, rc.y":"rc.y, i * 2",p=a?"rc.z, i * 2":"i * 2, rc.z",f=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";o&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:u?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:g=`vec4 activation(vec4 x) {
          ${o}
        }`,y="result = activation(result);");const b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let x="rc.x",w="rc.x";t[0]<n[0]?x=`imod(rc.x, ${t[0]})`:n[0]<t[0]&&(w=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x};
        int batchB = ${w};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kH={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class IH{constructor(t,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Nt(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SH="return a * b;";function a4(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=ni(r.dtype,s.dtype);if(r.dtype==="complex64"){const o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),u=new IH(kH.REAL,r.shape,s.shape),c=new IH(kH.IMAG,r.shape,s.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=n.runWebGLProgram(u,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=Vd({inputs:{real:h,imag:p},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([r,s])){const o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[u,c]=pft(r.shape,s.shape,o.values,l.values,a),d=n.makeTensorInfo(c,a),h=n.texData.get(d.dataId);return h.values=u,d}let i;return xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Cv(SH,r.shape,s.shape):i=new jg(SH,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const mmt={kernelName:M1,backendName:"webgl",kernelFunc:a4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gmt(e,t,n){const r=[Gg(e.shape),...Hg(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[Gg(t),...Hg(t)],i=new Aae(a,r),o=!0,l=[r],u=n.runWebGLProgram(i,[s],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function We(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=ve(s.shape),l=iQ(a,o),u=ve(l);U(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return c.isPacked&&!eC(s.shape,l)&&!(c.texture!==null&&eC(c.shape,l))?gmt(s,l,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const ymt={kernelName:p$,backendName:"webgl",kernelFunc:We};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CH{constructor(t,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:a,outSize:i}=t;this.outputShape=[s,i];const o=Math.floor(r/4)*4,l=r%4;let u="sumValue += dot(values, ones);";if(n!=null){const d=1/n;u=`sumValue += dot(values * ${Rg(d)?d.toPrecision(2):d}, ones);`}let c="";a%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bmt{constructor(t,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:a,outSize:i}=t;this.outputShape=[s,i];let o="0.0",l="";n==="prod"?o="1.0":n==="min"?(o="1.0 / 1e-20",l="min"):n==="max"&&(o="-1.0 / 1e-20",l="max");let u=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?u="sumValue":n==="prod"?u="prodValue":n==="all"?u="allValue":n==="any"&&(u="anyValue");const c=Math.floor(r/4)*4,d=r%4;let h=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";n==="all"?(o="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):n==="any"&&(o="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";a%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${d===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${d===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xmt(e){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const n=t.length?t[t.length-1].outSize:e[1],r=Z$(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function tm(e,t,n,r){const s=xmt(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:l,outSize:u}=s[i];let c,d;n==="mean"?c=i===0?new CH({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new CH({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):c=new bmt({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=a,a=r.runWebGLProgram(c,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wmt{constructor(t,n){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[n[i]];this.outputShape=r,this.rank=r.length;const s=Nn(this.rank),a=vmt(n);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}function vmt(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kmt{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let c=0;c<r.length;c++)r[c]=t[n[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Nn(this.rank),a=Eae("rc",this.rank),i=new Array(this.rank);for(let c=0;c<n.length;c++)i[n[c]]=a[c];const o=`vec2(${i.slice(-2).join()})`,l=`++${a[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fT(e,t,n){const r=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kmt(e.shape,t):new wmt(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Imt(e,t,n,r){const s=t,a=e.shape.length,i=Bt(s,e.shape);let o=i;const l=lr(o,a),u=l!=null;let c=e;u&&(c=fT(e,l,r),o=wr(o.length,a)),$s("sum",o,a);const[d,h]=ds(c.shape,o);let p=d;n&&(p=br(d,i));const f=ve(h),g=ve(e.shape)/f,y=We({inputs:{x:c},attrs:{shape:[g,f]},backend:r}),b=oz(e.dtype),x=tm(y,b,"sum",r),w=We({inputs:{x},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),u&&r.disposeIntermediateTensorInfo(c),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mT(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return Imt(s,a,i,n)}const Smt={kernelName:x$,backendName:"webgl",kernelFunc:mT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aa(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=s.shape[a[c]];let u;if(i.shouldExecuteOnCPU([s])){const d=i.texData.get(s.dataId).values,h=r4(d,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype);const p=i.texData.get(u.dataId);p.values=h}else u=fT(s,a,i);return u}const Cmt={kernelName:qm,backendName:"webgl",kernelFunc:aa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lae=1e3;function tC({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const u=e.shape.length,c=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],h=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=ve(m),b=ve(g),w=Nt(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);U(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);const v=n?[y,d,p]:[y,p,d],k=r?[b,f,h]:[b,h,f],I=We({inputs:{x:e},backend:s,attrs:{shape:v}}),S=We({inputs:{x:t},backend:s,attrs:{shape:k}}),$=[I,S],N=Math.max(y,b),T=n?I.shape[1]:I.shape[2],C=a!=null,E=i!=null,M=l==="leakyrelu",F=l!=null?G0(l,!0):null,z=C||E||M||F!=null;let H;if((p===1||f===1)&&T>Lae&&z===!1){let O=I,L=S;n&&(O=aa({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),$.push(O)),r&&(L=aa({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),$.push(L));const V=f!==1,q=f===1;let B=O;V&&(B=We({inputs:{x:O},backend:s,attrs:{shape:[N,T,1]}}),$.push(B));const X=f===1?2:1;let ee=L;q&&(ee=We({inputs:{x:L},backend:s,attrs:{shape:[N,1,T]}}),$.push(ee));const Z=a4({inputs:{a:B,b:ee},backend:s});H=mT({inputs:{x:Z},backend:s,attrs:{axis:X,keepDims:!0}}),$.push(Z)}else{const O=ni(e.dtype,t.dtype),L=new Mae(v,k,[N,p,f],n,r,C,F,E,M),V=[I,S];if(a!=null&&V.push(a),E&&V.push(i),M){const q=s.makeTensorInfo([],"float32",Rd(o,"float32"));V.push(q),$.push(q)}H=s.runWebGLProgram(L,V,O)}const P=We({inputs:{x:H},backend:s,attrs:{shape:w}});$.push(H);for(const O of $)s.disposeIntermediateTensorInfo(O);return P}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nmt(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return tC({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}const $mt={kernelName:TS,backendName:"webgl",kernelFunc:Nmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NH="return abs(x);";function Tmt(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const a=n.texData.get(r.dataId),i=Tae(a.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new kc(r.shape,NH):s=new Al(r.shape,NH),n.runWebGLProgram(s,[r],r.dtype)}const _mt={kernelName:C2,backendName:"webgl",kernelFunc:Tmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Emt=$o+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Amt=Qt({opSnippet:Emt}),Rmt={kernelName:o1,backendName:"webgl",kernelFunc:Amt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dmt=$o+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Fmt=Qt({opSnippet:Dmt}),Omt={kernelName:l1,backendName:"webgl",kernelFunc:Fmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $H="return a + b;",Mmt=_s({opSnippet:$H,packedOpSnippet:$H,supportsComplex:!0,cpuKernelImpl:qpt}),Lmt={kernelName:$b,backendName:"webgl",kernelFunc:Mmt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pmt{constructor(t,n){this.outputShape=[],this.outputShape=t,this.variableNames=n.map((a,i)=>`T${i}`);const r=[];this.variableNames.forEach(a=>{r.push(`float v${a} = get${a}AtOutCoords();`)});const s=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zmt{constructor(t,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=n.map((a,i)=>`T${i}`);const r=[];this.variableNames.forEach(a=>{r.push(`vec4 v${a} = get${a}AtOutCoords();`)});const s=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bI(e){const{inputs:t,backend:n}=e,r=t;if(r.length===1)return ai({inputs:{x:r[0]},backend:n});if(r.length>xe().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),u=bI({inputs:r.slice(0,l),backend:n}),c=bI({inputs:r.slice(l),backend:n});return bI({inputs:[u,c],backend:n})}const s=r.map(l=>l.dtype).reduce((l,u)=>ni(l,u)),a=r.map(l=>l.shape),o=xe().getBool("WEBGL_PACK")?new zmt(r[0].shape,a):new Pmt(r[0].shape,a);return n.runWebGLProgram(o,r,s)}const Bmt={kernelName:N2,backendName:"webgl",kernelFunc:bI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wmt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Bt(a,s.shape);let u=l;const c=lr(u,o);let d=s;c!=null&&(d=aa({inputs:{x:s},backend:n,attrs:{perm:c}}),u=wr(u.length,o)),$s("all",u,o);const[h,p]=ds(d.shape,u),f=ve(p),m=We({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=tm(m,m.dtype,"all",n);let y;if(i){const b=br(h,l);y=We({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=We({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}const Vmt={kernelName:nP,backendName:"webgl",kernelFunc:Wmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Umt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Bt(a,s.shape);let u=l;const c=lr(u,o);let d=s;c!=null&&(d=aa({inputs:{x:s},backend:n,attrs:{perm:c}}),u=wr(u.length,o)),$s("any",u,o);const[h,p]=ds(d.shape,u),f=ve(p),m=We({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=tm(m,m.dtype,"any",n);let y;if(i){const b=br(h,l);y=We({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=We({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}const Gmt={kernelName:rP,backendName:"webgl",kernelFunc:Umt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hmt{constructor(t,n,r){this.variableNames=["A"];const{windowSize:s,batchSize:a,outSize:i}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[a,i];const o=n==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jmt{constructor(t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,U(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const a=t[t.length-1],i=Math.ceil(a/n);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,u=Nn(l),c=Zs("coords",l);let d,h;if(i===1){h=l+1;const S=Nn(h);d=`
        ${S} sourceLocR = ${S}(${c.join()}, 0);
        ++${c[l-1]};
        ${S} sourceLocG = ${S}(${c.join()}, 0);
        ++${c[l-2]};
        ${S} sourceLocA = ${S}(${c.join()}, 0);
        --${c[l-1]};
        ${S} sourceLocB = ${S}(${c.join()}, 0);
        --${c[l-2]};`}else h=l,d=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],m=p.map(S=>"int "+S),g=Zs("sourceLocR",h-1).concat("inIdx.r"),y=Zs("sourceLocG",h-1).concat("inIdx.g"),b=Zs("sourceLocB",h-1).concat("inIdx.b"),x=Zs("sourceLocA",h-1).concat("inIdx.a"),w=r==="max"?"greaterThan":"lessThan",v=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${x.join()})));`,k=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,I=s?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${I}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${o[l-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pae(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];r!=null&&(s=r.shape[0],a=r.shape[1]);const i=Z$(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new Hmt(o,n,r==null),u=[t];r!=null&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const d=Pae(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function zae(e,t,n,r=null){const s=r!=null?r.shape:t.shape,a=s[s.length-1],i=Z$(a),o=new jmt(s,i,n,r==null),l=r==null?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){const c=zae(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}return u}function Bae(e,t,n,r){const s=[n];if($s("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!xe().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const a=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked;let l=t;o&&(l=e.unpackTensor(t),a.push(l));const[u,c]=ds(l.shape,s),d=ve(c),h=We({inputs:{x:l},backend:e,attrs:{shape:[-1,d]}});a.push(h);const p=Pae(e,h,r);a.push(p);const f=We({inputs:{x:p},backend:e,attrs:{shape:u}});return a.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return zae(e,t,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qmt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Bt(a,s.shape);const o=lr(i,s.shape.length);let l=s;const u=[];o!=null&&(l=aa({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=wr(i.length,l.shape.length)),$s("argMax",[i[0]],l.shape.length);const c=Bae(n,l,i[0],"max");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const Kmt={kernelName:$2,backendName:"webgl",kernelFunc:qmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xmt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Bt(a,s.shape);const o=lr(i,s.shape.length);let l=s;const u=[];o!=null&&(l=aa({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=wr(i.length,l.shape.length)),$s("argMin",[i[0]],l.shape.length);const c=Bae(n,l,i[0],"min");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const Ymt={kernelName:T2,backendName:"webgl",kernelFunc:Xmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zmt=$o+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Jmt=Qt({opSnippet:Zmt}),Qmt={kernelName:u1,backendName:"webgl",kernelFunc:Jmt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const egt=$o+"return log(x + sqrt(x * x + 1.0));",tgt=Qt({opSnippet:egt}),ngt={kernelName:c1,backendName:"webgl",kernelFunc:tgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rgt=$o+`
  return atan(x);
`,sgt=Qt({opSnippet:rgt}),agt={kernelName:d1,backendName:"webgl",kernelFunc:sgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const igt=s4+`
  return atan(a, b);
`,ogt=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+em+`
  return result;
`,lgt=_s({opSnippet:igt,packedOpSnippet:ogt}),ugt={kernelName:p1,backendName:"webgl",kernelFunc:lgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cgt=$o+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,dgt=Qt({opSnippet:cgt}),hgt={kernelName:h1,backendName:"webgl",kernelFunc:dgt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H0{constructor(t,n,r,s=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.top,f=t.padInfo.left;this.outputShape=t.outShape;const m=n==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,y=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let b="0.0";if(m||(b="-1.0 / 1e-20"),r){const S=">=";this.userCode=`
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${S} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?a?g:y:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const x="max";let w=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(w="avgValue / max(count, 1.0)");const v=Math.floor(i/4)*4,k=i%4,I=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${I}
          }

          int xC = xCCorner + ${v};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${I}
          }
        }
        setOutput(${w});
      }
    `}}class i4{constructor(t,n,r,s=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,d=t.dilationHeight,h=t.dilationWidth,p=t.effectiveFilterDepth,f=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const x=n==="avg";let w="0.0";if(x||(w="-1.0 / 1e-20"),r){const N=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${l}, ${u});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${N} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?a?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const v="max";let k=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(k="avgValue / max(count, 1.0)");const I=Math.floor(i/4)*4,S=i%4,$=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${l}, ${u});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${I}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${$}
            }

            int xC = xCCorner + ${I};
            if (${S===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${$}
            } else if (${S===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${$}
            } else if (${S===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${$}
            }
          }
        }
        setOutput(${k});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pgt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Iv(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;U(Ns(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Co(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&Xt(c.inShape,c.outShape))return ai({inputs:{x:s},backend:n});const d=new H0(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}const fgt={kernelName:_2,backendName:"webgl",kernelFunc:pgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mgt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],d=qu(s.shape,a,i,c,o,l,u),h=new i4(d,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}const ggt={kernelName:E2,backendName:"webgl",kernelFunc:mgt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ygt{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,a=t.strideWidth,i=t.dilationHeight,o=t.dilationWidth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=l-1-t.padInfo.top,d=u-1-t.padInfo.left,h=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${d});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class bgt{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterDepth,r=t.filterHeight,s=t.filterWidth,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,p=t.effectiveFilterWidth,f=d-1-t.padInfo.front,m=h-1-t.padInfo.top,g=p-1-t.padInfo.left,y=1/(n*r*s);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xgt(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],h=qu(i.shape,o,l,d,u,c),p=new bgt(h);return n.runWebGLProgram(p,[s],i.dtype)}const wgt={kernelName:aP,backendName:"webgl",kernelFunc:xgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vgt(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;Iv([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=Co(i.shape,o,l,1,u),d=new ygt(c);return n.runWebGLProgram(d,[s],i.dtype)}const kgt={kernelName:sP,backendName:"webgl",kernelFunc:vgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Igt(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return tC({a:s,b:a,transposeA:i,transposeB:o,backend:n})}const Sgt={kernelName:A2,backendName:"webgl",kernelFunc:Igt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cgt{constructor(t,n,r,s,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],Nt(t,n),Nt(t,r);let o="0.0";s!=null&&(Nt(t,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";a!=null&&(Nt(t,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ngt{constructor(t,n,r,s,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Nt(t,n),Nt(t,r);let o="vec4(0.0)";s!=null&&(Nt(t,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";a!=null&&(Nt(t,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $gt=({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:o}=e;U(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const u=[r,s,a];let c=null;i!=null&&(c=i.shape,u.push(i));let d=null;o!=null&&(d=o.shape,u.push(o));const h=xe().getBool("WEBGL_PACK_NORMALIZATION")?new Ngt(r.shape,s.shape,a.shape,c,d,l):new Cgt(r.shape,s.shape,a.shape,c,d,l);return t.runWebGLProgram(h,u,u[0].dtype)},Tgt={kernelName:U2,backendName:"webgl",kernelFunc:$gt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _gt{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const n=Nn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=Egt(this.rank);let s;const a=t.map((i,o)=>`sourceLoc.${cD[o]} = start[${o}] + coords.${cD[o]};`);s=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const cD=["x","y","z","w","u","v"];function Egt(e){if(e===1)return"sourceLoc";if(e<=6)return cD.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Agt{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Nn(this.rank),r=Zs("coords",this.rank),s=Zs("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${a})`,o=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${i};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${n}(${t.map((c,d)=>`start[${d}]`).join()});`:t.map((c,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rgt(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=eB(t,yt(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}function Wb(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=Y$(s,a,i);if(Zz(s,o,l),ve(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){const d=n.texData.get(s.dataId),h=Sft(d.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,h)}const{isPacked:u}=n.texData.get(s.dataId),c=Qz(s.shape,o,l);if(u||!c){const d=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Agt(l):new _gt(l),h=[o];return n.runWebGLProgram(d,[s],s.dtype,h)}return n.uploadToGPU(s.dataId),Rgt(s,o,l,n)}const Dgt={kernelName:b$,backendName:"webgl",kernelFunc:Wb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fgt=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;U(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((b,x)=>b*x),l=cv(s.shape,a,o),u=dv(l.length,a.length),c=hv(s.shape,a,o),d=aB(i,a.length),h=iB(c,i,a.length),p=[],f=We({inputs:{x:s},backend:n,attrs:{shape:l}}),m=aa({inputs:{x:f},backend:n,attrs:{perm:u}}),g=We({inputs:{x:m},backend:n,attrs:{shape:c}}),y=Wb({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},Ogt={kernelName:R2,backendName:"webgl",kernelFunc:Fgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mgt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=$ae(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}const Lgt={kernelName:iP,backendName:"webgl",kernelFunc:Mgt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pgt(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=Nt(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const zgt={kernelName:oP,backendName:"webgl",kernelFunc:Pgt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bgt="return float(a != b);",Wae=_s({opSnippet:Bgt,cpuKernelImpl:mft,dtype:"bool"}),Wgt={kernelName:i$,backendName:"webgl",kernelFunc:Wae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nv(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return ai({inputs:{x:s.complexTensorInfos.real},backend:n})}const Vgt={kernelName:BP,backendName:"webgl",kernelFunc:Nv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ugt="return float(int(x));";function Ggt(e,t){const n=new Al(e.shape,Ugt),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dD(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return ai({inputs:{x:s},backend:n});const i=Fr(s.shape),o=dD({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Vd({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(s.dtype==="complex64"){const i=Nv({inputs:{input:s},backend:n}),o=dD({inputs:{x:i},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(i),o}if(!oQ(s.dtype,a)){const i=ai({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(n.shouldExecuteOnCPU([s])){const i=n.texData.get(s.dataId).values,[o,l,u]=Xpt(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}if(a==="int32")return Ggt(s,n);if(a==="bool"){const i=n.makeTensorInfo([],"bool",Is("bool",1)),l=Wae({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}const Hgt={kernelName:f1,backendName:"webgl",kernelFunc:dD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TH="return ceil(x);",jgt=Qt({opSnippet:TH,packedOpSnippet:TH,cpuKernelImpl:Ypt}),qgt={kernelName:m1,backendName:"webgl",kernelFunc:jgt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kgt{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xgt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ygt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;xe().getBool("WEBGL_PACK_CLIP")?o=new Xgt(s.shape):o=new Kgt(s.shape);const l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}const Zgt={kernelName:g1,backendName:"webgl",kernelFunc:Ygt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jgt{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _H(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function Qgt(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new Jgt(r.shape),i=[_H(r,s.complexTensorInfos.real),_H(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}const eyt={kernelName:D2,backendName:"webgl",kernelFunc:Qgt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tyt{constructor(t){this.outputShape=[],this.outputShape=Bl(t,1),this.variableNames=t.map((i,o)=>`T${o}`);const n=new Array(t.length-1);n[0]=t[0][1];for(let i=1;i<n.length;i++)n[i]=n[i-1]+t[i][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<n.length;i++){const o=n[i-1];r.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${o}));`)}const s=n.length,a=n[n.length-1];r.push(`else setOutput(getT${s}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nyt{constructor(t,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Bl(t,n);const r=this.outputShape,s=r.length,a=Nn(s),i=Zs("coords",s),o=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((m,g)=>`T${g}`);const l=new Array(t.length-1);l[0]=t[0][n];for(let m=1;m<l.length;m++)l[m]=l[m-1]+t[m][n];const u=o[n],c=o.slice(-2),d=o.join();let h=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${c.join()}));
        }`;for(let m=1;m<l.length;m++){const g=l[m-1];h+=`
        if (${u} < ${l[m]}  && ${u} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${Wk(o,u,g)}),
            vec2(${Wk(c,u,g)}));
        }`}const p=l.length,f=l[l.length-1];h+=`
        return getChannel(
          getT${p}(${Wk(o,u,f)}),
          vec2(${Wk(c,u,f)}));`,this.userCode=`
      float getValue(${o.map(m=>"int "+m)}) {
        ${h}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[s-1]} = ${i[s-1]} + 1;
        if (${i[s-1]} < ${r[s-1]}) {
          result.g = getValue(${i});
        }

        ${i[s-2]} = ${i[s-2]} + 1;
        if (${i[s-2]} < ${r[s-2]}) {
          result.a = getValue(${i});
        }

        ${i[s-1]} = ${i[s-1]} - 1;
        if (${i[s-2]} < ${r[s-2]} &&
            ${i[s-1]} < ${r[s-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function Wk(e,t,n){const r=e.indexOf(t);return e.map((a,i)=>i===r?`${a} - ${n}`:a).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gT(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return ai({inputs:{x:s.complexTensorInfos.imag},backend:n})}const ryt={kernelName:NP,backendName:"webgl",kernelFunc:gT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _x(e,t,n){const r=e[0].dtype;if(r==="complex64"){const p=e.map(b=>Nv({inputs:{input:b},backend:n})),f=e.map(b=>gT({inputs:{input:b},backend:n})),m=_x(p,t,n),g=_x(f,t,n),y=Vd({inputs:{real:m,imag:g},backend:n});return p.forEach(b=>n.disposeIntermediateTensorInfo(b)),f.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){const p=e.map(w=>{const k=[-1,ve(w.shape.slice(t))];return We({inputs:{x:w},backend:n,attrs:{shape:k}})}),f=p.map(w=>({vals:n.readSync(w.dataId),shape:w.shape})),m=Bl(p.map(w=>w.shape),1),g=p[0].shape[0]===1,y=Zpt(f,m,r,g),b=Bl(e.map(w=>w.shape),t),x=n.makeTensorInfo(b,r,y);return p.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}const a=e.filter(p=>ve(p.shape)>0),i=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){const p=i?new Al(e[0].shape,uc):new kc(e[0].shape,uc);return n.runWebGLProgram(p,e,r)}const o=xe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const p=[];for(let m=0;m<a.length;m+=o){const g=a.slice(m,m+o);p.push(_x(g,t,n))}const f=_x(p,t,n);for(const m of p)n.disposeIntermediateTensorInfo(m);return f}if(i){const p=new nyt(a.map(f=>f.shape),t);return n.runWebGLProgram(p,a,r)}const{tensors2D:l,outShape:u}=syt(a,t,n),c=new tyt(l.map(p=>p.shape)),d=n.runWebGLProgram(c,l,r);l.forEach(p=>n.disposeIntermediateTensorInfo(p));const h=We({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function syt(e,t,n){const r=Bl(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>We({inputs:{x:a},attrs:{shape:[-1,ve(a.shape.slice(t))]},backend:n})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vae(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Bt(s,t[0].shape)[0],i=t.map(u=>u.shape);nB(i,a);const o=Bl(t.map(u=>u.shape),a);if(ve(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter(u=>ve(u.shape)>0);return l.length===1?ai({inputs:{x:l[0]},backend:n}):_x(l,a,n)}const ayt={kernelName:F2,backendName:"webgl",kernelFunc:Vae};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uae{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,o=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,d=t.dilationWidth,h=t.filterHeight,p=t.filterWidth,f=Math.floor(t.inChannels/4)*4,m=t.inChannels%4,g=t.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,x=g?3:1;let w="",v="";r&&(s?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:w=`
          float activation(float x) {
            ${r}
          }
        `,v="result = activation(result);");const k=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${v}
        setOutput(result);
      }
    `}}class iyt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const n=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,d=t.filterDepth,h=t.filterHeight,p=t.filterWidth,f=Math.floor(t.inChannels/4)*4,m=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${i}, ${o});
      const ivec3 pads = ivec3(${n}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gae{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Bs(this.outputShape.length);const i=t.padInfo.left,o=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,d=c;let h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)h+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;h+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)h+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(d+1)/2;g++){const y=g*2;if(h+=`
           xC = xCCorner + ${y*l};
           `,o===1){if(y<c&&(i%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?h+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){const b=i%2===0?QL(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:h+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?h+=`
                     xC${y+1} = xTexelC${y};
                     `:h+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(i%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(h+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(h+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(h+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let p="",f="";r&&(s?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:a?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:p=`vec4 activation(vec4 x) {
           ${r}
         }`,f="result = activation(result);");const m=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oyt{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Bs(this.outputShape.length);const{dataFormat:r}=n,s=da(),a=r==="channelsLast",i=a?1:2,o=a?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)u+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nC(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function Hae({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],h=n.outChannels,p=n.dataFormat==="channelsLast",f=!1,m=!1;let g;const y=[];if(a!=null){const w=nC(a.shape,p);w!=null&&(a=We({inputs:{x:a},backend:r,attrs:{shape:w}}),y.push(a))}if(s!=null){const w=nC(s.shape,p);w!=null&&(s=We({inputs:{x:s},backend:r,attrs:{shape:w}}),y.push(s))}if(!((d===1||h===1)&&c>Lae)&&u.isPacked&&p&&u.texture!=null&&l[2]%2!==0&&Xt(u.shape.slice(-3),l.slice(-3))){const w=l[0]*l[1]*(l[2]+1),v={dataId:e.dataId,shape:[1,w,n.inChannels],dtype:e.dtype},k=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,U(eC(u.shape,v.shape),()=>`packed reshape ${u.shape} to ${v.shape} isn't free`);const I=We({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(I);const S=tC({a:v,b:I,backend:r,transposeA:f,transposeB:m,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),$=r.texData.get(S.dataId);U($.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=k,$.shape=n.outShape,g=ai({inputs:{x:S},backend:r}),g.shape=n.outShape,y.push(S)}else{const w=n.outHeight*n.outWidth,v=We({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,w,n.inChannels]:[n.batchSize,n.inChannels,w]}}),k=We({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),I=tC({a:p?v:k,b:p?k:v,transposeA:!p,transposeB:m,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});g=We({inputs:{x:I},backend:r,attrs:{shape:n.outShape}}),y.push(v),y.push(k),y.push(I)}for(const w of y)r.disposeIntermediateTensorInfo(w);return g}function jae({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=n,f=p==="channelsLast",m=l*u*c,g=h*d,y=[n.batchSize,m,g],b=!0,x=!1,w=[];if(a!=null){const P=nC(a.shape,f);P!=null&&(a=We({inputs:{x:a},backend:r,attrs:{shape:P}}),w.push(a))}if(s!=null){const P=nC(s.shape,f);P!=null&&(s=We({inputs:{x:s},backend:r,attrs:{shape:P}}),w.push(s))}const v=We({inputs:{x:t},backend:r,attrs:{shape:[1,m,ve(t.shape)/m]}});w.push(v);const k=new oyt(y,n),I=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],S=r.runWebGLProgram(k,[e],"float32",I),$=We({inputs:{x:S},backend:r,attrs:{shape:y}});w.push(S),w.push($);const N=s!=null,T=a!=null,C=o==="leakyrelu",E=o?G0(o,!0):null,M=new Mae(f?$.shape:v.shape,f?v.shape:$.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],b,x,N,E,T,C),F=f?[$,v]:[v,$];if(s&&F.push(s),T&&F.push(a),C){const P=r.makeTensorInfo([],"float32",Rd(i,"float32"));F.push(P),w.push(P)}const z=r.runWebGLProgram(M,F,"float32"),H=We({inputs:{x:z},backend:r,attrs:{shape:n.outShape}});w.push(z);for(const P of w)r.disposeIntermediateTensorInfo(P);return H}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lyt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=Ku(l),h=cs(s.shape,a.shape,i,u,o,c,!1,d);let p;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID"))p=Hae({x:s,filter:a,convInfo:h,backend:n});else if(h.strideWidth<=2&&d==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){const m=new Gae(h),g=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(m,[s,a],"float32",g)}else if(xe().getBool("WEBGL_CONV_IM2COL"))p=jae({x:s,filter:a,convInfo:h,backend:n});else{const m=new Uae(h);p=n.runWebGLProgram(m,[s,a],"float32")}const f=We({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}const uyt={kernelName:O2,backendName:"webgl",kernelFunc:lyt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cyt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,r=t.strideWidth,s=t.padInfo.top,a=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class dyt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,a=t.strideWidth,i=t.dataFormat==="channelsLast",o=n-1-t.padInfo.top,l=r-1-t.padInfo.left,u=i?1:2,c=i?2:3,d=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class hyt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideDepth,r=t.strideHeight,s=t.strideWidth,a=t.padInfo.front,i=t.padInfo.top,o=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${a};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${o};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class pyt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterDepth,r=t.filterHeight,s=t.filterWidth,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,l=n-1-t.padInfo.front,u=r-1-t.padInfo.top,c=s-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fyt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=Ku(l),h=cs(s.shape,c,i,1,o,u,!1,d),p=new cyt(h);return n.runWebGLProgram(p,[s,a],"float32")}const myt={kernelName:uP,backendName:"webgl",kernelFunc:fyt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gyt{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=Bs(this.outputShape.length);const n=t.filterHeight,r=t.filterWidth,s=n-1-t.padInfo.top,a=r-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yyt(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=Ku(u),h=cs(i,a.shape,o,1,l,c,!1,d);if(xe().getBool("WEBGL_PACK")&&d==="channelsLast"){const p=[[h.strideHeight,h.strideWidth]],f=new gyt(h);return n.runWebGLProgram(f,[s,a],"float32",p)}else{const p=new dyt(h);return n.runWebGLProgram(p,[s,a],"float32")}}const byt={kernelName:M2,backendName:"webgl",kernelFunc:yyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xyt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=Od(s.shape,a.shape,i,l,o),c=new iyt(u);return n.runWebGLProgram(c,[s,a],"float32")}const wyt={kernelName:L2,backendName:"webgl",kernelFunc:xyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vyt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=Od(s.shape,l,i,1,o),c=new hyt(u);return n.runWebGLProgram(c,[s,a],"float32")}const kyt={kernelName:cP,backendName:"webgl",kernelFunc:vyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iyt(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=Od(l,a.shape,o,1,i),c=new pyt(u);return n.runWebGLProgram(c,[s,a],"float32")}const Syt={kernelName:dP,backendName:"webgl",kernelFunc:Iyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cyt=Bb+`
  return cos(x);
`,Nyt=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${em}
  return result;
`,$yt=Qt({opSnippet:Cyt,packedOpSnippet:Nyt}),Tyt={kernelName:y1,backendName:"webgl",kernelFunc:$yt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _yt=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Eyt=Qt({opSnippet:_yt}),Ayt={kernelName:b1,backendName:"webgl",kernelFunc:Eyt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ryt{constructor(t,n,r,s,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,o,l,u]=t,[c]=n,[d,h]=r;this.outputShape=[c,d,h,u];const p=s==="bilinear"?1:0,[f,m]=[`${o-1}.0`,`${l-1}.0`],[g,y,b]=d>1?[`${(o-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[x,w,v]=h>1?[`${(l-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dyt=e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new Ryt(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")},Fyt={kernelName:pP,backendName:"webgl",kernelFunc:Dyt};var j0;(function(e){e.Prod="*",e.Sum="+"})(j0||(j0={}));class EH{constructor(t,n,r,s){this.op=t,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,i=this.op===j0.Prod?"1.0":"0.0",o=r?i:`getX(${AH(a,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";r?(u=s?`end != ${l-1}`:"end != 0",c=s?"end + 1":"end - 1"):(u=s?`end + pow2 < ${l}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Nn(a)} coords = getOutputCoords();
        int end = ${RH(a,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${RH(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${AH(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function AH(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function RH(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qae(e,t,n,r,s,a){const i=t.shape.length,o=lr([r],i);let l=t;o!=null&&(l=aa({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=wr(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=ai({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const p=new EH(e,l.shape,!1,a),f=[[h]],m=d;d=n.runWebGLProgram(p,[d],d.dtype,f),n.disposeIntermediateTensorInfo(m)}if(s){const h=new EH(e,l.shape,s,a),p=d;d=n.runWebGLProgram(h,[d],d.dtype),n.disposeIntermediateTensorInfo(p)}if(o!=null){const h=Md(o),p=aa({inputs:{x:d},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),p}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oyt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return qae(j0.Prod,s,n,a,i,o)}const Myt={kernelName:hP,backendName:"webgl",kernelFunc:Oyt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lyt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return qae(j0.Sum,s,n,a,i,o)}const Pyt={kernelName:P2,backendName:"webgl",kernelFunc:Lyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zyt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){const l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=$ae(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){const l=n.bufferSync(s),u=n.bufferSync(a),c=Kpt(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const Byt={kernelName:fP,backendName:"webgl",kernelFunc:zyt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wyt{constructor(t,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vyt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],u=i==="NHWC"?s.shape[2]:s.shape[3],c=i==="NHWC"?s.shape[3]:s.shape[1],d=l*a,h=u*a,p=c/(a*a),f=i==="NHWC"?[o,d,h,p]:[o,p,d,h],m=new Wyt(f,a,i);return n.runWebGLProgram(m,[s],s.dtype)}const Uyt={kernelName:mP,backendName:"webgl",kernelFunc:Vyt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kae{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Bs(this.outputShape.length);const i=t.filterHeight,o=t.filterWidth,l=t.outChannels/t.inChannels;let u="",c="";r&&(s?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:u=`
          float activation(float x) {
            ${r}
          }
        `,c="result = activation(result);");const d=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xae{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Bs(this.outputShape.length);const i=t.outChannels/t.inChannels,o=t.padInfo.left,l=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,d=t.filterWidth,h=d;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<d;y++)p+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;p+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<d;y++)p+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(h+1)/2;y++){const b=y*2;if(p+=`
          xC = xCCorner + ${b*u};
          `,l===1){if(b<d&&(o%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,u===1&&b>0?p+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<d)){const x=o%2===0?QL(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,u>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:p+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):x===1?p+=`
                    xC${b+1} = xTexelC${b};
                    `:p+=`
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<d&&(o%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<d&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<d&&(p+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<d&&(p+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<d&&(p+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",m="";r&&(s?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:f=`vec4 activation(vec4 x) {
          ${r}
        }`,m="result = activation(result);");const g=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gyt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;c==null&&(c=[1,1]),U(Ns(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=cs(s.shape,a.shape,i,c,o,u,!0);let h;xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?h=new Xae(d):h=new Kae(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[s,a],"float32",p)}const Hyt={kernelName:z2,backendName:"webgl",kernelFunc:Gyt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jyt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,r=t.strideWidth,s=t.padInfo.top,a=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class qyt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,a=t.strideWidth,i=n-1-t.padInfo.top,o=r-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kyt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=cs(s.shape,c,i,o,l,u,!0),h=new jyt(d);return n.runWebGLProgram(h,[s,a],"float32")}const Xyt={kernelName:gP,backendName:"webgl",kernelFunc:Kyt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yyt(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=cs(c,a.shape,i,o,l,u,!0),h=new qyt(d);return n.runWebGLProgram(h,[s,a],"float32")}const Zyt={kernelName:yP,backendName:"webgl",kernelFunc:Yyt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jyt{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qyt(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=ve(r.shape),i=We({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new Jyt(a),l=n.runWebGLProgram(o,[i],i.dtype),u=We({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}const ebt={kernelName:bP,backendName:"webgl",kernelFunc:Qyt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tbt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:n,inWidth:r,padInfo:s,strideHeight:a,strideWidth:i,filterHeight:o,filterWidth:l,dilationHeight:u,dilationWidth:c}=t,{top:d,left:h}=s;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${i});
      const ivec2 pads = ivec2(${d}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nbt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=rv(s.shape,a.shape,i,o,"NHWC",l);let c;const d=new tbt(u);c=n.runWebGLProgram(d,[s,a],"float32");const h=We({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}const rbt={kernelName:B2,backendName:"webgl",kernelFunc:nbt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sbt(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=fB(s,a.length);gB(i.length,l,a);const{path:u,steps:c}=yB(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:b}=mB(p,l[g]);let x;bB(y)?x=a[g]:(x=aa({inputs:{x:a[g]},backend:n,attrs:{perm:y}}),f.push(x));const w=x.shape.slice();for(let v=0;v<b.length;++v)w.splice(b[v],0,1);Xt(x.shape,w)||(x=We({inputs:{x},backend:n,attrs:{shape:w}}),f.push(x)),h===null?h=x:(h=a4({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=mT({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}const abt={kernelName:xP,backendName:"webgl",kernelFunc:sbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ibt="return (x >= 0.0) ? x : (exp(x) - 1.0);",obt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,lbt=Qt({opSnippet:ibt,packedOpSnippet:obt}),ubt={kernelName:w1,backendName:"webgl",kernelFunc:lbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cbt="return (b >= 0.0) ? a : a * (b + 1.0);",dbt=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,hbt=e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Cv(dbt,r.shape,s.shape):new jg(cbt,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)},pbt={kernelName:wP,backendName:"webgl",kernelFunc:hbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fbt=`
  return vec4(equal(a, b));
`,mbt="return float(a == b);",gbt=_s({opSnippet:mbt,packedOpSnippet:fbt,dtype:"bool",cpuKernelImpl:Jpt}),ybt={kernelName:W2,backendName:"webgl",kernelFunc:gbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bbt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${oB};
  float a1 = ${lB};
  float a2 = ${uB};
  float a3 = ${cB};
  float a4 = ${dB};
  float a5 = ${hB};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,xbt=Qt({opSnippet:bbt}),wbt={kernelName:v1,backendName:"webgl",kernelFunc:xbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vbt=Bb+`
  return exp(x);
`,kbt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Yae=Qt({opSnippet:vbt,packedOpSnippet:kbt,cpuKernelImpl:Qpt,dtype:"float32"}),Ibt={kernelName:k1,backendName:"webgl",kernelFunc:Yae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hD(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(U(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),We({inputs:{x:a},backend:r,attrs:{shape:o}})}const Sbt={kernelName:V2,backendName:"webgl",kernelFunc:hD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DH="return exp(x) - 1.0;",Cbt=Qt({opSnippet:DH,packedOpSnippet:DH,cpuKernelImpl:eft}),Nbt={kernelName:I1,backendName:"webgl",kernelFunc:Cbt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FH{constructor(t,n,r){this.variableNames=["real","imag"];const s=n[1];this.outputShape=n;const a=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let o;if(t==="real")o="return real * expR - imag * expI;";else if(t==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zae(e,t,n){const r=n.texData.get(e.dataId),s=ve(e.shape),a=e.shape[e.shape.length-1],i=s/a,o=We({inputs:{x:e},backend:n,attrs:{shape:[i,a]}}),l=o.shape,u=new FH("real",l,t),c=new FH("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=n.runWebGLProgram(u,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=Vd({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);const m=We({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $bt(e){const{inputs:t,backend:n}=e,{input:r}=t;return Zae(r,!1,n)}const Tbt={kernelName:vP,backendName:"webgl",kernelFunc:$bt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _bt{constructor(t,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $v(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||Cb(s),a==="string"){const i=yr(a,ve(r));return i.fill(s),t.makeTensorInfo(r,a,i)}else{const i=new _bt(r,s),o=[[s]];return t.runWebGLProgram(i,[],a,o)}}const Ebt={kernelName:kP,backendName:"webgl",kernelFunc:$v};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Abt{constructor(t){this.variableNames=["Image"],this.outputShape=[];const n=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rbt={kernelName:IP,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new Abt(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OH="return floor(x);",Dbt=Qt({opSnippet:OH,packedOpSnippet:OH,cpuKernelImpl:tft}),Fbt={kernelName:S1,backendName:"webgl",kernelFunc:Dbt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Obt=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Mbt=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Lbt=_s({opSnippet:Obt,packedOpSnippet:Mbt,dtype:"int32"}),Pbt={kernelName:C1,backendName:"webgl",kernelFunc:Lbt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zbt{constructor(t){this.variableNames=["A"];const n=da(),[r,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bbt{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=da(),[r,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wbt={kernelName:dR,backendName:"webgl",kernelFunc:Vbt};let pm,K_=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Vbt(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,a];if(o||i){const m=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(pm==null||m!==K_)&&(K_=m,pm=document.createElement("canvas").getContext("2d",{willReadFrequently:K_})),pm.canvas.width=l,pm.canvas.height=u,pm.drawImage(s,0,0,l,u),s=pm.canvas}const h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=Ii.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),s);const p=xe().getBool("WEBGL_PACK")?new Bbt(d):new zbt(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ubt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=Ku(c),g=cs(s.shape,a.shape,l,d,u,h,!1,m);let y;const b=[],x=i!=null,w=o!=null,v=p==="leakyrelu",k=()=>{const S=[s,a],$=(N,T)=>{if(T==="NCHW"&&N.shape.length===1&&N.shape[0]!==1){const C=We({inputs:{x:N},backend:n,attrs:{shape:[N.shape[0],1,1]}});return b.push(C),C}return N};if(x&&S.push($(i,c)),w&&S.push($(o,c)),v){const N=n.makeTensorInfo([],"float32",Rd(f,"float32"));S.push(N),b.push(N)}return S};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=Hae({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){const S=p?G0(p,!0):null,$=new Gae(g,x,S,w,v),N=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],T=k();y=n.runWebGLProgram($,T,"float32",N)}else if(xe().getBool("WEBGL_CONV_IM2COL"))y=jae({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const S=p?G0(p,!1):null,$=new Uae(g,x,S,w,v),N=k();y=n.runWebGLProgram($,N,"float32")}const I=We({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(S=>n.disposeIntermediateTensorInfo(S)),I}const Gbt={kernelName:_S,backendName:"webgl",kernelFunc:Ubt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hbt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let m=c;m==null&&(m=[1,1]),U(Ns(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=cs(s.shape,a.shape,l,m,u,d,!0),y=xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=h?G0(h,y):null,x=[s,a],w=i!=null,v=o!=null,k=h==="leakyrelu";if(w&&x.push(i),v&&x.push(o),k){const N=n.makeTensorInfo([],"float32",Rd(p,"float32"));x.push(N),f.push(N)}let I;y?I=new Xae(g,w,b,v,k):I=new Kae(g,w,b,v,k);const S=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],$=n.runWebGLProgram(I,x,"float32",S);return f.forEach(N=>n.disposeIntermediateTensorInfo(N)),$}const jbt={kernelName:ES,backendName:"webgl",kernelFunc:Hbt};class qbt{constructor(t,n,r,s){this.sliceDim=t,this.strides=n,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const a=Nn(r.length);let i=`
    int index;`;for(let o=0;o<this.sliceDim;o++)i+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kbt(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=ve(r.shape),[l,u,c,d]=Yz(r,s),h=We({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=We({inputs:{x:r},backend:n,attrs:{shape:[ve(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const y=n.readSync(s.dataId),b=n.bufferSync(r),x=nft(y,b,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,x.values)}const f=new qbt(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=We({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}const Xbt={kernelName:SP,backendName:"webgl",kernelFunc:Kbt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ybt{constructor(t,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=Nn(this.rank),s=Zbt(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}}function Zbt(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jae(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=Bt(i,s.shape)[0];if(xe().get("DEBUG")){const b=n.readSync(a.dataId),x=s.shape[l];for(let w=0;w<b.length;++w){const v=b[w];U(v<=x-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${x-1}]`)}}const u=wB(s,a,l,o),c=ve(a.shape),d=[],h=We({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=We({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||s.dtype==="string"){const b=n.bufferSync(p),x=n.bufferSync(h),w=rft(x,b,f);return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(u.outputShape,w.dtype,w.values)}const m=new Ybt(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const y=We({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}const Jbt={kernelName:G2,backendName:"webgl",kernelFunc:Jae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qbt="return float(a > b);",ext=`
  return vec4(greaterThan(a, b));
`,txt=_s({opSnippet:Qbt,packedOpSnippet:ext,cpuKernelImpl:sft,dtype:"bool"}),nxt={kernelName:H2,backendName:"webgl",kernelFunc:txt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rxt="return float(a >= b);",sxt=`
  return vec4(greaterThanEqual(a, b));
`,axt=_s({opSnippet:rxt,packedOpSnippet:sxt,dtype:"bool",cpuKernelImpl:aft}),ixt={kernelName:N1,backendName:"webgl",kernelFunc:axt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oxt(e){const{inputs:t,backend:n}=e,{input:r}=t;return Zae(r,!0,n)}const lxt={kernelName:CP,backendName:"webgl",kernelFunc:oxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uxt="return float(!isnan(x) && !isinf(x));",cxt=Qt({opSnippet:uxt,dtype:"bool"}),dxt={kernelName:T1,backendName:"webgl",kernelFunc:cxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hxt="return float(isinf(x));",pxt=Qt({opSnippet:hxt,dtype:"bool"}),fxt={kernelName:_1,backendName:"webgl",kernelFunc:pxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mxt="return float(isnan(x));",gxt=Qt({opSnippet:mxt,dtype:"bool"}),yxt={kernelName:E1,backendName:"webgl",kernelFunc:gxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bxt="return float(a < b);",xxt=`
  return vec4(lessThan(a, b));
`,wxt=_s({opSnippet:bxt,packedOpSnippet:xxt,cpuKernelImpl:ift,dtype:"bool"}),vxt={kernelName:q2,backendName:"webgl",kernelFunc:wxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kxt="return float(a <= b);",Ixt=`
  return vec4(lessThanEqual(a, b));
`,Sxt=_s({opSnippet:kxt,packedOpSnippet:Ixt,cpuKernelImpl:oft,dtype:"bool"}),Cxt={kernelName:K2,backendName:"webgl",kernelFunc:Sxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxt(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=lft(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}const $xt={kernelName:$P,backendName:"webgl",kernelFunc:Nxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Txt=Bb+`
  return x < 0.0 ? 0./0. : log(x);
`,_xt=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Ext=Qt({opSnippet:Txt,packedOpSnippet:_xt,cpuKernelImpl:uft}),Axt={kernelName:A1,backendName:"webgl",kernelFunc:Ext};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rxt=Bb+`
  return log(1.0 + x);
`,Dxt=Qt({opSnippet:Rxt}),Fxt={kernelName:R1,backendName:"webgl",kernelFunc:Dxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oxt="return float(a >= 1.0 && b >= 1.0);",Mxt=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Lxt=_s({opSnippet:Oxt,packedOpSnippet:Mxt,dtype:"bool"}),Pxt={kernelName:X2,backendName:"webgl",kernelFunc:Lxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zxt="return float(!(x >= 1.0));",Bxt=Qt({opSnippet:zxt}),Wxt={kernelName:Y2,backendName:"webgl",kernelFunc:Bxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vxt="return float(a >= 1.0 || b >= 1.0);",Uxt=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Gxt=_s({opSnippet:Vxt,packedOpSnippet:Uxt,dtype:"bool"}),Hxt={kernelName:Z2,backendName:"webgl",kernelFunc:Gxt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jxt{constructor(t,n,r,s,a){this.variableNames=["x"],this.outputShape=[];const i=n,o=t[3]-1;this.outputShape=t;let l;const u=`float(${r}) + float(${s}) * sum`;a===.5?l=`inversesqrt(${u})`:a===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qxt{constructor(t,n,r,s,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,o=t[3]-1;this.outputShape=t;let l;const u=`float(${r}) + float(${s}) * sum`;a===.5?l=`inversesqrt(${u})`:a===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kxt=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=xe().getBool("WEBGL_PACK_NORMALIZATION")?new qxt(s.shape,a,i,o,l):new jxt(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)},Xxt={kernelName:J2,backendName:"webgl",kernelFunc:Kxt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yxt{constructor(t,n,r,s,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=n,this.bias=r,this.alpha=s,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zxt=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new Yxt(s.shape,o,l,u,c);return n.runWebGLProgram(d,[s,a,i],s.dtype)},Jxt={kernelName:TP,backendName:"webgl",kernelFunc:Zxt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qxt(e,t,n,r){const s=ve(t),i=ve(e.shape)/s,o=We({inputs:{x:e},attrs:{shape:[i,s]},backend:r}),l=tm(o,e.dtype,"max",r),u=We({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qae(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=Bt(a,s.shape);let u=l;const c=lr(u,o),d=c!=null,h=n.shouldExecuteOnCPU([s]);let p=s;if(d){if(h){const x=n.texData.get(p.dataId).values,w=new Array(o);for(let I=0;I<w.length;I++)w[I]=s.shape[c[I]];const v=r4(x,s.shape,s.dtype,c,w);p=n.makeTensorInfo(w,s.dtype);const k=n.texData.get(p.dataId);k.values=v}else p=fT(s,c,n);u=wr(u.length,o)}$s("max",u,o);const[f,m]=ds(p.shape,u);let g=f;i&&(g=br(f,l));let y;if(h){const x=n.texData.get(p.dataId).values,w=cft(x,ve(m),g,s.dtype);y=n.makeTensorInfo(g,s.dtype);const v=n.texData.get(y.dataId);v.values=w}else y=Qxt(p,m,g,n);return d&&n.disposeIntermediateTensorInfo(p),y}const e0t={kernelName:Q2,backendName:"webgl",kernelFunc:Qae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t0t=s4+`
  return max(a, b);
`,n0t=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+em+`
  return result;
`,r0t=_s({opSnippet:t0t,packedOpSnippet:n0t,cpuKernelImpl:dft}),s0t={kernelName:D1,backendName:"webgl",kernelFunc:r0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a0t(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Iv(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;U(Ns(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Co(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&Xt(c.inShape,c.outShape))return ai({inputs:{x:s},backend:n});const d=new H0(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}const i0t={kernelName:e$,backendName:"webgl",kernelFunc:a0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o0t(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],d=qu(s.shape,a,i,c,o,u,l),h=new i4(d,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}const l0t={kernelName:t$,backendName:"webgl",kernelFunc:o0t};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u0t{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideHeight,r=t.strideWidth,s=t.dilationHeight,a=t.effectiveFilterHeight,i=t.effectiveFilterWidth,o=a-1-t.padInfo.top,l=i-1-t.padInfo.left,u=a*i-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class c0t{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideDepth,r=t.strideHeight,s=t.strideWidth,a=t.dilationDepth,i=t.dilationHeight,o=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,d=l-1-t.padInfo.front,h=u-1-t.padInfo.top,p=c-1-t.padInfo.left,f=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d0t(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],h=qu(i.shape,o,l,d,u,c),p=new i4(h,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new c0t(h),g=n.runWebGLProgram(m,[s,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}const h0t={kernelName:EP,backendName:"webgl",kernelFunc:d0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0t(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;Iv([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Co(o.shape,l,u,1,c,d),p=!0,f=new H0(h,"max",p),m=n.runWebGLProgram(f,[o],o.dtype),g=new u0t(h),y=n.runWebGLProgram(g,[s,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}const f0t={kernelName:_P,backendName:"webgl",kernelFunc:p0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m0t(e,t,n,r){let s=new H0(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");s=new H0(n,"max",!0,!0,t);const i=r.runWebGLProgram(s,[e],"float32");return[a,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g0t={kernelName:AP,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;U(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];U(Ns(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=Co(r.shape,s,a,u,i),[d,h]=m0t(r,o,c,l);return[d,h]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y0t(e,t,n,r){const s=ve(t),i=ve(e.shape)/s,o=We({inputs:{x:e},attrs:{shape:[i,s]},backend:r}),l=tm(o,"float32","mean",r),u=We({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b0t={kernelName:n$,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,l=Bt(a,r.shape);let u=l;const c=lr(u,o),d=c!=null,h=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(d){if(h){const w=i.texData.get(f.dataId).values,v=new Array(o);for(let S=0;S<v.length;S++)v[S]=r.shape[c[S]];const k=r4(w,r.shape,r.dtype,c,v);f=i.makeTensorInfo(v,r.dtype);const I=i.texData.get(f.dataId);I.values=k}else f=fT(r,c,i);p.push(f),u=wr(u.length,o)}$s("sum",u,o);const[m,g]=ds(f.shape,u);let y=m;s&&(y=br(m,l));const b=y0t(f,g,y,i);for(const x of p)i.disposeIntermediateTensorInfo(x);return b}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0t(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Bt(a,s.shape);let u=l;const c=lr(u,o);let d=s;c!=null&&(d=aa({inputs:{x:s},backend:n,attrs:{perm:c}}),u=wr(u.length,s.shape.length)),$s("min",u,o);const[h,p]=ds(d.shape,u),f=ve(p),m=We({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=tm(m,m.dtype,"min",n);let y;if(i){const b=br(h,l);y=We({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=We({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}const w0t={kernelName:r$,backendName:"webgl",kernelFunc:x0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v0t=s4+`
  return min(a, b);
`,k0t=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+em+`
  return result;
`,I0t=_s({opSnippet:v0t,packedOpSnippet:k0t,cpuKernelImpl:hft}),S0t={kernelName:F1,backendName:"webgl",kernelFunc:I0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C0t{constructor(t,n,r){this.variableNames=["x"],this.outputShape=n.map((c,d)=>c[0]+t[d]+c[1]);const s=t.length,a=Nn(s),i=n.map(c=>c[0]).join(","),o=n.map((c,d)=>c[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N0t{constructor(t,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((f,m)=>f[0]+t[m]+f[1]);const s=t.length,a=Nn(s),i=n.map(f=>f[0]).join(","),o=n.map((f,m)=>f[0]+t[m]).join(","),l=Zs("rc",s),u=Zs("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${u.slice(-2).join()})`,h=r==="reflect"?0:1;let p="";if(s===1){const f=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${d});
        ${l[s-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${d});
        }
      `}else{const f=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${d});
        ${l[s-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${d});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${f}
          result[2] = getChannel(getX(${u.join()}), ${d});
          ${l[s-1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${u.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $0t=({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:a}=n,i=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new N0t(r.shape,s,a):new C0t(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)},T0t={kernelName:s$,backendName:"webgl",kernelFunc:$0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _0t=`if (b == 0.0) return NAN;
  return mod(a, b);`,E0t=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+em+`
  return result;
`,A0t=_s({opSnippet:_0t,packedOpSnippet:E0t}),R0t={kernelName:O1,backendName:"webgl",kernelFunc:A0t};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D0t{constructor(t,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F0t=`
if (a == b) {
  return 1.0;
};
return a / b;`,O0t=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,eie=_s({opSnippet:F0t,packedOpSnippet:O0t,checkOutOfBounds:!0}),M0t={kernelName:x1,backendName:"webgl",kernelFunc:eie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MH="return a - b;",tie=_s({opSnippet:MH,packedOpSnippet:MH,supportsComplex:!0,cpuKernelImpl:Dft}),L0t={kernelName:Z1,backendName:"webgl",kernelFunc:tie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nie(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=Bt([a],s.shape),o=Qae({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=br(o.shape,i),u=We({inputs:{x:o},backend:n,attrs:{shape:l}}),c=tie({inputs:{a:s,b:u},backend:n}),d=Yae({inputs:{x:c},backend:n}),h=mT({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=We({inputs:{x:h},backend:n,attrs:{shape:l}}),f=eie({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const P0t={kernelName:k$,backendName:"webgl",kernelFunc:nie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z0t(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:nie({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new D0t(u,c,a),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}const B0t={kernelName:RP,backendName:"webgl",kernelFunc:z0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W0t=$o+`
  return -x;
`,V0t=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function U0t(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const a=n.texData.get(r.dataId),[i,o]=fft(a.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let s;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new kc(r.shape,V0t):s=new Al(r.shape,W0t),n.runWebGLProgram(s,[r],r.dtype)}const G0t={kernelName:a$,backendName:"webgl",kernelFunc:U0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H0t=Uz;function j0t(e){gi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=H0t(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const q0t={kernelName:DP,backendName:"webgl",kernelFunc:j0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K0t=Gz;function X0t(e){gi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),{selectedIndices:h,validOutputs:p}=K0t(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const Y0t={kernelName:FP,backendName:"webgl",kernelFunc:X0t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z0t=Hz;function J0t(e){gi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=Z0t(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const Q0t={kernelName:OP,backendName:"webgl",kernelFunc:J0t};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ewt{constructor(t,n,r,s){this.variableNames=["indices"],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const twt=e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=ve(s.shape),c=new ewt(u,i,o,l),d=We({inputs:{x:s},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],a);n.disposeIntermediateTensorInfo(d);const p=[...s.shape,i],f=We({inputs:{x:h},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(h),f},nwt={kernelName:l$,backendName:"webgl",kernelFunc:twt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rC(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){const s=Nv({inputs:{input:r},backend:n}),a=rC({inputs:{x:s},backend:n}),i=gT({inputs:{input:r},backend:n}),o=rC({inputs:{x:i},backend:n}),l=Vd({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return $v({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const rwt={kernelName:N$,backendName:"webgl",kernelFunc:rC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rie(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=Nv({inputs:{input:r},backend:n}),a=rie({inputs:{x:s},backend:n}),i=gT({inputs:{input:r},backend:n}),o=rC({inputs:{x:i},backend:n}),l=Vd({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return $v({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const swt={kernelName:o$,backendName:"webgl",kernelFunc:rie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function awt(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return hD({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(c=>{oi(a,c.shape,"All tensors passed to stack must have matching shapes"),U(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=t.map(c=>{const d=hD({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=Vae({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const iwt={kernelName:u$,backendName:"webgl",kernelFunc:awt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class owt{constructor(t,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((u,c)=>u[0]+t[c]+u[1]);const s=t.length,a=Nn(s),i=n.map(u=>u[0]).join(","),o=n.map((u,c)=>u[0]+t[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lwt{constructor(t,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((m,g)=>m[0]+t[g]+m[1]);const s=t.length,a=Nn(s),i=n.map(m=>m[0]).join(","),o=n.map((m,g)=>m[0]+t[g]).join(","),l=Zs("rc",s),u=Zs("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${u.slice(-2).join()})`,h=[`${a} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${c}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${c}) {`],p=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,g=s===1?2:4;m<g;m++)f+=`
        ${h[m]}
        if (${p}) {
          result[${m}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${m}] = getChannel(getX(${u.join()}), ${d});
        }
      `;f+=s===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sie=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(ve(s.shape)===0){const u=a.map((c,d)=>c[0]+s.shape[d]+c[1]);return $v({backend:n,attrs:{shape:u,value:i,dtype:s.dtype}})}const o=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lwt(s.shape,a,i):new owt(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},uwt={kernelName:c$,backendName:"webgl",kernelFunc:sie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cwt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,dwt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+em+`
  return result;
`,hwt=_s({opSnippet:cwt,packedOpSnippet:dwt}),pwt={kernelName:L1,backendName:"webgl",kernelFunc:hwt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fwt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=Bt(a,s.shape);let c=u;const d=lr(c,o);let h=s;d!=null&&(h=aa({inputs:{x:s},backend:n,attrs:{perm:d}}),c=wr(c.length,o),l.push(h)),$s("prod",c,o);let p;if(n.shouldExecuteOnCPU([h])){const f=n.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=gft(h.shape,h.dtype,f,c);p=n.makeTensorInfo(g,y,m)}else{const[f,m]=ds(h.shape,c),g=ve(m),y=We({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),b=oz(s.dtype),x=tm(y,b,"prod",n);p=We({inputs:{x},backend:n,attrs:{shape:f}}),l.push(y),l.push(x)}if(i){l.push(p);const f=br(p.shape,u);p=We({inputs:{x:p},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}const mwt={kernelName:h$,backendName:"webgl",kernelFunc:fwt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gwt(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map(y=>n.readSync(y.dataId)),u=s.map(y=>y.shape),c=n.readSync(a.dataId),d=n.readSync(i.dataId),[h,p,f]=yft(l,u,c,a.shape,a.dtype,d,i.shape,o),m=h.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}const ywt={kernelName:MP,backendName:"webgl",kernelFunc:gwt};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bwt(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=bft(i,r.shape,r.dtype,o,s.shape,l,a.shape),d=n.makeTensorInfo([u.length],"int32",u),h=n.makeTensorInfo([c.length],r.dtype,c);return[d,h]}const xwt={kernelName:LP,backendName:"webgl",kernelFunc:bwt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wwt(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),d=n.readSync(i.dataId),h=o.map(g=>n.readSync(g.dataId)),p=o.map(g=>g.shape),[f,m]=xft(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}const vwt={kernelName:PP,backendName:"webgl",kernelFunc:wwt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aie=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=wft(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},kwt={kernelName:zP,backendName:"webgl",kernelFunc:aie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iwt="return 1.0 / x;",Swt=Qt({opSnippet:Iwt}),Cwt={kernelName:P1,backendName:"webgl",kernelFunc:Swt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nwt=$o+`
  return (x < 0.0) ? 0.0 : x;
`,$wt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Twt=Qt({opSnippet:Nwt,packedOpSnippet:$wt}),_wt={kernelName:z1,backendName:"webgl",kernelFunc:Twt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ewt=$o+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Awt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Rwt=Qt({opSnippet:Ewt,packedOpSnippet:Awt}),Dwt={kernelName:B1,backendName:"webgl",kernelFunc:Rwt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fwt{constructor(t,n,r,s,a){this.variableNames=["A"],this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r];let h;a?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Owt{constructor(t,n,r,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r];let h;a?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mwt(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Owt(s.shape,l,u,a,i):new Fwt(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}const Lwt={kernelName:m$,backendName:"webgl",kernelFunc:Mwt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pwt{constructor(t,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,a]=n,[,i,o]=t,l=[r&&i>1?s-1:s,r&&o>1?a-1:a],u=[r&&i>1?i-1:i,r&&o>1?o-1:o],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=Math.ceil(h)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zwt(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Pwt(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const Bwt={kernelName:VP,backendName:"webgl",kernelFunc:zwt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wwt{constructor(t,n,r,s,a){this.variableNames=["A"],this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r],h=s?"0.5":"0.0";let p;a?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vwt{constructor(t,n,r,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r],h=s?"0.5":"0.0";let p;a?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uwt(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Vwt(s.shape,l,u,a,i):new Wwt(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}const Gwt={kernelName:f$,backendName:"webgl",kernelFunc:Uwt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hwt{constructor(t,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,a]=n,[,i,o]=t,l=[r&&i>1?s-1:s,r&&o>1?a-1:a],u=[r&&i>1?i-1:i,r&&o>1?o-1:o],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=Math.ceil(h)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jwt(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Hwt(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const qwt={kernelName:WP,backendName:"webgl",kernelFunc:jwt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kwt{constructor(t,n){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const s=o=>n.indexOf(o)!==-1&&t[o]!==1?`${t[o]} - coords[${o}] - 1`:`coords[${o}]`,a=t.map((o,l)=>s(l)).join(","),i=Nn(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xwt{constructor(t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=Zs("rc",r),a=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,o=Nn(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${a}){
            result.g = ${u(s.slice())};
          }
          if(${i}) {
            result.b = ${c(s.slice())};
            if(${a}) {
              result.a = ${d(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return h(f)}function u(f){return f[r-1]="("+f[r-1]+" + 1)",h(f)}function c(f){return f[r-2]="("+f[r-2]+" + 1)",h(f)}function d(f){return f[r-1]="("+f[r-1]+" + 1)",f[r-2]="("+f[r-2]+" + 1)",h(f)}function h(f){const m=t.map((b,x)=>p(x,f)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function p(f,m){return n.indexOf(f)!==-1&&t[f]!==1?`${t[f]} - ${m[f]} - 1`:`${m[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ywt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=Bt(a,s.shape);if(i===0)return ai({inputs:{x:s},backend:n});const l=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Xwt(s.shape,o):new Kwt(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}const Zwt={kernelName:g$,backendName:"webgl",kernelFunc:Ywt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jwt{constructor(t,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let a="";typeof n=="number"?a=`float outputValue = ${n.toFixed(2)};`:a=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qwt={kernelName:az,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=new Jwt(r.shape,a),[u,c]=sB(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(l,[r],r.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e1t=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,t1t=Qt({opSnippet:e1t}),n1t={kernelName:W1,backendName:"webgl",kernelFunc:t1t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r1t="return inversesqrt(x);",s1t=Qt({opSnippet:r1t,cpuKernelImpl:vft}),a1t={kernelName:V1,backendName:"webgl",kernelFunc:s1t};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o4{constructor(t,n,r,s,a,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const u=Nn(a.length),c=Nn(i.length);let d="";r===1?d="i":r===2&&(d="i, j");const h=`getIndices(${d})`;let p="";s===1?p="i":s===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=n>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i1t{constructor(t,n,r,s,a,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const u=Nn(a.length),c=Nn(i.length);let d="";r===1?d="i":r===2&&(d="i, j");const h=`getIndices(${d})`;let p="";s===1?p="i":s===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=n>1?"strides[j]":"strides",b=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${h});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o1t(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Xf(a,s,i),h=[d/u,u];if(d===0)return n.makeTensorInfo(i,s.dtype);const p=We({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=We({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;xe().getBool("WEBGL_PACK")?g=new i1t(l,o,p.shape.length,f.shape.length,c,h):g=new o4(l,o,p.shape.length,f.shape.length,c,h);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=We({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}const l1t={kernelName:UP,backendName:"webgl",kernelFunc:o1t};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u1t{constructor(t,n,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const a="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,o=xe().getNumber("WEBGL_VERSION")===2?a:i,l=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c1t(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new u1t(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}const d1t={kernelName:HP,backendName:"webgl",kernelFunc:c1t};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h1t{constructor(t,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let s,a;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)a="resRC",s="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<n.length;c++)u.push(`${o[c]}`),c<t&&l.push(`${o[c]}`);s=l.join(),a=u.join()}const i=Nn(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p1t(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new h1t(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],ni(s.dtype,a.dtype))}const f1t={kernelName:y$,backendName:"webgl",kernelFunc:p1t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m1t=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${J$};
  float scale = ${Q$};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,g1t=Qt({opSnippet:m1t}),y1t={kernelName:U1,backendName:"webgl",kernelFunc:g1t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b1t=Bb+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,x1t=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,w1t=Qt({opSnippet:b1t,packedOpSnippet:x1t,cpuKernelImpl:Ift}),v1t={kernelName:q1,backendName:"webgl",kernelFunc:w1t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k1t=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,I1t=Qt({opSnippet:k1t}),S1t={kernelName:j1,backendName:"webgl",kernelFunc:I1t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C1t=Bb+`
  return sin(x);
`,N1t=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${em}
  return result;
`,$1t=Qt({opSnippet:C1t,packedOpSnippet:N1t}),T1t={kernelName:G1,backendName:"webgl",kernelFunc:$1t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _1t=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,E1t=Qt({opSnippet:_1t}),A1t={kernelName:H1,backendName:"webgl",kernelFunc:E1t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R1t=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,D1t=Qt({opSnippet:R1t}),F1t={kernelName:K1,backendName:"webgl",kernelFunc:D1t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O1t=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;U(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+a.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=sie({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=cv(c.shape,a,o,!1),h=dv(d.length,a.length,!1),p=hv(c.shape,a,o,!1),f=We({inputs:{x:c},backend:n,attrs:{shape:d}}),m=aa({inputs:{x:f},backend:n,attrs:{perm:h}}),g=We({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(y=>n.disposeIntermediateTensorInfo(y)),g},M1t={kernelName:w$,backendName:"webgl",kernelFunc:O1t};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L1t(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=Cft(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const P1t={kernelName:jP,backendName:"webgl",kernelFunc:L1t};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z1t(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,d]=Nft(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const B1t={kernelName:qP,backendName:"webgl",kernelFunc:z1t};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W1t(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=_ae(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}const V1t={kernelName:KP,backendName:"webgl",kernelFunc:W1t};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U1t(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=_ae(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}const G1t={kernelName:XP,backendName:"webgl",kernelFunc:U1t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H1t(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Xf(a,s,o),p=!1;if(a.dtype==="string"){const y=n.bufferSync(s),b=n.bufferSync(a),x=td(n.readSync(i.dataId)[0]),w=kft(y,b,o,h,c,u,l,d,x,p);return n.makeTensorInfo(o,w.dtype,w.values)}const f=new o4(u,l,s.shape.length,a.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=We({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}const j1t={kernelName:YP,backendName:"webgl",kernelFunc:H1t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q1t(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Bt(i,s.shape)[0],l=xB(s,a,o),u=s.shape.length,c=new Array(u).fill(0),d=s.shape.slice();return l.map(h=>{const p=[...d];p[o]=h;const f=Wb({inputs:{x:s},backend:n,attrs:{begin:c,size:p}});return c[o]+=h,f})}const K1t={kernelName:v$,backendName:"webgl",kernelFunc:q1t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LH="return sqrt(x);",X1t=Qt({opSnippet:LH,packedOpSnippet:LH,cpuKernelImpl:$ft}),Y1t={kernelName:X1,backendName:"webgl",kernelFunc:X1t};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z1t="return x * x;",J1t=Qt({opSnippet:Z1t}),Q1t={kernelName:ZP,backendName:"webgl",kernelFunc:J1t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PH="return (a - b) * (a - b);",evt=_s({opSnippet:PH,packedOpSnippet:PH}),tvt={kernelName:Y1,backendName:"webgl",kernelFunc:evt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nvt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const a=n.readSync(s.dataId),i=zu(a),o=Tft(i,"string",r);return n.makeTensorInfo(s.shape,"string",o)}const rvt={kernelName:I$,backendName:"webgl",kernelFunc:nvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function svt({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=$o+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new Al(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}const avt={kernelName:tv,backendName:"webgl",kernelFunc:svt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ivt{constructor(t,n,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,a=Nn(r.length),i=Nn(r.length);let o="";if(s===1)o="coords * strides + begin";else{let l=0;o=r.map((u,c)=>(l++,r.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${t});
      ${a} strides = ${a}(${n});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ovt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=tB(s.shape,a,i,o,l,u,c,d,h);let v;if(m)v=We({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const I=Jz(b,x,w),S=Wb({inputs:{x:s},backend:n,attrs:{begin:b,size:I}});v=We({inputs:{x:S},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(S)}else if(n.shouldExecuteOnCPU([s])){const S=n.readSync(s.dataId),$=Mt(s.shape,s.dtype,S),N=_ft(p,$,w,b);v=n.makeTensorInfo(f,s.dtype,N.values)}else{const S=new ivt(b,w,p);v=n.runWebGLProgram(S,[s],s.dtype)}const k=We({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(v),k}const lvt={kernelName:JP,backendName:"webgl",kernelFunc:ovt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uvt(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=Eft(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}const cvt={kernelName:QP,backendName:"webgl",kernelFunc:uvt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dvt(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=Aft(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const hvt={kernelName:ez,backendName:"webgl",kernelFunc:dvt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pvt(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=Rft(i,s);return n.makeTensorInfo(a.shape,"int32",o)}const fvt={kernelName:tz,backendName:"webgl",kernelFunc:pvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mvt="return tan(x);",gvt=Qt({opSnippet:mvt}),yvt={kernelName:J1,backendName:"webgl",kernelFunc:gvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bvt=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,xvt=Qt({opSnippet:bvt}),wvt={kernelName:Q1,backendName:"webgl",kernelFunc:xvt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vvt(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Xf(i,a,s.shape),h=[d/u,u];if(d===0)return n.makeTensorInfo(s.shape,a.dtype);const p=We({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=We({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=We({inputs:{x:s},backend:n,attrs:{shape:h}}),g=new o4(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=We({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}const kvt={kernelName:GP,backendName:"webgl",kernelFunc:vvt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ivt{constructor(t,n){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[i]*n[i];this.outputShape=r,this.rank=r.length;const s=Nn(this.rank),a=Svt(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function Svt(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iie(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if(s.dtype==="string"||s.shape.length>5){const l=n.readSync(s.dataId),u=s.dtype==="string"?l.map(h=>td(h)):l,c=Mt(s.shape,s.dtype,u),d=Fft(c,a);return n.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new Ivt(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const Cvt={kernelName:ev,backendName:"webgl",kernelFunc:iie};class Nvt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class $vt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yd(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function zH(e){let t=1;for(;t<e;)t*=2;return t}function Tvt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=xe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=xe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){const N=n.readSync(s.dataId),[T,C]=Oft(N,u,s.dtype,a,i);return[n.makeTensorInfo(T.shape,T.dtype,T.values),n.makeTensorInfo(C.shape,C.dtype,C.values)]}if(a===0)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[s,$v({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(s.dataId),h=d!==null&&d.isPacked,p=h?n.unpackTensor(s):s,m=ve(u)/c,g=We({inputs:{x:p},attrs:{shape:[m,c]},backend:n});h&&Yd(n,p);const y=zH(a),b=zH(c);let x=null;const w=()=>x===null?[g,g]:[g,x],v=(N,T,C)=>{const E=w(),M=new Nvt(C),z=[[c],[x===null?1:0],[Number.NEGATIVE_INFINITY],[N],[T]],H=x;x=n.runWebGLProgram(M,E,"int32",z),Yd(n,H)};for(let N=1;N<y;N*=2){const T=N*2;for(let C=N;C>=1;C/=2)v(T,C,[m,b])}for(let N=b;N>y;N/=2){const T=w(),C=new $vt([m,N/2]),M=[[c],[x===null?1:0],[y]],F=x;x=n.runWebGLProgram(C,T,"int32",M),Yd(n,F);const z=y/2,H=z*2;for(let P=z;P>=1;P/=2)v(H,P,x.shape)}let k=x;x=Wb({inputs:{x},backend:n,attrs:{begin:0,size:[m,a]}}),Yd(n,k);let I=Jae({inputs:{x:g,indices:x},backend:n,attrs:{axis:1,batchDims:1}});Yd(n,g);const S=u.slice(0,-1);S.push(a),k=x,x=We({inputs:{x},attrs:{shape:S},backend:n}),Yd(n,k);const $=I;return I=We({inputs:{x:I},attrs:{shape:S},backend:n}),Yd(n,$),[I,x]}const _vt={kernelName:nz,backendName:"webgl",kernelFunc:Tvt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Evt{constructor(t,n,r,s,a,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const o=r==="nearest"?1:2;let l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${t}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Avt(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,m]=u??[d,h],g=[c,f,m,p],y=new Evt(d,h,i,o,l,g);return n.runWebGLProgram(y,[s,a],"float32")}const Rvt={kernelName:rz,backendName:"webgl",kernelFunc:Avt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dvt(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;Iv(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=Mft(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}const Fvt={kernelName:sz,backendName:"webgl",kernelFunc:Dvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ovt(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==a&&(u[c++]=i.shape[m]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(l);for(let m=0;m<f.length;m++){h[a]=m;const g=Wb({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),y=We({inputs:{x:g},backend:n,attrs:{shape:u}});f[m]=y,d.push(g)}return d.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const Mvt={kernelName:S$,backendName:"webgl",kernelFunc:Ovt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lvt{constructor(t,n){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,a=t.inSize,i=t.numSegments,o=i*Math.ceil(a/r);this.outputShape=[s,o];const l="0.0",u="sumValue",c=Math.floor(r/4)*4,d=r%4,h=`
        sumValue += dot(values, segFilter);
    `;let p="";a%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let f="";a%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pvt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[];let u=0;const c=lr([u],o);let d=s;c!=null&&(d=aa({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(d),u=wr(1,o)[0]);const h=Wte(d.shape,u,i),p=ve([d.shape[u]]),f=We({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=oz(s.dtype),g=(w,v,k,I,S)=>{const $=w.shape[0],N=w.shape[1],T=Bte(N,S),C={windowSize:T,inSize:N,batchSize:$,numSegments:S},E=new Lvt(C,v),M=n.compileAndRun(E,[w,k],I);if(l.push(M),M.shape[1]===S)return M;const F=aie({backend:n,attrs:{start:0,stop:S,step:1,dtype:"float32"}}),z=iie({inputs:{x:F},backend:n,attrs:{reps:[N/T]}});return l.push(F),l.push(z),g(M,v,z,I,S)},y=g(f,"unsortedSegmentSum",a,m,i),b=We({inputs:{x:y},backend:n,attrs:{shape:h}});let x=b;if(c!=null){l.push(b);const w=Md(c);x=aa({inputs:{x},backend:n,attrs:{perm:w}})}return l.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}const zvt={kernelName:C$,backendName:"webgl",kernelFunc:Pvt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bvt=[$mt,_mt,Rmt,Omt,Lmt,Bmt,Vmt,Gmt,Kmt,Ymt,Qmt,ngt,agt,ugt,hgt,fgt,ggt,wgt,kgt,Sgt,Tgt,Ogt,Lgt,zgt,Hgt,qgt,Zgt,cmt,eyt,ayt,uyt,myt,byt,wyt,kyt,Syt,Tyt,Ayt,Fyt,Myt,Pyt,Byt,Uyt,Hyt,Xyt,Zyt,ebt,rbt,abt,ubt,pbt,ybt,wbt,Ibt,Sbt,Nbt,Tbt,Ebt,Rbt,Fbt,Pbt,Wbt,Gbt,jbt,Xbt,Jbt,nxt,ixt,umt,lxt,ryt,dxt,fxt,yxt,hmt,vxt,Cxt,$xt,Axt,Fxt,Pxt,Wxt,Hxt,Xxt,Jxt,e0t,s0t,i0t,l0t,h0t,f0t,g0t,b0t,w0t,S0t,T0t,R0t,B0t,mmt,G0t,q0t,Y0t,Q0t,Wgt,nwt,swt,iwt,uwt,pwt,fmt,mwt,ywt,xwt,vwt,kwt,Vgt,M0t,Cwt,_wt,Dwt,ymt,Lwt,Bwt,Gwt,qwt,Zwt,Qwt,n1t,a1t,l1t,d1t,f1t,y1t,v1t,S1t,T1t,A1t,Dgt,P0t,F1t,M1t,P1t,B1t,V1t,G1t,j1t,K1t,Y1t,Q1t,tvt,rvt,avt,lvt,cvt,hvt,fvt,L0t,Smt,yvt,wvt,kvt,Cvt,_vt,Rvt,Cmt,Fvt,Mvt,zvt,rwt];for(const e of Bvt)hQ(e);const Wvt=({return_results_to_parent_component:e,refreshChat:t})=>{const[n,r]=J.useState(),[s,a]=J.useState(!1),[i,o]=J.useState(),l=J.useRef(null);J.useRef(null);const u=J.useRef(null),c=J.useRef(null),d=J.useRef(null),[h,p]=J.useState(!1);J.useEffect(()=>{(n||n==0)&&e([n,i])},[n]);const f=(m,g)=>{const y=async(I,S)=>{const $=await v(),N=await x();return await b(I,$,N)},b=async(I,S,$,N)=>{const T=await k(I,S);if(T){const C=await w($,T);if(C||C==0){const E=await w($,T);r(E)}}else setTimeout(()=>{b(I,S,$)},500)},x=async()=>aH(un.OBJECT_CLASSIFICATION_MODEL_URL),w=async(I,S)=>{if(typeof S<"u"&&S!==null){const $=bG(S),N=io.resizeBilinear($,[220,90]),T=N.cast("float32"),C=T.expandDims(0),E=await I.executeAsync(C),M=await E.array();if(M){const F=M[0].reduce((H,P,O,L)=>P>L[H]?O:H,0);return[9,10,11,1,2,3,4,5,6,7][F]}nt($),nt(N),nt(T),nt(C),nt(E)}},v=async()=>aH(un.OBJECT_DETECTION_MODEL_URL),k=async(I,S,$)=>{var C;if(typeof I.current<"u"&&I.current!==null&&((C=I.current.video)==null?void 0:C.readyState)===4){I.current.getScreenshot();const E=I.current.video,M=I.current.video,F=I.current.video.videoWidth,z=I.current.video.videoHeight;I.current.video.width=F,I.current.video.height=z;const H=bG(E),P=io.resizeBilinear(H,[640,480]),O=P.cast("int32"),L=O.expandDims(0),V=await S.executeAsync(L),q=await V[4].array(),B=await V[7].array(),X=await V[5].array();if(q&&a(!0),q[0][0]&&B[0][0]&&X[0][0]>.95){p(!0);const ee=parseInt((q[0][0][0]*z).toString()),Z=parseInt((q[0][0][1]*F).toString());parseInt((q[0][0][2]*F).toString()),parseInt((q[0][0][3]*F).toString()),c.current.width=90,c.current.height=220,c.current.getContext("2d").drawImage(M,Z-10,ee+200,90,220,0,0,90,220),u.current.width=640,u.current.height=480,u.current.getContext("2d").drawImage(M,0,0,M.width,M.height);const fe=u.current.getContext("2d");q[0][0],fe.strokeStyle="#ffa500",fe.lineWidth=3;const Q=`DETECTION [${Z-10}, ${ee+200}, ${Z+90}, ${ee+200+220}]`;fe.font="18px Arial",fe.fillStyle="#ffa500",fe.fillText(Q,Z-10,ee+190),fe.rect(Z-10,ee+200,90,220),fe.stroke();var N=u.current.toDataURL(),T=new Image(90,220);return T.src=c.current.toDataURL(),nt(H),nt(P),nt(O),nt(L),nt(V),nt(q),nt(B),nt(X),nt(S),o(N),dXe(),T}else nt(H),nt(P),nt(O),nt(L),nt(V),nt(q),nt(B),nt(X);nt(H),nt(P),nt(O),nt(L),nt(V),nt(q),nt(B),nt(X)}};return y(m)};return J.useEffect(()=>{f(l)},[]),K(Uvt,{children:[D(Vvt,{changeColor:s,children:D(Mh,{ref:l,muted:!0,screenshotFormat:"image/jpeg",style:{width:540,height:480}})}),K(Gvt,{children:[D("canvas",{style:{width:90,height:220,display:h?"block":"none"},ref:c}),D("canvas",{style:{width:90,height:220,display:h?"block":"none"},ref:d}),D("canvas",{style:{width:640,height:480,margin:5,display:h?"block":"none"},ref:u})]})]})},Vvt=pe.div.withConfig({displayName:"Decoration",componentId:"sc-1j83jv8-0"})(["border:5px solid;border-color:",";width:550px;height:480px;"],({changeColor:e,theme:t})=>e?t.colors.error:t.colors.background),Uvt=pe.div.withConfig({displayName:"CenterContainer",componentId:"sc-1j83jv8-1"})(["display:flex;justify-content:center;"]),Gvt=pe.div.withConfig({displayName:"Container",componentId:"sc-1j83jv8-2"})([""]),BH=({id:e,name:t,rerender:n,cation:r,chatCanTellNow:s,result_from_voice_description:a,lang:i,back:o})=>{const l=fn(i),[u,c]=J.useState([]),[d,h]=J.useState(),[p,f]=J.useState(1),[m,g]=J.useState(!1),[y,b]=J.useState(),[x,w]=J.useState(),[v,k]=J.useState([]),I=O8e(),[S,$]=J.useState(!1),[N,T]=J.useState(!1),C=r?"cation_analysis_result":"anion_analysis_result",E=r?l.analysis.cation_identification:l.analysis.anion_identification,M=r?["f1","f2","f3","f4","f5","f6","f7"]:["f1","f2","f3","f4"],F=O=>{O[0]!=="404"&&typeof O[0]<"u"&&(b(O[0]),w(O[1]),h(O),g(!m))};J.useEffect(()=>{z()},[]);const z=async()=>{await it.get(Ye[C].get).then(O=>{c(O.data),it.get(Ye.test_images.get).then(L=>{k(L.data)}).catch(L=>{console.log("db status :(",L)})}).catch(O=>{console.log("db status :(",O)})},H=async(O,L,V,q)=>{await it.put(Ye[C].put,{id:e,name:t,[V]:I[O],[L]:x,end:q}).then(n)},P=async()=>{await z().then(O=>{const L=u[u.length-1];if(L.end=="incomplete"&&p!==100){let V=!0;M.map((q,B)=>{L[q]==null&&L.end!=="end"&&V&&(H(y,`img${B+1}`,q,"incomplete"),V=!1)})}L.end=="incomplete"&&L.f7})};return J.useEffect(()=>{m&&(P(),g(!m))},[d]),J.useMemo(()=>{typeof a<"u"&&F([a,""])},[a]),K(vo,{style:{margin:"10px"},children:[D(lx,{children:K(Ue,{onClick:()=>{o()},children:[" ",l.common.end," "]})}),D(lx,{style:{width:"150px",margin:"50px"},children:D(R8e,{lang:i,cation:r})}),D(Hvt,{children:S&&D(Wvt,{refreshChat:O=>{s(O)},return_results_to_parent_component:O=>{F(O)}},p)}),!S&&K(lx,{children:[K(lx,{children:[K("h4",{children:["[ ",E," ]"]}),K("h2",{children:["  ",l.analysis.analysis_name," ",t," "]}),K("h3",{children:["ID: ",e]})]}),!N&&D(Ue,{onClick:()=>{T(!N)},children:". . ."}),N&&K(lx,{children:[D("label",{children:l.analysis.choose_img}),K("select",{name:"op",id:"op",onChange:O=>{b(O.target.value),w(v[O.target.value].img)},children:[K("option",{value:404,children:["  ",l.analysis.test_image," "]},89),v.map((O,L)=>K("option",{value:L,children:[" ",l.analysis_results_names[O.label]," "]},L))]}),K(Ue,{onClick:()=>{F([y,x])},children:[" ",l.analysis.fake_analysis]})]}),K(Ue,{onClick:()=>{$(!S)},children:["  ",l.analysis.webcam_detection," "]}),D(M8e,{lang:i,cation:r})]})]})},lx=pe.div.withConfig({displayName:"Container",componentId:"sc-9loe9u-0"})(["margin-bottom:10px;"]),Hvt=pe.div.withConfig({displayName:"Container2",componentId:"sc-9loe9u-1"})(["color:",";display:flex;flex:1;z-index:10000;"],({theme:e})=>e.colors.typography),WH=async(e,t,n,r)=>{if(n=="cation"){const s="incomplete";await it.post(Ye.cation_analysis_result.post,{id:e,name:t,end:s,user_id:r}).catch(a=>console.log(a))}if(n=="anion"){const s="incomplete";await it.post(Ye.anion_analysis_result.post,{id:e,name:t,end:s,user_id:r}).catch(a=>console.log(a))}},VH=({cation:e,return_script:t,ion_founded:n,rerender_chat:r,lang:s})=>{const a=fn(s),[i,o]=J.useState(),[l,u]=J.useState([]),[c,d]=J.useState([]),[h,p]=J.useState(),f=e?"cation_analysis_result":"anion_analysis_result",m=e?"cation_script_flow":"anion_script_flow",g=s=="EN"?e?"cation_voice_script_en":"anion_voice_script_en":e?"cation_voice_script":"anion_voice_script",y=s=="EN"?e?"cation_voice_script_en":"anion_voice_script_en":e?"cation_voice_script":"anion_voice_script";J.useEffect(()=>{x()},[]);const b=N=>{const T=new SpeechSynthesisUtterance;T.lang=s=="EN"?"en-US":"pl-PL",T.text=N,window.speechSynthesis.speak(T)},x=async()=>{await it.get(Ye[f].get).then(N=>{u(N.data),w(N.data)}).catch(N=>{console.log("db status :(",N)})},w=async N=>{const T=N[N.length-1];if(typeof T<"u"){if(T.end=="incomplete"&&i!==100){if(T.f1==null)return o(1),!0;if(T.f2==null)return o(2),!0;if(T.f3==null)return o(3),!0;if(T.f4==null)return o(4),!0;if(T.f5==null)return o(5),!0;if(T.f6==null)return o(6),!0;if(T.f7==null)return o(7),!0}T.end=="incomplete"&&T.f7!==null&&o(8)}},v=async()=>{const N=l[l.length-1];if(i==1&&typeof i<"u"&&S(),i!==1&&typeof i<"u"){const T="f"+(i-1),C=N[T];await it.put(Ye.shuffle_match.get,{phase:i-1,label:C,db_type:m}).then(E=>{E.data.map(F=>{i==2&&F.f1==N.f1&&d(z=>[...z,F.id]),i==3&&F.f1==N.f1&&F.f2==N.f2&&d(z=>[...z,F.id]),i==4&&F.f1==N.f1&&F.f2==N.f2&&F.f3==N.f3&&d(z=>[...z,F.id]),i==5&&F.f1==N.f1&&F.f2==N.f2&&F.f3==N.f3&&F.f4==N.f4&&d(z=>[...z,F.id]),i==6&&F.f1==N.f1&&F.f2==N.f2&&F.f3==N.f3&&F.f4==N.f4&&F.f5==N.f5&&d(z=>[...z,F.id]),i==7&&F.f1==N.f1&&F.f2==N.f2&&F.f3==N.f3&&F.f4==N.f4&&F.f5==N.f5&&F.f6==N.f6&&d(z=>[...z,F.id]),i==8&&F.f1==N.f1&&F.f2==N.f2&&F.f3==N.f3&&F.f4==N.f4&&F.f5==N.f5&&F.f6==N.f6&&F.f7==N.f7&&d(z=>[...z,F.id])}),p(!0)})}},k=async()=>{const N=l[l.length-1];N.end!=="end"&&N.end!=="fail"&&await it.put(Ye[f].put,{id:N.id,end:"fail"})},I=async N=>{const T=l[l.length-1];T.end!=="end"&&await it.put(Ye[f].put,{id:T.id,end:"success"}).then(C=>{const E=`SELECT symbol FROM ${m} WHERE id = ${N}`;it.post(Ye.custom_query.get,{query:E}).then(M=>{it.put(Ye[f].set_result,{id:T.id,result:M.data[0].symbol})})})},S=async()=>{if(i){const N=`SELECT script FROM ${y} WHERE id = 1`;await it.post(Ye.custom_query.get,{query:N}).then(T=>{const C=l[l.length-1];it.post(Ye.chat_messages.post,{chat_id:C.id,message:T.data[0].script,author:"bot",ion:e?"cation":"anion"}).then(r),b(T.data[0].script)})}},$=async()=>{i&&await it.put(Ye[g].get_required_script,{phase:i,match_id:c[0]}).then(N=>{const T=l[l.length-1];if(N.data[0].f7!=="end"&&it.post(Ye.chat_messages.post,{chat_id:T.id,message:N.data[0].script,author:"bot",ion:e?"cation":"anion"}).then(r),N.data[0].f7=="end"){const C=N.data[0].script+a.analysis.end_of_analysis;it.post(Ye.chat_messages.post,{chat_id:T.id,message:C,author:"bot",ion:e?"cation":"anion"}).then(r)}N.data[0].f7!=="end"&&(b(N.data[0].script),t(N.data[0].script)),N.data[0].f7=="end"&&(n(),t(N.data[0].script),b(N.data[0].script),b(a.analysis.end_of_analysis),I(N.data[0].f6))}).catch(N=>{console.log(N)})};return J.useMemo(()=>{typeof i<"u"&&v()},[i]),J.useMemo(()=>{typeof i<"u"&&c.length!==0&&$()},[c]),J.useMemo(()=>{if(typeof i<"u"&&i!==1&&c.length==0&&h==!0){const N=l[l.length-1];it.post(Ye.chat_messages.post,{chat_id:N.id,message:a.analysis.wrong_result,author:"bot",ion:e?"cation":"anion"}).then(r).then(()=>{k()}).then(()=>{b(a.analysis.wrong_result)})}},[h]),null},oie=()=>K(jvt,{children:[" ",D(qvt,{})," ",D(Kvt,{})," ",D(Xvt,{})," "]}),jvt=pe.div.withConfig({displayName:"Containder",componentId:"sc-1h93z59-0"})(["float:left;position:relative;bottom:0px;right:10px;margin-left:10px;margin-right:1px;"]),qvt=pe.div.withConfig({displayName:"Dots1",componentId:"sc-1h93z59-1"})(["display:inline-block;width:8px;height:8px;border-radius:50%;background-color:gray;animation:jumpingAnimation 1s 0.6s linear infinite;@keyframes jumpingAnimation{0%{transform:translate(0,0);}16%{transform:translate(0,-10px);}33%{transform:translate(0,0);}100%{transform:translate(0,0);}}"]),Kvt=pe.div.withConfig({displayName:"Dots2",componentId:"sc-1h93z59-2"})(["display:inline-block;width:8px;height:8px;border-radius:50%;background-color:gray;animation:jumpingAnimation 1s 0.3s linear infinite;@keyframes jumpingAnimation{0%{transform:translate(0,0);}16%{transform:translate(0,-10px);}33%{transform:translate(0,0);}100%{transform:translate(0,0);}}"]),Xvt=pe.div.withConfig({displayName:"Dots3",componentId:"sc-1h93z59-3"})(["display:inline-block;width:8px;height:8px;border-radius:50%;background-color:gray;animation:jumpingAnimation 1s 0s linear infinite;@keyframes jumpingAnimation{0%{transform:translate(0,0);}16%{transform:translate(0,-10px);}33%{transform:translate(0,0);}100%{transform:translate(0,0);}}"]),Yvt=({script:e,phase:t,cation:n,id:r})=>{const[s,a]=J.useState(!0),i=J.useRef(null);J.useRef(null);const o=async()=>{await it.get(Ye.chat_messages.get_one_conversation+`/${r}`).then(u=>{const c=u.data;c[c.length-1].mark!="read"&&c[c.length-1].author!="human"&&(l(c[c.length-1].message),it.put(Ye.chat_messages.mark_message,{id:c[c.length-1].id,mark:"read"}))}).catch(u=>{console.log("db Chat status :(",u)})},l=u=>{if(typeof u<"u"&&u.length>0){const d=u.slice().split(" ");let h=0;a(!0);const p=setInterval(()=>{if(d.length>=h){if(typeof d[h]<"u"&&d)try{i.current.append(d[h]+" ")}catch{}try{i.current.scrollIntoView({behavior:"smooth"})}catch{}h=h+1}else a(!1),clearTimeout(p)},350)}};return J.useMemo(async()=>{typeof t=="number"&&await o()},[t]),K("div",{children:[s&&D(oie,{}),D(Zvt,{ref:i,children:"   "})]})},Zvt=pe.div.withConfig({displayName:"ChatContainer",componentId:"sc-17uwifj-0"})(["border:1px solid;border-color:rgba(255,255,255,.35);border-radius:10px;justify-content:center;width:270px;float:left;margin:5px;padding:5px;"]);pe.div.withConfig({displayName:"ActivityIndicatro",componentId:"sc-17uwifj-1"})(["width:50px;height:2px;margin:5px;background-color:",";border-radius:6px;animation:ladowanko 0.7s linear infinite alternate;@keyframes ladowanko{0%{width:0%}100%{width:50%}}"],({theme:e})=>e.colors.primary);const Jvt=({grabSound:e,return_described_to_parent_component:t,cation:n,id:r,phase:s,lang:a})=>{const[i,o]=J.useState(),[l,u]=J.useState(!0);let c="",d,h=new SpeechRecognition;h.lang=a=="PL"?"pl-PL":"en-US",h.continuous=!1,h.interimResults=!0,h.maxAlternatives=1;const p=()=>{h.start(),h.onresult=f=>{u(!0),o(f.results[0][0].transcript),c=f.results[0][0].transcript,(f.results[0][0].transcript.search("brak")!=-1||f.results[0][0].transcript.search("nic")!=-1)&&(d=0),(f.results[0][0].transcript.search("nothing")!=-1||f.results[0][0].transcript.search("nic")!=-1)&&(d=0),(f.results[0][0].transcript.search("biały")!=-1||f.results[0][0].transcript.search("białe")!=-1)&&(d=1),(f.results[0][0].transcript.search("czarny")!=-1||f.results[0][0].transcript.search("Czarny")!=-1||f.results[0][0].transcript.search("ciemny")!=-1)&&(d=2),(f.results[0][0].transcript.search("dark")!=-1||f.results[0][0].transcript.search("Czarny")!=-1||f.results[0][0].transcript.search("ciemny")!=-1)&&(d=2),(f.results[0][0].transcript.search("pomarańczowy")!=-1||f.results[0][0].transcript.search("pomarańczowym")!=-1)&&(d=9),(f.results[0][0].transcript.search("fioletowy")!=-1||f.results[0][0].transcript.search("fioletowym")!=-1)&&(d=10),(f.results[0][0].transcript.search("zółtym")!=-1||f.results[0][0].transcript.search("żółty")!=-1)&&(d=11)},h.onend=f=>{c!=null&&c.length&&it.post(Ye.chat_messages.post,{chat_id:r,message:c,author:"human",ion:n?"cation":"anion"}).then(m=>console.log("Messages db: ",m.data)).then(()=>{typeof d<"u"&&t(d)}),u(!1)}};return J.useMemo(()=>{p()},[e]),K("div",{children:[D("div",{children:i}),l&&D(oie,{})]})},UH=({cation:e,id:t,ready:n,refreshChat:r,return_results_to_parent_component:s,lang:a})=>{const i=fn(a),[o,l]=J.useState(),[u,c]=J.useState([]),[d,h]=J.useState(),[p,f]=J.useState(),[m,g]=J.useState(!1),y=J.useRef(null),[b,x]=J.useState(1),w=()=>{x(Math.random())},v=e?"cation_analysis_result":"anion_analysis_result",k=e?"cation":"anion";J.useEffect(()=>{$()},[]);const I=async T=>{const C=T[T.length-1];if(typeof C<"u"){if(C.end=="incomplete"&&o!==100){if(C.f1==null)return l(1),!0;if(C.f2==null)return l(2),!0;if(C.f3==null)return l(3),!0;if(C.f4==null)return l(4),!0;if(C.f5==null)return l(5),!0;if(C.f6==null)return l(6),!0;if(C.f7==null)return l(7),!0}C.end=="incomplete"&&C.f7!==null&&l(8)}},S=()=>{if(p&&o){const T=Object.keys(p);return T.map((C,E)=>{const M=p[C].date.replace("T"," | ").slice(13,-8);if(p[C]!==p[T.length-1]&&p[C].author=="bot"&&p[C].ion==k)return D("div",{children:K(Qvt,{children:[p[C].message," ",D("div",{style:{marginLeft:"220px",marginTop:"20px",fontSize:"11px",float:"left"},children:M})]},E)},E);if(p[C]!==p[T.length-1]&&p[C].author=="human"&&p[C].ion==k)return D("div",{children:K(ekt,{children:[p[C].message," ",D("div",{style:{marginLeft:"220px",marginTop:"20px",fontSize:"11px",float:"left"},children:M}),"  "]},E)},E)})}else return D("div",{children:i.analysis.default_message})},$=async()=>{await it.get(Ye[v].get).then(T=>{c(T.data),I(T.data)}).catch(T=>{console.log("db ChatCat status :(",T)})},N=async()=>{await it.get(Ye.chat_messages.get_one_conversation+`/${t}`).then(T=>{const C=T.data;f(C)}).catch(T=>{console.log("db status :(",T)})};return J.useMemo(async()=>{n&&N()},[n]),J.useMemo(async()=>{w()},[r]),D(okt,{children:K(tkt,{children:[D(akt,{children:i.analysis.chat_name}),K(ikt,{children:[S(),D("div",{style:{clear:"left"}}),D("div",{style:{clear:"right"}}),n&&D(Yvt,{cation:e,id:t,script:d,phase:o},b),D("div",{style:{clear:"left"}}),D(skt,{ref:y,children:K(rkt,{children:[" ",m&&D(Jvt,{lang:a,cation:e,id:t,phase:o,return_described_to_parent_component:T=>{s(T)},grabSound:3}),"   "]})})]}),D(nkt,{onClick:()=>{g(!m)},children:D("img",{style:{cursor:"pointer",backgroundColor:"rgb(200, 214, 229)",borderRadius:"5px",margin:"5px"},src:un.MICROPHONE_IMAGE,alt:"",height:25,width:25})})]})})},Qvt=pe.div.withConfig({displayName:"ChatContainer_left",componentId:"sc-vlinei-0"})(["border:1px solid;border-color:rgba(255,255,255,.35);border-radius:10px;justify-content:center;width:270px;float:left;margin:5px;padding:5px;"]),ekt=pe.div.withConfig({displayName:"ChatContainer_right",componentId:"sc-vlinei-1"})(["border:1px solid;border-color:rgba(255,255,255,.35);border-radius:10px;justify-content:center;width:270px;float:right;margin:5px;padding:5px;"]),tkt=pe.div.withConfig({displayName:"ContainerF",componentId:"sc-vlinei-2"})(["overflow:hidden;"]),nkt=pe.div.withConfig({displayName:"AnswerBox",componentId:"sc-vlinei-3"})(["height:50px;width:50px;float:right;cursor:pointer;"]),rkt=pe.div.withConfig({displayName:"Container",componentId:"sc-vlinei-4"})(["border:1px solid;border-color:rgba(255,255,255,.35);border-radius:10px;padding:5px;"]),skt=pe.div.withConfig({displayName:"Container2",componentId:"sc-vlinei-5"})(["display:flex;justify-content:flex-end;"]),akt=pe.div.withConfig({displayName:"ChatHeader",componentId:"sc-vlinei-6"})(["border:1px solid;border-color:rgba(255,255,255,.35);border-radius:10px;display:flex;flex-direction:column;justify-content:center;text-align:center;height:40px;width:100px;margin-bottom:5px;"]),ikt=pe.div.withConfig({displayName:"ChatBody",componentId:"sc-vlinei-7"})(["width:350px;padding:5px;border:1px solid;border-color:rgba(255,255,255,.35);border-radius:10px;justify-content:center;height:350px;max-height:350px;color:",";overflow-y:scroll;::-webkit-scrollbar{width:5px;background:grey;}::-webkit-scrollbar-thumb{background:#484748;}"],({theme:e})=>e.colors.typography),okt=pe.div.withConfig({displayName:"ContainerP",componentId:"sc-vlinei-8"})(["color:",";display:flex;flex-direction:column;justify-content:center;flex:1;padding:5px;"],({theme:e})=>e.colors.typography),lkt=({lang:e,userName:t,back:n})=>{const r=fn(e),[s,a]=J.useState(1),[i,o]=J.useState("start"),[l,u]=J.useState("unknown"),[c,d]=J.useState([]),[h,p]=J.useState("Default name"),[f,m]=J.useState(1),[g,y]=J.useState(1),[b,x]=J.useState(!1),[w,v]=J.useState(),[k,I]=J.useState(!1),[S,$]=J.useState(),[N,T]=J.useState(),C=()=>{a(s+1),y(Math.random()),k||v(void 0)},E=P=>{T(P)},M=P=>{const O=P[P.length-1].id+1;return m(O),O},F=async()=>{c.length==0&&await WH(1,h,l,t).then(()=>o("analiza")),c[0]&&await WH(f,h,l,t).then(()=>o("analiza"))},z=P=>{it.get(P=="cation_analysis_result"?Ye.cation_analysis_result.get:Ye.anion_analysis_result.get).then(O=>{d(O.data),M(O.data)}).catch(O=>{console.log(O)})};return D(Vk,{children:(()=>{if(i=="start")return K(Zd,{children:[K(Ue,{onClick:()=>{o("choose_ion")},children:[" ",r.analysis.new_analysis]}),K(Ue,{onClick:()=>{o("stara")},children:[" ",r.analysis.continue_analysis]})]});if(i=="choose_ion")return K(Zd,{children:[K(Ue,{onClick:()=>{o("new_analysis"),u("cation"),z("cation_analysis_result")},children:[" ",r.analysis.cation_analysis," "]}),K(Ue,{onClick:()=>{o("new_analysis"),u("anion"),z("anion_analysis_result")},children:[" ",r.analysis.anion_analysis," "]})]});if(i=="new_analysis")return D(Zd,{children:K(Vk,{children:[D(Zd,{children:K(Ue,{onClick:()=>{o("start")},children:[" ",r.common.back," "]})}),K(ukt,{children:[r.analysis.analysis_name,D("input",{style:{backgroundColor:"gray"},type:"text",onChange:P=>{p(P.target.value)}})]}),D(Zd,{children:K(Ue,{onClick:()=>{F()},children:[" ",r.analysis.analysis_begin," "]})})]})});if(i=="stara")return K(Vk,{children:[D(Vk,{children:K(Ue,{onClick:()=>{o("start")},children:[" ",r.common.back," "]})}),D("div",{children:D(N8e,{})})]});if(i=="analiza"){if(l=="cation")return K(Zd,{children:[D(BH,{lang:e,result_from_voice_description:N,chatCanTellNow:()=>{$(S+1)},cation:!0,rerender:()=>{x(!1),C()},name:h,id:f,back:()=>{n("UserIonAnalysis")}},g),D(VH,{lang:e,rerender_chat:()=>{x(!0)},ion_founded:()=>{I(!0)},cation:!0,return_script:P=>{v(P)}},g+3),D(UH,{lang:e,return_results_to_parent_component:P=>{T(P),E(P)},refreshChat:S,id:f,cation:!0,script:w,ready:b},g+9)]});if(l=="anion")return K(Zd,{children:[D(BH,{lang:e,result_from_voice_description:N,chatCanTellNow:()=>{$(S+1)},cation:!1,rerender:()=>{x(!1),C()},name:h,id:f,back:()=>{n("UserIonAnalysis")}},g),D(VH,{lang:e,rerender_chat:()=>{x(!0)},ion_founded:()=>{I(!0)},cation:!1,return_script:P=>{v(P)}},g+3),D(UH,{lang:e,return_results_to_parent_component:P=>{T(P),E(P)},refreshChat:S,id:f,cation:!1,script:w,ready:b},g+9)]})}})()})},Vk=pe.div.withConfig({displayName:"Container",componentId:"sc-1ehmi1c-0"})(["position:absolute;width:100%;top:20%;display:flex;flex-direction:column;align-items:center;justify-content:center;border:1px solid;border-color:rgba(255,255,255,.15);background-color:#161b22;"]),Zd=pe.div.withConfig({displayName:"ContainerP",componentId:"sc-1ehmi1c-1"})(["color:",";display:flex;flex-direction:row;justify-content:center;flex:1;"],({theme:e})=>e.colors.typography),ukt=pe.div.withConfig({displayName:"ContainerW",componentId:"sc-1ehmi1c-2"})(["color:",";display:flex;flex-direction:column;justify-content:center;flex:1;"],({theme:e})=>e.colors.typography),ckt=({lang:e,userName:t})=>{const n=fn(e),r=J.useRef(null),s=J.useRef(null),a=J.useRef(null),i=J.useRef(null),o=J.useRef(null),[l,u]=J.useState(),[c,d]=J.useState(),[h,p]=J.useState(!1),[f,m]=J.useState(),[g,y]=J.useState(),[b,x]=J.useState([]),[w,v]=J.useState(),[k,I]=J.useState(),[S,$]=J.useState(1),[N,T]=J.useState(!1),[C,E]=J.useState("panel"),[M,F]=J.useState(),[z,H]=J.useState(),[P,O]=J.useState(),[L,V]=J.useState("Default"),[q,B]=J.useState([]),[X,ee]=J.useState([]),[Z,fe]=J.useState("start"),[Q,be]=J.useState(),[we,Ne]=J.useState(),$e=()=>{$(Math.random()+1)},je=De=>{var pt=i.current.getBoundingClientRect();i.current.onMouseMove;const tn={x:De.clientX-pt.left,y:De.clientY-pt.top};d(tn),p(!0)},He=async De=>{const pt=o.current;i.current.onMouseMove;const tn={x:De.clientX,y:De.clientY-(g==null?void 0:g.height)};var zn=pt.getContext("2d");zn.fillStyle="#9ea7b8",zn.fillRect(c==null?void 0:c.x,c==null?void 0:c.y,g==null?void 0:g.width,g==null?void 0:g.height),pt.style.opacity="0.3",p(!1),await Fe().then(()=>{Qe(tn),T(!0)})},Re=De=>{if(De.preventDefault(),De.stopPropagation(),!h)return;const pt=o.current;let tn=De.clientX-f.left,zn=De.clientY-f.top;var qr=pt.getContext("2d");qr.clearRect(0,0,pt.width,pt.height);let Zt=tn-(c==null?void 0:c.x),Kr=zn-(c==null?void 0:c.y);y({width:Zt,height:Kr}),qr.strokeRect(c==null?void 0:c.x,c==null?void 0:c.y,Zt,Kr),a.current.getContext("2d").drawImage(i.current,c.x,c.y,Zt,Kr,0,0,Math.abs(Zt),Math.abs(Kr))},Fe=async()=>{a.current.width=Math.abs(g.width),a.current.height=Math.abs(g.height),a.current.getContext("2d").drawImage(i.current,c.x,c.y,g.width,g.height,0,0,Math.abs(g.width),Math.abs(g.height)),await on()},Pe=De=>{var pt=5,tn={r:12,g:12,b:12},zn=document.createElement("canvas"),qr=De.getContext("2d"),Zt,Kr,pa,ci=-4,hl,fa={r:10,g:10,b:10},ke=0;if(!qr)return tn;pa=zn.height=De.naturalHeight||De.offsetHeight||De.height,Kr=zn.width=De.naturalWidth||De.offsetWidth||De.width,qr.drawImage(De,0,0);try{Zt=qr.getImageData(0,0,Kr,pa)}catch{return alert("x"),tn}for(hl=Zt.data.length;(ci+=pt*4)<hl;)++ke,fa.r+=Zt.data[ci],fa.g+=Zt.data[ci+1],fa.b+=Zt.data[ci+2];return fa.r=~~(fa.r/ke),fa.g=~~(fa.g/ke),fa.b=~~(fa.b/ke),fa},Je=async()=>{if(r.current){const De=r.current.getScreenshot();if(De){const pt=new Image(540,380);pt.src=De,await Ws().then(()=>{an(pt)})}}},pn=async De=>{const pt=new Image(540,380),tn=new FileReader;tn.readAsDataURL(De[0]),tn.onloadend=async()=>{const zn=tn.result;pt.src=zn},await Bi().then(()=>{an(pt)})},ct=async()=>{if(r.current){const De=r.current.getScreenshot();if(De){const pt=new Image(540,380);pt.src=De,await Bi().then(()=>{an(pt)})}}},an=De=>{i.current.width=540,i.current.height=380,o.current.width=540,o.current.height=380,i.current.getContext("2d").drawImage(De,0,0,540,380),m(i.current.getBoundingClientRect())},Lt=()=>{if(k){const pt=a.current.toDataURL(),tn={value:k,img:pt,rgb:z,rgbForDiv:P};x(qr=>[...qr,tn]),$e(),T(!1);const zn=o.current;var De=zn.getContext("2d");De.clearRect(0,0,zn.width,zn.height),F("no")}},Gt=async()=>{T(!1);const De=o.current;var pt=De.getContext("2d");pt.clearRect(0,0,De.width,De.height),F("no");let tn=0,zn=0,qr=0,Zt=1e3,Kr=1e4;await X.map((pa,ci)=>{pa.R!=null&&(tn=Math.abs(pa.R-z.r),zn=Math.abs(pa.G-z.g),qr=Math.abs(pa.B-z.b),tn/z.r,zn/z.g,qr/z.b,Zt=tn+zn+qr,Zt<=Kr&&(Kr=Zt,Ne(pa.ph)))})};J.useMemo(()=>{M=="ok"&&C=="labellinngPh"&&Lt(),M=="ok"&&C=="makeComparison"&&Gt()},[M]);const Qe=De=>{C=="labellinngPh"&&v(K(qH,{style:{top:`${De.y+"px"}`,left:`${De.x+"px"}`},children:[D("input",{type:"text",placeholder:n.ph.p_value,onChange:pt=>{I(pt.target.value)}}),D(Ue,{onClick:()=>{F("ok")},children:"OK"})]},S+1)),C=="makeComparison"&&v(D(qH,{style:{top:`${De.y+"px"}`,left:`${De.x+"px"}`},children:D(Ue,{onClick:()=>{F("ok")},children:"OK"})},S+1))},It=()=>{if(Z=="makeScreenToComparison")return K(fm,{children:[D(Mh,{ref:r,muted:!0,screenshotFormat:"image/jpeg",style:{margin:10,width:540,height:380}}),D(uu,{children:K(Ue,{style:{width:"150px",height:"50px"},onClick:()=>{ct()},children:[" ",n.ph.take_screenshot," "]})})]});if(Z=="getFileFromDevice")return D(fm,{children:D(uu,{children:D("input",{type:"file",multiple:!0,onChange:De=>{const pt=De.target.files;pn(pt),De.target.files[0].name.slice(0,-4)}})})})},mn=()=>{if(Z=="start")return K("div",{children:[K(Ue,{style:{width:"auto",height:"50px",zIndex:2},onClick:()=>{fe("makeScreenToComparison")},children:[" ",n.ph.take_screenshot,"  "]}),K(Ue,{style:{width:"auto",height:"50px",zIndex:2},onClick:()=>{fe("getFileFromDevice")},children:[" ",n.ph.file_from_device,"  "]})]});if(Z=="imageTaken")return K("div",{children:[D(fD,{ref:i}),D(jH,{onMouseMove:De=>{Re(De)},onMouseUp:De=>{He(De)},onMouseDown:De=>{je(De)},ref:o})]})},en=()=>w,on=()=>{let De=Pe(a.current);s.current.style.backgroundColor="rgb("+De.r+","+De.g+","+De.b+")",O("rgb("+De.r+","+De.g+","+De.b+")"),H(De),u("RGB ["+De.r+" , "+De.g+" , "+De.b+"]")},Ws=async()=>{E("labellinngPh")},Bi=async()=>{fe("imageTaken")},ha=async()=>{const De=Object.keys(b);let pt=L;L=="Default"&&(pt="Default"+new Date().toISOString().toString());const tn=t||"test",zn=i.current.toDataURL(),qr=`INSERT INTO ph_analysis (username, img, ph, rgb, date, analysis_name) VALUES ('${tn}','${zn}','prime','-',now(), '${pt}') `;it.post(Ye.custom_query.get,{query:qr}).then(()=>{De.map(Zt=>{const Kr=`INSERT INTO ph_analysis (username, img, ph, rgb, date, analysis_name,R,G,B,ph_number) VALUES ('${tn}','${b[Zt].img}','${b[Zt].value}','${b[Zt].rgbForDiv}',now(), '${pt}',${b[Zt].rgb.r},${b[Zt].rgb.g},${b[Zt].rgb.b},${b[Zt].value}) `;it.post(Ye.custom_query.get,{query:Kr}).then().catch(pa=>{console.log("send status :(",pa)})})}).then(()=>{E("panel")}).catch(Zt=>{console.log("send status :(",Zt)})},tu=()=>{const De=t?`SELECT DISTINCT analysis_name FROM ph_analysis WHERE username = '${t}'`:"SELECT DISTINCT analysis_name FROM ph_analysis";it.post(Ye.custom_query.get,{query:De}).then(pt=>{B(pt.data)}).then().catch(pt=>{console.log("send status :(",pt)})},Es=De=>{const pt=`SELECT * FROM ph_analysis WHERE analysis_name = '${De}' ORDER BY ph_number `;it.post(Ye.custom_query.get,{query:pt}).then(tn=>{ee(tn.data)}).then(()=>{const tn=`SELECT CONVERT(img USING utf8) as img FROM ph_analysis WHERE analysis_name = '${De}' AND ph = 'prime' `;it.post(Ye.custom_query.get,{query:tn}).then(zn=>{be(zn.data)})}).catch(tn=>{console.log("send status :(",tn)})};return D(dkt,{children:(()=>{if(C=="panel")return D(fm,{children:K(uu,{children:[K(Ue,{style:{width:"auto",height:"50px",zIndex:2},onClick:()=>{E("start")},children:[" ",n.ph.new_calibrations,"  "]}),K(Ue,{style:{width:"auto",height:"50px",zIndex:2},onClick:()=>{E("choose"),tu()},children:[" ",n.ph.prevoius_calibrations," "]})]})});if(C=="choose")return D(fm,{children:K(uu,{children:[D("span",{style:{margin:"10px"},children:n.ph.saved_cal}),D(co,{children:D("table",{children:D("tbody",{children:q.map((De,pt)=>D("tr",{children:D(Qd,{style:{cursor:"pointer",width:"180px",borderRadius:"5px"},onClick:()=>{Es(De.analysis_name),E("makeComparison")},children:De.analysis_name})},pt))})})})]})});if(C=="makeComparison")return K(GH,{children:[N&&en(),K(HH,{style:{overflowY:"hidden",width:"250px"},children:[K("div",{children:[D("h3",{children:"pH table:"}),Q&&D("img",{style:{width:"220px",height:"100px"},src:Q[0].img,alt:""}),D(co,{style:{height:"200px"},children:D("table",{children:K("tbody",{children:[K(Yo,{children:[D(Jd,{children:" pH"},100),D(Jd,{children:"color"},300),D(Jd,{children:"rgb"},400)]}),X.map((De,pt)=>K("tr",{children:[D(Qd,{children:De.ph_number}),D(Qd,{style:{backgroundColor:`${De.rgb}`}}),K(Qd,{style:{fontSize:"small"},children:["[",De.rgb,"]"]})]},pt))]})})})]}),D("div",{})]},S+100),K("div",{style:{margin:"10px",position:"relative",width:"auto",height:"auto"},children:[It(),mn()]}),K(pD,{style:{width:"300px"},children:[D("h3",{children:n.ph.preview}),K(uu,{style:{marginLeft:"0px",marginRight:"0px",width:"auto"},children:[D("div",{children:D("canvas",{ref:a,style:{height:`${g?g.height+"px":"0px"}`,width:`${g?g.width+"px":"0px"}`}})}),D("div",{children:K("div",{style:{marginTop:"10px",width:"100px",height:"100px",zIndex:"100"},ref:s,children:[" ",D("h6",{children:l}),"  "]})})]}),K(uu,{style:{marginLeft:"0px",marginRight:"0px",width:"auto"},children:[n.ph.result," ",we]})]})]});if(C=="start")return D(fm,{children:K(uu,{style:{width:"250px",maxWidth:"300px"},children:[n.ph.cal_name,D("input",{style:{backgroundColor:"gray"},type:"text",onChange:De=>{V(De.target.value)}}),K(Ue,{style:{width:"auto",height:"50px",zIndex:2},onClick:()=>{E("takeImg")},children:[" ",n.common.begin,"  "]})]})});if(C=="takeImg")return K(fm,{children:[D(Mh,{ref:r,muted:!0,screenshotFormat:"image/jpeg",style:{margin:10,width:540,height:380}}),K(uu,{children:[D(Ue,{style:{width:"150px",height:"50px"},onClick:()=>{Je()},children:n.ph.take_screenshot}),K(Ue,{style:{width:"auto",height:"50px",zIndex:2},onClick:()=>{fe("getFileFromDevice")},children:[" ",n.ph.file_from_device,"  "]})]})]});if(C=="labellinngPh"){const De=Object.keys(b);return K(GH,{children:[N&&en(),K(pD,{children:[D("h3",{children:n.ph.preview}),D("div",{children:D("canvas",{ref:a,style:{height:`${g?g.height+"px":"0px"}`,width:`${g?g.width+"px":"0px"}`}})}),D("div",{children:K("div",{style:{marginTop:"10px",width:"100px",height:"100px",zIndex:"100"},ref:s,children:[" ",D("h6",{children:l}),"  "]})})]}),K("div",{style:{margin:"10px",position:"relative",width:"auto",height:"auto"},children:[D(fD,{ref:i}),D(jH,{onMouseMove:pt=>{Re(pt)},onMouseUp:pt=>{He(pt)},onMouseDown:pt=>{je(pt)},ref:o})]}),K(HH,{style:{overflowY:"hidden"},children:[K("div",{children:[D("h3",{children:n.ph.ph_table}),D(Ue,{style:{float:"right"},onClick:()=>{ha()},children:"Save"}),D(co,{children:D("table",{children:K("tbody",{children:[K(Yo,{children:[D(Jd,{children:" pH"},100),D(Jd,{children:"img"},200),D(Jd,{children:"color"},300),D(Jd,{children:"rgb"},400)]}),De.map((pt,tn)=>K("tr",{children:[D(Qd,{children:b[pt].value}),K(bi,{children:["  ",D(hkt,{src:b[pt].img})]}),D(Qd,{style:{backgroundColor:`${b[pt].rgbForDiv}`}}),K(Qd,{style:{fontSize:"small"},children:["[",b[pt].rgb.r,"-",b[pt].rgb.g,"-",b[pt].rgb.b,"]"]})]},tn))]})})})]}),D("div",{})]},S+100)]})}})()})},dkt=pe.div.withConfig({displayName:"MainContainer",componentId:"sc-1kqvuvo-0"})(["position:absolute;width:100%;top:20%;display:flex;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border:1px solid;border-color:rgba(255,255,255,.15);background-color:#161b22;"]),fm=pe.div.withConfig({displayName:"CenterContainer",componentId:"sc-1kqvuvo-1"})(["color:",";display:flex;flex-direction:row;flex:1;justify-content:center;"],({theme:e})=>e.colors.typography),GH=pe.div.withConfig({displayName:"OrderContainer",componentId:"sc-1kqvuvo-2"})(["color:",";display:flex;flex-direction:row;flex:1;justify-content:space-between;"],({theme:e})=>e.colors.typography),uu=pe.div.withConfig({displayName:"Container",componentId:"sc-1kqvuvo-3"})(["display:flex;justify-content:center;flex-direction:column;z-index:2;width:200px;max-width:200px;overflow:hidden;padding:10px;margin-left:30px;margin-right:30px;border:1px solid;border-color:rgba(255,255,255,.15);border:1px solid;border-color:rgba(255,255,255,.15);"]),pD=pe(uu).withConfig({displayName:"SpaceBetweenContainer",componentId:"sc-1kqvuvo-4"})(["justify-content:space-between;"]),HH=pe(pD).withConfig({displayName:"SavedContainer",componentId:"sc-1kqvuvo-5"})(["width:350px;max-width:350px;"]),fD=pe.canvas.withConfig({displayName:"Canvas",componentId:"sc-1kqvuvo-6"})(["width:540px;height:380px;z-index:3;"]),jH=pe(fD).withConfig({displayName:"DrawCanvas",componentId:"sc-1kqvuvo-7"})(["position:absolute;z-index:5;top:0;right:0;"]),qH=pe.div.withConfig({displayName:"LabelComponent",componentId:"sc-1kqvuvo-8"})(["position:fixed;z-index:100;height:auto;"]),Jd=pe.th.withConfig({displayName:"Th",componentId:"sc-1kqvuvo-9"})(["border:1px solid gray;justify-content:center;"]),Qd=pe.td.withConfig({displayName:"Td",componentId:"sc-1kqvuvo-10"})(["border:1px solid gray;justify-content:center;text-align:center;"]),hkt=pe(Uo).withConfig({displayName:"MyImage2",componentId:"sc-1kqvuvo-11"})(["width:20;height:20;"]),pkt=({lang:e})=>{const t=fn(e),[n,r]=J.useState(!1),[s,a]=J.useState(!1),[i,o]=J.useState(!1),[l,u]=J.useState(),[c,d]=J.useState(),[h,p]=J.useState(),[f,m]=J.useState([]),g=J.useRef(null),y=340,b=520,x=J.useRef(null),w=J.useRef(null);J.useEffect(()=>{(async()=>{const $=un.FACES_MODELS_URL;Promise.all([wn.tinyFaceDetector.loadFromUri($),wn.faceLandmark68Net.loadFromUri($),wn.faceRecognitionNet.loadFromUri($),wn.faceExpressionNet.loadFromUri($),wn.ageGenderNet.loadFromUri($),wn.ssdMobilenetv1.loadFromUri($)]).then(async()=>{r(!0);const N="SELECT id, CONVERT(img1 USING utf8) as img1, CONVERT(img2 USING utf8) as img2, CONVERT(img3 USING utf8) as img3, username, date FROM face_img_storage";await it.post(Ye.custom_query.get,{query:N}).then(T=>{m(T.data)})})})()},[]);const v=()=>{a(!0),o(!0)},k=async()=>{if(typeof g.current<"u"&&g.current!==null&&g.current.video){const S=Object.keys(f);return Promise.all(S.map(async $=>{let N=[];const T=f[$];for(let C=1;C==1;C++){const E=T[`img${C}`],M=await $L(E),F=await YL(M).withFaceLandmarks().withFaceDescriptor();N.push(F==null?void 0:F.descriptor)}if(N.length)return new xc(T.username,N)}))}},I=async()=>{if(typeof g.current<"u"&&g.current!==null&&g.current.video){const S=await k(),$=new I2(S),N={width:b,height:y};TL(x.current,N),setInterval(async()=>{var T;if((T=g.current)!=null&&T.video){const C=await ZL(g.current.video,new v2).withFaceLandmarks().withFaceDescriptors().withFaceExpressions().withAgeAndGender(),E=S2(C,N);x&&x.current&&x.current.getContext("2d").clearRect(0,0,b,y),x&&x.current&&Ll.drawDetections(x.current,E),x&&x.current&&Ll.drawFaceLandmarks(x.current,E);const M=E.map(F=>$.findBestMatch(F.descriptor));if(C){u(parseInt(C[0].age.toString())),d(C[0].gender);const F=C[0].expressions,z=Object.keys(F),H=Object.values(F);z.map(P=>{F[P]==Math.max(...H)&&p(P)})}M.forEach(async(F,z)=>{const H=E[z].detection.box;new Ll.DrawBox(H,{label:F}).draw(x.current)})}},100)}};return J.useMemo(()=>{if(s){const S=setInterval(()=>{typeof g.current<"u"&&g.current!==null&&g.current.video&&(clearInterval(S),I())},100)}},[s]),K(mkt,{children:[D("div",{style:{textAlign:"center",padding:"10px"},children:!i&&D(Ue,{onClick:v,style:{cursor:"pointer",display:f[0]?"block":"none"},children:t.face_recognition.open_webcam})}),s?n?D("div",{children:K(fkt,{children:[D(Mh,{ref:g,height:y,width:b,style:{display:"block",position:"fixed",right:"30%",borderRadius:"10px"}}),D("canvas",{ref:x,style:{display:"block",position:"fixed",right:"30%"}})]})}):D("div",{children:"loading..."}):D(wD,{children:"  "}),s&&n&&K(gkt,{children:[K(X_,{children:[t.face_recognition.age," ",l]}),K(X_,{children:[t.face_recognition.gender," ",c]}),K(X_,{children:[t.face_recognition.expression," ",h]})]}),D("canvas",{style:{width:640,height:480,margin:5,display:"none"},ref:w})]})},fkt=pe.div.withConfig({displayName:"Container",componentId:"sc-1iqyn7d-0"})(["position:relative;top:20%;z-index:5;justify-content:center;"]),mkt=pe.div.withConfig({displayName:"ContainerC",componentId:"sc-1iqyn7d-1"})(["position:absolute;width:100%;top:20%;display:flex;flex-direction:column;align-items:center;justify-content:center;border:1px solid;border-color:rgba(255,255,255,.15);"]),X_=pe.div.withConfig({displayName:"ContainerLabel",componentId:"sc-1iqyn7d-2"})(["margin:20px;"]),gkt=pe.div.withConfig({displayName:"ContainerC2",componentId:"sc-1iqyn7d-3"})(["position:absolute;width:200px;top:50%;left:30px;display:flex;flex-direction:column;align-items:center;justify-content:center;border:1px solid;border-color:rgba(255,255,255,.15);"]),ykt=({userName:e,lang:t,back:n})=>{const r=fn(t),[s,a]=J.useState(!1),[i,o]=J.useState(!1),[l,u]=J.useState(),[c,d]=J.useState([]),[h,p]=J.useState(!1),[f,m]=J.useState(!1),g=J.useRef(null),y=240,b=320,x=J.useRef(null),w=J.useRef(null);J.useEffect(()=>{u(e),(async()=>{const T=un.FACES_MODELS_URL;Promise.all([wn.tinyFaceDetector.loadFromUri(T),wn.faceLandmark68Net.loadFromUri(T),wn.faceRecognitionNet.loadFromUri(T),wn.faceExpressionNet.loadFromUri(T),wn.ageGenderNet.loadFromUri(T),wn.ssdMobilenetv1.loadFromUri(T)]).then(()=>{a(!0)})})()},[]);const v=async()=>{if(typeof c[2]<"u"){const N=`INSERT INTO face_img_storage (userName, img1, img2, img3, date) VALUES ('${e}','${c[0]}','${c[1]}','${c[2]}',now()) `;await it.post(Ye.custom_query.get,{query:N}).catch(T=>{console.log("send status :(",T)})}};J.useMemo(()=>{v()},[c]);const k=()=>{o(!1)},I=()=>{o(!0)},S=async()=>{if(typeof g.current<"u"&&g.current!==null&&g.current.video){const N=g.current.video;w.current.width=640,w.current.height=480;let T=[];const C=l;for(let E=1;E<=3;E++){w.current.getContext("2d").drawImage(N,0,0,640,480);const M=w.current.toDataURL(),F=await $L(M);d(H=>[...H,M]);const z=await YL(F).withFaceLandmarks().withFaceDescriptor();T.push(z==null?void 0:z.descriptor)}if(typeof T<"u")return await v().then(()=>{m(!1)}),new xc(C,T)}},$=async()=>{if(typeof g.current<"u"&&g.current!==null&&g.current.video){const N=await S(),T=new I2(N),C={width:b,height:y};TL(x.current,C),setInterval(async()=>{var E;if((E=g.current)!=null&&E.video){const M=await ZL(g.current.video,new v2).withFaceLandmarks().withFaceDescriptors(),F=S2(M,C);x&&x.current&&x.current.getContext("2d").clearRect(0,0,b,y),x&&x.current&&Ll.drawDetections(x.current,F),x&&x.current&&Ll.drawFaceLandmarks(x.current,F),F.map(H=>T.findBestMatch(H.descriptor)).forEach((H,P)=>{const O=F[P].detection.box;new Ll.DrawBox(O,{label:H}).draw(x.current)})}},100)}};return K(xkt,{children:[D("h3",{children:"Your new Face ID"}),D(bkt,{children:K(wkt,{children:[K("div",{style:{width:"100px"},children:[D(Ue,{onClick:()=>{n()},children:r.common.back}),D("canvas",{style:{width:100,height:100,margin:5,display:"none"},ref:w})]}),K(vkt,{children:[i&&s?K(Ue,{onClick:k,children:[" ",r.face_recognition.close_webcam," "]}):K(Ue,{onClick:I,children:[" ",r.face_recognition.open_webcam," "]}),i?s?D("div",{children:K("div",{style:{display:"flex",justifyContent:"center",padding:"10px"},children:[D(Mh,{ref:g,height:y,width:b,style:{borderRadius:"10px",border:f?"3px solid red":"none"}}),D("canvas",{ref:x,style:{position:"absolute"}})]})}):D("div",{children:"loading..."}):D(wD,{children:"  "})]}),i&&s&&K(lie,{children:[!h&&D(Ue,{onClick:()=>{$(),m(!0),p(!0)},style:{cursor:"pointer"},children:r.face_recognition.start_scan}),c[0]&&c.map((N,T)=>D(kkt,{src:N},T))]})]})})]})},bkt=pe.div.withConfig({displayName:"MainContainer2",componentId:"sc-1kgehyq-0"})(["width:100%;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border:1px solid;border-color:rgba(255,255,255,.15);background-color:#161b22;"]),xkt=pe.div.withConfig({displayName:"MainContainer1",componentId:"sc-1kgehyq-1"})(["justify-content:center;"]),wkt=pe.div.withConfig({displayName:"OrderContainer",componentId:"sc-1kgehyq-2"})(["color:",";display:flex;flex-direction:row;flex:1;justify-content:space-between;"],({theme:e})=>e.colors.typography),lie=pe.div.withConfig({displayName:"Container",componentId:"sc-1kgehyq-3"})(["display:flex;justify-content:center;flex-direction:column;z-index:2;width:200px;max-width:200px;overflow:hidden;padding:10px;margin-left:30px;margin-right:30px;border:1px solid;border-color:rgba(255,255,255,.15);"]),vkt=pe(lie).withConfig({displayName:"SpaceBetweenContainer",componentId:"sc-1kgehyq-4"})(["width:350px;max-width:350px;justify-content:space-between;"]),kkt=pe.img.withConfig({displayName:"Image",componentId:"sc-1kgehyq-5"})(["width:70px;height:70px;margin:10px;display:flex;justify-self:center;"]);var mD={},Ikt={get exports(){return mD},set exports(e){mD=e}};(function(e,t){(function(n,r){r()})(mi,function(){function n(u,c){return typeof c>"u"?c={autoBom:!1}:typeof c!="object"&&(console.warn("Deprecated: Expected third argument to be a object"),c={autoBom:!c}),c.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(u.type)?new Blob(["\uFEFF",u],{type:u.type}):u}function r(u,c,d){var h=new XMLHttpRequest;h.open("GET",u),h.responseType="blob",h.onload=function(){l(h.response,c,d)},h.onerror=function(){console.error("could not download file")},h.send()}function s(u){var c=new XMLHttpRequest;c.open("HEAD",u,!1);try{c.send()}catch{}return 200<=c.status&&299>=c.status}function a(u){try{u.dispatchEvent(new MouseEvent("click"))}catch{var c=document.createEvent("MouseEvents");c.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),u.dispatchEvent(c)}}var i=typeof window=="object"&&window.window===window?window:typeof self=="object"&&self.self===self?self:typeof mi=="object"&&mi.global===mi?mi:void 0,o=i.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),l=i.saveAs||(typeof window!="object"||window!==i?function(){}:"download"in HTMLAnchorElement.prototype&&!o?function(u,c,d){var h=i.URL||i.webkitURL,p=document.createElement("a");c=c||u.name||"download",p.download=c,p.rel="noopener",typeof u=="string"?(p.href=u,p.origin===location.origin?a(p):s(p.href)?r(u,c,d):a(p,p.target="_blank")):(p.href=h.createObjectURL(u),setTimeout(function(){h.revokeObjectURL(p.href)},4e4),setTimeout(function(){a(p)},0))}:"msSaveOrOpenBlob"in navigator?function(u,c,d){if(c=c||u.name||"download",typeof u!="string")navigator.msSaveOrOpenBlob(n(u,d),c);else if(s(u))r(u,c,d);else{var h=document.createElement("a");h.href=u,h.target="_blank",setTimeout(function(){a(h)})}}:function(u,c,d,h){if(h=h||open("","_blank"),h&&(h.document.title=h.document.body.innerText="downloading..."),typeof u=="string")return r(u,c,d);var p=u.type==="application/octet-stream",f=/constructor/i.test(i.HTMLElement)||i.safari,m=/CriOS\/[\d]+/.test(navigator.userAgent);if((m||p&&f||o)&&typeof FileReader<"u"){var g=new FileReader;g.onloadend=function(){var x=g.result;x=m?x:x.replace(/^data:[^;]*;/,"data:attachment/file;"),h?h.location.href=x:location=x,h=null},g.readAsDataURL(u)}else{var y=i.URL||i.webkitURL,b=y.createObjectURL(u);h?h.location=b:location.href=b,h=null,setTimeout(function(){y.revokeObjectURL(b)},4e4)}});i.saveAs=l.saveAs=l,e.exports=l})})(Ikt);const Skt=({lang:e})=>{const[t,n]=J.useState(null),[r,s]=J.useState(1),[a,i]=J.useState(1),o=Kg.useRef(null),l=()=>{const d=o.current.getScreenshot();n(d);const p="zdjecie_"+a.toString()+".jpg";mD.saveAs(d,p),i(a+1),u()},u=async()=>{i(a+1)};return K("section",{style:{display:"flex",flexDirection:"row"},children:[K(KH,{children:[D(Ue,{style:{margin:"10px"},onClick:l,children:"Zapisz aktualny obraz z kamery"}),D("input",{onChange:d=>{s(d.target.value)}}),D(Ue,{onClick:async()=>{let d=1;const h=setInterval(()=>{d>=r&&clearInterval(h),l(),d++},2e3)},children:"Multiple shot"})]}),K(KH,{children:[D(Mh,{audio:!1,height:480,ref:o,screenshotFormat:"image/jpeg",width:640,videoConstraints:Ckt}),K("p",{children:["Liczba zapisanych zdjęć: ",a-1]}),D("img",{width:100,height:100,src:t,alt:"screenshot"})]})]})},KH=pe.div.withConfig({displayName:"Container",componentId:"sc-1vpfkgc-0"})(["display:flex;flex-direction:column;justify-content:center;justify-items:center;width:200px;"]),Ckt={width:640,height:480,facingMode:"user"},Nkt=({lang:e})=>{const t=fn(e);return K($kt,{children:[K(XH,{children:[t.user_help.system_info,D("a",{style:{color:"gray"},href:un.GITHUB_URL,children:t.components.header.github})," "]}),D("p",{}),K(XH,{children:[t.user_help.model_info,D("a",{style:{color:"gray"},href:un.MODELS_URL,children:t.components.footer.models})]})]})},$kt=pe.div.withConfig({displayName:"MainContainer",componentId:"sc-2u1oa4-0"})(["position:absolute;width:100%;top:20%;display:flex;display:flex;flex-direction:column;align-items:center;justify-content:space-between;border:1px solid;border-color:rgba(255,255,255,.15);background-color:#161b22;"]),XH=pe.span.withConfig({displayName:"Text",componentId:"sc-2u1oa4-1"})(["margin:10px;"]),Tkt=({lang:e,userName:t})=>{const[n,r]=J.useState(),[s,a]=J.useState(1),i=()=>{a(Math.random())};return K(_kt,{children:[K(Ekt,{children:[D(Ue,{onClick:()=>{r("anion_analysis_result"),i()},children:"Anion"}),D(Ue,{onClick:()=>{r("cation_analysis_result"),i()},children:"Cation"})]}),n&&D(sR,{lang:e,rout_name:n,user:!0,userName:t},s)]})},_kt=pe.div.withConfig({displayName:"MainContainer",componentId:"sc-1qktxwa-0"})(["position:absolute;width:100%;top:20%;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border:1px solid;border-color:rgba(255,255,255,.15);background-color:#161b22;"]),Ekt=pe.div.withConfig({displayName:"Container",componentId:"sc-1qktxwa-1"})(["display:flex;flex-direction:column;"]),Akt=({lang:e,userName:t})=>D(Rkt,{children:D(sQ,{lang:e,user:!0,userName:t})}),Rkt=pe.div.withConfig({displayName:"MainContainer",componentId:"sc-865aow-0"})(["position:absolute;width:100%;top:20%;display:flex;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border:1px solid;border-color:rgba(255,255,255,.15);background-color:#161b22;"]),Dkt=({lang:e,userName:t})=>{const n=fn(e),[r,s]=J.useState(),[a,i]=J.useState(),o=async()=>{const c=`SELECT * FROM account_credentials WHERE username = '${t}' `;await it.post(Ye.custom_query.get,{query:c}).then(d=>{s(d.data[0])}).catch(d=>{console.log("db status :(",d)})},l=async()=>{const c=`SELECT CONVERT(img1 USING utf8) as img FROM face_img_storage WHERE username = '${t}'`;await it.post(Ye.custom_query.get,{query:c}).then(d=>{i(d.data[0].img)}).catch(d=>{console.log("db status :(",d)})};J.useEffect(()=>{o(),l()},[]);const u=c=>{const d=c.length;let h="";for(let p=0;p<d;p++)h=h+"*";return h};return K(Fkt,{children:[K(Mkt,{children:[n.user_profile.data_header,D(wm,{}),K(ux,{children:[n.user_profile.username,"    ",D("span",{}),"  ",r!=null&&r.username?r.username:n.common.no_data,"                                "]}),K(wm,{children:[n.user_profile.first_name,"   ",D("span",{}),"  ",r!=null&&r.first_name?r.first_name:n.common.no_data,"                            "]}),K(ux,{children:[n.user_profile.last_name,"   ",D("span",{}),"  ",r!=null&&r.last_name?r.last_name:n.common.no_data,"                              "]}),K(wm,{children:[n.user_profile.emial,"        ",D("span",{}),"  ",r!=null&&r.email?r.email:n.common.no_data,"                                      "]}),K(ux,{children:[n.user_profile.phone,"       ",D("span",{}),"  ",r!=null&&r.phone?r.phone:n.common.no_data,"                              "]}),K(wm,{children:[n.user_profile.auth,"         ",D("span",{}),"  ",r!=null&&r.id?r.id:n.common.no_data,"                                      "]}),K(ux,{children:[n.user_profile.password,"    ",D("span",{}),"  ",r!=null&&r.password?u(r.password):n.common.no_data,"        "]}),K(wm,{children:[" ",n.user_profile.accout_type,"        ",D("span",{})," ",r!=null&&r.status?r.status:n.common.no_data,"      "]}),K(ux,{children:[n.user_profile.date,"  ",D("span",{}),"   ",r!=null&&r.date?r.date.replace("T"," | ").slice(0,-16):n.common.no_data,"         "]})]}),D(Pkt,{children:K(Lkt,{children:[n.user_profile.image_header,D(zkt,{src:a||un.USER_IMG_URL})]})})]})},Fkt=pe.div.withConfig({displayName:"OrderContainer",componentId:"sc-1hhhoqs-0"})(["color:",";display:flex;flex-direction:row;flex:1;margin:10px;"],({theme:e})=>e.colors.typography),Okt=pe.div.withConfig({displayName:"Container",componentId:"sc-1hhhoqs-1"})(["display:flex;justify-content:center;flex-direction:column;z-index:2;overflow:hidden;padding:10px;margin-left:30px;margin-right:30px;border:1px solid;border-color:rgba(255,255,255,.15);"]),Mkt=pe(Okt).withConfig({displayName:"UserDataContainer",componentId:"sc-1hhhoqs-2"})(["justify-content:space-between;width:60%;"]),Lkt=pe.div.withConfig({displayName:"ImageContainer",componentId:"sc-1hhhoqs-3"})(["display:flex;flex-direction:column;height:400px;justify-content:space-around;"]),Pkt=pe.div.withConfig({displayName:"CenterContainer",componentId:"sc-1hhhoqs-4"})(["display:flex;width:300px;justify-content:center;border:1px solid;border-color:rgba(255,255,255,.15);"]),wm=pe.span.withConfig({displayName:"DataBar",componentId:"sc-1hhhoqs-5"})(["   padding:10px;height:45px;display:flex;justify-content:space-between;justify-items:center;"]),ux=pe(wm).withConfig({displayName:"DataBar2",componentId:"sc-1hhhoqs-6"})(["background-color:#282728;"]),zkt=pe.img.withConfig({displayName:"UserImage",componentId:"sc-1hhhoqs-7"})(["background-color:rgb(200,214,229);border-radius:15px;margin:10px;height:200px;width:200px;"]),Bkt=({lang:e,language:t})=>{const n=fn(e),[r,s]=J.useState(),a=()=>{if(r=="language")return K(YH,{children:[n.user_settings.lang_header,D(Ue,{onClick:()=>{t("EN")},children:n.user_settings.EN_btn}),D(Ue,{onClick:()=>{t("PL")},children:n.user_settings.PL_btn})]});if(r=="apperance")return D(YH,{children:n.user_settings.apperance_header})};return K(Wkt,{children:[K(Vkt,{children:[K(Ue,{onClick:()=>{s("language")},children:[" ",n.user_settings.lang_btn," "]}),K(Ue,{onClick:()=>{s("apperance")},children:[" ",n.user_settings.apperance_btn,"  "]})]}),D(Ukt,{children:a()})]})},Wkt=pe.div.withConfig({displayName:"OrderContainer",componentId:"sc-gffcin-0"})(["color:",";display:flex;flex-direction:row;flex:1;margin:30px;"],({theme:e})=>e.colors.typography),uie=pe.div.withConfig({displayName:"Container",componentId:"sc-gffcin-1"})(["display:flex;justify-content:center;flex-direction:column;z-index:2;overflow:hidden;padding:10px;margin-left:30px;margin-right:30px;border:1px solid;border-color:rgba(255,255,255,.15);"]),YH=pe(uie).withConfig({displayName:"SettingContainer",componentId:"sc-gffcin-2"})(["border:none;"]),Vkt=pe(uie).withConfig({displayName:"UserDataContainer",componentId:"sc-gffcin-3"})(["width:300px;"]);pe.div.withConfig({displayName:"ImageContainer",componentId:"sc-gffcin-4"})(["display:flex;flex-direction:column;height:400px;justify-content:space-around;"]);const Ukt=pe.div.withConfig({displayName:"CenterContainer",componentId:"sc-gffcin-5"})(["display:flex;width:60&;justify-content:center;border:1px solid;border-color:rgba(255,255,255,.15);"]),Gkt=pe.span.withConfig({displayName:"DataBar",componentId:"sc-gffcin-6"})(["   padding:10px;height:50px;display:flex;justify-content:space-between;justify-items:center;"]);pe(Gkt).withConfig({displayName:"DataBar2",componentId:"sc-gffcin-7"})(["background-color:#282728;"]);pe.img.withConfig({displayName:"UserImage",componentId:"sc-gffcin-8"})(["width:200px;height:200px;"]);const Hkt=({lang:e,userName:t})=>{const n=fn(e),[r,s]=J.useState(),[a,i]=J.useState(!0),[o,l]=J.useState(),[u,c]=J.useState(),d=async()=>{const p=`SELECT CONVERT(img1 USING utf8) as img, date FROM face_img_storage WHERE username = '${t}'`;await it.post(Ye.custom_query.get,{query:p}).then(f=>{c(f.data[0].img),l(f.data[0].date)}).catch(f=>{console.log("db status :(",f)})};J.useEffect(()=>{d()},[]);const h=()=>{if(r=="RegisterFaceRecognition")return D(ykt,{back:()=>{s(""),i(!0)},lang:e,userName:t});if(r=="apperance")return K(qkt,{children:[u&&o?K("div",{style:{marginTop:"10px"},children:[n.user_faceid.scan_exist_text," ",o.replace("T"," | ").slice(0,-8)]}):D("div",{style:{marginTop:"10px"},children:n.user_faceid.no_scan_text}),u?D(Zkt,{src:u}):D(Ue,{onClick:()=>{s("RegisterFaceRecognition"),i(!1)},children:n.user_faceid.no_scan_btn}),u&&D(Ue,{onClick:()=>{s("RegisterFaceRecognition"),i(!1)},children:n.user_faceid.scan_exist_btn})]})};return K(jkt,{children:[a&&D(Kkt,{children:D(Ue,{onClick:()=>{s("apperance")},children:n.user_faceid.menu_btn})}),D(Xkt,{children:h()})]})},jkt=pe.div.withConfig({displayName:"OrderContainer",componentId:"sc-1gsbuzh-0"})(["color:",";display:flex;flex-direction:row;flex:1;margin:30px;"],({theme:e})=>e.colors.typography),cie=pe.div.withConfig({displayName:"Container",componentId:"sc-1gsbuzh-1"})(["display:flex;justify-content:center;flex-direction:column;z-index:2;overflow:hidden;padding:10px;margin-left:30px;margin-right:30px;border:1px solid;border-color:rgba(255,255,255,.15);"]),qkt=pe(cie).withConfig({displayName:"SettingContainer",componentId:"sc-1gsbuzh-2"})(["border:none;flex:1;"]),Kkt=pe(cie).withConfig({displayName:"UserDataContainer",componentId:"sc-1gsbuzh-3"})(["width:300px;"]);pe.div.withConfig({displayName:"ImageContainer",componentId:"sc-1gsbuzh-4"})(["display:flex;flex-direction:column;height:400px;justify-content:space-around;"]);const Xkt=pe.div.withConfig({displayName:"CenterContainer",componentId:"sc-1gsbuzh-5"})(["display:flex;width:60&;justify-content:center;border:1px solid;border-color:rgba(255,255,255,.15);"]),Ykt=pe.span.withConfig({displayName:"DataBar",componentId:"sc-1gsbuzh-6"})(["   padding:10px;height:50px;display:flex;justify-content:space-between;justify-items:center;"]);pe(Ykt).withConfig({displayName:"DataBar2",componentId:"sc-1gsbuzh-7"})(["background-color:#282728;"]);const Zkt=pe.img.withConfig({displayName:"UserImage",componentId:"sc-1gsbuzh-8"})(["background-color:rgb(200,214,229);border-radius:15px;margin:10px;height:50px;width:50px;"]),Jkt=()=>{const[e,t]=J.useState("Start"),[n,r]=J.useState("Start"),[s,a]=J.useState(),[i,o]=J.useState("EN");return K(ZH,{children:[n=="Login"&&K(Qkt,{children:[D(e8e,{lang:i,userName:s,choosenWeb:l=>{t(l)}})," ",K(ZH,{children:[e=="Start"&&D(Sce,{lang:i}),e=="DataBase"&&D(I8e,{lang:i}),e=="Analysis"&&D(lkt,{userName:s,lang:i,back:l=>{t(l)}}),e=="pH"&&D(ckt,{userName:s,lang:i}),e=="FaceRecognition"&&D(pkt,{lang:i}),e=="RegisterFaceRecognition"&&D(Hkt,{lang:i,userName:s}),e=="Screenshot"&&D(Skt,{lang:i}),e=="UserSettings"&&D(Bkt,{language:l=>{o(l)},lang:i}),e=="UserProfile"&&D(Dkt,{userName:s,lang:i}),e=="UserIonAnalysis"&&D(Tkt,{userName:s,lang:i}),e=="UserPHAnalysis"&&D(Akt,{userName:s,lang:i}),e=="UserHelp"&&D(Nkt,{lang:i})]})]}),n=="Start"&&D(Zqe,{language:l=>{o(l)},choosenWeb:l=>{a(l.userName),r(l.result)}})]})},ZH=pe.div.withConfig({displayName:"Container",componentId:"sc-cnc1ms-0"})(["   "]),Qkt=pe.div.withConfig({displayName:"MojDIV",componentId:"sc-cnc1ms-1"})(["background-color:#0d1117;color:",";display:flex;flex-direction:column;justify-content:space-between;"],({theme:e})=>e.colors.typography);var JH={},eIt={get exports(){return JH},set exports(e){JH=e}};(function(e){var t=function(n){var r=Object.prototype,s=r.hasOwnProperty,a=Object.defineProperty||function(O,L,V){O[L]=V.value},i,o=typeof Symbol=="function"?Symbol:{},l=o.iterator||"@@iterator",u=o.asyncIterator||"@@asyncIterator",c=o.toStringTag||"@@toStringTag";function d(O,L,V){return Object.defineProperty(O,L,{value:V,enumerable:!0,configurable:!0,writable:!0}),O[L]}try{d({},"")}catch{d=function(L,V,q){return L[V]=q}}function h(O,L,V,q){var B=L&&L.prototype instanceof x?L:x,X=Object.create(B.prototype),ee=new z(q||[]);return a(X,"_invoke",{value:C(O,V,ee)}),X}n.wrap=h;function p(O,L,V){try{return{type:"normal",arg:O.call(L,V)}}catch(q){return{type:"throw",arg:q}}}var f="suspendedStart",m="suspendedYield",g="executing",y="completed",b={};function x(){}function w(){}function v(){}var k={};d(k,l,function(){return this});var I=Object.getPrototypeOf,S=I&&I(I(H([])));S&&S!==r&&s.call(S,l)&&(k=S);var $=v.prototype=x.prototype=Object.create(k);w.prototype=v,a($,"constructor",{value:v,configurable:!0}),a(v,"constructor",{value:w,configurable:!0}),w.displayName=d(v,c,"GeneratorFunction");function N(O){["next","throw","return"].forEach(function(L){d(O,L,function(V){return this._invoke(L,V)})})}n.isGeneratorFunction=function(O){var L=typeof O=="function"&&O.constructor;return L?L===w||(L.displayName||L.name)==="GeneratorFunction":!1},n.mark=function(O){return Object.setPrototypeOf?Object.setPrototypeOf(O,v):(O.__proto__=v,d(O,c,"GeneratorFunction")),O.prototype=Object.create($),O},n.awrap=function(O){return{__await:O}};function T(O,L){function V(X,ee,Z,fe){var Q=p(O[X],O,ee);if(Q.type==="throw")fe(Q.arg);else{var be=Q.arg,we=be.value;return we&&typeof we=="object"&&s.call(we,"__await")?L.resolve(we.__await).then(function(Ne){V("next",Ne,Z,fe)},function(Ne){V("throw",Ne,Z,fe)}):L.resolve(we).then(function(Ne){be.value=Ne,Z(be)},function(Ne){return V("throw",Ne,Z,fe)})}}var q;function B(X,ee){function Z(){return new L(function(fe,Q){V(X,ee,fe,Q)})}return q=q?q.then(Z,Z):Z()}a(this,"_invoke",{value:B})}N(T.prototype),d(T.prototype,u,function(){return this}),n.AsyncIterator=T,n.async=function(O,L,V,q,B){B===void 0&&(B=Promise);var X=new T(h(O,L,V,q),B);return n.isGeneratorFunction(L)?X:X.next().then(function(ee){return ee.done?ee.value:X.next()})};function C(O,L,V){var q=f;return function(X,ee){if(q===g)throw new Error("Generator is already running");if(q===y){if(X==="throw")throw ee;return P()}for(V.method=X,V.arg=ee;;){var Z=V.delegate;if(Z){var fe=E(Z,V);if(fe){if(fe===b)continue;return fe}}if(V.method==="next")V.sent=V._sent=V.arg;else if(V.method==="throw"){if(q===f)throw q=y,V.arg;V.dispatchException(V.arg)}else V.method==="return"&&V.abrupt("return",V.arg);q=g;var Q=p(O,L,V);if(Q.type==="normal"){if(q=V.done?y:m,Q.arg===b)continue;return{value:Q.arg,done:V.done}}else Q.type==="throw"&&(q=y,V.method="throw",V.arg=Q.arg)}}}function E(O,L){var V=L.method,q=O.iterator[V];if(q===i)return L.delegate=null,V==="throw"&&O.iterator.return&&(L.method="return",L.arg=i,E(O,L),L.method==="throw")||V!=="return"&&(L.method="throw",L.arg=new TypeError("The iterator does not provide a '"+V+"' method")),b;var B=p(q,O.iterator,L.arg);if(B.type==="throw")return L.method="throw",L.arg=B.arg,L.delegate=null,b;var X=B.arg;if(!X)return L.method="throw",L.arg=new TypeError("iterator result is not an object"),L.delegate=null,b;if(X.done)L[O.resultName]=X.value,L.next=O.nextLoc,L.method!=="return"&&(L.method="next",L.arg=i);else return X;return L.delegate=null,b}N($),d($,c,"Generator"),d($,l,function(){return this}),d($,"toString",function(){return"[object Generator]"});function M(O){var L={tryLoc:O[0]};1 in O&&(L.catchLoc=O[1]),2 in O&&(L.finallyLoc=O[2],L.afterLoc=O[3]),this.tryEntries.push(L)}function F(O){var L=O.completion||{};L.type="normal",delete L.arg,O.completion=L}function z(O){this.tryEntries=[{tryLoc:"root"}],O.forEach(M,this),this.reset(!0)}n.keys=function(O){var L=Object(O),V=[];for(var q in L)V.push(q);return V.reverse(),function B(){for(;V.length;){var X=V.pop();if(X in L)return B.value=X,B.done=!1,B}return B.done=!0,B}};function H(O){if(O){var L=O[l];if(L)return L.call(O);if(typeof O.next=="function")return O;if(!isNaN(O.length)){var V=-1,q=function B(){for(;++V<O.length;)if(s.call(O,V))return B.value=O[V],B.done=!1,B;return B.value=i,B.done=!0,B};return q.next=q}}return{next:P}}n.values=H;function P(){return{value:i,done:!0}}return z.prototype={constructor:z,reset:function(O){if(this.prev=0,this.next=0,this.sent=this._sent=i,this.done=!1,this.delegate=null,this.method="next",this.arg=i,this.tryEntries.forEach(F),!O)for(var L in this)L.charAt(0)==="t"&&s.call(this,L)&&!isNaN(+L.slice(1))&&(this[L]=i)},stop:function(){this.done=!0;var O=this.tryEntries[0],L=O.completion;if(L.type==="throw")throw L.arg;return this.rval},dispatchException:function(O){if(this.done)throw O;var L=this;function V(fe,Q){return X.type="throw",X.arg=O,L.next=fe,Q&&(L.method="next",L.arg=i),!!Q}for(var q=this.tryEntries.length-1;q>=0;--q){var B=this.tryEntries[q],X=B.completion;if(B.tryLoc==="root")return V("end");if(B.tryLoc<=this.prev){var ee=s.call(B,"catchLoc"),Z=s.call(B,"finallyLoc");if(ee&&Z){if(this.prev<B.catchLoc)return V(B.catchLoc,!0);if(this.prev<B.finallyLoc)return V(B.finallyLoc)}else if(ee){if(this.prev<B.catchLoc)return V(B.catchLoc,!0)}else if(Z){if(this.prev<B.finallyLoc)return V(B.finallyLoc)}else throw new Error("try statement without catch or finally")}}},abrupt:function(O,L){for(var V=this.tryEntries.length-1;V>=0;--V){var q=this.tryEntries[V];if(q.tryLoc<=this.prev&&s.call(q,"finallyLoc")&&this.prev<q.finallyLoc){var B=q;break}}B&&(O==="break"||O==="continue")&&B.tryLoc<=L&&L<=B.finallyLoc&&(B=null);var X=B?B.completion:{};return X.type=O,X.arg=L,B?(this.method="next",this.next=B.finallyLoc,b):this.complete(X)},complete:function(O,L){if(O.type==="throw")throw O.arg;return O.type==="break"||O.type==="continue"?this.next=O.arg:O.type==="return"?(this.rval=this.arg=O.arg,this.method="return",this.next="end"):O.type==="normal"&&L&&(this.next=L),b},finish:function(O){for(var L=this.tryEntries.length-1;L>=0;--L){var V=this.tryEntries[L];if(V.finallyLoc===O)return this.complete(V.completion,V.afterLoc),F(V),b}},catch:function(O){for(var L=this.tryEntries.length-1;L>=0;--L){var V=this.tryEntries[L];if(V.tryLoc===O){var q=V.completion;if(q.type==="throw"){var B=q.arg;F(V)}return B}}throw new Error("illegal catch attempt")},delegateYield:function(O,L,V){return this.delegate={iterator:H(O),resultName:L,nextLoc:V},this.method==="next"&&(this.arg=i),b}},n}(e.exports);try{regeneratorRuntime=t}catch{typeof globalThis=="object"?globalThis.regeneratorRuntime=t:Function("r","regeneratorRuntime = r")(t)}})(eIt);const tIt=()=>D(cce,{theme:dce,children:D(nIt,{children:D(Jkt,{})})}),nIt=pe.div.withConfig({displayName:"MojDIV",componentId:"sc-1claygu-0"})(["background-color:",";color:",";"],({theme:e})=>e.colors.background,({theme:e})=>e.colors.typography);Y_.createRoot(document.getElementById("root")).render(D(tIt,{}));
